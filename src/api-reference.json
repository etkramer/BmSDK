{
  "Core": {
    "Commandlet": {
      "comment": "UnrealScript Commandlet (command-line applet) class.\n Commandlets are executed from the ucc.exe command line utility, using the\n following syntax:\n yourgame.exe package_name.commandlet_class_name [parm=value]...\n for example:\n yourgame.exe Core.HelloWorldCommandlet\n yourgame.exe UnrealEd.MakeCommandlet\n As a convenience, if a user tries to run a commandlet and the exact\n name he types isn't found, then ucc.exe appends the text \"commandlet\"\n onto the name and tries again. Therefore, the following shortcuts\n perform identically to the above:\n yourgame.exe Core.HelloWorld\n yourgame.exe UnrealEd.Make\n Commandlets are executed in a \"raw\" UnrealScript environment, in which\n the game isn't loaded, the client code isn't loaded, no levels are\n loaded, and no actors exist.",
      "properties": {
        "HelpDescription": {
          "comment": "Description of the commandlet's purpose"
        },
        "HelpParamDescriptions": {
          "comment": "The description of the parameter"
        },
        "HelpParamNames": {
          "comment": "The name of the parameter the commandlet takes"
        },
        "HelpUsage": {
          "comment": "Usage template to show for \"ucc help\""
        },
        "HelpWebLink": {
          "comment": "Hyperlink for more info"
        },
        "IsClient": {
          "comment": "Whether to load objects required in server, client, and editor context. If IsEditor is set to false, then a\n UGameEngine (or whatever the value of Engine.Engine.GameEngine is) will be created for the commandlet instead\n of a UEditorEngine (or Engine.Engine.EditorEngine), unless the commandlet overrides the CreateCustomEngine method."
        },
        "IsEditor": {
          "comment": "Whether to load objects required in server, client, and editor context. If IsEditor is set to false, then a\n UGameEngine (or whatever the value of Engine.Engine.GameEngine is) will be created for the commandlet instead\n of a UEditorEngine (or Engine.Engine.EditorEngine), unless the commandlet overrides the CreateCustomEngine method."
        },
        "IsServer": {
          "comment": "Whether to load objects required in server, client, and editor context. If IsEditor is set to false, then a\n UGameEngine (or whatever the value of Engine.Engine.GameEngine is) will be created for the commandlet instead\n of a UEditorEngine (or Engine.Engine.EditorEngine), unless the commandlet overrides the CreateCustomEngine method."
        },
        "LogToConsole": {
          "comment": "Whether to redirect standard log to the console"
        },
        "ShowErrorCount": {
          "comment": "Whether to show standard error and warning count on exit"
        }
      },
      "functions": {
        "Main": {
          "comment": "Entry point for your commandlet",
          "params": {
            "Params": "the string containing the parameters for the commandlet"
          }
        }
      }
    },
    "Component": {
      "comment": "This class is the base class for any kind of object that wants the following features:\n - be a subobject inside a class definition (called the owner class)\n - values of the component can be overridden in a subclass of the owner class, by\n defining a component in the subclass with the same name as the component in the base class\n definition. Note, you CANNOT GIVE IT A CLASS= DEFINITION! (See UDN page for more info)\n - Changes to the default values to the component will be propagated to components that are\n created inside a map, unless the value was changed away from the default value in the editor."
    },
    "DistributionFloat": {
      "properties": {
        "bIsDirty": {
          "comment": "Set internally when the distribution is updated so that that FRawDistribution can know to update itself"
        },
        "bCanBeBaked": {
          "comment": "Can this variable be baked out to a FRawDistribution? Should be TRUE 99% of the time"
        }
      },
      "functions": {
        "GetFloatValue": {
          "comment": "Script-accessible way to query a float distribution"
        }
      },
      "structs": {
        "RawDistributionFloat": {
          "properties": {
            "Distribution": {
              "comment": "Is this distribution a uniform type? (ie, does it have two values per entry?)"
            }
          }
        }
      }
    },
    "DistributionVector": {
      "properties": {
        "bIsDirty": {
          "comment": "Set internally when the distribution is updated so that that FRawDistribution can know to update itself"
        },
        "bCanBeBaked": {
          "comment": "Can this variable be baked out to a FRawDistribution? Should be TRUE 99% of the time"
        }
      },
      "functions": {
        "GetVectorValue": {
          "comment": "Script-accessible way to query a vector distribution"
        }
      },
      "structs": {
        "RawDistributionVector": {
          "properties": {
            "Distribution": {
              "comment": "Is this distribution a uniform type? (ie, does it have two values per entry?)"
            }
          }
        }
      }
    },
    "Factory": {
      "properties": {
        "ValidGameNames": {
          "comment": "List of game names that this factory can be used for (if empty, all games valid)"
        }
      }
    },
    "HelpCommandlet": {
      "comment": "This commandlet finds and displays help information on other commandlets",
      "functions": {
        "Main": {
          "comment": "Looks at the parameters and displays help based upon those parameters",
          "params": {
            "Params": "the string containing the parameters for the commandlet"
          }
        }
      }
    },
    "Object": {
      "functions": {
        "!": {
          "comment": "not yet implemented"
        },
        "*": {
          "comment": "multiply the RGB components of a LinearColor by a float"
        },
        "-": {
          "comment": "subtract the RGB components of B from the RGB components of A"
        },
        "BeginState": {
          "comment": "Called immediately when entering a state, while within the\n GotoState() call that caused the state change (before any\n state code is executed)."
        },
        "ByteToFloat": {
          "comment": "Converts a 0-255 byte to a float value, to a range of 0.f\n to 1.f.",
          "params": {
            "inputByte": "byte to convert",
            "bSigned": "optional, spit out -1.f to 1.f instead"
          }
        },
        "ClampLength": {
          "comment": "Clamps a vector to not be longer than MaxLength."
        },
        "ClampRotAxis": {
          "comment": "Clamp a rotation Axis.\n The ViewAxis rotation component must be normalized (within the [-32768,+32767] range).\n This function will set out_DeltaViewAxis to the delta needed to bring ViewAxis within the [MinLimit,MaxLimit] range.",
          "params": {
            "ViewAxis": "Rotation Axis to clamp\n \n@input out_DeltaViewAxis Delta Rotation Axis to be added to ViewAxis rotation (from ProcessViewRotation).\n Set to be the Delta to bring ViewAxis within the [MinLimit,MaxLimit] range.",
            "MaxLimit": "Maximum for Clamp. ViewAxis will not exceed this.",
            "MinLimit": "Minimum for Clamp. ViewAxis will not go below this."
          }
        },
        "ClampRotAxisFromBase": {
          "comment": "Clamp Rotator Axis.",
          "params": {
            "Current": "Input axis angle.",
            "Center": "Center of allowed angle.",
            "MaxDelta": "Maximum delta allowed."
          }
        },
        "ClampRotAxisFromRange": {
          "comment": "Clamp Rotator Axis.",
          "params": {
            "Current": "Input axis angle.",
            "Min": "Min allowed angle.",
            "Max": "Max allowed angle."
          }
        },
        "ClassIsChildOf": {
          "comment": "Determine if a class is a child of another class."
        },
        "ColorToLinearColor": {
          "comment": "converts a color to a LinearColor",
          "params": {
            "OldColor": "the color to convert"
          }
        },
        "ContinuedState": {
          "comment": "Called on the state that is no longer paused because of a PopState()."
        },
        "DebugBreak": {
          "comment": "Script-induced breakpoint. Useful for examining state with the debugger at a particular point in script.",
          "params": {
            "UserFlags": "user-defined flags to be used for e.g. indentifying different calls to DebugBreak in the same session",
            "DebuggerType": "C++ debugger, UScript debugger, or both"
          }
        },
        "DumpStateStack": {
          "comment": "Logs the current state stack for debugging purposes."
        },
        "EndState": {
          "comment": "Called immediately before going out of the current state, while\n within the GotoState() call that caused the state change, and\n before BeginState() is called within the new state."
        },
        "EvalInterpCurveFloat": {
          "comment": "Evaluate a float curve for an input of InVal"
        },
        "EvalInterpCurveVector": {
          "comment": "Evaluate a vector curve for an input of InVal"
        },
        "EvalInterpCurveVector2D": {
          "comment": "Evaluate a vector2D curve for an input of InVal"
        },
        "FCubicInterp": {
          "comment": "Cubic Spline interpolation.",
          "params": {
            "P": "end points",
            "T": "tangent directions at end points",
            "Alpha": "distance along spline"
          }
        },
        "FindDeltaAngle": {
          "comment": "Gets the difference in world space angles in [-PI,PI] range",
          "params": {
            "A1": "First angle",
            "A2": "Second angle"
          }
        },
        "FInterpConstantTo": {
          "comment": "Same as above, but using a constant step"
        },
        "FInterpEaseIn": {
          "comment": "Interpolates with ease-in (smoothly approaches B).",
          "params": {
            "A": "Value to interpolate from.",
            "B": "Value to interpolate to.",
            "Alpha": "Interpolant.",
            "Exp": "Exponent. Higher values result in more rapid deceleration."
          }
        },
        "FInterpEaseInOut": {
          "comment": "Interpolates with both ease-in and ease-out (smoothly departs A, smoothly approaches B).",
          "params": {
            "A": "Value to interpolate from.",
            "B": "Value to interpolate to.",
            "Alpha": "Interpolant.",
            "Exp": "Exponent. Higher values result in more rapid acceleration adn deceleration."
          }
        },
        "FInterpEaseOut": {
          "comment": "Interpolates with ease-out (smoothly departs A).",
          "params": {
            "A": "Value to interpolate from.",
            "B": "Value to interpolate to.",
            "Alpha": "Interpolant.",
            "Exp": "Exponent. Higher values result in more rapid acceleration."
          }
        },
        "FInterpTo": {
          "comment": "Tries to reach Target based on distance from Current position,\n giving a nice smooth feeling when tracking a position.\n (Doesn't work well when target teleports)",
          "params": {
            "Current": "Actual position",
            "Target": "Target position",
            "DeltaTime": "time since last tick",
            "InterpSpeed": "Interpolation speed"
          }
        },
        "float": {
          "comment": "Return a random number within the given range."
        },
        "FloatToByte": {
          "comment": "Converts a float value to a 0-255 byte, assuming a range of\n 0.f to 1.f.",
          "params": {
            "inputFloat": "float to convert",
            "bSigned": "optional, assume a range of -1.f to 1.f"
          }
        },
        "FPctByRange": {
          "comment": "Returns the relative percentage position Value is in the range [Min,Max].\n Examples:\n - GetRangeValueByPct( 2, 4, 2 ) == 0\n - GetRangeValueByPct( 2, 4, 4 ) == 1\n - GetRangeValueByPct( 2, 4, 3 ) == 0.5",
          "params": {
            "Min": "Min limit",
            "Max": "Max limit",
            "Value": "Value between Range."
          }
        },
        "GetAngularDistance": {
          "comment": "Calculates the angular distance of vector 'Direction' to coordinate system O(AxisX,AxisY,AxisZ).\n Orientation: (consider 'O' the first person view of the player, and 'Direction' a vector pointing to an enemy)\n - positive azimuth means enemy is on the right of crosshair. (negative means left).\n - positive elevation means enemy is on top of crosshair, negative means below.",
          "params": {
            "out_AngularDist": ".X = Azimuth angle (in radians) of 'Direction' vector compared to plane (AxisX,AxisZ).\n .Y = Elevation angle (in radians) of 'Direction' vector compared to plane (AxisX,AxisY).",
            "Direction": "Direction of target.",
            "AxisX": "X component of reference system.",
            "AxisY": "Y component of reference system.",
            "AxisZ": "Z component of reference system.\n \n@output true if 'Direction' is facing AxisX (Direction dot AxisX >= 0.f)"
          }
        },
        "GetAngularFromDotDist": {
          "comment": "Converts Dot distance to angular distance.\n \n@see GetAngularDistance() and GetDotDistance().",
          "params": {
            "OutAngDist": "Angular distance in radians.",
            "DotDist": "Dot distance."
          }
        },
        "GetDotDistance": {
          "comment": "Calculates the dotted distance of vector 'Direction' to coordinate system O(AxisX,AxisY,AxisZ).\n Orientation: (consider 'O' the first person view of the player, and 'Direction' a vector pointing to an enemy)\n - positive azimuth means enemy is on the right of crosshair. (negative means left).\n - positive elevation means enemy is on top of crosshair, negative means below.\n \n@Note: 'Azimuth' (.X) sign is changed to represent left/right and not front/behind. front/behind is the funtion's return value.",
          "params": {
            "OutDotDist": ".X = 'Direction' dot AxisX relative to plane (AxisX,AxisZ). (== Cos(Azimuth))\n .Y = 'Direction' dot AxisX relative to plane (AxisX,AxisY). (== Sin(Elevation))",
            "Direction": "direction of target.",
            "AxisX": "X component of reference system.",
            "AxisY": "Y component of reference system.",
            "AxisZ": "Z component of reference system."
          }
        },
        "GetFuncName": {
          "comment": "Returns the current calling function's name, useful for\n debugging."
        },
        "GetHeadingAngle": {
          "comment": "Returns world space angle (in radians) of given vector",
          "params": {
            "Dir": "Vector to be converted into heading angle"
          }
        },
        "GetMappedRangeValue": {
          "comment": "Useful for mapping a value in one value range to a different value range. Output is clamped to the OutputRange.\n e.g. given that velocities [50..100] correspond to a sound volume of [0.2..1.4], find the\n volume for a velocity of 77."
        },
        "GetPerObjectConfigSections": {
          "comment": "Retrieve the names of sections which contain data for the specified PerObjectConfig class.",
          "params": {
            "SearchClass": "the PerObjectConfig class to retrieve sections for.",
            "out_SectionNames": "will receive the list of section names that correspond to PerObjectConfig sections of the specified class",
            "ObjectOuter": "the Outer to use for determining which file to look in. Specify the same object that is used when creating the PerObjectConfig\n objects that sections are being retrieved for. (PerObjectConfig data is generally stored in a file named after the Outer used when\n creating those objects, unless the PerObjectConfig class specifies a config file in its class declaration);\n specify None to use the transient package as the Outer.",
            "MaxResults": "the maximum number of section names to retrieve"
          }
        },
        "GetRangePctByValue": {
          "comment": "Returns the relative percentage position Value is in the Range.\n Examples:\n - GetRangeValueByPct( Range, Range.X ) == 0\n - GetRangeValueByPct( Range, Range.Y ) == 1\n - GetRangeValueByPct( Range, (Range.X+Range.Y)/2 ) == 0.5",
          "params": {
            "Range": "Range of values. [Range.X,Range.Y]",
            "Value": "Value between Range."
          }
        },
        "GetRangeValueByPct": {
          "comment": "Returns the value in the Range, relative to Pct.\n Examples:\n - GetRangeValueByPct( Range, 0.f ) == Range.X\n - GetRangeValueByPct( Range, 1.f ) == Range.Y\n - GetRangeValueByPct( Range, 0.5 ) == (Range.X+Range.Y)/2",
          "params": {
            "Range": "Range of values. [Range.X,Range.Y]",
            "Pct": "Relative position in range in percentage. [0,1]"
          }
        },
        "GetRightMost": {
          "comment": "Get right most number from an actor name (ie Text == \"CoverLink_45\" returns \"45\")"
        },
        "GetScriptTrace": {
          "comment": "Gets the current script function stack back so you can log it to a specific log location (e.g. AILog)."
        },
        "GetStateName": {
          "comment": "Returns the current state name, useful for determining current\n state similar to IsInState. Note: This *doesn't* work with\n inherited states, in that it will only compare at the lowest\n state level."
        },
        "GetSystemTime": {
          "comment": "Return the system time components."
        },
        "GotoState": {
          "comment": "Transitions to the desired state and label if specified,\n generating the EndState event in the current state if applicable\n and BeginState in the new state, unless transitioning to the same\n state.",
          "params": {
            "NewState": "new state to transition to",
            "Label": "optional Label to jump to",
            "bForceEvents": "optionally force EndState/BeginState to be\n called even if transitioning to the same state.",
            "bKeepStack": "prevents state stack from being cleared"
          }
        },
        "IsChildState": {
          "comment": "Returns true if TestState derives from TestParentState."
        },
        "IsInState": {
          "comment": "Checks the current state and determines whether or not this object\n is actively in the specified state. Note: This does work with\n inherited states.",
          "params": {
            "TestState": "state to check for",
            "bTestStateStack": "check the state stack? (does *NOT* work with inherited states in the stack)"
          }
        },
        "IsPendingKill": {
          "comment": "Returns whether the object is pending kill and about to have references to it NULLed by\n the garbage collector."
        },
        "IsUTracing": {
          "comment": "Returns whether script function call trace logging is currently enabled."
        },
        "JoinArray": {
          "comment": "Create a single string from an array of strings, using the delimiter specified, optionally ignoring blank members",
          "params": {
            "StringArray": "the array of strings to join into the single string",
            "out_Result": "[out] will contain a single string containing all elements of the array, separated by the delimiter specified",
            "Delim": "the delimiter to insert where array elements are concatenated",
            "bIgnoreBlanks": "TRUE to skip elements which contain emtpy strings"
          }
        },
        "LerpColor": {
          "comment": "Util to interpolate between two colors"
        },
        "LogInternal": {
          "comment": "Writes a message to the log. This function should never be called directly - use the `log macro instead, which has the following signature:\n log( coerce string Msg, optional bool bCondition=true, optional name LogTag='ScriptLog' );",
          "params": {
            "Msg": "the string to print to the log",
            "bCondition": "if specified, the message is only printed to the log if this condition is satisfied.",
            "LogTag": "if specified, the message will be prepended with this tag in the log file"
          }
        },
        "MakeColor": {
          "comment": "Create a Color from independant RGBA components"
        },
        "MakeLinearColor": {
          "comment": "Create a LinearColor from independant RGBA components."
        },
        "MakeRotator": {
          "comment": "Create a Rotation from independant Pitch, Yaw, Roll"
        },
        "NormalizeRotAxis": {
          "comment": "Returns a Rotator axis within the [-32768,+32767] range in float",
          "params": {
            "RotAxis,": "axis of the rotator"
          }
        },
        "NoZDot": {
          "comment": "Returns dot product of two vectors while ignoring the Z component."
        },
        "ParseLocalizedPropertyPath": {
          "comment": "given a path to a localized key of the form \"Package.Section.Name\",\n return the appropriate value from the localization file for the current language"
        },
        "ParseStringIntoArray": {
          "comment": "Breaks up a delimited string into elements of a string array.",
          "params": {
            "BaseString": "The string to break up",
            "Pieces": "The array to fill with the string pieces",
            "Delim": "The string to delimit on",
            "bCullEmpty": "If true, empty strings are not added to the array"
          }
        },
        "PathName": {
          "comment": "Returns the full path name of the specified object (including package and groups), ie CheckObject::GetPathName()."
        },
        "PausedState": {
          "comment": "Called on the state that is being paused because of a PushState()."
        },
        "PointDistToLine": {
          "comment": "Calculates the distance of a given Point in world space to a given line,\n defined by the vector couple (Origin, Direction).",
          "params": {
            "Point": "point to check distance to Axis",
            "Line": "unit vector indicating the direction to check against",
            "Origin": "point of reference used to calculate distance",
            "OutClosestPoint": "optional point that represents the closest point projected onto Axis"
          }
        },
        "PointDistToPlane": {
          "comment": "Calculates the distance of a given point to the given plane. (defined by a combination of vector and rotator)\n Rotator.AxisX = U, Rotator.AxisY = Normal, Rotator.AxisZ = V",
          "params": {
            "Point": "Point to check distance to Orientation",
            "Orientation": "Rotator indicating the direction to check against",
            "Origin": "Point of reference used to calculate distance",
            "out_ClosestPoint": "Optional point that represents the closest point projected onto Plane defined by the couple (Origin, Orientation)"
          }
        },
        "PointDistToSegment": {
          "comment": "Returns closest distance from a point to a segment.",
          "params": {
            "Point": "point to check distance for",
            "StartPoint": "StartPoint of segment",
            "EndPoint": "EndPoint of segment",
            "OutClosestPoint": "Closest point on segment."
          }
        },
        "PointProjectToPlane": {
          "comment": "Calculates a point's projection onto a plane",
          "params": {
            "Point": "point to project onto the plane",
            "A": "point on plane",
            "B": "point on plane",
            "C": "point on plane"
          }
        },
        "PoppedState": {
          "comment": "Called immediately in the current state that is being popped off\n of the state stack, before the new state is activated."
        },
        "PopState": {
          "comment": "Pops the current pushed state, returning execution to the previous\n state at the same code point. Note: PopState() will have no effect\n if no state has been pushed onto the stack.\n This will call PoppedState when entering the state that was just\n pushed on the state stack. It will not call EndState.\n \n@see event PoppedState\n \n@see event PausedState",
          "params": {
            "bPopAll": "optionally pop all states on the stack to the\n originally executing one"
          }
        },
        "PushedState": {
          "comment": "Called immediately in the new state that was pushed onto the\n state stack, before any state code is executed."
        },
        "PushState": {
          "comment": "Pushes the new state onto the state stack, setting it as the\n current state until a matching PopState() is called. Note that\n multiple states may be pushed on top of each other.\n You may not push the same state multiple times.\n This will call PushedState when entering the state that was just\n pushed on the state stack. It will not call BeginState.\n \n@see event PushedState\n \n@see event ContinuedState",
          "params": {
            "NewState": "name of the state to push on the stack",
            "NewLabel": "optional name of the state label to jump to"
          }
        },
        "Rand": {
          "comment": "Rand will give you a value between 0 and Max -1"
        },
        "RDiff": {
          "comment": "Gives the rotation difference between two Rotators, taking the shortest route between them (in degrees)."
        },
        "RInterpTo": {
          "comment": "Tries to reach Target based on distance from Current position,\n giving a nice smooth feeling when tracking a position.\n (Doesn't work well when target teleports)",
          "params": {
            "Current": "Actual position",
            "Target": "Target position",
            "DeltaTime": "time since last tick",
            "InterpSpeed": "Interpolation speed, if !bConstantInterpSpeed will perform a continuous lerp, otherwise will interp at constant speed"
          }
        },
        "RSize": {
          "comment": "returns Rotator Size (vector definition applied to rotators)",
          "params": {
            "Rotator": "R"
          }
        },
        "RTransform": {
          "comment": "Given rotation R in the space defined by RBasis, return R in \"world\" space"
        },
        "SClampRotAxis": {
          "comment": "Smooth clamp a rotator axis.\n This is mainly used to bring smoothly a rotator component within a certain range [MinLimit,MaxLimit].\n For example to limit smoothly the player's ViewRotation Pitch or Yaw component.",
          "params": {
            "fDeltaTime": "Elapsed time since this function was last called, for interpolation.",
            "ViewAxis": "Rotator's Axis' current angle.\n \n@input out_DeltaViewAxis Delta Value of Axis to be added to ViewAxis (through PlayerController::ProcessViewRotation().\n This value gets modified.",
            "MaxLimit": "Up angle limit.",
            "MinLimit": "Negative angle limit (value must be negative)",
            "InterpolationSpeed": "Interpolation Speed to bring ViewAxis within the [MinLimit,MaxLimit] range."
          }
        },
        "ScriptTrace": {
          "comment": "Dumps the current script function stack to the log file, useful\n for debugging."
        },
        "SetUTracing": {
          "comment": "Enables/disables script function call trace logging."
        },
        "Split": {
          "comment": "Splits Text on the first Occurrence of Split and returns the remaining\n part of Text."
        },
        "SplitString": {
          "comment": "Wrapper for splitting a string into an array of strings using a single expression."
        },
        "TimeStamp": {
          "comment": "Returns a string containing a system timestamp"
        },
        "TransformVectorByRotation": {
          "comment": "Script hook to FRotationMatrix::TransformFVector()."
        },
        "vect2d": {
          "comment": "Construct a vector2d variable"
        },
        "VInterpTo": {
          "comment": "Tries to reach Target based on distance from Current position,\n giving a nice smooth feeling when tracking a location.\n (Doesn't work well when target teleports)",
          "params": {
            "Current": "Actual location",
            "Target": "Target location",
            "DeltaTime": "time since last tick",
            "InterpSpeed": "Interpolation speed"
          }
        },
        "WarnInternal": {
          "comment": "Same as calling LogInternal(SomeMsg, 'Warning'); This function should never be called directly - use the `warn macro instead, which has the following signature:\n warn( coerce string Msg, optional bool bCondition=true );"
        }
      },
      "structs": {
        "BoneAtom": {
          "comment": "Bone Atom definition"
        },
        "InlinePointerArray_Mirror": {
          "comment": "Structure mirroring an array of pointers using an inline allocator."
        },
        "IntPoint": {
          "comment": "Screen coordinates"
        },
        "OctreeElementId": {
          "comment": "Mirror for FElementId used in generic Octree"
        },
        "RenderCommandFence": {
          "comment": "A fence used to track rendering thread command execution."
        },
        "SHVector": {
          "comment": "A vector of spherical harmonic coefficients."
        },
        "SHVectorRGB": {
          "comment": "A vector of spherical harmonic coefficients for each color component."
        },
        "TAlphaBlend": {
          "comment": "Structure to encompass Alpha Interpolation.",
          "properties": {
            "AlphaIn": {
              "comment": "Internal Lerped value for Alpha"
            },
            "AlphaOut": {
              "comment": "Resulting Alpha value, between 0.f and 1.f"
            },
            "AlphaTarget": {
              "comment": "Target to reach"
            },
            "BlendTime": {
              "comment": "Default blend time"
            },
            "BlendTimeToGo": {
              "comment": "Time left to reach target"
            },
            "BlendType": {
              "comment": "Type of blending used (Linear, Cubic, etc.)"
            }
          }
        },
        "TPOV": {
          "comment": "Point Of View type.",
          "properties": {
            "FOV": {
              "comment": "FOV angle"
            },
            "Location": {
              "comment": "Location"
            },
            "Rotation": {
              "comment": "Rotation"
            }
          }
        }
      }
    }
  },
  "Engine": {
    "AccessControl": {
      "functions": {
        "GetControllerFromString": {
          "comment": "Takes a string and tries to find the matching controller associated with it. First it searches as if the string is the\n player's name. If it doesn't find a match, it attempts to resolve itself using the target as the player id.\n \n@Params Target The search key"
        },
        "ParseAdminOptions": {
          "comment": "Parses the specified string for admin auto-login options",
          "params": {
            "Options": "a string containing key/pair options from the URL (?key=value,?key=value)"
          }
        }
      }
    },
    "Actor": {
      "properties": {
        "AllComponents": {
          "comment": "All actor components which are directly or indirectly attached to the actor."
        },
        "Attached": {
          "comment": "array of actors attached to this actor."
        },
        "bAlwaysEncroachCheck": {
          "comment": "If true (and is an encroacher) will do the encroachment check inside MoveActor even if there is no movement.\n This is useful for objects that may change bounding box but not actually move."
        },
        "bCallRigidBodyWakeEvents": {
          "comment": "Should call OnWakeRBPhysics/OnSleepRBPhysics events"
        },
        "bCanBeAdheredTo": {
          "comment": "Determines whether or not adhesion code should attempt to adhere to this actor."
        },
        "bCanBeFrictionedTo": {
          "comment": "Determines whether or not friction code should attempt to friction to this actor."
        },
        "bCollideAsEncroacher": {
          "comment": "If true, this actor collides as an encroacher, even if its physics is not PHYS_RigidBody or PHYS_Interpolating"
        },
        "bComponentOutsideWorld": {
          "comment": "Set TRUE if a component is ever attached which is outside the world. OutsideWorldBounds will be called in Tick in this case."
        },
        "bDemoOwner": {
          "comment": "Demo recording driver owns this actor."
        },
        "bDemoRecording": {
          "comment": "Set when we are currently replicating this Actor into a demo"
        },
        "bDestroyedByInterpActor": {
          "comment": "If TRUE, when an InterpActor (Mover) encroaches or runs into this Actor, it is destroyed, and will not stop the mover."
        },
        "bExchangedRoles": {
          "comment": "whether we already exchanged Role/RemoteRole on the client, as removing then readding a streaming level\n causes all initialization to be performed again even though the actor may not have actually been reloaded"
        },
        "bForceAllowKismetModification": {
          "comment": "always allow Kismet to modify this Actor, even if it's static and not networked (e.g. for server side only stuff)"
        },
        "bForceDemoRelevant": {
          "comment": "force Actor to be relevant for demos (only works on dynamic actors)"
        },
        "bForceNetUpdate": {
          "comment": "When set to TRUE will force this actor to immediately be considered for replication, instead of waiting for NetUpdateTime"
        },
        "bForceOctreeSNFilter": {
          "comment": "If TRUE, components of this Actor will only ever be placed into one node of the octree. This makes insertion faster, but may impact runtime performance"
        },
        "bHasAlternateTargetLocation": {
          "comment": "whether this Actor may return an alternate location from GetTargetLocation() when bRequestAlternateLoc is true\n (used as an early out when tracing to those locations, etc)"
        },
        "bIgnoreRigidBodyPawns": {
          "comment": "Ignore Unreal collisions between PHYS_RigidBody pawns (vehicles/ragdolls) and this actor (only relevant if bIgnoreEncroachers is false)"
        },
        "bIsMoving": {
          "comment": "Used to determine when we stop moving, so we can update PreviousLocalToWorld to stop motion blurring."
        },
        "bMoveIgnoresDestruction": {
          "comment": "Controls whether move operations should collide with destructible pieces or not."
        },
        "bNetInitialRotation": {
          "comment": "Should replicate initial rotation. This property should never be changed during execution, as the client and server rely on the default value of this property always being the same."
        },
        "bPendingNetUpdate": {
          "comment": "Is this actor still pending a full net update due to clients that weren't able to replicate the actor at the time of LastNetUpdateTime"
        },
        "bPostRenderIfNotVisible": {
          "comment": "IF true, may call PostRenderFor() even when this actor is not visible"
        },
        "bProjectileMoveSingleBlocking": {
          "comment": "When in PHYS_Projectile, this actor will move with the MOVE_SingleBlocking flag"
        },
        "bPushedByEncroachers": {
          "comment": "whether encroachers can push this Actor (only relevant if bIgnoreEncroachers is false and not an encroacher ourselves)\n if false, the encroacher gets EncroachingOn() called immediately instead of trying to safely move this actor first"
        },
        "bRigidBodyWasAwake": {
          "comment": "RigidBody of CollisionComponent was awake last frame -- used to call OnWakeRBPhysics/OnSleepRBPhysics events"
        },
        "bRouteBeginPlayEvenIfStatic": {
          "comment": "Whether to route BeginPlay even if the actor is static."
        },
        "bTickIsDisabled": {
          "comment": "if set, this Actor and all of its components are not ticked. Modify via SetTickIsDisabled()\n this flag has no effect on bStatic Actors"
        },
        "Components": {
          "comment": "The actor components which are attached directly to the actor's location/rotation."
        },
        "CustomTimeDilation": {
          "comment": "Allow each actor to run at a different time speed"
        },
        "DetachFence": {
          "comment": "A fence to track when the primitive is detached from the scene in the rendering thread."
        },
        "GeneratedEvents": {
          "comment": "List of all events currently associated with this actor"
        },
        "HiddenEditorViews": {
          "comment": "Bitflag to represent which views this actor is hidden in, via per-view layer visibilty"
        },
        "LastNetUpdateTime": {
          "comment": "Last time this actor was updated for replication via NetUpdateTime or bForceNetUpdate\n @warning: internal net driver time, not related to WorldInfo.TimeSeconds"
        },
        "LastRenderTime": {
          "comment": "The value of WorldInfo->TimeSeconds for the frame when this actor was last rendered. This is written\n from the render thread, which is up to a frame behind the game thread, so you should allow this time to\n be at least a frame behind the game thread's world time before you consider the actor non-visible.\n There's an equivalent variable in PrimitiveComponent."
        },
        "LatentActions": {
          "comment": "List of all latent actions currently active on this actor"
        },
        "NetPriority": {
          "comment": "Priority for this actor when checking for replication in a low bandwidth or saturated situation, higher priority means it is more likely to replicate"
        },
        "NetTag": {
          "comment": "Internal - used by UWorld::ServerTickClients()"
        },
        "NetUpdateFrequency": {
          "comment": "How often (per second) this actor will be considered for replication, used to determine NetUpdateTime"
        },
        "NetUpdateTime": {
          "comment": "Next time this actor will be considered for replication, set by SetNetUpdateTime()"
        },
        "PendingTouch": {
          "comment": "PLEASE NOTE DesiredRotation is removed\n This DesiredRotation is moved to Pawn to remove redundant variables usage. (i.e. between Pawn and Controller)\n Pawn now handles all DesiredRotation and it is only one place.\n All Actor's DesiredRotation won't work anymore - Use RotationRate to control Actor's rotation"
        },
        "RelativeLocation": {
          "comment": "location relative to base/bone (valid if base exists)"
        },
        "RelativeRotation": {
          "comment": "rotation relative to base/bone (valid if base exists)"
        },
        "ReplicatedCollisionType": {
          "comment": "used when collision is changed via Kismet \"Change Collision\" action to set component flags on the CollisionComponent\n will not modify replicated Actor flags regardless of setting"
        },
        "SupportedEvents": {
          "comment": "List of all events that this actor can support, for use by the editor"
        },
        "TickFrequency": {
          "comment": "How often to tick this actor. If 0, tick every frame"
        },
        "TickFrequencyDecreaseDistanceEnd": {
          "comment": "How far from the player to stop decreasing the tick, with a linear fall off from TickFrequencyDecreaseDistanceStart"
        },
        "TickFrequencyDecreaseDistanceStart": {
          "comment": "How far from the player to start decreasing the tick, with a linear fall off until TickFrequencyDecreaseDistanceEnd"
        },
        "TickFrequencyLastSeenTimeBeforeForcingMaxTickFrequency": {
          "comment": "This is the time before we force the TickFrequency to TickFrequencyAtEndDistance"
        },
        "TickGroup": {
          "comment": "The ticking group this actor belongs to"
        },
        "Timers": {
          "comment": "This is going to scale this timer's values by this amoun"
        },
        "TimeSinceLastTick": {
          "comment": "How long has it been since the last tick? Once this reaches TickFrequency, Tick the actor with a DeltaTime for how long since last"
        },
        "bConsiderAllStaticMeshComponentsForStreaming": {
          "comment": "If true, texture streaming code iterates over all StaticMeshComponents found on this actor when building texture streaming information."
        },
        "TickFrequencyAtEndDistance": {
          "comment": "When the actor is TickFrequencyDecreaseDistanceEnd from the player, tick at this frequency (in seconds, bigger is less frequent ticks). If this is 0, no decrease in frequency will occur"
        },
        "bHardAttach": {
          "comment": "Uses 'hard' attachment code. bBlockActor must also be false.\nThis actor cannot then move relative to base (setlocation etc.)."
        },
        "bIgnoreBaseRotation": {
          "comment": "If TRUE, this actor ignores the effects of changes in its base's rotation on its location and rotation."
        },
        "bShadowParented": {
          "comment": "If TRUE, BaseSkelComponent is used as the shadow parent for this actor."
        },
        "bCanStepUpOn": {
          "comment": "If TRUE, PHYS_Walking will attempt to step up onto this object when it hits it"
        },
        "BlockRigidBody": {
          "comment": "mirrored copy of CollisionComponent's BlockRigidBody for the Actor property window for LDs (so it's next to CollisionType)\n purely for editing convenience and not used at all by the physics code"
        },
        "bNoEncroachCheck": {
          "comment": "For encroachers, don't do the overlap check when they move. You will not get touch events for this actor moving, but it is much faster.\n So if you want touch events from volumes or triggers you need to set this to be FALSE.\n This is an optimisation for large numbers of PHYS_RigidBody actors for example."
        },
        "bPhysRigidBodyOutOfWorldCheck": {
          "comment": "If true, do a zero-extent trace each frame from old to new Location when in PHYS_RigidBody. If it hits the world (ie might be tunneling), call FellOutOfWorld."
        },
        "CollisionType": {
          "comment": "enum for LDs to select collision options - sets Actor flags and that of our CollisionComponent via PostEditChange()"
        },
        "bHidden": {
          "comment": "If this is True, all PrimitiveComponents of the actor are hidden. If this is false, only PrimitiveComponents with HiddenGame=True are hidden."
        },
        "DrawScale3D": {
          "comment": "Scaling vector, (1.0,1.0,1.0)=normal size."
        },
        "DrawScale<UIMin=0.1|UIMax=4.0>": {
          "comment": "Scaling factor, 1.0=normal size."
        },
        "EditorIconColor": {
          "comment": "Color to tint the icon for this actor"
        },
        "PrePivot": {
          "comment": "Offset from box center for drawing."
        },
        "Location": {
          "comment": "Actor's location; use Move or SetLocation to change."
        },
        "Rotation": {
          "comment": "The actor's rotation; use SetRotation to change."
        },
        "bBlocksNavigation": {
          "comment": "indicates that this Actor can dynamically block AI paths"
        },
        "bAllowFluidSurfaceInteraction": {
          "comment": "Whether this actor will interact with fluid surfaces or not."
        }
      },
      "functions": {
        "ActivateEventClass": {
          "comment": "Iterates through the given list of events and looks for all\n matching events, activating them as found."
        },
        "ActorEffectIsRelevant": {
          "comment": "Determine whether an effect being spawned on this actor\n is relevant to the local client (to determine whether it really needs to be spawned).\n Intended for use only with short lived effects\n NOTE: Use ImpactEffectIsRelevant if the actor is not rendered!\n @PARAM EffectInstigator: Instigator os this effect - always relevant if instigated by local player\n @PARAM SpawnLocation: Location where effect is being spawned. If being spawned attached to this actor, use this actor's location to take advantage of check for whether actor is being rendered.\n @PARAM bForceDedicated: Whether effect should always be spawned on dedicated server (if effect is replicated to clients)\n @PARAM CullDistance: Max distance to spawn this effect if SpawnLocation is visible to the local player\n @PARAM HiddenCullDistance: Max distance to spawn this effect if SpawnLocation is not visible to the local player"
        },
        "AllOwnedComponents": {
          "comment": "Iterates over all components directly or indirectly attached to this actor.",
          "params": {
            "BaseClass": "Only components deriving from BaseClass will be iterated upon.",
            "OutComponent": "The iteration variable."
          }
        },
        "AnimTreeUpdated": {
          "comment": "Notification called when one of our meshes gets his AnimTree updated"
        },
        "ApplyFluidSurfaceImpact": {
          "comment": "Called when this actor touches a fluid surface"
        },
        "AttachComponent": {
          "comment": "Adds a component to the actor's components array, attaching it to the actor.",
          "params": {
            "NewComponent": "The component to attach."
          }
        },
        "BeginAnimControl": {
          "comment": "Called when we start an AnimControl track operating on this Actor. Supplied is the set of AnimSets we are going to want to play from."
        },
        "BP2Vect": {
          "comment": "This will take the BasedPosition passed and return a Vector for it"
        },
        "CalcCamera": {
          "comment": "Calculate camera view point, when viewing this actor.",
          "params": {
            "fDeltaTime": "delta time seconds since last update",
            "out_CamLoc": "Camera Location",
            "out_CamRot": "Camera Rotation",
            "out_FOV": "Field of View"
          }
        },
        "CalculateMinSpeedTrajectory": {
          "comment": "CalculateMinSpeedTrajectory()\n returns a velocity that will result in a trajectory that minimizes the speed of the projectile within the given range",
          "params": {
            "out_Velocity": "out param stuffed with the computed velocity to use",
            "End": "desired end point of arc",
            "Start": "desired start point of arc",
            "MaxTossSpeed": "Max acceptable speed of projectile",
            "MinTossSpeed": "Min Acceptable speed of projectile",
            "CollisionSize": "(optional) - is the size of bunding box of the tossed actor (defaults to (0,0,0)",
            "TerminalVelocity": "(optional) - terminal velocity of the projectile",
            "GravityZ": "(optional) - gravity inflicted upon the projectile in the z direction",
            "bOnlyTraceUp": "(optional) - when TRUE collision checks verifying the arc will only be done along the upward portion of the arc"
          }
        },
        "CanActorPlayFaceFXAnim": {
          "comment": "Returns FALSE if Actor can play facefx\n Implement in sub-class."
        },
        "ChartData": {
          "comment": "Draw some value over time onto the StatChart. Toggle on and off with"
        },
        "CheckHitInfo": {
          "comment": "Make sure we pass along a valid HitInfo struct for damage.\n The main reason behind this is that SkeletalMeshes do require a BoneName to receive and process an impulse...\n So if we don't have access to it (through touch() or for any non trace damage results), we need to perform an extra trace call().",
          "params": {
            "HitInfo,": "initial structure to check",
            "FallBackComponent,": "PrimitiveComponent to use if HitInfo.HitComponent is none",
            "Dir,": "Direction to use if a Trace needs to be performed to find BoneName on skeletalmesh. Trace from HitLocation.",
            "out_HitLocation,": "HitLocation to use for potential Trace, will get updated by Trace."
          }
        },
        "ClampRotation": {
          "comment": "Clamps out_Rot between the upper and lower limits offset from the base"
        },
        "ClearAllTimers": {
          "comment": "Clears all previously set timers"
        },
        "ClearLatentAction": {
          "comment": "Clears all latent actions of the specified class.",
          "params": {
            "actionClass": "type of latent action to clear",
            "bAborted": "was this latent action aborted?",
            "exceptionAction": "action to skip"
          }
        },
        "ClearTimer": {
          "comment": "Clears a previously set timer, identical to calling\n SetTimer() with a <= 0.f rate.",
          "params": {
            "inTimerFunc": "the name of the timer to remove or the default one if not specified"
          }
        },
        "CollisionChanged": {
          "comment": "Called when collision values change for this actor (via SetCollision/SetCollisionSize)."
        },
        "ComponentList": {
          "comment": "returns each component in the Components list"
        },
        "ConstraintBrokenNotify": {
          "comment": "When a constraint is broken we will get this event from c++ land."
        },
        "CreateForceField": {
          "comment": "Called by AnimNotify_CreateForceField\n Looks for a socket name first then bone name",
          "params": {
            "AnimNotifyData": "The AnimNotify_ForceField which will have all of the various params on it"
          }
        },
        "DebugFreezeGame": {
          "comment": "Debug Freeze Game\n dumps the current script function stack and pauses the game with PlayersOnly (still allowing the player to move around)."
        },
        "DetachComponent": {
          "comment": "Removes a component from the actor's components array, detaching it from the actor.",
          "params": {
            "ExComponent": "The component to detach."
          }
        },
        "DisplayDebug": {
          "comment": "list important Actor variables on canvas. HUD will call DisplayDebug() on the current ViewTarget when\n the ShowDebug exec is used",
          "params": {
            "HUD": "HUD with canvas to draw on\n \n@input out_YL - Height of the current font\n \n@input out_YPos - Y position on Canvas. out_YPos += out_YL, gives position to draw text for next debug line."
          }
        },
        "DoKismetAttachment": {
          "comment": "Performs actual attachment. Can be subclassed for class specific behaviors."
        },
        "DrawDebugBox": {
          "comment": "Draw a debug box"
        },
        "DrawDebugCone": {
          "comment": "Draw a debug cone"
        },
        "DrawDebugCoordinateSystem": {
          "comment": "Draw Debug coordinate system"
        },
        "DrawDebugCylinder": {
          "comment": "Draw a debug cylinder"
        },
        "DrawDebugLine": {
          "comment": "Draw a debug line"
        },
        "DrawDebugPoint": {
          "comment": "Draw a debug point"
        },
        "DrawDebugSphere": {
          "comment": "Draw a debug sphere"
        },
        "DrawDebugStar": {
          "comment": "Draw a debug star"
        },
        "DrawDebugString": {
          "comment": "Draw Debug string in the world (SLOW, use only in debug)",
          "params": {
            "TextLocation": "location the string should be drawn (NOTE: if base actor is non-null this will be treated as an offset from that actor)",
            "Text": "text to draw",
            "TestBaseActor": "(optional) - actor the string should be attached to (none if it should be static)",
            "Color": "(optional) - the color of the text to draw",
            "Duration": "(optional) - the duration the text should stick around; defauls to forever"
          }
        },
        "EffectIsRelevant": {
          "comment": "OBSOLETE, replaced by ActorEffectIsRelevant and ImpactEffectIsRelevant"
        },
        "EncroachingOn": {
          "comment": "called when this Actor is encroaching on Other and we couldn't find an appropriate place to push Other to"
        },
        "FellOutOfWorld": {
          "comment": "called when the actor falls out of the world 'safely' (below KillZ and such)"
        },
        "FindBase": {
          "comment": "Attempts to find a valid base for this actor and sets it as the current base if found"
        },
        "FindEventsOfClass": {
          "comment": "Builds a list of all events of the specified class.",
          "params": {
            "eventClass": "type of event to search for",
            "out_EventList": "list of found events",
            "bIncludeDisabled": "will not filter out the events with bEnabled = FALSE"
          }
        },
        "FindGoodEndView": {
          "comment": "Used by PlayerController.FindGoodView() in RoundEnded State"
        },
        "FinishAnimControl": {
          "comment": "Called when we are done with the AnimControl track."
        },
        "fixedTurn": {
          "comment": "Returns a new rotation component value\n @PARAM Current is the current rotation value\n @PARAM Desired is the desired rotation value\n @PARAM DeltaRate is the rotation amount to apply"
        },
        "FlushDebugStrings": {
          "comment": "clear all debug strings"
        },
        "FlushPersistentDebugLines": {
          "comment": "Flush persistent lines"
        },
        "ForceNetRelevant": {
          "comment": "forces this actor to be net relevant if it is not already\n by default, only works on level placed actors (bNoDelete)"
        },
        "ForceUpdateComponents": {
          "comment": "Flags all components as dirty and then calls UpdateComponents().",
          "params": {
            "bCollisionUpdate": "[opt] As per UpdateComponents; defaults to FALSE.",
            "bTransformOnly": "[opt] TRUE to update only the component transforms, FALSE to update the entire component."
          }
        },
        "GetActorEyesViewPoint": {
          "comment": "returns the point of view of the actor.\n note that this doesn't mean the camera, but the 'eyes' of the actor.\n For example, for a Pawn, this would define the eye height location,\n and view rotation (which is different from the pawn rotation which has a zeroed pitch component).\n A camera first person view will typically use this view point. Most traces (weapon, AI) will be done from this view point.",
          "params": {
            "out_Location": "location of view point",
            "out_Rotation": "view rotation of actor."
          }
        },
        "GetActorFaceFXAsset": {
          "comment": "Used by Matinee in-game to mount FaceFXAnimSets before playing animations."
        },
        "GetActorMetrics": {
          "comment": "Retrieve various actor metrics depending on the provided type. All of\n these will total the values of the given type for every component that\n makes up the actor.",
          "params": {
            "MetricsType": "The type of metric to calculate.\n METRICS_VERTS - Get the number of vertices.\n METRICS_TRIS - Get the number of triangles.\n METRICS_SECTIONS - Get the number of sections."
          }
        },
        "GetAggregateBaseVelocity": {
          "comment": "This will compute the aggregate velocity all the way up the Base chain"
        },
        "GetAimAdhesionExtent": {
          "comment": "Returns aim-adhesion zone extents for this actor.\n Extents are in world units centered around Actor's location, and assumed to be\n oriented to face the viewer (like a billboard sprite)."
        },
        "GetAimFrictionExtent": {
          "comment": "Returns aim-friction zone extents for this actor.\n Extents are in world units centered around Actor's location, and assumed to be\n oriented to face the viewer (like a billboard sprite)."
        },
        "GetALocalPlayerController": {
          "comment": "Return first found LocalPlayerController. Fine for single player, in split screen, one will be picked."
        },
        "GetAvoidanceVector": {
          "comment": "Calculates a direction (unit vector) to avoid all actors contained in Obstacles list, assuming each entry in Obstacles is also\n avoiding this actor. Based loosely on RVO as described in http://gamma.cs.unc.edu/RVO/icra2008.pdf ."
        },
        "GetBasedPosition": {
          "comment": "This will take the BasedPosition passed and return a Vector for it"
        },
        "GetBaseMost": {
          "comment": "Walks up the Base chain from this Actor and returns the Actor at the top (the eventual Base). this->Base is NULL, returns this."
        },
        "GetDestination": {
          "comment": "returns the position the AI should move toward to reach this actor\n accounts for AI using path lanes, cutting corners, and other special adjustments"
        },
        "GetFaceFXAudioComponent": {
          "comment": "Function for allowing you to tell FaceFX which AudioComponent it should use for playing audio\n for corresponding facial animation."
        },
        "GetGravityZ": {
          "comment": "Get gravity currently affecting this actor"
        },
        "GetPackageGuid": {
          "comment": "Looks up the GUID of a package on disk. The package must NOT be in the autodownload cache.\n This may require loading the header of the package in question and is therefore slow."
        },
        "GetTargetLocation": {
          "params": {
            "RequestedBy": "the Actor requesting the target location",
            "bRequestAlternateLoc": "(optional) - return a secondary target location if there are multiple"
          }
        },
        "GetTerminalVelocity": {
          "comment": "returns terminal velocity (max speed while falling) for this actor. Unless overridden, it returns the TerminalVelocity of the PhysicsVolume in which this actor is located."
        },
        "GetTimerCount": {
          "comment": "Gets the current count for the specified timer, defaults\n to 'Timer' if no function is specified. Returns -1.f\n if the timer is not currently active.",
          "params": {
            "inTimerFunc": "the name of the timer to remove or the default one if not specified"
          }
        },
        "GetTimerRate": {
          "comment": "Gets the current rate for the specified timer.\n \n@note: GetTimerRate('SomeTimer') - GetTimerCount('SomeTimer') is the time remaining before 'SomeTimer' is called",
          "params": {
            ":": "TimerFuncName the name of the function to check for a timer for; 'Timer' is the default"
          }
        },
        "HealDamage": {
          "comment": "the reverse of TakeDamage(); heals the specified amount",
          "params": {
            "Amount": "The amount of damage to heal",
            "Healer": "Who is doing the healing",
            "DamageType": "What type of healing is it"
          }
        },
        "ImpactEffectIsRelevant": {
          "comment": "Determine whether an effect being spawned at some spot in the world\n is relevant to the local client (to determine whether it really needs to be spawned).\n Intended for use only with short lived effects\n @PARAM EffectInstigator: Instigator os this effect - always relevant if instigated by local player\n @PARAM SpawnLocation: Location where effect is being spawned. If being spawned attached to this actor, use this actor's location to take advantage of check for whether actor is being rendered.\n @PARAM bForceDedicated: Whether effect should always be spawned on dedicated server (if effect is replicated to clients)\n @PARAM CullDistance: Max distance to spawn this effect if SpawnLocation is visible to the local player\n @PARAM HiddenCullDistance: Max distance to spawn this effect if SpawnLocation is not visible to the local player\n @PARAM bSkipLOSCheck: If true, don't perform a LOS trace, as the object is \"big\" like an explosion and a LOS would be inaccurate"
        },
        "InterpolationChanged": {
          "comment": "called when a SeqAct_Interp action affecting this Actor received an event that changed its properties\n (paused, reversed direction, etc)\n \n@note this function is called on clients for actors that are interpolated clientside via MatineeActor",
          "params": {
            "InterpAction": "the SeqAct_Interp that is affecting the Actor"
          }
        },
        "InterpolationFinished": {
          "comment": "called when a SeqAct_Interp action finished interpolating this Actor\n \n@note this function is called on clients for actors that are interpolated clientside via MatineeActor",
          "params": {
            "InterpAction": "the SeqAct_Interp that was affecting the Actor"
          }
        },
        "InterpolationStarted": {
          "comment": "called when a SeqAct_Interp action starts interpolating this Actor via matinee\n \n@note this function is called on clients for actors that are interpolated clientside via MatineeActor",
          "params": {
            "InterpAction": "the SeqAct_Interp that is affecting the Actor"
          }
        },
        "IsActorPlayingFaceFXAnim": {
          "comment": "Returns TRUE if Actor is playing a FaceFX anim.\n Implement in sub-class."
        },
        "IsBasedOn": {
          "comment": "iterates up the Base chain to see whether or not this Actor is based on the given Actor",
          "params": {
            "TestActor": "the Actor to test for"
          }
        },
        "IsInPain": {
          "comment": "@RETURN true if this actor is touching a pain causing volume"
        },
        "IsInPersistentLevel": {
          "comment": "whether this Actor is in the persistent level, i.e. not a sublevel"
        },
        "IsOwnedBy": {
          "comment": "iterates up the Owner chain to see whether or not this Actor is owned by the given Actor",
          "params": {
            "TestActor": "the Actor to test for"
          }
        },
        "IsPlayerOwned": {
          "comment": "Searches the owner chain looking for a player."
        },
        "IsTimerActive": {
          "comment": "Returns true if the specified timer is active, defaults\n to 'Timer' if no function is specified.",
          "params": {
            "inTimerFunc": "the name of the timer to remove or the default one if not specified"
          }
        },
        "LocalPlayerControllers": {
          "comment": "iterator LocalPlayerControllers()\nreturns all locally rendered/controlled player controllers (typically 1 per client, unless split screen)"
        },
        "ModifyHearSoundComponent": {
          "comment": "called when a sound is going to be played on this Actor via PlayerController::ClientHearSound()\n gives it a chance to modify the component that will be used (add parameter values, etc)"
        },
        "ModifyTimerTimeDilation": {
          "comment": "This will search the Timers on this actor and set the passed in TimerTimeDilation"
        },
        "MovingWhichWay": {
          "comment": "This will return the direction in LocalSpace that that actor is moving. This is useful for firing off effects based on which way the actor is moving."
        },
        "NativePostRenderFor": {
          "comment": "Hook to allow actors to render HUD overlays for themselves.\nAssumes that appropriate font has already been set"
        },
        "OnAnimEnd": {
          "comment": "Event called when an AnimNodeSequence (in the animation tree of one of this Actor's SkeletalMeshComponents) reaches the end and stops.\n Will not get called if bLooping is 'true' on the AnimNodeSequence.\n bCauseActorAnimEnd must be set 'true' on the AnimNodeSequence for this event to get generated.",
          "params": {
            "SeqNode": "Node that finished playing. You can get to the SkeletalMeshComponent by looking at SeqNode->SkelComponent",
            "PlayedTime": "Time played on this animation. (play rate independant).",
            "ExcessTime": "how much time overlapped beyond end of animation. (play rate independant)."
          }
        },
        "OnAnimPlay": {
          "comment": "Event called when a PlayAnim is called AnimNodeSequence in the animation tree of one of this Actor's SkeletalMeshComponents.\n bCauseActorAnimPlay must be set 'true' on the AnimNodeSequence for this event to get generated.",
          "params": {
            "SeqNode": "Node had PlayAnim called. You can get to the SkeletalMeshComponent by looking at SeqNode->SkelComponent"
          }
        },
        "OnAttachToActor": {
          "comment": "Attach an actor to another one. Kismet action."
        },
        "OnChangeCollision": {
          "comment": "Handler for collision action, allow designer to toggle collide/block actors"
        },
        "OnDestroy": {
          "comment": "If this actor is not already scheduled for destruction,\n destroy it now."
        },
        "OnRanOver": {
          "comment": "Called each frame (for each wheel) when an SVehicle has a wheel in contact with this Actor.\n Not called on Actors that have bWorldGeometry or bStatic set to TRUE."
        },
        "OnRigidBodySpringOverextension": {
          "comment": "Notification forwarded from RB_BodyInstance, when a spring is over extended and disabled."
        },
        "OnSetBlockRigidBody": {
          "comment": "Handler for the SeqAct_SetBlockRigidBody action. Allows level designer to toggle the rigid-body blocking\n flag on an Actor, and will handle updating the physics engine etc."
        },
        "OnSetPhysics": {
          "comment": "Handler for the SeqAct_SetPhysics action, allowing designer to change the Physics mode of an Actor."
        },
        "OnSetVelocity": {
          "comment": "Handler for the SeqAct_SetVelocity action. Allows level designer to impart a velocity on the actor."
        },
        "OnSleepRBPhysics": {
          "comment": "RigidBody went to sleep after being awake - only valid if bCallRigidBodyWakeEvents==TRUE"
        },
        "OnTeleport": {
          "comment": "Called upon receiving a SeqAct_Teleport action. Grabs\n the first destination available and attempts to teleport\n this actor.",
          "params": {
            "Action": "teleport action that was activated"
          }
        },
        "OnToggleHidden": {
          "comment": "Handler for SeqAct_ToggleHidden, just sets bHidden."
        },
        "OnWakeRBPhysics": {
          "comment": "RigidBody woke up after being stationary - only valid if bCallRigidBodyWakeEvents==TRUE"
        },
        "OutsideWorldBounds": {
          "comment": "called when the Actor is outside the hard limit on world bounds\n @note physics and collision are automatically turned off after calling this function"
        },
        "OverlappingActors": {
          "comment": "Returns colliding (bCollideActors==true) which overlap a Sphere from location 'Loc' and 'Radius' radius.",
          "params": {
            "BaseClass": "The Actor returns must be a subclass of this.",
            "out_Actor": "returned Actor at each iteration.",
            "Radius": "Radius of sphere for overlapping check.",
            "Loc": "Center of sphere for overlapping check. (Optional, caller's location is used otherwise).",
            "bIgnoreHidden": "if true, ignore bHidden actors."
          }
        },
        "OverRotated": {
          "comment": "Called by ClampRotation if the rotator was outside of the limits"
        },
        "PauseTimer": {
          "comment": "Pauses/Unpauses a previously set timer",
          "params": {
            "bPause": "whether to pause/unpause the timer",
            "inTimerFunc": "the name of the timer to pause or the default one if not specified",
            "inObj": "object timer is attached to"
          }
        },
        "PlayActorFaceFXAnim": {
          "comment": "Play FaceFX animations on this Actor.\n Returns TRUE if succeeded, if failed, a log warning will be issued."
        },
        "PlayParticleEffect": {
          "comment": "Called by AnimNotify_PlayParticleEffect\n Looks for a socket name first then bone name",
          "params": {
            "AnimNotifyData": "The AnimNotify_PlayParticleEffect which will have all of the various params on it"
          }
        },
        "PointCheckComponent": {
          "comment": "Run a point check against just this PrimitiveComponent. Return TRUE if we hit.\n NOTE: the actual Actor we call this on is irrelevant!"
        },
        "PostDemoRewind": {
          "comment": "called on all dynamic or net relevant actors after rewinding a demo\n primarily used to propagate properties to components, since components are ignored for rewinding"
        },
        "PostInitAnimTree": {
          "comment": "called after initializing the AnimTree for the given SkeletalMeshComponent that has this Actor as its Owner\n this is a good place to cache references to skeletal controllers, etc that the Actor modifies"
        },
        "PostRenderFor": {
          "comment": "Script function called by NativePostRenderFor()."
        },
        "PrestreamTextures": {
          "comment": "Calls PrestreamTextures() for all the actor's meshcomponents.",
          "params": {
            "Seconds": "Number of seconds to force all mip-levels to be resident",
            "bEnableStreaming": "Whether to start (TRUE) or stop (FALSE) streaming",
            "CinematicTextureGroups": "Bitfield indicating which texture groups that use extra high-resolution mips"
          }
        },
        "ReattachComponent": {
          "comment": "Detaches and immediately reattaches specified component. Handles bWillReattach properly."
        },
        "ReceivedNewEvent": {
          "comment": "Called by SeqAct_AttachToEvent when a duplicate event is added to this actor at run-time"
        },
        "ReplicationEnded": {
          "comment": "called ONLY for bNoDelete Actors on the client when the server was replicating data on this Actor,\n but no longer considers it relevant (i.e. the actor channel was destroyed)\n for !bNoDelete Actors this results in destruction, so cleanup code can be done there, but bNoDelete Actors\n just keep going with whatever data was last received, so this is their chance to perform any cleanup"
        },
        "Reset": {
          "comment": "Reset actor to initial state - used when restarting level without reloading."
        },
        "ResetTimerTimeDilation": {
          "comment": "This will search the Timers on this actor and reset the TimerTimeDilation to 1.0f"
        },
        "RigidBodyCollision": {
          "comment": "Called when a PrimitiveComponent this Actor owns has:\n -bNotifyRigidBodyCollision set to true\n -ScriptRigidBodyCollisionThreshold > 0\n -it is involved in a physics collision where the relative velocity exceeds ScriptRigidBodyCollisionThreshold",
          "params": {
            "HitComponent": "the component of this Actor that collided",
            "OtherComponent": "the other component that collided",
            "RigidCollisionData": "information on the collision itslef, including contact points",
            "ContactIndex": "the element in each ContactInfos' ContactVelocity and PhysMaterial arrays that corresponds\n to this Actor/HitComponent"
          }
        },
        "RootMotionExtracted": {
          "comment": "Notification called after root motion has been extracted, and before it's been used.\n This notification can be used to alter extracted root motion before it is forwarded to physics.\n It is only called when bRootMotionExtractedNotify is TRUE on the SkeletalMeshComponent.\n @note: It is fairly slow in Script, so enable only when really needed."
        },
        "RootMotionModeChanged": {
          "comment": "Notification that root motion mode changed.\n Called only from SkelMeshComponents that have bRootMotionModeChangeNotify set.\n This is useful for synchronizing movements.\n For intance, when using RMM_Translate, and the event is called, we know that root motion will kick in on next frame.\n It is possible to kill in-game physics, and then use root motion seemlessly."
        },
        "RootMotionProcessed": {
          "comment": "Notification that Root Motion has been processed."
        },
        "SearchForBaseBelow": {
          "comment": "Attempts to find a base for this actor; does not modify the actor's base. HeightBelow is the number of units below center to trace (FindBase uses 8)"
        },
        "SetAnimPosition": {
          "comment": "Called each from while the Matinee action is running, with the desired sequence name and position we want to be at."
        },
        "SetBasedPosition": {
          "comment": "This will calculate and then set the passed in BasedPosition. This is just modifying the passed in BasedPosition."
        },
        "SetForcedInitialReplicatedProperty": {
          "comment": "adds/removes a property from a list of properties that will always be replicated when this Actor is bNetInitial, even if the code thinks\n the client has the same value the server already does\n This is a workaround to the problem where an LD places an Actor in the level, changes a replicated variable away from the defaults,\n then at runtime the variable is changed back to the default but it doesn't replicate because initial replication is based on class defaults\n Only has an effect when called on bStatic or bNoDelete Actors\n Only properties already in the owning class's replication block may be specified",
          "params": {
            "PropToReplicate": "the property to add or remove to the list",
            "bAdd": "true to add the property, false to remove the property"
          }
        },
        "SetHidden": {
          "comment": "Changes the value of bHidden.",
          "params": {
            "bNewHidden": "The value to assign to bHidden."
          }
        },
        "SetHUDLocation": {
          "comment": "function used to update where icon for this actor should be rendered on the HUD",
          "params": {
            "NewHUDLocation": "is a vector whose X and Y components are the X and Y components of this actor's icon's 2D position on the HUD"
          }
        },
        "SetMorphWeight": {
          "comment": "Called each frame by Matinee to update the weight of a particular MorphNodeWeight."
        },
        "SetNetUpdateTime": {
          "comment": "Updates NetUpdateTime to the new value for future net relevancy checks"
        },
        "SetOnlyOwnerSee": {
          "comment": "changes the value of bOnlyOwnerSee",
          "params": {
            "bNewOnlyOwnerSee": "the new value to assign to bOnlyOwnerSee"
          }
        },
        "SetSkelControlScale": {
          "comment": "Called each frame by Matinee to update the scaling on a SkelControl."
        },
        "SetTickGroup": {
          "comment": "Changes the ticking group for this actor"
        },
        "SetTickIsDisabled": {
          "comment": "turns on or off this Actor's desire to be ticked (bTickIsDisabled)\n because this is implemented as a separate tickable list, calls to this function\n to disable ticking will not take effect until the end of the current list to avoid shuffling\n elements around while they are being iterated over"
        },
        "SetTimer": {
          "comment": "Sets a timer to call the given function at a set\n interval. Defaults to calling the 'Timer' event if\n no function is specified. If InRate is set to\n 0.f it will effectively disable the previous timer.\n NOTE: Functions with parameters are not supported!",
          "params": {
            "InRate": "the amount of time to pass between firing",
            "inbLoop": "whether to keep firing or only fire once",
            "inTimerFunc": "the name of the function to call when the timer fires"
          }
        },
        "SetZone": {
          "comment": "updates the zone/PhysicsVolume of this Actor",
          "params": {
            "bForceRefresh": "forces the code to do a full collision check instead of exiting early if the current info is valid"
          }
        },
        "ShouldBeHiddenBySHOW_NavigationNodes": {
          "comment": "replaces IsA(NavigationPoint) check for primitivecomponents"
        },
        "ShutDown": {
          "comment": "ShutDown an actor."
        },
        "Spawn": {
          "comment": "Spawn an actor. Returns an actor of the specified class, not\n of class Actor (this is hardcoded in the compiler). Returns None\n if the actor could not be spawned (if that happens, there will be a log warning indicating why)\n Defaults to spawning at the spawner's location.\n @note: ActorTemplate is sent for replicated actors and therefore its properties will also be applied\n at initial creation on the client. However, because of this, ActorTemplate must be a static resource\n (an actor archetype, default object, or a bStatic/bNoDelete actor in a level package)\n or the spawned Actor cannot be replicated"
        },
        "SpawnedByKismet": {
          "comment": "called when this Actor was spawned by a Kismet actor factory (SeqAct_ActorFactory)\n after all other spawn events (PostBeginPlay(), etc) have been called"
        },
        "StopActorFaceFXAnim": {
          "comment": "Stop any matinee FaceFX animations on this Actor."
        },
        "SupportsKismetModification": {
          "comment": "whether this Actor can be modified by Kismet actions\n primarily used by error checking to warn LDs when their Kismet may not apply changes correctly (especially on clients)",
          "params": {
            "AskingOp": "Kismet operation to which this Actor is linked",
            "Reason": "(out) - If this function returns false, contains the reason why the Kismet action is not allowed to execute on this Actor"
          }
        },
        "TakeDamage": {
          "comment": "apply some amount of damage to this actor",
          "params": {
            "DamageAmount": "the base damage to apply",
            "EventInstigator": "the Controller responsible for the damage",
            "HitLocation": "world location where the hit occurred",
            "Momentum": "force caused by this hit",
            "DamageType": "class describing the damage that was done",
            "HitInfo": "additional info about where the hit occurred",
            "DamageCauser": "the Actor that directly caused the damage (i.e. the Projectile that exploded, the Weapon that fired, etc)"
          }
        },
        "TakeRadiusDamage": {
          "comment": "Take Radius Damage\n by default scales damage based on distance from HurtOrigin to Actor's location.\n This can be overridden by the actor receiving the damage for special conditions (see KAsset.uc).\n This then calls TakeDamage() to go through the same damage pipeline.",
          "params": {
            "InstigatedBy,": "instigator of the damage",
            "DamageRadius": "(from Origin)",
            "DamageType": "class",
            "Momentum": "(float)",
            "HurtOrigin,": "origin of the damage radius.",
            "bFullDamage,": "if true, damage not scaled based on distance HurtOrigin",
            "DamageCauser": "the Actor that directly caused the damage (i.e. the Projectile that exploded, the Weapon that fired, etc)",
            "DamageFalloff": "allows for nonlinear damage falloff from the point. Default is linera."
          }
        },
        "TickSkelControl": {
          "comment": "Called every tick if bShouldTickOwner is true"
        },
        "Trace": {
          "comment": "Trace a line and see what it collides with first.\n Takes this actor's collision properties into account.\n Returns first hit actor, Level if hit level, or None if hit nothing."
        },
        "TraceComponent": {
          "comment": "Run a line check against just this PrimitiveComponent. Return TRUE if we hit.\n NOTE: the actual Actor we call this on is irrelevant!"
        },
        "TrailsNotify": {
          "comment": "Called by AnimNotify_Trails",
          "params": {
            "AnimNotifyData": "The AnimNotify_Trails which will have all of the various params on it"
          }
        },
        "TrailsNotifyEnd": {
          "comment": "Called by AnimNotify_Trails",
          "params": {
            "AnimNotifyData": "The AnimNotify_Trails which will have all of the various params on it"
          }
        },
        "TrailsNotifyTick": {
          "comment": "Called by AnimNotify_Trails",
          "params": {
            "AnimNotifyData": "The AnimNotify_Trails which will have all of the various params on it"
          }
        },
        "TriggerEventClass": {
          "comment": "Convenience function for triggering events in the GeneratedEvents list\n If you need more options (activating multiple outputs, etc), call ActivateEventClass() directly"
        },
        "TriggerGlobalEventClass": {
          "comment": "trigger a \"global\" Kismet event (one that doesn't have an Originator, generally because it's triggered by a game-time object)"
        },
        "UsedBy": {
          "comment": "Called when being activated by the specified pawn. Default\n implementation searches for any SeqEvent_Used and activates\n them."
        },
        "Vect2BP": {
          "comment": "This will calculate and then set the passed in BasedPosition. This is just modifying the passed in BasedPosition."
        },
        "VolumeBasedDestroy": {
          "comment": "Called when an Actor should be destroyed by a pain volume."
        },
        "WillOverlap": {
          "comment": "Steps from each position given the respective velocities performing simple radius checks"
        }
      },
      "structs": {
        "ActorReference": {
          "comment": "Struct used for cross level actor references"
        },
        "AnimSlotDesc": {
          "comment": "Used to indicate each slot name and how many channels they have.",
          "properties": {
            "NumChannels": {
              "comment": "Number of channels that are available in this slot."
            },
            "SlotName": {
              "comment": "Name of the slot."
            }
          }
        },
        "AnimSlotInfo": {
          "comment": "Struct used for passing information from Matinee to an Actor for blending animations during a sequence.",
          "properties": {
            "ChannelWeights": {
              "comment": "Strength of each Channel within this Slot. Channel indexs are determined by track order in Matinee."
            },
            "SlotName": {
              "comment": "Name of slot that we want to play the animtion in."
            }
          }
        },
        "BasedPosition": {
          "comment": "Struct for handling positions relative to a base actor, which is potentially moving"
        },
        "CollisionImpactData": {
          "comment": "Information about an overall collision, including contacts\n @warning: C++ mirroring is in UnPhysPublic.h",
          "properties": {
            "ContactInfos": {
              "comment": "all the contact points in the collision"
            },
            "TotalFrictionForceVector": {
              "comment": "the total counterforce applied of the two objects sliding against each other"
            },
            "TotalNormalForceVector": {
              "comment": "the total force applied as the two objects push against each other"
            }
          }
        },
        "ImpactInfo": {
          "comment": "Hit definition struct. Mainly used by Instant Hit Weapons.",
          "properties": {
            "HitActor": {
              "comment": "Actor Hit"
            },
            "HitInfo": {
              "comment": "Trace Hit Info (material, bonename...)"
            },
            "HitLocation": {
              "comment": "world location of hit impact"
            },
            "HitNormal": {
              "comment": "Hit normal of impact"
            },
            "RayDir": {
              "comment": "Direction of ray when hitting actor"
            },
            "StartTrace": {
              "comment": "Start location of trace"
            }
          }
        },
        "NavReference": {
          "comment": "Slow version of deref that will use GUID if Actor is NULL"
        },
        "PhysEffectInfo": {
          "comment": "Struct used to pass back information for physical impact effect"
        },
        "RigidBodyContactInfo": {
          "comment": "Information about one contact between a pair of rigid bodies\n @warning: C++ mirroring is in UnPhysPublic.h"
        },
        "RigidBodyState": {
          "comment": "describes the physical state of a rigid body\n @warning: C++ mirroring is in UnPhysPublic.h"
        }
      }
    },
    "ActorComponent": {
      "properties": {
        "bNeedsReattach": {
          "comment": "Is this component in need of an update?"
        },
        "bNeedsUpdateTransform": {
          "comment": "Is this component's transform in need of an update?"
        },
        "TickGroup": {
          "comment": "The ticking group this component belongs to"
        }
      },
      "functions": {
        "DetachFromAny": {
          "comment": "detaches the component from whatever it's attached to"
        },
        "ForceUpdate": {
          "comment": "force this component to be updated right now\n component must be directly attached to its Owner (not attached to another component)",
          "params": {
            "bTransformOnly": "if true, only update transform, otherwise do a full reattachment"
          }
        },
        "SetComponentRBFixed": {
          "comment": "Sets whether or not the physics for this object should be 'fixed' (ie kinematic) or allowed to move with dynamics.\n If bFixed is true, all bodies within this component will be fixed.\n If bFixed is false, bodies will be set back to the default defined by their BodySetup."
        },
        "SetTickGroup": {
          "comment": "Changes the ticking group for this component"
        }
      }
    },
    "ActorFactory": {
      "properties": {
        "AlternateMenuPriority": {
          "comment": "DEPRECATED - Alternate value for menu priority; Used to allow things like modifier keys to access items in a different order."
        },
        "bPlaceable": {
          "comment": "Whether to appear on menu (or this Factory only used through scripts etc.)"
        },
        "bShowInEditorQuickMenu": {
          "comment": "Whether to appear in the editor add actor quick menu"
        },
        "GameplayActorClass": {
          "comment": "class to spawn during gameplay; only used if NewActorClass is left at the default"
        },
        "MenuName": {
          "comment": "Name used as basis for 'New Actor' menu."
        },
        "MenuPriority": {
          "comment": "Indicates how far up the menu item should be. The higher the number, the higher up the list."
        },
        "NewActorClass": {
          "comment": "Actor subclass this ActorFactory creates."
        }
      },
      "functions": {
        "PostCreateActor": {
          "comment": "Allows script to modify new actor"
        }
      }
    },
    "ActorFactoryActor": {
      "properties": {
        "ActorClass": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter\n \n@return True if the actor can be created with this factory"
        }
      }
    },
    "ActorFactoryAI": {
      "properties": {
        "bGiveDefaultInventory": {
          "comment": "whether or not to give the spawned Pawn the default inventory for the gametype being played"
        },
        "ControllerClass": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter\n \n@return True if the actor can be created with this factory"
        },
        "InventoryList": {
          "comment": "additional inventory to give the Pawn"
        },
        "TeamIndex": {
          "comment": "what team to put the AI on"
        }
      }
    },
    "ActorFactoryAmbientSound": {
      "comment": "The base class of all ambient sound types",
      "properties": {
        "AmbientSoundCue": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter\n \n@return True if the actor can be created with this factory"
        }
      }
    },
    "ActorFactoryAmbientSoundSimple": {
      "properties": {
        "SoundNodeWave": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter\n \n@return True if the actor can be created with this factory"
        }
      }
    },
    "ActorFactoryApexClothing": {
      "properties": {
        "ClothingAssets": {
          "comment": "List of clothing assets associated with each material int this mesh."
        },
        "ClothingRBChannel": {
          "comment": "Allows setting the RBChannel flag on the spawned rigid body's StaticMeshComponent."
        },
        "ClothingRBCollideWithChannels": {
          "comment": "Define the channels with which this actor will collide."
        }
      }
    },
    "ActorFactoryApexDestructible": {
      "properties": {
        "bStartAwake": {
          "comment": "Starts the actor in an awake(dynamic) state"
        },
        "CollideWithChannels": {
          "comment": "Define the channels with which this actor will collide."
        },
        "RBChannel": {
          "comment": "Allows setting the RBChannel flag on the spawned rigid body's StaticMeshComponent."
        }
      }
    },
    "ActorFactoryArchetype": {
      "properties": {
        "ArchetypeActor": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter\n \n@return True if the actor can be created with this factory"
        }
      }
    },
    "ActorFactoryDecal": {
      "properties": {
        "DecalMaterial": {
          "comment": "Clears references to resources [usually set by the call to AutoFillFields] when the factory has done its work. The default behavior\n (which is to call AutoFillFields() with an empty selection set) should be sufficient for most factories, but this method is provided\n to allow customized behavior."
        }
      }
    },
    "ActorFactoryDynamicSM": {
      "properties": {
        "bCastDynamicShadow": {
          "comment": "If false, primitive does not cast dynamic shadows."
        },
        "bNoEncroachCheck": {
          "comment": "For encroachers, don't do the overlap check when they move. You will not get touch events for this actor moving, but it is much faster.\n So if you want touch events from volumes or triggers you need to set this to be FALSE.\n This is an optimisation for large numbers of PHYS_RigidBody actors for example.\n @see Actor.uc bNoEncroachCheck"
        },
        "bUseCompartment": {
          "comment": "Try and use physics hardware for this spawned object."
        },
        "StaticMesh": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter\n \n@return True if the actor can be created with this factory"
        }
      }
    },
    "ActorFactoryEmitter": {
      "properties": {
        "ParticleSystem": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter\n \n@return True if the actor can be created with this factory"
        }
      }
    },
    "ActorFactoryFogVolumeConstantDensityInfo": {
      "properties": {
        "SelectedMaterial": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Used to determine if we should add to context menu for example.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter"
        }
      }
    },
    "ActorFactoryFracturedStaticMesh": {
      "properties": {
        "FracturedStaticMesh": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter\n \n@return True if the actor can be created with this factory"
        }
      }
    },
    "ActorFactoryLensFlare": {
      "properties": {
        "LensFlareObject": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter\n \n@return True if the actor can be created with this factory"
        }
      }
    },
    "ActorFactoryPhysicsAsset": {
      "properties": {
        "bCastDynamicShadow": {
          "comment": "If false, primitive does not cast dynamic shadows."
        },
        "bUseCompartment": {
          "comment": "Try and use physics hardware for this spawned object."
        }
      }
    },
    "ActorFactoryRigidBody": {
      "properties": {
        "AdditionalVelocity": {
          "comment": "If valid, Velocity added to InitialVelocity when creating actor.\n This is here in addition to InitialVelocity to maintain backwards compatibility."
        },
        "bDamageAppliesImpulse": {
          "comment": "Sets the bDamageAppliesImpulse flag on the new Actor."
        },
        "bEnableStayUprightSpring": {
          "comment": "Enable 'Stay upright' torque, that tries to keep Z axis of KActor pointing along world Z"
        },
        "bLocalSpaceInitialVelocity": {
          "comment": "Indicates if the initial velocity settings below should be considered in the world space or local space of the spawn target actor."
        },
        "bStartAwake": {
          "comment": "Should spawned Actor start simulating as soon as its created, or be 'asleep' until hit."
        },
        "InitialAngularVelocity": {
          "comment": "If valid, Angular Velocity given to newly spawned Actor."
        },
        "InitialVelocity": {
          "comment": "Velocity that new rigid bodies will have when created. In the ref frame of the spawn target actor."
        },
        "RBChannel": {
          "comment": "Allows setting the RBChannel flag on the spawned rigid body's StaticMeshComponent."
        },
        "StayUprightMaxTorque": {
          "comment": "Max torque that can be applied to try and keep KActor horizontal"
        },
        "StayUprightTorqueFactor": {
          "comment": "Torque applied to try and keep KActor horizontal."
        }
      }
    },
    "ActorFactorySkeletalMesh": {
      "properties": {
        "SkeletalMesh": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter\n \n@return True if the actor can be created with this factory"
        }
      }
    },
    "ActorFactoryStaticMesh": {
      "properties": {
        "StaticMesh": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter\n \n@return True if the actor can be created with this factory"
        }
      }
    },
    "ActorFactoryVehicle": {
      "properties": {
        "VehicleClass": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter\n \n@return True if the actor can be created with this factory"
        }
      }
    },
    "AICommandBase": {
      "functions": {
        "GetUtility": {
          "comment": "When determining the utility value one can think of it in these terms:\n -how important is doing this action compared to other actions\n -how exciting is doing this action compared to other actions\n \n e.g. I have 2 idle actions; reading a newspaper and picking on a pedestrian. Picking on the pedestrian is more existing\n so it should be higher rated than reading the newspaper\n e.g. I have an action am drinking ambrosia and responding to a threat. In this case drinking ambrosia is really \n important. At the same importance as \"EngageThreat\" classification. So we will add EngageThreat.UtilityStartVal\n to our utilty score to represent that.\n Utility functions should be checking for the data that says whether or not something occured. They should NOT be\n checking for things like: If you were in an Idle Action and/or if your current Action has some property set. \n That is bad as that is causing undue coupling between Actions.\n Additionally, the Utilty Function rules all. Period.\n If things are not correctly occurring then the utility function is broken in some way.\n One should not try to set special bools on blackboard/controller/active state and then look for them\n \n If the current set of stimuli is not \"valid\" / \"able to have data for the utility\" then we need to\n more than likely add some generalized functionality to it.\n If that can not be done then we need to start along the \"bool cloud\" path in the stimulus struct But that should be the last option."
        }
      }
    },
    "AICommandNodeBase": {
      "properties": {
        "UtilityDMC": {
          "comment": "DMC for utility function"
        }
      }
    },
    "AIController": {
      "properties": {
        "bAdjustFromWalls": {
          "comment": "auto-adjust around corners, with no hitwall notification for controller or pawn"
        },
        "bReverseScriptedRoute": {
          "comment": "if true, we're following the scripted route in reverse"
        },
        "ScriptedFocus": {
          "comment": "view focus from last scripted action"
        },
        "ScriptedMoveTarget": {
          "comment": "Move target from last scripted action"
        },
        "ScriptedRoute": {
          "comment": "Route from last scripted action; if valid, sets ScriptedMoveTarget with the points along the route"
        },
        "ScriptedRouteIndex": {
          "comment": "if ScriptedRoute is valid, the index of the current point we're moving to"
        },
        "Skill": {
          "comment": "skill, scaled by game difficulty (add difficulty to this value)"
        }
      },
      "functions": {
        "DisplayDebug": {
          "comment": "list important AIController variables on canvas. HUD will call DisplayDebug() on the current ViewTarget when\n the ShowDebug exec is used",
          "params": {
            "HUD": "HUD with canvas to draw on\n \n@input out_YL - Height of the current font\n \n@input out_YPos - Y position on Canvas. out_YPos += out_YL, gives position to draw text for next debug line."
          }
        },
        "OnAIMoveToActor": {
          "comment": "Scripting hook to move this AI to a specific actor."
        },
        "PreBeginPlay": {
          "comment": "Called when the AIController is destroyed via script"
        }
      }
    },
    "AIGatherNodeBase": {
      "properties": {
        "LastUpdateTime": {
          "comment": "Last time this gather node was updated"
        },
        "NodeName": {
          "comment": "Name of the gather node, so we can search by node name from the utility functions of command nodes"
        }
      }
    },
    "AISwitchablePylon": {
      "properties": {
        "bOpen": {
          "comment": "returns TRUE if the path from Poly back to start has an edge which is linked to a switch which is linked to this \n pylon\n \n@param Edge - the edge linking Poly to the next neighbor in question\n \n@param Poly - the source poly (the current end-of-line poly in the chain)\n \n@return - TRUE if the previousPath chain of Poly has a switch linked to this pylon in it"
        }
      }
    },
    "AITree": {
      "properties": {
        "GatherList": {
          "comment": "Graph of all gather nodes for this tree"
        },
        "RootList": {
          "comment": "List of all roots available in the tree"
        }
      },
      "functions": {
        "SetActiveRoot": {
          "comment": "Set active root to root node with given name"
        }
      },
      "structs": {
        "AITreeHandle": {
          "comment": "Struct that allows AI Controller to store state information about the AI tree \n Used because multiple AI can share the same tree content and they should not be altering the actual tree",
          "properties": {
            "ActiveRoot": {
              "comment": "Ptr to active root node"
            },
            "ActiveRootName": {
              "comment": "Name of the active root node"
            },
            "DisabledNodes": {
              "comment": "List of command nodes that we want to ignore"
            }
          }
        }
      }
    },
    "AmbientOcclusionEffect": {
      "properties": {
        "FilterSize": {
          "comment": "Size of the blur filter, in pixels."
        },
        "HistoryWeightConvergenceTime": {
          "comment": "Time in which the weight history should approximately converge."
        },
        "OcclusionAttenuation<UIMin=0.0|UIMax=10.0>": {
          "comment": "Attenuation factor that determines how much to weigh in samples based on distance, larger values result in a faster falloff over distance."
        },
        "SSAO2": {
          "comment": "SSAO2 is SSAO with quality improvements, it is now the new method so the flag is no longer needed"
        },
        "MinOcclusion": {
          "comment": "Minimum occlusion value after all other transforms have been applied."
        },
        "OcclusionBias<UIMin=-1.0|UIMax=4.0>": {
          "comment": "Bias to apply to the calculated occlusion value."
        },
        "OcclusionColor": {
          "comment": "The color that will replace scene color where there is a lot of occlusion."
        },
        "OcclusionPower<UIMin=0.1|UIMax=20.0>": {
          "comment": "Power to apply to the calculated occlusion value. \n Higher powers result in more contrast, but will need other factors like OcclusionScale to be tweaked as well."
        },
        "OcclusionScale<UIMin=0.0|UIMax=10.0>": {
          "comment": "Scale to apply to the calculated occlusion value."
        },
        "EdgeDistanceScale": {
          "comment": "Scale factor to increase EdgeDistanceThreshold for distant pixels. \n A value of .001 would result in EdgeDistanceThreshold being 1 unit larger at a distance of 1000 world units."
        },
        "EdgeDistanceThreshold": {
          "comment": "Difference in depth that two pixels must be to be considered an edge, and therefore not blurred across, in world units."
        },
        "FilterDistanceScale": {
          "comment": "Distance in world units which should map to the kernel size in screen space. \n This is useful to reduce filter kernel size for distant pixels and keep detail, at the cost of leaving more noise in the result."
        },
        "HaloDistanceScale": {
          "comment": "Scale factor to increase HaloDistanceThreshold for distant pixels. \n A value of .001 would result in HaloDistanceThreshold being 1 unit larger at a distance of 1000 world units."
        },
        "HaloDistanceThreshold": {
          "comment": "Distance in front of a pixel that an occluder must be to be considered a different object, in world units. \n This threshold is used to identify halo regions around nearby objects, for example a first person weapon."
        },
        "HaloOcclusion": {
          "comment": "Occlusion factor to assign to samples determined to be contributing to a halo. \n 0 would result in full occlusion for that sample, increasing values map to quadratically decreasing occlusion values."
        },
        "HistoryConvergenceTime": {
          "comment": "Time in which the occlusion history should approximately converge. \n Longer times (.5s) allow more smoothing between frames and less noise but history streaking is more noticeable.\n 0 means the feature is off (less GPU performance and memory overhead)"
        },
        "bAngleBasedSSAO": {
          "comment": "SSAO quality improvements, less noise, more detail, no darkening of flat surfaces, no overbright on convex, parameter retweak needed"
        },
        "OcclusionFadeoutMaxDistance": {
          "comment": "Distance at which the occlusion factor should be fully faded, in world units."
        },
        "OcclusionFadeoutMinDistance": {
          "comment": "Distance at which to start fading out the occlusion factor, in world units. \n This is useful for hiding distant artifacts on skyboxes."
        },
        "OcclusionQuality": {
          "comment": "Quality of the ambient occlusion effect. Low quality gives the best performance and is appropriate for gameplay. \n Medium quality smooths noise between frames at a slightly higher performance cost. High quality uses extra samples to preserve detail."
        },
        "OcclusionRadius<UIMin=0.0|UIMax=256.0>": {
          "comment": "Distance to check around each pixel for occluders, in world units."
        }
      }
    },
    "AmbientSound": {
      "properties": {
        "bIsPlaying": {
          "comment": "Is the audio component currently playing?"
        },
        "bAutoPlay": {
          "comment": "Should the audio component automatically play on load?"
        },
        "AudioComponent": {
          "comment": "Audio component to play"
        }
      }
    },
    "AmbientSoundSimple": {
      "properties": {
        "SoundCueInstance": {
          "comment": "Dummy sound cue property to force instantiation of subobject."
        },
        "SoundNodeInstance": {
          "comment": "Dummy sound node property to force instantiation of subobject."
        },
        "AmbientProperties": {
          "comment": "Mirrored property for easier editability, set in Spawned."
        }
      }
    },
    "AmbientSoundSimpleToggleable": {
      "properties": {
        "bCurrentlyPlaying": {
          "comment": "used to update status of toggleable level placed ambient sounds on clients"
        },
        "bIgnoreAutoPlay": {
          "comment": "Used to track whether the sound's auto-play setting should be ignored or not"
        }
      },
      "functions": {
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        }
      }
    },
    "AnimationCompressionAlgorithm": {
      "properties": {
        "bNeedsSkeleton": {
          "comment": "Compression algorithms requiring a skeleton should set this value to TRUE."
        },
        "Description": {
          "comment": "A human-readable name for this modifier; appears in editor UI."
        },
        "TranslationCompressionFormat": {
          "comment": "Format for bitwise compression of translation data."
        },
        "RotationCompressionFormat": {
          "comment": "Format for bitwise compression of rotation data."
        }
      }
    },
    "AnimationCompressionAlgorithm_Automatic": {
      "properties": {
        "MaxEndEffectorError": {
          "comment": "Maximum amount of error that a compression technique can introduce in an end effector"
        }
      }
    },
    "AnimationCompressionAlgorithm_PerTrackCompression": {
      "properties": {
        "PerReductionCachedData": {
          "comment": "Cached metastructures used within DoReduction, tied to a particular sequence and mesh"
        },
        "PerturbationProbeSize": {
          "comment": "How big of a perturbation should be made when probing error propagation"
        },
        "bUseAdaptiveError": {
          "comment": "If TRUE, adjust the error thresholds based on the 'height' within the skeleton"
        },
        "bUseOverrideForEndEffectors": {
          "comment": "If TRUE, uses MinEffectorDiff as the threhsold for end effectors"
        },
        "ParentingDivisor<ClampMin=1.0>": {
          "comment": "Reduces the error tolerance the further up the tree that a key occurs\n EffectiveErrorTolerance = Max(BaseErrorTolerance / Power(ParentingDivisor, Max(Height+Bias,0) * ParentingDivisorExponent), ZeroingThreshold)\n Only has an effect bUseAdaptiveError is TRUE"
        },
        "ParentingDivisorExponent<ClampMin=0.1>": {
          "comment": "Reduces the error tolerance the further up the tree that a key occurs\n EffectiveErrorTolerance = Max(BaseErrorTolerance / Power(ParentingDivisor, Max(Height+Bias,0) * ParentingDivisorExponent), ZeroingThreshold)\n Only has an effect bUseAdaptiveError is TRUE"
        },
        "TrackHeightBias": {
          "comment": "A bias added to the track height before using it to calculate the adaptive error"
        },
        "bUseAdaptiveError2": {
          "comment": "If true, the adaptive error system will determine how much error to allow for each track, based on the\n error introduced in end effectors due to errors in the track."
        },
        "MaxErrorPerTrackRatio<ClampMin=0.0|ClampMax=1.0>": {
          "comment": "A fraction that determines how much of the total error budget can be introduced by any particular track"
        },
        "RotationErrorSourceRatio<ClampMin=0.0|ClampMax=1.0>": {
          "comment": "This ratio determines how much error in end effector rotation can come from a given track's rotation error or translation error.\n If 1, all of it must come from rotation error, if 0.5, half can come from each, and if 0.0, all must come from translation error."
        },
        "TranslationErrorSourceRatio<ClampMin=0.0|ClampMax=1.0>": {
          "comment": "This ratio determines how much error in end effector translation can come from a given track's rotation error or translation error.\n If 1, all of it must come from rotation error, if 0.5, half can come from each, and if 0.0, all must come from translation error."
        },
        "AllowedRotationFormats": {
          "comment": "Which encoding formats is the per-track compressor allowed to try on rotation keys"
        },
        "AllowedTranslationFormats": {
          "comment": "Which encoding formats is the per-track compressor allowed to try on translation keys"
        },
        "MaxAngleDiffBitwise": {
          "comment": "Maximum angle difference to use when testing if an animation key may be removed. Lower values retain more keys, but yield less compression."
        },
        "MaxPosDiffBitwise": {
          "comment": "Maximum position difference to use when testing if an animation key may be removed. Lower values retain more keys, but yield less compression."
        },
        "MaxZeroingThreshold": {
          "comment": "Maximum threshold to use when replacing a component with zero. Lower values retain more keys, but yield less compression."
        },
        "bResampleAnimation": {
          "comment": "If TRUE, resample the animation to ResampleFramerate frames per second"
        },
        "MinKeysForResampling": {
          "comment": "Animations with fewer keys than MinKeysForResampling will not be resampled."
        },
        "ResampledFramerate<ClampMin=1.0|ClampMax=30.0|EditCondition=bResampleAnimation>": {
          "comment": "When bResampleAnimation is true, this defines the desired framerate"
        }
      }
    },
    "AnimationCompressionAlgorithm_RemoveEverySecondKey": {
      "properties": {
        "bStartAtSecondKey": {
          "comment": "If bStartAtSecondKey is TRUE, remove keys 1,3,5,etc.\n If bStartAtSecondKey is FALSE, remove keys 0,2,4,etc."
        },
        "MinKeys": {
          "comment": "Animations with fewer than MinKeys will not lose any keys."
        }
      }
    },
    "AnimationCompressionAlgorithm_RemoveLinearKeys": {
      "properties": {
        "bActuallyFilterLinearKeys": {
          "comment": "Controls whether the final filtering step will occur, or only the retargetting after bitwise compression.\n If both this and bRetarget are false, then the linear compressor will do no better than the underlying bitwise compressor, extremely slowly."
        },
        "bRetarget": {
          "comment": "TRUE = As the animation is compressed, adjust animated nodes to compensate for compression error.\n FALSE= Do not adjust animated nodes."
        },
        "EffectorDiffSocket": {
          "comment": "Error threshold for End Effectors with Sockets attached to them.\n Typically more important bone, where we want to be less aggressive with compression."
        },
        "MaxAngleDiff": {
          "comment": "Maximum angle difference to use when testing if an animation key may be removed. Lower values retain more keys, but yield less compression."
        },
        "MaxEffectorDiff": {
          "comment": "As keys are tested for removal, we monitor the effects all the way down to the end effectors. \n If their position changes by more than this amount as a result of removing a key, the key will be retained.\n This value is used for all bones except the end-effectors parent."
        },
        "MaxPosDiff": {
          "comment": "Maximum position difference to use when testing if an animation key may be removed. Lower values retain more keys, but yield less compression."
        },
        "MinEffectorDiff": {
          "comment": "As keys are tested for removal, we monitor the effects all the way down to the end effectors. \n If their position changes by more than this amount as a result of removing a key, the key will be retained.\n This value is used for the end-effectors parent, allowing tighter restrictions near the end of a skeletal chain."
        },
        "ParentKeyScale": {
          "comment": "A scale value which increases the likelihood that a bone will retain a key if it's parent also had a key at the same time position. \n Higher values can remove shaking artifacts from the animation, at the cost of compression."
        }
      }
    },
    "AnimMetaData": {
      "comment": "Definition of AnimMetaData class\n Warning: those are not instanced per AnimNodeSequence, they are solely attached to an AnimSequence.\n Therefore they can be affecting multiple nodes at the same time!"
    },
    "AnimMetaData_SkelControl": {
      "properties": {
        "bFullControlOverController": {
          "comment": "If TRUE, then it requires bControlledByAnimMetadata to be set as well on the BoneController.\n It will then affect AnimMetadataWeight instead of ControlStrength.\n And BoneController will only be turned on if there is such metadata present in the animation.\n FALSE will set directly the BoneController's ControlStrength when that metadata is present."
        },
        "SkelControlNameList": {
          "comment": "List of Bone Controllers Names to control."
        }
      }
    },
    "AnimMetaData_SkelControlKeyFrame": {
      "properties": {
        "KeyFrames": {
          "comment": "Modifiers for what time and what strength for this skelcontrol"
        }
      }
    },
    "AnimNode": {
      "properties": {
        "bCachedHasRootMotion": {
          "comment": "Cached bool indicating if node supplies root motion, to avoid recalculating (see above)."
        },
        "bDisableCaching": {
          "comment": "Temporarily disable caching when calling Super::GetBoneAtoms so it's not done multiple times."
        },
        "bEditorOnly": {
          "comment": "This node is editor only and used for something like placement preview"
        },
        "bJustBecameRelevant": {
          "comment": "set to TRUE when this node became relevant this round of updates. Will be set to false on the next tick."
        },
        "bRelevant": {
          "comment": "This node is considered 'relevant' - that is, has >0 weight in the final blend."
        },
        "CachedBoneAtoms": {
          "comment": "If a node is linked to more than once in the graph, this is a cache of the results, to avoid re-evaluating the results."
        },
        "CachedCurveKeys": {
          "comment": "Cached curve keys to avoid recalculating (see above)."
        },
        "CachedNumDesiredBones": {
          "comment": "Num Desired Bones used in CachedBoneAtoms. If we request something different, CachedBoneAtoms array is not going to be valid."
        },
        "CachedRootMotionDelta": {
          "comment": "Cached root motion delta, to avoid recalculating (see above)."
        },
        "NodeCachedAtomsTag": {
          "comment": "Used to indicate whether the BoneAtom cache for this node is up-to-date or not."
        },
        "NodeInitTag": {
          "comment": "Initialization tag, for deferred InitAnim."
        },
        "NodeTickTag": {
          "comment": "Used to avoid ticking a node twice if it has multiple parents."
        },
        "NodeTotalWeight": {
          "comment": "Total apparent weight this node has in the final blend of all animations."
        },
        "ParentNodes": {
          "comment": "Array of Parent nodes, which in most cases only has 1 element."
        },
        "SearchTag": {
          "comment": "used when iterating over nodes via GetNodes() and related functions to skip nodes that have already been processed"
        },
        "TickArrayIndex": {
          "comment": "Index in AnimTick Array. Serialized, because we serialize TickArrayIndex in UAnimTree."
        },
        "bCallScriptEventOnInit": {
          "comment": "Flags to control if Script Events should be called. Note that those will affect performance, so be careful!"
        },
        "NodeName": {
          "comment": "This is the name used to find an AnimNode by name from a tree."
        },
        "LastUpdatedAnimMorphKeys": {
          "comment": "Array of blended curve key for editor only"
        },
        "bTickDuringPausedAnims": {
          "comment": "If TRUE, this node will be ticked, even if bPauseAnims is TRUE on the SkelMeshComp."
        }
      },
      "functions": {
        "FindAnimNode": {
          "comment": "Find an Animation Node in the Animation Tree whose NodeName matches InNodeName.\n Will search this node and all below it.\n Warning: The search is O(n^2), so for large AnimTrees, cache result."
        },
        "OnBecomeRelevant": {
          "comment": "Get notification that this node has become relevant for the final blend. ie TotalWeight is now > 0"
        },
        "OnCeaseRelevant": {
          "comment": "Get notification that this node is no longer relevant for the final blend. ie TotalWeight is now == 0"
        },
        "OnInit": {
          "comment": "Called from InitAnim. Allows initialization of script-side properties of this node."
        }
      },
      "structs": {
        "CurveKey": {
          "comment": "Curve Key\n@CurveName : Morph Target name to blend"
        }
      }
    },
    "AnimNodeAdditiveBlending": {
      "properties": {
        "bPassThroughWhenNotRendered": {
          "comment": "if TRUE, pass through (skip additive animation blending) when mesh is not rendered"
        }
      },
      "functions": {
        "SetBlendTarget": {
          "comment": "Overridden so we can keep child zero weight at 1."
        }
      }
    },
    "AnimNodeAimOffset": {
      "properties": {
        "AimCpntIndexLUT": {
          "comment": "Look Up Table for AimCpnt Indices"
        },
        "RequiredBones": {
          "comment": "Internal, array of required bones. Selected bones and their parents for local to component space transformation."
        },
        "TemplateNode": {
          "comment": "Pointer to AimOffset node in package (AnimTreeTemplate), to avoid duplicating profile data. \n Always NULL in AimOffset Editor (in ATE)."
        },
        "Aim": {
          "comment": "Angle of aiming, between -1..+1"
        },
        "AngleOffset": {
          "comment": "Angle offset applied to Aim before processing"
        },
        "bBakeFromAnimations": {
          "comment": "Bake offsets from animations."
        },
        "bForceAimDir": {
          "comment": "If true, ignore Aim, and use the ForcedAimDir enum instead to determine which aim direction to draw."
        },
        "CurrentProfileIndex": {
          "comment": "Index of currently active Profile.\n Use the SetActiveProfileByName or SetActiveProfileByIndex function to change."
        },
        "ForcedAimDir": {
          "comment": "If bForceAimDir is true, this is the direction to render the character aiming in."
        },
        "Profiles": {
          "comment": "Array of different aiming 'profiles'"
        },
        "bSynchronizeNodesInEditor": {
          "comment": "When moving the slider, keep nodes with same property in sync."
        },
        "bPassThroughWhenNotRendered": {
          "comment": "if TRUE, pass through (skip additive animation blending) when mesh is not rendered"
        },
        "PassThroughAtOrAboveLOD": {
          "comment": "If the LOD of this skeletal mesh is at or above this LOD, then this node will do nothing."
        }
      },
      "functions": {
        "SetActiveProfileByIndex": {
          "comment": "Change the currently active profile to the one with the supplied index.\n If ProfileIndex is outside range, this does nothing."
        },
        "SetActiveProfileByName": {
          "comment": "Change the currently active profile to the one with the supplied name.\n If a profile with that name does not exist, this does nothing."
        }
      },
      "structs": {
        "AimComponent": {
          "comment": "definition of an AimComponent.",
          "properties": {
            "BoneName": {
              "comment": "Bone transformed"
            },
            "CU": {
              "comment": "Center"
            },
            "LU": {
              "comment": "Left column"
            },
            "RU": {
              "comment": "Right"
            }
          }
        },
        "AimOffsetProfile": {
          "properties": {
            "AimComponents": {
              "comment": "Array of AimComponents.\n Represents the selected bones and their transformations."
            },
            "AnimName_LU": {
              "comment": "Names of animations to use when automatically generating offsets based animations for each direction.\n Animations are not actually used in-game - just for editor."
            },
            "HorizontalRange": {
              "comment": "Maximum horizontal range (min, max) for horizontal aiming."
            },
            "ProfileName": {
              "comment": "Name of this aim-offset profile."
            },
            "VerticalRange": {
              "comment": "Maximum horizontal range (min, max) for vertical aiming."
            }
          }
        },
        "AimTransform": {
          "comment": "9 control points range:\n Left Center Right\n LU CU RU Up\n LC CC RC Center\n LD CD RD Down"
        }
      }
    },
    "AnimNodeBlend": {
      "properties": {
        "bSkipBlendWhenNotRendered": {
          "comment": "if TRUE, do not blend when the Skeletal Mesh is not visible.\n Optimization to save on blending time when meshes are not rendered.\n Instant switch instead."
        }
      },
      "functions": {
        "SetBlendTarget": {
          "comment": "Set desired balance of this blend.",
          "params": {
            "BlendTarget": "Target amount of weight to put on Children(1) (second child). Between 0.0 and 1.0.\n 1.0 means take all animation from second child.",
            "BlendTime": "How long to take to get to BlendTarget."
          }
        }
      }
    },
    "AnimNodeBlendBase": {
      "properties": {
        "bFixNumChildren": {
          "comment": "Whether children connectors (ie elements of the Children array) may be added/removed."
        },
        "Children": {
          "comment": "Array of children AnimNodes. These will be blended together and the results returned by GetBoneAtoms."
        },
        "BlendType": {
          "comment": "Type of animation blending. Affects how the weight interpolates."
        }
      },
      "functions": {
        "PlayAnim": {
          "comment": "Update Child Weight : Make sure childIndex isn't OOB"
        }
      },
      "structs": {
        "AnimBlendChild": {
          "comment": "Link to a child AnimNode.",
          "properties": {
            "Anim": {
              "comment": "Child AnimNode."
            },
            "bIsAdditive": {
              "comment": "Is Children Additive Animation."
            },
            "BlendWeight": {
              "comment": "Weight used for blending. See AnimBlendType."
            },
            "bMirrorSkeleton": {
              "comment": "Whether this child's skeleton should be mirrored.\n Do not use this lightly, mirroring is rather expensive.\n So minimize the number of times mirroring is done in the tree."
            },
            "DrawY": {
              "comment": "For editor use."
            },
            "Name": {
              "comment": "Name of link."
            },
            "Weight": {
              "comment": "Weight with which this child will be blended in. Sum of all weights in the Children array must be 1.0"
            }
          }
        }
      }
    },
    "AnimNodeBlendByBase": {
      "properties": {
        "CachedBase": {
          "comment": "Cached Base Actor"
        },
        "ActorClass<AllowAbstract>": {
          "comment": "Actor class that will match the base"
        },
        "ActorTag": {
          "comment": "Actor tag that will match the base"
        },
        "BlendTime": {
          "comment": "Duration of blend"
        },
        "Type": {
          "comment": "Type of comparison to do"
        }
      }
    },
    "AnimNodeBlendByProperty": {
      "properties": {
        "bForceUpdate": {
          "comment": "Force an update on the node"
        },
        "CachedFloatProperty": {
          "comment": "Cached property object pointer. Avoids slow FindField on a per tick basis, and cast."
        },
        "CachedOwner": {
          "comment": "Track Owner changes"
        },
        "CachedPropertyName": {
          "comment": "Name of cached property. Used to detect changes and invalidating the cached property."
        },
        "bUseOwnersBase": {
          "comment": "If Property should be looked up on the Owner's base instead of the Owner."
        },
        "bUseSpecificBlendTimes": {
          "comment": "Use BlendToChild1Time/BlendToChild2Time instead of BlendTime?"
        },
        "PropertyName": {
          "comment": "Property Name to look up"
        },
        "bSynchronizeNodesInEditor": {
          "comment": "When moving the slider, keep nodes with same property in sync."
        }
      }
    },
    "AnimNodeBlendBySpeed": {
      "properties": {
        "LastChannel": {
          "comment": "Last Channel being used"
        },
        "Speed": {
          "comment": "How fast they are moving this frame."
        },
        "BlendDownDelay": {
          "comment": "Optional delay before blending to the next channel"
        },
        "BlendDownPerc": {
          "comment": "When should we start blending back down"
        },
        "BlendDownTime": {
          "comment": "How fast to blend when going down"
        },
        "BlendUpDelay": {
          "comment": "Optional delay before blending to the next channel"
        },
        "BlendUpTime": {
          "comment": "How fast to blend when going up"
        },
        "bUseAcceleration": {
          "comment": "Use acceleration instead of Velocity to determine speed"
        },
        "Constraints": {
          "comment": "Weights/ constraints used for transition between child nodes"
        }
      }
    },
    "AnimNodeBlendDirectional": {
      "properties": {
        "DirAngle": {
          "comment": "In radians. Between -PI and PI. 0.0 is running the way we are looking."
        },
        "RotationOffset": {
          "comment": "Rotational offset to apply"
        },
        "bUseAcceleration": {
          "comment": "Use acceleration instead of Velocity to determine speed"
        },
        "DirDegreesPerSecond": {
          "comment": "Allows control over how quickly the directional blend should be allowed to change."
        },
        "SingleAnimAtOrAboveLOD": {
          "comment": "If the LOD for the mesh is at or above this LOD level, only use a single directional animation instead of blending."
        }
      }
    },
    "AnimNodeBlendList": {
      "properties": {
        "ActiveChildIndex": {
          "comment": "Child currently active - that is, at or ramping up to 100%."
        },
        "BlendTimeToGo": {
          "comment": "How long before current blend is complete (ie. active child reaches 100%)"
        },
        "SliderPosition": {
          "comment": "slider position, for animtree editor"
        },
        "TargetWeight": {
          "comment": "Array of target weights for each child. Size must be the same as the Children array."
        },
        "bPlayActiveChild": {
          "comment": "Call play anim when active child is changed"
        },
        "EditorActiveChildIndex": {
          "comment": "ActiveChildIndex for use in editor only, to debug transitions"
        },
        "bForceChildFullWeightWhenBecomingRelevant": {
          "comment": "If TRUE (Default), then when the node becomes relevant, the Active Child will be forced to full weight.\n This is a general optimization, as multiple nodes tend to change state at the same time, this will\n reduce the maximum number of blends and animation decompression done at the same time.\n Setting it to FALSE, will let the node interpolate animation normally."
        },
        "bSkipBlendWhenNotRendered": {
          "comment": "if TRUE, do not blend when the Skeletal Mesh is not visible.\n Optimization to save on blending time when meshes are not rendered.\n Instant switch instead."
        }
      },
      "functions": {
        "SetActiveChild": {
          "comment": "Called after (copy/)pasted - reset values or re-link if neede"
        }
      }
    },
    "AnimNodeBlendMultiBone": {
      "properties": {
        "SourceRequiredBones": {
          "comment": "Indices of bones required from Source (at LOD 0), if Target's weight is 1.0.\n Bones are only in this array if their per-bone weight is <1.0 (or they have a child in the array).\n Indices should be strictly increasing."
        },
        "BlendTargetList": {
          "comment": "List of blend targets - one per bone to blend"
        }
      },
      "functions": {
        "SetTargetStartBone": {
          "comment": "Updating the StartBoneName or PerBoneIncrease, will cause the TargetPerBoneWeight to be automatically re-updated, you'll loose custom values!"
        }
      },
      "structs": {
        "ChildBoneBlendInfo": {
          "properties": {
            "InitPerBoneIncrease": {
              "comment": "Used in InitAnim, so you can set up partial blending in the defaultproperties. See SetTargetStartBone."
            },
            "InitTargetStartBone": {
              "comment": "Used in InitAnim, so you can set up partial blending in the defaultproperties. See SetTargetStartBone."
            },
            "OldBoneIncrease": {
              "comment": "Old OldBoneIncrease, to monitor changes"
            },
            "OldStartBone": {
              "comment": "Old StartBone, to monitor changes"
            },
            "TargetPerBoneWeight": {
              "comment": "Weight scaling for each bone of the skeleton. Must be same size as RefSkeleton of SkeletalMesh. If all 0.0, no animation can ever be drawn from Child2."
            },
            "TargetRequiredBones": {
              "comment": "Indices of bones required from Target (at LOD 0), if Target's weight is >0.0.\n Bones are only in this array if their per-bone weight is >0.0 (or they have a child in the array).\n Indices should be strictly increasing."
            }
          }
        }
      }
    },
    "AnimNodeBlendPerBone": {
      "properties": {
        "Child2PerBoneWeight": {
          "comment": "per bone weight list, built from list of branches."
        },
        "LocalToCompReqBones": {
          "comment": "Required bones for local to component space conversion"
        },
        "bForceLocalSpaceBlend": {
          "comment": "If TRUE, blend will be done in local space."
        },
        "BranchStartBoneName": {
          "comment": "List of branches to mask in from child2"
        }
      },
      "functions": {
        "SetBlendTarget": {
          "comment": "Overridden so we can keep child zero weight at 1."
        }
      }
    },
    "AnimNodeCrossfader": {
      "properties": {
        "bDontBlendOutOneShot": {
          "comment": "true if not blending out of the current one shot anim. Anim will just freeze at last frame"
        },
        "PendingBlendOutTimeOneShot": {
          "comment": "Blend Out time for current One Shot anim"
        },
        "DefaultAnimSeqName": {
          "comment": "default animation sequence played upon startup"
        }
      },
      "functions": {
        "BlendToLoopingAnim": {
          "comment": "Blend to a looping animation.",
          "params": {
            "AnimSeqName": "Name of animation sequence to play.",
            "BlendInTime": "time to blend from current animation to this (new) one.",
            "Rate": "Playing rate of animation."
          }
        },
        "GetActiveChild": {
          "comment": "Get active AnimNodeSequence child. To access animation properties and control functions."
        },
        "GetAnimName": {
          "comment": "Get Animation Name currently playing"
        },
        "PlayOneShotAnim": {
          "comment": "Play a One Shot animation.",
          "params": {
            "AnimSeqName": "Name of animation sequence to play",
            "BlendInTime": "time to blend from current animation to this (new) one.",
            "BlendOutTime": "time to blend from this animation (before it finishes playing) back to the previous one.",
            "bDontBlendOut": "if true, animation will freeze at last frame, and not blend back to the old one.",
            "Rate": "Playing rate of animation."
          }
        }
      }
    },
    "AnimNodePlayCustomAnim": {
      "properties": {
        "bIsPlayingCustomAnim": {
          "comment": "True, when we're playing a custom animation"
        },
        "CustomPendingBlendOutTime": {
          "comment": "save blend out time when playing a one shot animation."
        }
      },
      "functions": {
        "GetCustomAnimNodeSeq": {
          "comment": "Returns AnimNodeSequence playing the custom animation"
        },
        "PlayCustomAnim": {
          "comment": "Play a custom animation.\n Supports many features, including blending in and out.",
          "params": {
            "AnimName": "Name of animation to play.",
            "Rate": "Rate animation should be played at.",
            "BlendInTime": "Blend duration to play anim.",
            "BlendOutTime": "Time before animation ends (in seconds) to blend out.\n -1.f means no blend out.\n 0.f = instant switch, no blend.\n otherwise it's starting to blend out at AnimDuration - BlendOutTime seconds.",
            "bLooping": "Should the anim loop? (and play forever until told to stop)",
            "bOverride": "play same animation over again only if bOverride is set to true."
          }
        },
        "PlayCustomAnimByDuration": {
          "comment": "Play a custom animation.\n Auto adjusts the animation's rate to match a given duration in seconds.\n Supports many features, including blending in and out.",
          "params": {
            "AnimName": "Name of animation to play.",
            "Duration": "duration in seconds the animation should be played.",
            "BlendInTime": "Blend duration to play anim.",
            "BlendOutTime": "Time before animation ends (in seconds) to blend out.\n -1.f means no blend out.\n 0.f = instant switch, no blend.\n otherwise it's starting to blend out at AnimDuration - BlendOutTime seconds.",
            "bLooping": "Should the anim loop? (and play forever until told to stop)",
            "bOverride": "play same animation over again only if bOverride is set to true."
          }
        },
        "SetActorAnimEndNotification": {
          "comment": "Set bCauseActorAnimEnd flag"
        },
        "SetCustomAnim": {
          "comment": "Set Custom animation."
        },
        "SetRootBoneAxisOption": {
          "comment": "Set custom animation root bone options."
        },
        "StopCustomAnim": {
          "comment": "Stop playing a custom animation.\n Used for blending out of a looping custom animation."
        }
      }
    },
    "AnimNodeRandom": {
      "properties": {
        "PlayingSeqNode": {
          "comment": "Pointer to AnimNodeSequence currently playing random animation."
        }
      },
      "structs": {
        "RandomAnimInfo": {
          "comment": "Notification when node becomes relevant.",
          "properties": {
            "BlendInTime": {
              "comment": "Blend in time for this child"
            },
            "bStillFrame": {
              "comment": "If it's a still frame, don't play animation. Just randomly pick one, and stick to it until we lose focus"
            },
            "Chance": {
              "comment": "Chance this child will be selected"
            },
            "LastPosition": {
              "comment": "Keep track of last position"
            },
            "LoopCount": {
              "comment": "Number of loops left to play for this round"
            },
            "LoopCountMax": {
              "comment": "Maximum number of loops to play this animation"
            },
            "LoopCountMin": {
              "comment": "Minimum number of loops to play this animation"
            },
            "PlayRateRange": {
              "comment": "Animation Play Rate Scale"
            }
          }
        }
      }
    },
    "AnimNodeSequence": {
      "properties": {
        "ActiveCameraAnimInstance": {
          "comment": "Ref to the CameraAnimInst that is currently playing."
        },
        "AnimLinkupIndex": {
          "comment": "Bone -> Track mapping info for this player node. Index into the LinkupCache array in the AnimSet. Found from AnimSet when you call SetAnim."
        },
        "AnimSeq": {
          "comment": "Pointer to actual AnimSequence. Found from SkeletalMeshComponent using AnimSeqName when you call SetAnim."
        },
        "bEditorOnlyAddRefPoseToAdditiveAnimation": {
          "comment": "EDITOR ONLY\n Add Ref Pose to Additive Animation, so it can be viewed fully into the AnimSetViewer."
        },
        "bIsIssuingNotifies": {
          "comment": "Flag that indicates if Notifies are currently being executed.\n Allows you to avoid doing dangerous things to this Node while this is going on."
        },
        "EndTime": {
          "comment": "This is the time at which to end the anim. Example: You have a 10 second anim where you just want a portion of the anim! Great for prototyping!"
        },
        "MetaDataSkelControlList": {
          "comment": "List of SkelControl controlled by MetaData"
        },
        "AnimSeqName": {
          "comment": "This name will be looked for in all AnimSet's specified in the AnimSets array in the SkeletalMeshComponent."
        },
        "bCauseActorAnimEnd": {
          "comment": "Should this node call the OnAnimEnd event on its parent Actor when it reaches the end and stops."
        },
        "bCauseActorAnimPlay": {
          "comment": "Should this node call the OnAnimPlay event on its parent Actor when PlayAnim is called on it."
        },
        "bDisableWarningWhenAnimNotFound": {
          "comment": "if TRUE, don't display a warning when animation is not found."
        },
        "bForceRefposeWhenNotPlaying": {
          "comment": "Forces the skeletal mesh into the ref pose by setting bForceRespose on the skelmesh comp when not playing. (Optimization)"
        },
        "bLooping": {
          "comment": "If animation is looping. If false, animation will stop when it reaches end, otherwise will continue from beginning."
        },
        "bNoNotifies": {
          "comment": "Whether any notifies in the animation sequence should be executed for this node."
        },
        "bPlaying": {
          "comment": "Whether this animation is currently playing ie. if the CurrentTime will be advanced when Tick is called."
        },
        "bZeroRootRotation": {
          "comment": "Always return a zero rotation (unit quaternion) for the root bone of this animation."
        },
        "bZeroRootTranslation": {
          "comment": "Always return root bone translation at the origin."
        },
        "CurrentTime": {
          "comment": "Current position (in seconds)"
        },
        "NotifyWeightThreshold": {
          "comment": "Total weight that this node must be at in the final blend for notifies to be executed.\n This is ignored when the node is part of a group."
        },
        "Rate": {
          "comment": "Speed at which the animation will be played back. Multiplied by the RateScale in the AnimSequence. Default is 1.0"
        },
        "RootBoneOption[3]": {
          "comment": "discard root movement on animation, and forward its velocity to the owning actor."
        },
        "RootRotationOption[3]": {
          "comment": "Discard root rotation from animation, and forwards it to the actor. (to be used by it or not)."
        },
        "bLoopCameraAnim": {
          "comment": "True to loop the CameraAnim, false for a one-off."
        },
        "bRandomizeCameraAnimLoopStartTime": {
          "comment": "True to randomize the CameraAnims start position, so it doesn't look the same every time. Ignored if bLoopCameraAnim is false."
        },
        "CameraAnim": {
          "comment": "Reference to the CameraAnim to play in conjunction with this animation."
        },
        "CameraAnimBlendInTime": {
          "comment": "How long to blend in the camera anim."
        },
        "CameraAnimBlendOutTime": {
          "comment": "How long to blend out the camera anim."
        },
        "CameraAnimPlayRate": {
          "comment": "How fast to playback the camera anim."
        },
        "CameraAnimScale": {
          "comment": "\"Intensity\" multiplier applied to the camera anim."
        },
        "bShowTimeLineSlider": {
          "comment": "Display time line slider"
        },
        "bForceAlwaysSlave": {
          "comment": "If TRUE, this node can never be a synchronization master node, always slave."
        },
        "bReverseSync": {
          "comment": "Reverse synchronization. Go in opposite direction."
        },
        "bSynchronize": {
          "comment": "TRUE by default. This node can be synchronized with others, when part of a SynchGroup. \n Set to FALSE if node shouldn't be synchronized, but still part of notification group."
        },
        "SynchGroupName": {
          "comment": "name of group this node belongs to"
        },
        "SynchPosOffset": {
          "comment": "Relative position offset."
        }
      },
      "functions": {
        "FindGroupPosition": {
          "comment": "Finds out position of a synchronized node given a relative position of a group. \n Takes into account node's relative SynchPosOffset."
        },
        "FindGroupRelativePosition": {
          "comment": "Finds out normalized position of a synchronized node given a relative position of a group. \n Takes into account node's relative SynchPosOffset."
        },
        "GetAnimPlaybackLength": {
          "comment": "Returns the duration (in seconds) of the current animation at the current play rate. Returns 0.0 if no animation."
        },
        "GetGlobalPlayRate": {
          "comment": "Returns the global play rate of this animation. Taking into account all Rate Scales"
        },
        "GetGroupRelativePosition": {
          "comment": "Get relative position of a synchronized node. \n Taking into account node's relative offset."
        },
        "GetNormalizedPosition": {
          "comment": "Get normalized position, from 0.f to 1.f."
        },
        "GetTimeLeft": {
          "comment": "Returns in seconds the time left until the animation is done playing.\n This is assuming the play rate is not going to change."
        },
        "PlayAnim": {
          "comment": "Start the current animation playing with the supplied parameters."
        },
        "SetAnim": {
          "comment": "Change the animation this node is playing to the new name. Will be looked up in owning SkeletaMeshComponent's AnimSets array."
        },
        "SetPosition": {
          "comment": "Force the animation to a particular time. NewTime is in seconds."
        },
        "SetRootBoneAxisOption": {
          "comment": "Set custom animation root bone options."
        },
        "SetRootBoneRotationOption": {
          "comment": "Set custom animation root rotation options."
        },
        "StopAnim": {
          "comment": "Stop the current animation playing. CurrentTime will stay where it was."
        }
      }
    },
    "AnimNodeSequenceBlendBase": {
      "comment": "This class encapsulates a common interface to extract multiple animation data and blend it.",
      "properties": {
        "Anims": {
          "comment": "Array of animations to blend"
        }
      },
      "structs": {
        "AnimBlendInfo": {
          "comment": "Structure to define animation blending.",
          "properties": {
            "AnimInfo": {
              "comment": "Animation info"
            },
            "AnimName": {
              "comment": "Name of animation sequence"
            },
            "Weight": {
              "comment": "Weight i the blend"
            }
          }
        },
        "AnimInfo": {
          "comment": "Structure regrouping all we need to extract an animation.",
          "properties": {
            "AnimLinkupIndex": {
              "comment": "Bone -> Track mapping info for this player node. \n Index into the LinkupCache array in the AnimSet. \n Found from AnimSet when you call SetAnim."
            },
            "AnimSeq": {
              "comment": "Pointer to actual AnimSequence. \n Found from SkeletalMeshComponent using AnimSeqName when you call SetAnim."
            },
            "AnimSeqName": {
              "comment": "Animation Name"
            }
          }
        }
      }
    },
    "AnimNodeSequenceBlendByAim": {
      "properties": {
        "PreviousAim": {
          "comment": "Keep track if aim changed to force an update of the node"
        },
        "Aim": {
          "comment": "Angle of aiming, between -1..+1"
        },
        "AngleOffset": {
          "comment": "Angle offset applied to Aim before processing"
        }
      },
      "functions": {
        "CheckAnimsUpToDate": {
          "comment": "Makes sure animations are updated.\n If you're changing any of the AnimName_XX during game, call this function afterwards."
        }
      }
    },
    "AnimNodeSlot": {
      "comment": "Slot for Matinee controlled Animation Trees.\n Each slot will be able to blend a defined number of channels (AnimNodeSequence connections).",
      "properties": {
        "bIsBeingUsedByInterpGroup": {
          "comment": "TRUE if current it's used by Matinee, InterpTrackAnimControl\n FALSE if not"
        },
        "bIsPlayingCustomAnim": {
          "comment": "True, when we're playing a custom animation"
        },
        "BlendTimeToGo": {
          "comment": "How long before current blend is complete (ie. target child reaches 100%)"
        },
        "CustomChildIndex": {
          "comment": "Child index playing a custom animation"
        },
        "PendingBlendOutTime": {
          "comment": "save blend out time when playing a one shot animation."
        },
        "SynchNode": {
          "comment": "SynchNode, used for multiple node synchronization"
        },
        "TargetChildIndex": {
          "comment": "Child currently active, being blended to"
        },
        "TargetWeight": {
          "comment": "Array of target weights for each child. Size must be the same as the Children array."
        },
        "bAdditiveAnimationsOverrideSource": {
          "comment": "If TRUE, Additive Animations override the source input.\n If FALSE, Additive Animations are added to source input. (DEFAULT)"
        },
        "bEarlyAnimEndNotify": {
          "comment": "If TRUE (default), then forward the AnimEnd notification when we start blending out the animation.\n This usually improves transitions and blends, as we can start playing new animations as soon as this one\n starts blending out, as opposed to waiting until it is fully blended out.\n Setting this to FALSE, will trigger the standard behavior of triggering AnimEnd notifies when the animation is really done playing."
        },
        "bSkipBlendWhenNotRendered": {
          "comment": "if TRUE, do not blend when the Skeletal Mesh is not visible.\n Optimization to save on blending time when meshes are not rendered.\n Instant switch instead."
        }
      },
      "functions": {
        "AddToSynchGroup": {
          "comment": "Synchronize this animation with others.",
          "params": {
            "GroupName": "Add node to synchronization group named group name."
          }
        },
        "GetCustomAnimNodeSeq": {
          "comment": "Returns AnimNodeSequence currently selected for playing animations.\n Note that calling PlayCustomAnim *may* change which node plays the animation.\n (Depending on the blend in time, and how many nodes are available, to provide smooth transitions."
        },
        "GetPlayedAnimation": {
          "comment": "Returns the Name of the currently played animation or '' otherwise."
        },
        "PlayCustomAnim": {
          "comment": "Play a custom animation.\n Supports many features, including blending in and out.",
          "params": {
            "AnimName": "Name of animation to play.",
            "Rate": "Rate animation should be played at.",
            "BlendInTime": "Blend duration to play anim.",
            "BlendOutTime": "Time before animation ends (in seconds) to blend out.\n -1.f means no blend out. \n 0.f = instant switch, no blend. \n otherwise it's starting to blend out at AnimDuration - BlendOutTime seconds.",
            "bLooping": "Should the anim loop? (and play forever until told to stop)",
            "bOverride": "play same animation over again only if bOverride is set to true.",
            "StartTime": "When to start the anim (e.g. start at 2 seconds into the anim)",
            "EndTime": "When to end the anim (e.g. end at 4 second into the anim)"
          }
        },
        "PlayCustomAnimByDuration": {
          "comment": "Play a custom animation.\n Supports many features, including blending in and out.",
          "params": {
            "AnimName": "Name of animation to play.",
            "Duration": "duration in seconds the animation should be played.",
            "BlendInTime": "Blend duration to play anim.",
            "BlendOutTime": "Time before animation ends (in seconds) to blend out.\n -1.f means no blend out. \n 0.f = instant switch, no blend. \n otherwise it's starting to blend out at AnimDuration - BlendOutTime seconds.",
            "bLooping": "Should the anim loop? (and play forever until told to stop)",
            "bOverride": "play same animation over again only if bOverride is set to true."
          }
        },
        "SetActorAnimEndNotification": {
          "comment": "Set bCauseActorAnimEnd flag"
        },
        "SetCustomAnim": {
          "comment": "Switch currently played animation to another one."
        },
        "SetRootBoneAxisOption": {
          "comment": "Set custom animation root bone options."
        },
        "SetRootBoneRotationOption": {
          "comment": "Set custom animation root rotation options."
        },
        "StopCustomAnim": {
          "comment": "Stop playing a custom animation. \n Used for blending out of a looping custom animation."
        }
      }
    },
    "AnimNodeSynch": {
      "comment": "Animation Node used to synch childs.\n Would be typically used to synch several walk/run/crouch cycles together.\n This node works by using the most relevant node in the final blend as the master node,\n to update all the others (slaves).\n This requires all cycles to be relatively synched (i.e. left foot is down on all cycles at 0.25% of the animation, regarless of its length).",
      "properties": {
        "Groups": {
          "comment": "List of groups to synchronize"
        }
      },
      "functions": {
        "AddNodeToGroup": {
          "comment": "Add a node to an existing group"
        },
        "ForceRelativePosition": {
          "comment": "Force a group at a relative position."
        },
        "GetMasterNodeOfGroup": {
          "comment": "Accesses the Master Node driving a given group"
        },
        "GetRelativePosition": {
          "comment": "Get the relative position of a group."
        },
        "RemoveNodeFromGroup": {
          "comment": "Remove a node from an existing group"
        },
        "SetGroupRateScale": {
          "comment": "Adjust the Rate Scale of a group"
        }
      },
      "structs": {
        "SynchGroup": {
          "comment": "definition of a group of AnimNodeSequence to synchronize together",
          "properties": {
            "bFireSlaveNotifies": {
              "comment": "If FALSE, do not trigger slave nodes notifies."
            },
            "GroupName": {
              "comment": "Name of group."
            },
            "MasterNode": {
              "comment": "Last master node used, do not search for a new one, if this one has a full weight..."
            },
            "RateScale": {
              "comment": "Rate Scale"
            },
            "SeqNodes": {
              "comment": "Cached array of anim node sequence nodes to synchronize"
            }
          }
        }
      }
    },
    "AnimNode_MultiBlendPerBone": {
      "properties": {
        "PawnOwner": {
          "comment": "Internal cached pointer to Pawn Owner"
        },
        "MaskList": {
          "comment": "List of Masks. Matches size of Children array - 1"
        },
        "RotationBlendType": {
          "comment": "How rotation should be blended"
        }
      },
      "functions": {
        "SetMaskWeight": {
          "comment": "Control the weight of a given Mask."
        }
      },
      "structs": {
        "BranchInfo": {
          "properties": {
            "BoneName": {
              "comment": "Name of bone branch is starting from"
            },
            "PerBoneWeightIncrease": {
              "comment": "Used to set up smooth blending"
            }
          }
        },
        "PerBoneMaskInfo": {
          "comment": "Per bone masking definition",
          "properties": {
            "bDisableForNonLocalHumanPlayers": {
              "comment": "If the owner is not a local human player, then ignore this branch.\n (ie AI, other players in network...)"
            },
            "bPendingBlend": {
              "comment": "Set when there is a blend pending, and it's being delayed by CanBlendTo()/CanBlendOutFrom()"
            },
            "DesiredWeight": {
              "comment": "Desired weight for this Mask"
            },
            "PerBoneWeights": {
              "comment": "Weight scaling for each bone of the skeleton. Must be same size as RefSkeleton of SkeletalMesh. If all 0.0, no animation can ever be drawn from Child2."
            },
            "TransformReqBone": {
              "comment": "Bones required to be transformed to mesh space.\n When doing a MeshSpace blending, this array defines which bones need to be blended that way\n as an optimization. As it is expensive to convert from Parent Bone Space -> Mesh Space and back.\n So this ensures that the conversion is only performed on the critical bones.\n These are the bones which have a different mask weight than their parents (so they will be blended)\n and their parents (needed to build the mesh space skeleton, as we are converting from PARENT bone space.\n The other bones can be done with the faster parent bone space blend."
            },
            "TransformReqBoneIndex": {
              "comment": "Index to navigate above array"
            },
            "WeightRuleList": {
              "comment": "Rules for turning off Mask.\n This system allows to turn off a mask based on a set of rules.\n Most of the time BlendPerBone is associated with a AnimNodeSlot\n to play cutsom animations.\n So with this system, it's possible to make the BlendPerBone a pass through node\n when no custom animation is played on the AnimNodeSlot. Hence optimizing significantly the tree.\n Example:\n - NodeName = Name of AnimNodeSlot\n - ChildIndex = 0 (source of AnimNodeSlot, when no custom animation is playing)\n - WeightCheck = EWC_ChildIndexFullWeight\n So this reads, if the Source children of the AnimNodeSlot is full weight\n (ie no custom animation is playing), then turn off this mask and\n make this BlendPerBone a pass through node.\n @note: When setting up multiple rules, ALL of them must be true in order to turn off the mask.\n if one fails, then the mask will NOT be disabled."
            }
          }
        },
        "WeightNodeRule": {
          "comment": "Rule put on a node.",
          "properties": {
            "CachedNode": {
              "comment": "Reference to node"
            },
            "CachedSlotNode": {
              "comment": "Reference to cached slot node"
            },
            "ChildIndex": {
              "comment": "Child index of node to check weight for"
            },
            "NodeName": {
              "comment": "Name of node"
            },
            "WeightCheck": {
              "comment": "How the weight should be checked."
            }
          }
        },
        "WeightRule": {
          "comment": "Definition of a mask rule."
        }
      }
    },
    "AnimNotify": {
      "properties": {
        "NotifyColor": {
          "comment": "Color of Notify in editor"
        }
      },
      "functions": {
        "FindNextNotifyOfClass": {
          "comment": "Called by the AnimSet viewer when the 'parent' FAnimNotifyEvent is edited.",
          "params": {
            "NodeSeq": "The AnimNodeSequence this notify is associated with.",
            "OwnerEvent": "The FAnimNotifyEvent that 'owns' this AnimNotify."
          }
        }
      }
    },
    "AnimNotify_CameraEffect": {
      "properties": {
        "CameraLensEffect": {
          "comment": "The effect to play non the camera"
        }
      }
    },
    "AnimNotify_ClothingMaxDistanceScale": {
      "properties": {
        "StartScale": {
          "comment": "The Particle system to play"
        }
      }
    },
    "AnimNotify_ForceField": {
      "properties": {
        "bAttach": {
          "comment": "If this ForceField system should be attached to the location"
        },
        "BoneName": {
          "comment": "The bone name in which to attach the ForceField. Looks for a socket name first then bone name"
        },
        "ForceFieldComponent": {
          "comment": "Type of Forcefield"
        },
        "SocketName": {
          "comment": "The socketname in which to attach the ForceField. Looks for a socket name first then bone name"
        }
      }
    },
    "AnimNotify_PlayFaceFXAnim": {
      "comment": "Play a facial animation on a character.",
      "properties": {
        "bOverridePlayingAnim": {
          "comment": "If a FaceFX animation is already playing, then override if TRUE, skip is FALSE"
        },
        "FaceFXAnimSetRef": {
          "comment": "Reference to FaceFX AnimSet package the animation is in"
        },
        "PlayFrequency": {
          "comment": "Chance to play. 0 - 1.f"
        },
        "SoundCueToPlay": {
          "comment": "The sound cue to play for the this animatio"
        }
      }
    },
    "AnimNotify_PlayParticleEffect": {
      "properties": {
        "bAttach": {
          "comment": "If this particle system should be attached to the location"
        },
        "bIsExtremeContent": {
          "comment": "If this effect should be considered extreme content"
        },
        "BoneName": {
          "comment": "The bone name in which to play the particle effect. Looks for a socket name first then bone name"
        },
        "BoneSocketModuleActorName": {
          "comment": "Parameter name for the bone socket actor - SkelMeshActorParamName in the LocationBoneSocketModule.\n (Default value in module is 'BoneSocketActor')"
        },
        "bPreview": {
          "comment": "If TRUE, the particle system will play in the viewer as well as in game"
        },
        "bSkipIfOwnerIsHidden": {
          "comment": "If Owner is hidden, skip particle effect"
        },
        "PSNonExtremeContentTemplate": {
          "comment": "If this is extreme content(bIsExtremeContent == TRUE), play this instead"
        },
        "PSTemplate": {
          "comment": "The Particle system to play"
        },
        "SocketName": {
          "comment": "The socketname in which to play the particle effect. Looks for a socket name first then bone name"
        }
      }
    },
    "AnimNotify_Rumble": {
      "properties": {
        "bCheckForBasedPlayer": {
          "comment": "If set the player must be based on this actor for the wave to be played"
        },
        "EffectRadius": {
          "comment": "If non-zero the effect will happen if the player is with in this radius of the playing actor"
        },
        "PredefinedWaveForm<AllowAbstract>": {
          "comment": "A predefined WaveForm"
        },
        "WaveForm": {
          "comment": "The waveform to play"
        }
      }
    },
    "AnimNotify_Script": {
      "properties": {
        "NotifyEndName": {
          "comment": "If this notify has a duration, name of the function to call at the end"
        },
        "NotifyTickName": {
          "comment": "If this notify has a duration, name of the function to call each update"
        }
      }
    },
    "AnimNotify_Sound": {
      "properties": {
        "PercentToPlay": {
          "comment": "This is the percent to play this Sound. Defaults to 100% (aka 1.0f)"
        }
      }
    },
    "AnimNotify_Trails": {
      "comment": "AnimNotify for having a Trails emitter spawn based on an animation.",
      "properties": {
        "CurrentTime": {
          "comment": "Used by the event functions..."
        },
        "EndTime": {
          "comment": "The end time (will auto-adjust Duration setting, and vice-versa)"
        },
        "LastStartTime": {
          "comment": "Locally store 'start' time to determine when regenerating the curve data is required."
        },
        "SampleTimeStep": {
          "comment": "The timestep at which to sample the animation for trail points"
        },
        "TrailSampledData": {
          "comment": "The sampled data for the trail"
        },
        "bPreview": {
          "comment": "If TRUE, the particle system will play in the viewer as well as in game"
        },
        "bSkipIfOwnerIsHidden": {
          "comment": "If Owner is hidden, skip particle effect"
        },
        "bIsExtremeContent": {
          "comment": "If this effect should be considered extreme content"
        },
        "ControlPointSocketName": {
          "comment": "The control point socket - controls the UV tiling as well as\n tapering the two edges to this point."
        },
        "FirstEdgeSocketName": {
          "comment": "The first edge socket - with the second edge defines the edges of the trail"
        },
        "PSTemplate": {
          "comment": "The Particle system to play"
        },
        "SamplesPerSecond": {
          "comment": "The frame rate (FPS) to sample the animation at for trail points"
        },
        "SecondEdgeSocketName": {
          "comment": "The second edge socket - with the first edge defines the edges of the trail"
        }
      },
      "functions": {
        "GetNumSteps": {
          "comment": "Called from NotifyTick or NotifyEnd, this function will return the \n number of steps to take for a notify call given the index of the \n last sample that was processed.",
          "params": {
            "InLastTrailIndex": "The index of the last sample that was processed."
          }
        }
      },
      "structs": {
        "TrailSample": {
          "properties": {
            "ControlPointSample": {
              "comment": "The sample for the control point"
            },
            "FirstEdgeSample": {
              "comment": "The sample for the first edge"
            },
            "RelativeTime": {
              "comment": "The time value at this sample point, relative to the starting time."
            },
            "SecondEdgeSample": {
              "comment": "The sample for the second edge"
            }
          }
        },
        "TrailSamplePoint": {
          "properties": {
            "ControlPointSample": {
              "comment": "The sample for the control point"
            },
            "FirstEdgeSample": {
              "comment": "The sample for the first edge"
            },
            "RelativeTime": {
              "comment": "The time value at this sample point, relative to the starting time."
            },
            "SecondEdgeSample": {
              "comment": "The sample for the second edge"
            }
          }
        },
        "TrailSocketSamplePoint": {
          "properties": {
            "Position": {
              "comment": "Position of the socket relative to the root-bone at the sample point"
            },
            "Velocity": {
              "comment": "Velocity of the socket at the sample point"
            }
          }
        }
      }
    },
    "AnimNotify_ViewShake": {
      "properties": {
        "Duration": {
          "comment": "Duration in seconds of shake"
        },
        "FOVAmplitude": {
          "comment": "fov shake amplitude"
        },
        "FOVFrequency": {
          "comment": "fov shake frequency"
        },
        "LocAmplitude": {
          "comment": "relative view offset amplitude (x,y,z)"
        },
        "LocFrequency": {
          "comment": "frequency of view offset shake"
        },
        "RotAmplitude": {
          "comment": "view rotation amplitude (pitch,yaw,roll)"
        },
        "RotFrequency": {
          "comment": "frequency of rotation shake"
        },
        "BoneName": {
          "comment": "if so, bone name to use"
        },
        "bUseBoneLocation": {
          "comment": "Should use a bone location as the shake's epicenter?"
        },
        "ShakeRadius": {
          "comment": "Radius within which to shake player views. If 0 only plays on the animated player"
        }
      },
      "functions": {
        "Notify": {
          "comment": "Trigger the view shake",
          "params": {
            "Owner": "the actor that is playing this animation",
            "AnimSeqInstigator": "the anim sequence that triggered the notify"
          }
        }
      }
    },
    "AnimObject": {
      "properties": {
        "CategoryDesc": {
          "comment": "Editor category for this object. Determines which animtree submenu this object\n should be placed in"
        },
        "DrawHeight": {
          "comment": "for editor use"
        },
        "DrawWidth": {
          "comment": "For editor use."
        },
        "NodePosX": {
          "comment": "for editor use."
        },
        "NodePosY": {
          "comment": "For editor use."
        },
        "OutDrawY": {
          "comment": "for editor use."
        },
        "SkelComponent": {
          "comment": "SkeletalMeshComponent owner"
        }
      }
    },
    "AnimSequence": {
      "properties": {
        "AdditiveBasePose": {
          "comment": "Store Reference Pose animation used to create this additive one. For playback in editor only."
        },
        "AdditiveBasePoseAnimSeq": {
          "comment": "If this animation is Additive, this is the reference to the Base Pose used. For automatic rebuilding in the editor. Made into a list to handle duplicate animations."
        },
        "AdditiveRefName": {
          "comment": "Reference animation name"
        },
        "AdditiveRefPose": {
          "comment": "Reference pose for additive animation. Deprecated."
        },
        "AdditiveTargetPoseAnimSeq": {
          "comment": "If this animation is Additive, this is the reference to the Target Pose used. For automatic rebuilding in the editor. Made into a list to handle duplicate animations."
        },
        "AnimTags": {
          "comment": "Animation tag for stat system: This is temporary until we can add content tag to animation\n Currently it auto tags based on \"contains\" - Check DefaultEngine.ini for modification"
        },
        "bAdditiveBuiltLooping": {
          "comment": "TRUE if additive animation was built with looping interpolation."
        },
        "bHasBeenUsed": {
          "comment": "Debug flag to trace if this anim sequence was played."
        },
        "bIsAdditive": {
          "comment": "TRUE if this is an Additive Animation"
        },
        "BoneControlModifiers": {
          "comment": "DEPRECATED VER_ADDED_ANIM_METADATA_FIXED_QUATERROR Bone Control Modifiers, sorted by time (earliest notification first)."
        },
        "CompressCommandletVersion": {
          "comment": "Saved version number with CompressAnimations commandlet. To help with doing it in multiple passes."
        },
        "CompressedByteStream": {
          "comment": "ByteStream for compressed animation data.\n All keys are currently stored at evenly-spaced intervals (ie no explicit key times).\n For a translation track of n keys, data is packed as n uncompressed float[3]:\n For a rotation track of n>1 keys, the first 24 bytes are reserved for compression info\n (eg Fixed32 stores float Mins[3]; float Ranges[3]), followed by n elements of the compressed type.\n For a rotation track of n=1 keys, the single key is packed as an FQuatFloat96NoW."
        },
        "CompressedTrackOffsets": {
          "comment": "An array of 4*NumTrack ints, arranged as follows:\n [0] Trans0.Offset\n [1] Trans0.NumKeys\n [2] Rot0.Offset\n [3] Rot0.NumKeys\n [4] Trans1.Offset\n . . ."
        },
        "EncodingPkgVersion": {
          "comment": "The version of the global encoding package used at the time of import"
        },
        "NumFrames": {
          "comment": "Number of raw frames in this sequence (not used by engine - just for informational purposes)."
        },
        "RawAnimData": {
          "comment": "Raw uncompressed keyframe data. RawAnimData is deprecated and moved to RawAnimationData\n to switch to native serialization. Down the road it should be switched to use lazy loading\n as the data is only used in the editor. It is used pervasively enough to be a separate change."
        },
        "RelatedAdditiveAnimSeqs": {
          "comment": "If this animation was used, either as a Base or Target Pose, to build additive animations, they are referenced there. For automatic rebuilding in the editor."
        },
        "RotationCompressionFormat": {
          "comment": "The compression format that was used to compress rotation tracks."
        },
        "RotationData": {
          "comment": "Rotation data post keyframe reduction. RotationData.Num() is zero if keyframe reduction\n has not yet been applied."
        },
        "SequenceLength": {
          "comment": "Length (in seconds) of this AnimSequence if played back with a speed of 1.0."
        },
        "SequenceName": {
          "comment": "Name of the animation sequence. Used in AnimNodeSequence."
        },
        "TranslationCodec": {
          "comment": "The runtime interface to decode and byte swap the compressed animation\n May be NULL. Set at runtime - does not exist in editor"
        },
        "TranslationCompressionFormat": {
          "comment": "The compression format that was used to compress translation tracks."
        },
        "TranslationData": {
          "comment": "Translation data post keyframe reduction. TranslationData.Num() is zero if keyframe reduction\n has not yet been applied."
        },
        "UseScore": {
          "comment": "Debug score to find out animation usage"
        },
        "bDoNotOverrideCompression": {
          "comment": "Do not attempt to override compression scheme when running CompressAnimations commandlet.\n Some high frequency animations are too sensitive and shouldn't be changed."
        },
        "bNoLoopingInterpolation": {
          "comment": "if TRUE, disable interpolation between last and first frame when looping."
        },
        "CompressionScheme": {
          "comment": "The compression scheme that was most recently used to compress this animation.\n May be NULL."
        },
        "MetaData": {
          "comment": "Animation Meta Data"
        },
        "Notifies": {
          "comment": "Animation notifies, sorted by time (earliest notification first)."
        },
        "RateScale": {
          "comment": "Number for tweaking playback rate of this animation globally."
        }
      },
      "functions": {
        "GetNotifyTimeByClass": {
          "comment": "Get the time (in seconds) from the start of the animation that the first notify of the given class would fire",
          "params": {
            "NotifyClass": "Class of AnimNotify we are looking for (ie AnimNotify_Sound)",
            "PlayRate": "Rate that animation would be played at",
            "StartPosition": "Initial position in the animation to start checking from"
          }
        }
      },
      "structs": {
        "AnimTag": {
          "comment": "Temporary Animation Tagging Information: until we integrate Content Tagging\n This is configurable information in Engine\n Tag: Name of Tag\n Contains: Contains text\n Priority is index of array"
        },
        "CurveTrack": {
          "comment": "Key frame curve data for one track\n CurveName: Morph Target Name\n CurveWeights: List of weights for each frame"
        },
        "RawAnimSequenceTrack": {
          "comment": "Raw keyframe data for one track. Each array will contain either NumFrames elements or 1 element.\n One element is used as a simple compression scheme where if all keys are the same, they'll be\n reduced to 1 key that is constant over the entire sequence.\n @warning: manually mirrored in UnMiscDeclerations.h due to mixed native/ script serialization",
          "properties": {
            "PosKeys": {
              "comment": "Position keys."
            },
            "RotKeys": {
              "comment": "Rotation keys."
            }
          }
        },
        "RotationTrack": {
          "comment": "Keyframe rotation data for one track. Rot(i) occurs at Time(i). Rot.Num() always equals Time.Num()."
        },
        "SkelControlModifier": {
          "properties": {
            "Modifiers": {
              "comment": "Modifiers for what time and what strength for this skelcontrol nam"
            },
            "SkelControlName": {
              "comment": "SkelControl Node Name in the Anim Tree that would apply"
            }
          }
        },
        "TimeModifier": {
          "properties": {
            "TargetStrength": {
              "comment": "This will linearly interpolate between multiple strength within one anim dat"
            },
            "Time": {
              "comment": "Time to apply"
            }
          }
        },
        "TranslationTrack": {
          "comment": "Keyframe position data for one track. Pos(i) occurs at Time(i). Pos.Num() always equals Time.Num()."
        }
      }
    },
    "AnimSet": {
      "properties": {
        "BestRatioSkelMeshName": {
          "comment": "Holds the name of the skeletal mesh whose reference skeleton best matches the TrackBoneName array."
        },
        "BoneUseAnimTranslation": {
          "comment": "Array of booleans that indicate whether or not to read the translation of a bone from animation or ref skeleton.\n This is basically a cooked down version of UseTranslationBoneNames for speed.\n Size matches the number of tracks."
        },
        "ForceUseMeshTranslation": {
          "comment": "Cooked down version of ForceMeshTranslationBoneNames"
        },
        "LinkupCache": {
          "comment": "Non-serialised cache of linkups between different skeletal meshes and this AnimSet."
        },
        "PreviewSkelMeshName": {
          "comment": "In the AnimSetEditor, when you switch to this AnimSet, it sees if this skeletal mesh is loaded and if so switches to it."
        },
        "SequenceCache": {
          "comment": "Lookup-cache, populated in PostLoad."
        },
        "Sequences": {
          "comment": "Actual animation sequence information."
        },
        "SkelMesh2LinkupCache": {
          "comment": "Runtime built mapping table between SkeletalMeshes, and LinkupCache array indices."
        },
        "TrackBoneNames": {
          "comment": "Bone name that each track relates to. TrackBoneName.Num() == Number of tracks."
        },
        "bAnimRotationOnly": {
          "comment": "Indicates that only the rotation should be taken from the animation sequence and the translation should come from the SkeletalMesh ref pose. \n Note that the root bone always takes translation from the animation, even if this flag is set.\n You can use the UseTranslationBoneNames array to specify other bones that should use translation with this flag set."
        },
        "ForceMeshTranslationBoneNames": {
          "comment": "List of bones which are ALWAYS going to use their translation from the mesh and not the animation."
        },
        "UseTranslationBoneNames": {
          "comment": "Names of bones that should use translation from the animation, if bAnimRotationOnly is set."
        }
      },
      "structs": {
        "AnimSetMeshLinkup": {
          "comment": "This is a mapping table between each bone in a particular skeletal mesh and the tracks of this animation set.",
          "properties": {
            "BoneToTrackTable": {
              "comment": "Mapping table. Size must be same as size of SkelMesh reference skeleton. \n No index should be more than the number of tracks in this AnimSet.\n -1 indicates no track for this bone - will use reference pose instead."
            }
          }
        }
      }
    },
    "AnimTree": {
      "properties": {
        "AnimTickArray": {
          "comment": "Copy of the AnimTickArray, to be serialized, and not rebuilt at run time."
        },
        "bBeingEdited": {
          "comment": "Used to avoid editing the same AnimTree in multiple AnimTreeEditors at the same time."
        },
        "bParentNodeArrayBuilt": {
          "comment": "Keep track if ParentNodeArray has been built. Needs to happen in editor. Otherwise, we have to build it at runtime."
        },
        "bRebuildAnimTickArray": {
          "comment": "was going to make this transient, but because of cooking problem, changing this to non-transient. Once tree is converted, it will be saved"
        },
        "bUseSavedPose": {
          "comment": "If TRUE, AnimTree will always just return cached pose, rather than evaluating entire anim tree."
        },
        "MorphConnDrawY": {
          "comment": "Y position of MorphNode input on AnimTree."
        },
        "PreviewAnimSetIndex": {
          "comment": "Preview AnimSet Index in the list - used to assign/preview for AnimSequenceNode"
        },
        "PreviewCamPos": {
          "comment": "Saved position of camera used for previewing skeletal mesh in AnimTreeEditor."
        },
        "PreviewCamRot": {
          "comment": "Saved orientation of camera used for previewing skeletal mesh in AnimTreeEditor."
        },
        "PreviewFloorPos": {
          "comment": "Saved position of floor mesh used for in AnimTreeEditor preview window."
        },
        "PreviewFloorYaw": {
          "comment": "Saved yaw rotation of floor mesh used for in AnimTreeEditor preview window."
        },
        "PrioritizedSkelBranches": {
          "comment": "Skeleton Branches that should be composed first.\n This is to solve Controllers relying on bones to be updated before them."
        },
        "RootMorphNodes": {
          "comment": "Root of tree of MorphNodes."
        },
        "SavedPose": {
          "comment": "Array for storing pose when bUseSavedPose is TRUE"
        },
        "SkelControlLists": {
          "comment": "Array of lists of SkelControls. Each list is executed after the bone specified using BoneName is updated with animation data."
        },
        "AnimGroups": {
          "comment": "List of animations groups"
        },
        "AnimTreeTemplate": {
          "comment": "Anim Tree template we were created from, or None if we are a template"
        },
        "bEnablePooling": {
          "comment": "Enable pooling for this AnimTree. This will pool freed copies of this AnimTree for later reuse"
        },
        "PreviewMeshList": {
          "comment": "SkeletalMesh used when previewing this AnimTree in the AnimTreeEditor."
        },
        "PreviewPlayRate": {
          "comment": "Play rate used when previewing animations"
        }
      },
      "functions": {
        "FindSkelControl": {
          "comment": "Custom Serialize function\n This function will save some information we can use in InitAnimTree"
        },
        "ForceGroupRelativePosition": {
          "comment": "Force a group at a relative position."
        },
        "GetGroupIndex": {
          "comment": "Returns the index in the AnimGroups list of a given GroupName.\n If group cannot be found, then INDEX_NONE will be returned."
        },
        "GetGroupNotifyMaster": {
          "comment": "Returns the master node driving notifications for this group."
        },
        "GetGroupRateScale": {
          "comment": "Get the Rate Scale of a group"
        },
        "GetGroupRelativePosition": {
          "comment": "Get the relative position of a group."
        },
        "GetGroupSynchMaster": {
          "comment": "Returns the master node driving synchronization for this group."
        },
        "SetAnimGroupForNode": {
          "comment": "Add a node to an existing anim group"
        },
        "SetGroupRateScale": {
          "comment": "Adjust the Rate Scale of a group"
        },
        "SetUseSavedPose": {
          "comment": "When passing in TRUE, will cause tree to evaluate and then save resulting pose. From then on will continue to use that saved pose instead of re-evaluating the tree\n This feature is turned off when the SkeletalMesh changes"
        }
      },
      "structs": {
        "AnimGroup": {
          "comment": "Definition of a group of AnimNodeSequences",
          "properties": {
            "NotifyMaster": {
              "comment": "Master node for notifications. (Highest weight of the group)"
            },
            "RateScale": {
              "comment": "Rate Scale"
            },
            "SeqNodes": {
              "comment": "Cached array of AnimNodeSequence nodes to update."
            },
            "SynchMaster": {
              "comment": "Master node for synchronization. (Highest weight of the group)"
            },
            "SynchPctPosition": {
              "comment": "Tracked Synch Position"
            }
          }
        },
        "PreviewAnimSetsStruct": {
          "comment": "AnimSets used when previewing this AnimTree in the AnimTreeEditor."
        },
        "PreviewSkelMeshStruct": {
          "comment": "Structure to hold a preview mesh, and a name for quick selection from within the editor",
          "properties": {
            "DisplayName": {
              "comment": "Display name in combo box"
            },
            "PreviewMorphSets": {
              "comment": "MorphTargetSets used when previewing this AnimTree in the AnimTreeEditor."
            },
            "PreviewSkelMesh": {
              "comment": "Preview Skeletal Mesh"
            }
          }
        },
        "PreviewSocketStruct": {
          "comment": "previewing of socket",
          "properties": {
            "DisplayName": {
              "comment": "Preview Name for quick selection"
            },
            "PreviewSkelMesh": {
              "comment": "Attached preview skeletal mesh"
            },
            "PreviewStaticMesh": {
              "comment": "Attached preview staticmesh"
            },
            "SocketName": {
              "comment": "Name of socket to use"
            }
          }
        },
        "SkelControlListHead": {
          "properties": {
            "BoneName": {
              "comment": "Name of bone that this list of SkelControls will be executed after."
            },
            "ControlHead": {
              "comment": "First Control in the linked list of SkelControls to execute."
            },
            "DrawY": {
              "comment": "For editor use."
            }
          }
        }
      }
    },
    "ApexAsset": {
      "comment": "This is the base class for ApexAssets"
    },
    "ApexClothingAsset": {
      "properties": {
        "ApexClothingLibrary": {
          "comment": "ApexClothingLibrary is only for legacy APEX 0.9 assets."
        }
      }
    },
    "ApexComponentBase": {
      "properties": {
        "ComponentBaseResources": {
          "comment": "This component's index buffer."
        },
        "ReleaseResourcesFence": {
          "comment": "A fence used to track when the rendering thread has released the component's resources."
        }
      }
    },
    "ApexDestructibleActor": {
      "comment": "This class defines a single instance of a destructible asset",
      "properties": {
        "FractureParticleEffects": {
          "comment": "Cached particle effects for fractures."
        },
        "FractureSounds": {
          "comment": "Cached sounds for fractures."
        },
        "VisibilityFactors": {
          "comment": "Defines an array that designates which of the destructible chunks are visible"
        },
        "bFractureMaterialOverride": {
          "comment": "If set, use this actor's fracture materials instead of the asset's fracture materials."
        },
        "FractureMaterials": {
          "comment": "Fracture effects for each fracture level. Used only if Fracture Material Override is set."
        },
        "LightEnvironment": {
          "comment": "Expose LightEnvironment to the user"
        },
        "StaticDestructibleComponent": {
          "comment": "The destructible static component."
        }
      },
      "functions": {
        "CacheFractureEffects": {
          "comment": "Initialize FractureSounds and FractureParticleEffects"
        },
        "TakeDamage": {
          "comment": "Declares the TakeDamage script function"
        },
        "TakeRadiusDamage": {
          "comment": "Declares the radius damage script function"
        }
      }
    },
    "ApexDestructibleAsset": {
      "comment": "This class fully describes an APEX destructible asset and associated propreties",
      "properties": {
        "MApexAsset": {
          "comment": "MApexAsset is a pointer to the Apex asset interface for this destructible asset"
        },
        "MDestructibleThumbnailComponent": {
          "comment": "Make the Destructible Thumbnail component singular"
        },
        "bDynamic": {
          "comment": "Whether or not the destructible starts life as a dynamic actor"
        },
        "CrumbleEmitterName": {
          "comment": "The name of the NxMeshParticleSystem to use for crumbling. This overrides the crumble system defined\nin the NxDestructibleAsset if specified."
        },
        "DefaultPhysMaterial": {
          "comment": "Default physical material to use for this asset. If the actor has a physical material defined in its mesh component, that will be used instead."
        },
        "DestructibleParameters": {
          "comment": "Parameters controlling the destruction properties."
        },
        "DustEmitterName": {
          "comment": "The name of the NxMeshParticleSystem to use for fracture-line dust. This overrides the dust system defined\nin the NxDestructibleAsset if specified."
        },
        "FractureMaterials": {
          "comment": "Fracture effects for each fracture level"
        },
        "Materials": {
          "comment": "Materials contains an array of Materials which can be remapped relative to this asset"
        }
      },
      "structs": {
        "NxDestructibleDepthParameters": {
          "comment": "Flags that may be set for all chunks at a particular depth in the fracture hierarchy",
          "properties": {
            "IGNORE_CONTACT_CALLBACKS": {
              "comment": "Chunks at this depth should be ignored in contact callbacks."
            },
            "IGNORE_POSE_UPDATES": {
              "comment": "Chunks at this depth should have pose updates ignored."
            },
            "IGNORE_RAYCAST_CALLBACKS": {
              "comment": "Chunks at this depth should be ignored in raycast callbacks."
            },
            "TAKE_IMPACT_DAMAGE": {
              "comment": "Chunks at this hierarchy depth level may take impact damage if this flag is set.\nNote, NxDestructibleParameters::forceToDamage must also be positive for this\nto take effect."
            },
            "USER_FLAG_0": {
              "comment": "User defined flags."
            }
          }
        },
        "NxDestructibleParameters": {
          "comment": "Parameters that apply to a destructible actor",
          "properties": {
            "bFormExtendedStructures": {
              "comment": "If initially static, the destructible will become part of an extended support structure if it is\nin contact with another static destructible that also has this flag set."
            },
            "DamageCap": {
              "comment": "Limits the amount of damage applied to a chunk. This is useful for preventing the entire destructible\nfrom getting pulverized by a very large application of damage. This can easily happen when impact damage is\nused, and the damage amount is proportional to the impact force (see forceToDamage)."
            },
            "DamageThreshold": {
              "comment": "The damage amount which will cause a chunk to fracture (break free) from the destructible.\nThis is obtained from the damage value passed into the NxDestructibleActor::applyDamage,\nor NxDestructibleActor::applyRadiusDamage, or via impact (see 'forceToDamage', below)."
            },
            "DamageToPercentDeformation": {
              "comment": "Damage applied to chunks may deform (move) a chunk without fracturing it, if damageToPercentDeformation is\npositive. The damage applied to the chunk is multiplied by damageToPercentDeformation, and the resulting\n\"percent deformation\" is used to translate and rotate the chunk. The translation is the \"percent deformation\"\ntimes the size of the chunk, in the direction given by the 'direction' paramater in applyDamage\n(see NxDestructibleActor). For radius damage, the direction is always radial from the impact position.\nThe rotation appplied is the \"percent deformation\" times one radian.\nThe default value is zero, which disables deformation."
            },
            "DamageToRadius": {
              "comment": "Controls the distance into the destructible to propagate damage. The damage applied to the chunk\nis multiplied by damageToRadius, to get the propagation distance. All chunks within the radius\nwill have damage applied to them. The damage applied to each chunk varies with distance to the damage\napplication position. Full damage is taken at zero distance, and zero damage at the damage radius."
            },
            "DebrisDepth": {
              "comment": "The chunk hierarchy depth at which chunks are considered to be \"debris.\" Chunks at this depth or\nbelow will be considered for various debris settings, such as debrisLifetime.\nNegative values indicate that no chunk depth is considered debris.\nDefault value is -1."
            },
            "DebrisLifetimeMin": {
              "comment": "\"Debris chunks\" (see debrisDepth, above) will be destroyed after a time (in seconds)\nseparated from non-debris chunks. The actual lifetime is interpolated between these\ntwo values, based upon the module's LOD setting. To disable lifetime, clear the\nNX_DESTRUCTIBLE_DEBRIS_TIMEOUT flag in the flags field.\nIf debrisLifetimeMax < debrisLifetimeMin, the mean of the two is used for both.\nDefault debrisLifetimeMin = 1.0, debrisLifetimeMax = 10.0f."
            },
            "DebrisMaxSeparationMin": {
              "comment": "\"Debris chunks\" (see debrisDepth, above) will be destroyed if they are separated from\ntheir origin by a distance greater than maxSeparation. The actual maxSeparation is\ninterpolated between these two values, based upon the module's LOD setting. To disable\nmaxSeparation, clear the NX_DESTRUCTIBLE_DEBRIS_MAX_SEPARATION flag in the flags field.\nIf debrisMaxSeparationMax < debrisMaxSeparationMin, the mean of the two is used for both.\nDefault debrisMaxSeparationMin = 1.0, debrisMaxSeparationMax = 10.0f."
            },
            "DeformationPercentLimit": {
              "comment": "If a chunk's percent deformation (see damageToPercentDeformation) exceeds deformationPercentLimit in\neither translation or rotation, then the chunk will fracture."
            },
            "DepthParameters": {
              "comment": "Parameters that apply to every chunk at a given level (see NxDestructibleDepthParameters).\nthe element [0] of the array applies to the level 0 (unfractured) chunk, element [1] applies\nto the level 1 chunks, etc."
            },
            "EssentialDepth": {
              "comment": "The chunk hierarchy depth up to which chunks will always be processed. These chunks are considered\nto be essential either for gameplay or visually.\nThe minimum value is 0, meaning the level 0 chunk is always considered essential.\nDefault value is 0."
            },
            "Flags": {
              "comment": "A collection of flags defined in NxDestructibleParametersFlag."
            },
            "ForceToDamage": {
              "comment": "If a chunk is at a depth which has NX_DESTRUCTIBLE_TAKE_IMPACT_DAMAGE set (see NxDestructibleDepthParameters),\nthen when a chunk has a collision in the NxScene, it will take damage equal to forceToDamage mulitplied by\nthe impact force.\nThe default value is zero, which effectively disables impact damage."
            },
            "FractureImpulseScale": {
              "comment": "Scale factor used to apply an impulse force along the normal of chunk when fractured. This is used\nin order to \"push\" the pieces out as they fracture."
            },
            "GrbParticleSpacing": {
              "comment": "Spacing of particle grid used to represent rigid bodies in GRB"
            },
            "GrbVolumeLimit": {
              "comment": "The relative volume (chunk volume / whole destructible volume) below which GRBs are used\ninstead of RBs to represent chunks in the physics scene."
            },
            "ImpactVelocityThreshold": {
              "comment": "Large impact force may be reported if rigid bodies are spawned inside one another. In this case the realative velocity of the two\nobjects will be low. This variable allows the user to set a minimum velocity threshold for impacts to ensure that the objects are \nmoving at a min velocity in order for the impact force to be considered."
            },
            "MassScaleExponent": {
              "comment": "Dynamic chunk islands will have their masses raised to this power. Values less than 1 have the\neffect of reducing the ratio of different masses. The closer massScaleExponent is to zero, the\nmore the ratio will be \"flattened.\" This helps PhysX converge when there is a very large number\nof interacting rigid bodies (such as a pile of destructible chunks).\nValid range: [0,1]. Default = 0.5."
            },
            "MaterialStrength": {
              "comment": "When a chunk takes impact damage due to physical contact (see NxDestructibleDepthParametersFlag::TAKE_IMPACT_DAMAGE), this parameter\nis the maximum impulse the contact can generate. Weak materials such as glass may have this set to a low value, so that\nheavier objects will pass through them during fracture.\nN.B.: Setting this parameter to 0 disables the impulse cap; that is, zero is interpreted as infinite.\nDefault value = 0.0f."
            },
            "MaxChunkSpeed": {
              "comment": "If greater than 0, the chunks' speeds will not be allowed to exceed this value. Use 0\nto disable this feature (this is the default)."
            },
            "SupportDepth": {
              "comment": "The chunk hierarchy depth at which to create a support graph. Higher depth levels give more detailed support,\nbut will give a higher computational load. Chunks below the support depth will never be supported."
            },
            "ValidBounds": {
              "comment": "\"Debris chunks\" (see debrisDepth, above) will be destroyed if they are separated from\ntheir origin by a distance greater than maxSeparation multiplied by the original\ndestructible asset size. The actual maxSeparation is interpolated between these\ntwo values, based upon the module's LOD setting. To disable maxSeparation, clear the\nNX_DESTRUCTIBLE_DEBRIS_MAX_SEPARATION flag in the flags field.\nIf debrisMaxSeparationMax < debrisMaxSeparationMin, the mean of the two is used for both.\nDefault debrisMaxSeparationMin = 1.0, debrisMaxSeparationMax = 10.0f."
            }
          }
        },
        "NxDestructibleParametersFlag": {
          "comment": "Flags that apply to a destructible actor",
          "properties": {
            "ACCUMULATE_DAMAGE": {
              "comment": "If set, chunks will \"remember\" damage applied to them, so that many applications of a damage amount\nbelow damageThreshold will eventually fracture the chunk. If not set, a single application of\ndamage must exceed damageThreshold in order to fracture the chunk."
            },
            "ACCURATE_RAYCASTS": {
              "comment": "If set, the NxDestructibleActor::rayCast function will search within the nearest visible chunk hit\nfor collisions with child chunks. This is used to get a better raycast position and normal, in\ncase the parent collision volume does not tightly fit the graphics mesh. The returned chunk index\nwill always be that of the visible parent that is intersected, however."
            },
            "ASSET_DEFINED_SUPPORT": {
              "comment": "If set, then chunks which are tagged as \"support\" chunks (via NxDestructibleChunkDesc::isSupportChunk)\nwill have environmental support in static destructibles.\nNote: if both ASSET_DEFINED_SUPPORT and WORLD_SUPPORT are set, then chunks must be tagged as\n\"support\" chunks AND overlap the NxScene's static geometry in order to be environmentally supported."
            },
            "CRUMBLE_SMALLEST_CHUNKS": {
              "comment": "If set, the smallest chunks may be further broken down, either by fluid crumbles (if a crumble particle\nsystem is specified in the NxDestructibleActorDesc), or by simply removing the chunk if no crumble\nparticle system is specified. Note: the \"smallest chunks\" are normally defined to be the deepest level\nof the fracture hierarchy. However, they may be taken from higher levels of the hierarchy if\nNxModuleDestructible::setMaxChunkDepthOffset is called with a non-zero value."
            },
            "DEBRIS_MAX_SEPARATION": {
              "comment": "Whether or not chunks at or deeper than the \"debris\" depth (see NxDestructibleParameters::debrisDepth)\nwill be removed if they separate too far from their origins. The maxSeparation is a value between\nNxDestructibleParameters::debrisMaxSeparationMin and NxDestructibleParameters::debrisMaxSeparationMax,\nbased upon the destructible module's LOD setting."
            },
            "DEBRIS_TIMEOUT": {
              "comment": "Whether or not chunks at or deeper than the \"debris\" depth (see NxDestructibleParameters::debrisDepth)\nwill time out. The lifetime is a value between NxDestructibleParameters::debrisLifetimeMin and\nNxDestructibleParameters::debrisLifetimeMax, based upon the destructible module's LOD setting."
            },
            "USE_VALID_BOUNDS": {
              "comment": "If set, the ValidBounds field of NxDestructibleParameters will be used. These bounds are translated\n(but not scaled or rotated) to the origin of the destructible actor. If a chunk or chunk island moves\noutside of those bounds, it is destroyed."
            },
            "WORLD_SUPPORT": {
              "comment": "If set, then chunks which overlap the NxScene's static geometry will have environmental support in\nstatic destructibles.\nNote: if both ASSET_DEFINED_SUPPORT and WORLD_SUPPORT are set, then chunks must be tagged as\n\"support\" chunks AND overlap the NxScene's static geometry in order to be environmentally supported."
            }
          }
        }
      }
    },
    "ApexGenericAsset": {
      "comment": "This class defines an Apex Generic Asset\n An Apex Generic asset is any APEX asset that is described purely as a data blob and does not have any factories associated with it.",
      "properties": {
        "MApexAsset": {
          "comment": "Contains a pointer to the allocated Apex asset interface"
        }
      }
    },
    "ApexStaticDestructibleComponent": {
      "comment": "This is the base class for static destructible components",
      "properties": {
        "ApexDestructibleActor": {
          "comment": "The APEX destructible actor (instantiated destructible asset)"
        },
        "ApexDestructiblePreview": {
          "comment": "The APEX preview class which can render a preview of a destructible asset"
        },
        "bIsThumbnailComponent": {
          "comment": "If this component is being used for a thumbnail render"
        },
        "SleepDamping<ClampMin=0.0>": {
          "comment": "Increasing this value will cause fracture chunks to be gradually slowed down before putting them to sleep."
        },
        "SleepEnergyThreshold<ClampMin=0.0>": {
          "comment": "Increasing this value will cause fracture chunks to be put to sleep more quickly."
        }
      }
    },
    "ArrowComponent": {
      "properties": {
        "SpriteCategoryName": {
          "comment": "Sprite category that the arrow component belongs to, if being treated as a sprite. Value serves as a key into the localization file."
        },
        "bTreatAsASprite": {
          "comment": "If TRUE, don't show the arrow when SHOW_Sprites is disabled."
        }
      }
    },
    "AudioComponent": {
      "properties": {
        "AdjustVolumeTargetVolume": {
          "comment": "This is the volume level we are adjusting to"
        },
        "bAllowSpatialization": {
          "comment": "Is this audio component allowed to be spatialized?"
        },
        "bAlwaysPlay": {
          "comment": "Whether to artificially prioritise the component to play"
        },
        "bApplyRadioFilter": {
          "comment": "If TRUE, this sound will not be stopped when flushing the audio device."
        },
        "bAutoDestroy": {
          "comment": "Auto destroy this component on completion"
        },
        "bAutoPlay": {
          "comment": "Auto start this component on creation"
        },
        "bCenterChannelOnly": {
          "comment": "Whether or not this sound class forces sounds to the center channel"
        },
        "bEQFilterApplied": {
          "comment": "Whether audio effects are applied"
        },
        "bFinished": {
          "comment": "Whether the current component has finished playing"
        },
        "bIgnoreForFlushing": {
          "comment": "If TRUE, this sound will not be stopped when flushing the audio device."
        },
        "bIsMusic": {
          "comment": "Whether or not this audio component is a music clip"
        },
        "bIsUISound": {
          "comment": "Whether or not this sound plays when the game is paused in the UI"
        },
        "bPreviewComponent": {
          "comment": "Whether this audio component is previewing a sound"
        },
        "bRadioFilterSelected": {
          "comment": "If TRUE, the decision on whether to apply the radio filter has been made."
        },
        "bReverb": {
          "comment": "Whether or not the audio component should be excluded from reverb EQ processing"
        },
        "bShouldRemainActiveIfDropped": {
          "comment": "Whether the wave instances should remain active if they're dropped by the prioritization code. Useful for e.g. vehicle sounds that shouldn't cut out."
        },
        "bStopWhenOwnerDestroyed": {
          "comment": "Stop sound when owner is destroyed"
        },
        "bSuppressSubtitles": {
          "comment": "If true, subtitles in the sound data will be ignored."
        },
        "bUseOwnerLocation": {
          "comment": "Spatialise to the owner's coordinates"
        },
        "bWasOccluded": {
          "comment": "whether we were occluded the last time we checked"
        },
        "bWasPlaying": {
          "comment": "Set to true when the component has resources that need cleanup"
        },
        "FadeInTargetVolume": {
          "comment": "This is the volume level we are fading to"
        },
        "FadeOutTargetVolume": {
          "comment": "This is the volume level we are fading to"
        },
        "LastInteriorSettings": {
          "comment": "cache what volume settings we had last time so we don't have to search again if we didn't move"
        },
        "LastLocation": {
          "comment": "location last time playback was updated"
        },
        "LastOcclusionCheckTime": {
          "comment": "last time we checked for occlusion"
        },
        "LastOwner": {
          "comment": "Remember the last owner so we can remove it from the actor's component array even if it's already been detached"
        },
        "LFEBleed": {
          "comment": "The amount of a sound to bleed to the LFE channel"
        },
        "OcclusionCheckInterval": {
          "comment": "while playing, this component will check for occlusion from its closest listener every this many seconds and call OcclusionChanged() if the status changes"
        },
        "SoundNodeOffsetMap": {
          "comment": "We explicitly disregard SoundNodeOffsetMap/WaveMap/ResetWaveMap for GC as all references are already\n handled elsewhere and we can't NULL references anyways."
        },
        "StereoBleed": {
          "comment": "The amount of stereo sounds to bleed to the rear speakers"
        },
        "SubtitlePriority": {
          "comment": "Used by the subtitle manager to prioritize subtitles wave instances spawned by this component."
        },
        "InstanceParameters": {
          "comment": "Array of per-instance parameters for this AudioComponent."
        }
      },
      "functions": {
        "AdjustVolume": {
          "comment": "This will allow one to adjust the volume of an AudioComponent on the fly"
        },
        "FadeIn": {
          "comment": "This is called in place of \"play\". So you will say AudioComponent->FadeIn().\n This is useful for fading in music or some constant playing sound.\n If FadeTime is 0.0, this is the same as calling Play() but just modifying the volume by\n FadeVolumeLevel. (e.g. you will play instantly but the FadeVolumeLevel will affect the AudioComponent)\n If FadeTime is > 0.0, this will call Play(), and then increase the volume level of this\n AudioCompoenent to the passed in FadeVolumeLevel over FadeInTime seconds.\n The VolumeLevel is MODIFYING the AudioComponent's \"base\" volume. (e.g. if you have an\n AudioComponent that is volume 1000 and you pass in .5 as your VolumeLevel then you will fade to 500 )",
          "params": {
            "FadeInDuration": "how long it should take to reach the FadeVolumeLevel",
            "FadeVolumeLevel": "the percentage of the AudioComponents's calculated volume in which to fade to"
          }
        },
        "FadeOut": {
          "comment": "This is called in place of \"stop\". So you will say AudioComponent->FadeOut().\n This is useful for fading out music or some constant playing sound.\n If FadeTime is 0.0, this is the same as calling Stop().\n If FadeTime is > 0.0, this will decrease the volume level of this\n AudioCompoenent to the passed in FadeVolumeLevel over FadeInTime seconds.\n The VolumeLevel is MODIFYING the AudioComponent's \"base\" volume. (e.g. if you have an\n AudioComponent that is volume 1000 and you pass in .5 as your VolumeLevel then you will fade to 500 )",
          "params": {
            "FadeOutDuration": "how long it should take to reach the FadeVolumeLevel",
            "FadeVolumeLevel": "the percentage of the AudioComponents's calculated volume in which to fade to"
          }
        },
        "OcclusionChanged": {
          "comment": "called when OcclusionCheckInterval > 0.0 and the occlusion status changes"
        },
        "ResetToDefaults": {
          "comment": "stops the audio (if playing), detaches the component, and resets the component's properties to the values of its template"
        }
      },
      "structs": {
        "AudioComponentParam": {
          "comment": "Struct used for storing one per-instance named paramter for this AudioComponent.\n Certain nodes in the SoundCue may reference parameters by name so they can be adjusted per-instance."
        }
      }
    },
    "AudioDevice": {
      "properties": {
        "ChirpInSoundNodeWaveName": {
          "comment": "Sound node wave to use for the radio chirp in sound"
        },
        "ChirpOutSoundNodeWaveName": {
          "comment": "Sound node wave to use for the radio chirp out sound"
        },
        "CommonAudioPool": {
          "comment": "Pointer to permanent memory allocation stack."
        },
        "CommonAudioPoolFreeBytes": {
          "comment": "Available size in permanent memory stack"
        },
        "CommonAudioPoolSize": {
          "comment": "The amount of memory to reserve for always resident sounds"
        },
        "DebugState": {
          "comment": "The debug state of the audio device"
        },
        "Effects": {
          "comment": "Interface to audio effects processing"
        },
        "InteriorStartTime": {
          "comment": "The times of interior volumes fading in and out"
        },
        "LastUpdateTime": {
          "comment": "Timestamp of the last update"
        },
        "ListenerVolumeIndex": {
          "comment": "The index of the volume the listener resides in"
        },
        "LowPassFilterResonance": {
          "comment": "Low pass filter OneOverQ value"
        },
        "MaxChannels": {
          "comment": "The maximum number of concurrent audible sounds"
        },
        "MinCompressedDurationEditor": {
          "comment": "Sound duration in seconds below which sounds are entirely expanded to PCM at load time in the Editor."
        },
        "MinCompressedDurationGame": {
          "comment": "Sound duration in seconds below which sounds are entirely expanded to PCM at load time in the Game."
        },
        "SoundModes": {
          "comment": "Map of available sound modes"
        },
        "SourceSoundClasses": {
          "comment": "Source, current and destination properties of all sound classes"
        },
        "TestAudioComponent": {
          "comment": "An AudioComponent to play test sounds on"
        },
        "TextToSpeech": {
          "comment": "Interface to text to speech processor"
        },
        "TransientMasterVolume": {
          "comment": "transient master volume multiplier that can be modified at runtime without affecting user settings automatically reset to 1.0 on level change"
        },
        "WorkAroundXDKRegression": {
          "comment": "Whether to workaround the XAudio2 audio regression in the Feb 2011 XDK"
        },
        "SoundClasses": {
          "comment": "Map of available sound classes"
        }
      },
      "functions": {
        "FindSoundClass": {
          "comment": "Find SoundClass given a Name"
        },
        "SetSoundMode": {
          "comment": "Sets a new sound mode and applies it to all appropriate sound classes"
        }
      },
      "structs": {
        "AudioClassInfo": {
          "comment": "Structure for collating info about sound classes"
        },
        "Listener": {
          "comment": "Defines the properties of the listener"
        }
      }
    },
    "AutoTestManager": {
      "properties": {
        "AutomatedMapTestingList": {
          "comment": "List of maps that we are going to be using for the AutomatedMapTesting"
        },
        "AutomatedMapTestingTransitionMap": {
          "comment": "This will be the 'transition' map used w/ OpenMap runs"
        },
        "AutomatedPerfRemainingTime": {
          "comment": "Amount of time remaining before match ends -- used for auto performance test shutdown"
        },
        "AutomatedTestingExecCommandToRunAtStartMatch": {
          "comment": "This will be run at the start of each start match"
        },
        "AutomatedTestingMapIndex": {
          "comment": "The index of the current automated testing map.\n If < 0 we are in the transition map."
        },
        "bAutoContinueToNextRound": {
          "comment": "This will auto continue to the next round. Very useful doing soak testing and testing traveling to next level"
        },
        "bAutomatedPerfTesting": {
          "comment": "Whether the game is currently in automated perf test mode."
        },
        "bAutomatedTestingWithOpen": {
          "comment": "If TRUE, use OpenMap to transition; if FALSE, use SeamlessTravel"
        },
        "bCheckingForFragmentation": {
          "comment": "Whether or not this game should check for fragmentation. This can be used to have a specific game type check for fragmentation at some point\n (e.g. start/end of match, time period)"
        },
        "bCheckingForMemLeaks": {
          "comment": "Whether or not this game should check for memory leaks"
        },
        "bDoingASentinelRun": {
          "comment": "Whether or this game is doing a bDoingASentinelRun test"
        },
        "bExitOnCyclesComplete": {
          "comment": "Whether to exit when NumAutomatedMapTestingCycles is reached"
        },
        "bSentinelStreamingLevelStillLoading": {
          "comment": "Used to delay until streaming levels are fully loaded"
        },
        "bUsingAutomatedTestingMapList": {
          "comment": "Whether or not we are using the Automated Testing Map list"
        },
        "CommandsToRunAtEachTravelTheWorldNode": {
          "comment": "At each TravelTheWorld node we fire off all of the commands in this array. This is good for being able to\n do things like fire off a debug command without having to recook the entire map (e.g. MemLeakCheck at each node)."
        },
        "CommandStringToExec": {
          "comment": "Transient string that we need for our foreach in the TravelTheWorld state code"
        },
        "NumAutomatedMapTestingCycles": {
          "comment": "Number of times to run through the list. (0 in infinite)"
        },
        "NumberOfMatchesPlayed": {
          "comment": "Number of matches played (maybe remove this before shipping)\n This is really useful for doing soak testing and such to see how long you lasted!\n NOTE: This is not replicated out to clients atm."
        },
        "NumMapListCyclesDone": {
          "comment": "Keeps track of the current run so when we have repeats and such we know how far along we are"
        },
        "NumMinutesPerMap": {
          "comment": "How many minutes per map we are allowed to run."
        },
        "NumRotationsIncrement": {
          "comment": "Change increments for iterating through rotations used at sentinel travel locations"
        },
        "SentinelIdx": {
          "comment": "Iterator for various sentinel state code loops - for loop is in state code, so can't define locally"
        },
        "SentinelNavigationIdx": {
          "comment": "Iterator for looping through SentinelTravelArray - for loop is in state code, so can't define locally"
        },
        "SentinelPC": {
          "comment": "PlayerController used for Sentinel - picked randomly"
        },
        "SentinelTagDesc": {
          "comment": "Used for the BeginRun Task___ strings"
        },
        "SentinelTaskDescription": {
          "comment": "Used for the BeginRun Task___ strings, examples \"FlyThrough\", \"FlyThroughSplitScreen\", \"BVT\""
        },
        "SentinelTaskParameter": {
          "comment": "Used for the BeginRun Task___ strings"
        },
        "SentinelTravelArray": {
          "comment": "Locations where sentinel should go to"
        },
        "TravelPointsIncrement": {
          "comment": "Change increments for iterating through sentinel travel locations"
        }
      },
      "functions": {
        "AddSentinelPerTimePeriodStats": {
          "comment": "This will output some set of data that we care about when we are doing Sentinel runs while we are\n doing a MP test or a BVT.\n Prob just stat unit and some other random stats (streaming fudge factor and such)"
        },
        "BeginSentinelRun": {
          "comment": "This will start a SentinelRun in the DB. Setting up the Run table with all of metadata that a run has.\n This will also set the GSentinelRunID so that the engine knows what the current run is.",
          "params": {
            "TaskDescription": "The name/description of the task that we are running",
            "TaskParameter": "Any Parameters that the task needs",
            "TagDesc": "A specialized tag (e.g. We are doing Task A with Param B and then \"MapWithParticlesAdded\" so it can be found)"
          }
        },
        "CheckForSentinelRun": {
          "comment": "Start Sentinel Run if needed"
        },
        "CloseAutomatedMapTestTimer": {
          "comment": "Restart the game when timer pops"
        },
        "DoMemoryTracking": {
          "comment": "Determine if memory tracking will be triggered"
        },
        "DoSentinelActionPerLoadedMap": {
          "comment": "This will run on every map load. (e.g. You have P map which consists of N sublevels. For each SubLevel this will run."
        },
        "DoSentinel_MemoryAtSpecificLocation": {
          "comment": "This will write out the Sentinel data at this location / rotation"
        },
        "DoTimeBasedSentinelStatGathering": {
          "comment": "This function should be triggered via SetTimer ever few seconds to do the Per Time Period stats gathering"
        },
        "DoTravelTheWorld": {
          "comment": "function to start the world traveling"
        },
        "EndSentinelRun": {
          "comment": "This will tell the DB to end the current Sentinel run (i.e. GSentinelRunID) and set that Run's RunResult to the passed in var.",
          "params": {
            "RunResult": "The result of this Sentinel run (e.g. OOM, Passed, etc.)"
          }
        },
        "GetTravelLocations": {
          "comment": "This will look at the levels and then gather all of the travel points we are interested in"
        },
        "HandlePerLoadedMapAudioStats": {
          "comment": "Add the audio related stats to the database"
        },
        "InitializeOptions": {
          "comment": "Initialize AutoTestManager based on command line options",
          "params": {
            "Options": "is the full command line options string passed to GameInfo"
          }
        },
        "SetIncrementsForLoops": {
          "comment": "Modify our Increments so that we get the most number of nodes traveled to\n best is to travel to all doing 8 directions\n next is to travel to all and do 4 directions\n next is to travel to as many as possible across the map doing 4 directions",
          "params": {
            "NumTravelLocations": "is the total number of destination positions"
          }
        },
        "StartAutomatedMapTestTimer": {
          "comment": "Start the AutomatedMapTest transition timer which will sit there and poll the status of the streaming levels.\n When we are doing malloc profiling and such loading is a lot slower so we can't just assume some time limit before moving on."
        },
        "StartAutomatedMapTestTimerWorker": {
          "comment": "This will look to make certain that all of the streaming levels are finished streaming"
        },
        "StartMatch": {
          "comment": "Used to initialize automated testing as needed when match starts.\n Called from GameInfo.StartMatch()."
        },
        "Timer": {
          "comment": "Base AutoTestManager timer ticks once per second\n Checks if perf test timer has run out"
        }
      }
    },
    "BlockingVolume": {
      "properties": {
        "bBlockCamera": {
          "comment": "GameCameras ignore BlockingVolumes with bBlockCamera=false"
        }
      },
      "functions": {
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        }
      }
    },
    "BlurEffect": {
      "comment": "Blur post process effect",
      "properties": {
        "BlurKernelSize": {
          "comment": "Distance to blur in pixels"
        }
      }
    },
    "BookMark": {
      "properties": {
        "HiddenLevels": {
          "comment": "Array of levels that are hidden"
        },
        "Location": {
          "comment": "Camera position/rotation"
        }
      }
    },
    "BookMark2D": {
      "comment": "Simple class to store 2D camera information.",
      "properties": {
        "Location": {
          "comment": "Location of the camera"
        },
        "Zoom2D": {
          "comment": "Zoom of the camera"
        }
      }
    },
    "Brush": {
      "properties": {
        "bPlaceableFromClassBrowser": {
          "comment": "If TRUE, this brush class can be placed using the class browser like other simple class types"
        },
        "SavedSelections": {
          "comment": "Stores selection information from geometry mode. This is the only information that we can't\n regenerate by looking at the source brushes following an undo operation."
        }
      }
    },
    "BrushComponent": {
      "properties": {
        "BrushAggGeom": {
          "comment": "Simplified collision data for the mesh."
        },
        "BrushPhysDesc": {
          "comment": "Physics engine shapes created for this BrushComponent."
        },
        "CachedPhysBrushData": {
          "comment": "Cached brush convex-mesh data for use with the physics engine."
        },
        "CachedPhysBrushDataVersion": {
          "comment": "Indicates version that CachedPhysBrushData was created at.\n Compared against CurrentCachedPhysDataVersion."
        },
        "bBlockComplexCollisionTrace": {
          "comment": "Normally a blocking volume is considered 'pure simplified collision', so when tracing for complex collision, never collide \n This flag overrides that behaviour"
        }
      },
      "structs": {
        "KCachedConvexData_Mirror": {
          "comment": "Mirror for FKCachedConvexData struct."
        }
      }
    },
    "Camera": {
      "properties": {
        "ActiveAnims": {
          "comment": "Array of anim instances that are currently playing and in-use"
        },
        "AnimCameraActor": {
          "comment": "Internal. Receives the output of individual camera animations."
        },
        "AnimInstPool[MAX_ACTIVE_CAMERA_ANIMS]": {
          "comment": "Pool of anim instance objects available with which to play camera animations"
        },
        "bConstrainAspectRatio": {
          "comment": "If we should insert black areas when rendering the scene to ensure an aspect ratio of ConstrainedAspectRatio"
        },
        "bDebugClientSideCamera": {
          "comment": "If true, replicate the client side camera position but don't use it, and draw the positions on the server"
        },
        "bEnableColorScaleInterp": {
          "comment": "Should interpolate color scale values"
        },
        "bEnableColorScaling": {
          "comment": "Turn on scaling of color channels in final image using ColorScale property."
        },
        "bEnableFading": {
          "comment": "If we should apply FadeColor/FadeAmount to the screen."
        },
        "BlendTimeToGo": {
          "comment": "Time left when blending to pending view target"
        },
        "bLockedFOV": {
          "comment": "true if FOV is locked to a constant value"
        },
        "bShouldSendClientSideCameraUpdate": {
          "comment": "if true, send a camera update to the server on next update"
        },
        "bUseClientSideCameraUpdates": {
          "comment": "if true, server will use camera positions replicated from the client instead of calculating locally."
        },
        "CameraLensEffects": {
          "comment": "CameraBlood emitter attached to this camera"
        },
        "CameraStyle": {
          "comment": "Camera Mode"
        },
        "CamOverridePostProcessAlpha": {
          "comment": "Indicates if CamPostProcessSettings should be used when using this Camera to view through."
        },
        "CamPostProcessSettings": {
          "comment": "Post-process settings to use if bCamOverridePostProcess is TRUE."
        },
        "ColorScale": {
          "comment": "Allows control over scaling individual color channels in the final image."
        },
        "ColorScaleInterpDuration": {
          "comment": "Total time for color scale interpolation to complete"
        },
        "ColorScaleInterpStartTime": {
          "comment": "Time at which interpolation started"
        },
        "ConstrainedAspectRatio": {
          "comment": "If bConstrainAspectRatio is true, add black regions to ensure aspect ratio is this. Ratio is horizontal/vertical."
        },
        "DefaultAspectRatio": {
          "comment": "Default aspect ratio"
        },
        "DefaultFOV": {
          "comment": "default FOV"
        },
        "DesiredColorScale": {
          "comment": "Desired color scale which ColorScale will interpolate to"
        },
        "FadeAlpha": {
          "comment": "camera fade management"
        },
        "FadeAmount": {
          "comment": "Amount of fading to apply."
        },
        "FadeColor": {
          "comment": "Color to fade to."
        },
        "FreeAnims": {
          "comment": "Array of anim instances that are not playing and available"
        },
        "FreeCamDistance": {
          "comment": "Distance to place free camera from view target"
        },
        "FreeCamOffset": {
          "comment": "Offset to Z free camera position"
        },
        "LockedFOV": {
          "comment": "value FOV is locked at"
        },
        "ModifierList": {
          "comment": "List of camera modifiers to apply during update of camera position/ rotation"
        },
        "OffAxisPitchAngle": {
          "comment": "Off-axis pitch angle offset"
        },
        "OffAxisYawAngle": {
          "comment": "Off-axis yaw angle offset"
        },
        "OriginalColorScale": {
          "comment": "Color scale value at start of interpolation"
        },
        "PCOwner": {
          "comment": "PlayerController Owning this Camera Actor"
        },
        "PendingViewTarget": {
          "comment": "Pending view target for blending"
        },
        "RenderingOverrides": {
          "comment": "Rendering overrides that are active on this camera."
        },
        "ViewTarget": {
          "comment": "Current ViewTarget"
        },
        "CameraShakeCamMod": {
          "comment": "Camera modifier for cone-driven screen shakes"
        },
        "CameraShakeCamModClass": {
          "comment": "Class to use when instantiating screenshake modifier object. Provided to support overrides."
        }
      },
      "functions": {
        "AddCameraLensEffect": {
          "comment": "Initiates a camera lens effect of the given class on this camera."
        },
        "ApplyCameraModifiers": {
          "comment": "Apply modifiers on Camera.",
          "params": {
            "DeltaTime": "Time is seconds since last update",
            "OutPOV": "Point of View"
          }
        },
        "BlendViewTargets": {
          "comment": "Blend 2 viewtargets.",
          "params": {
            "A": "Source view target",
            "n": "B destination view target",
            "Alpha": "Alpha, % of blend from A to B."
          }
        },
        "CalcRadialShakeScale": {
          "comment": "Internal. Returns intensity scalar in the range [0..1] for a shake originating at Epicenter."
        },
        "CheckViewTarget": {
          "comment": "Make sure ViewTarget is valid"
        },
        "ClearCameraLensEffects": {
          "comment": "Removes all Camera Lens Effects."
        },
        "CreateCameraModifier": {
          "comment": "Internal. Creates and initializes a new camera modifier of the specified class, returns the object ref."
        },
        "DisplayDebug": {
          "comment": "list important Camera variables on canvas. HUD will call DisplayDebug() on the current ViewTarget when\n the ShowDebug exec is used",
          "params": {
            "HUD": "HUD with canvas to draw on\n \n@input out_YL - Height of the current font\n \n@input out_YPos - Y position on Canvas. out_YPos += out_YL, gives position to draw text for next debug line."
          }
        },
        "FillCameraCache": {
          "comment": "Cache update results"
        },
        "FindCameraLensEffect": {
          "comment": "Finds the first instance of a lens effect of the given class, using linear search."
        },
        "GetCameraViewPoint": {
          "comment": "Master function to retrieve Camera's actual view point.\n do not call this directly, call PlayerController::GetPlayerViewPoint() instead.",
          "params": {
            "OutCamLoc": "Camera Location",
            "OutCamRot": "Camera Rotation"
          }
        },
        "GetFOVAngle": {
          "comment": "returns camera's current FOV angle"
        },
        "InitializeFor": {
          "comment": "Initialize Camera for associated PlayerController",
          "params": {
            "PC": "PlayerController attached to this Camera."
          }
        },
        "PlayCameraAnim": {
          "comment": "Play the indicated CameraAnim on this camera. Returns the CameraAnim instance."
        },
        "PlayCameraShake": {
          "comment": "Play a camera shake"
        },
        "PlayWorldCameraShake": {
          "comment": "Static. Plays an in-world camera shake that affects all nearby players, with distance-based attenuation."
        },
        "ProcessViewRotation": {
          "comment": "Give each modifier a chance to change view rotation/deltarot"
        },
        "RemoveCameraLensEffect": {
          "comment": "Removes this particular lens effect from the camera."
        },
        "SetDesiredColorScale": {
          "comment": "Sets the new desired color scale and enables interpolation."
        },
        "SetFOV": {
          "comment": "Lock FOV to a specific value.\n A value of 0 to beyond 170 will unlock the FOV setting."
        },
        "SetViewTarget": {
          "comment": "Set a new ViewTarget with optional BlendTime"
        },
        "StopAllCameraAnims": {
          "comment": "Stop playing all instances of the indicated CameraAnim.\n bImmediate: TRUE to stop it right now, FALSE to blend it out over BlendOutTime."
        },
        "StopAllCameraAnimsByType": {
          "comment": "Stop playing all instances of the indicated CameraAnim.\n bImmediate: TRUE to stop it right now, FALSE to blend it out over BlendOutTime."
        },
        "StopCameraAnim": {
          "comment": "Stops the given CameraAnim instance from playing. The given pointer should be considered invalid after this."
        },
        "StopCameraShake": {
          "comment": "Stop playing a camera shake."
        },
        "UpdateCamera": {
          "comment": "Performs camera update.\n Called once per frame after all actors have been ticked.\n Non-local players replicate the POV if bUseClientSideCameraUpdates is true"
        },
        "UpdateViewTarget": {
          "comment": "Query ViewTarget and outputs Point Of View.",
          "params": {
            "OutVT": "ViewTarget to use.",
            "DeltaTime": "Delta Time since last camera update (in seconds)."
          }
        }
      },
      "structs": {
        "TCameraCache": {
          "comment": "The actors which the camera shouldn't see. Used to hide actors which the camera penetrates.",
          "properties": {
            "POV": {
              "comment": "cached Point of View"
            },
            "TimeStamp": {
              "comment": "Cached Time Stamp"
            }
          }
        },
        "TViewTarget": {
          "comment": "View Target definition\n A View Target is responsible for providing the Camera with an ideal Point of View (POV)",
          "properties": {
            "AspectRatio": {
              "comment": "Aspect ratio"
            },
            "Controller": {
              "comment": "Controller of Target (only for non Locally controlled Pawns)"
            },
            "POV": {
              "comment": "Point of View"
            },
            "PRI": {
              "comment": "PlayerReplicationInfo (used to follow same player through pawn transitions, etc., when spectating)"
            },
            "Target": {
              "comment": "Target Actor used to compute ideal POV"
            }
          }
        },
        "ViewTargetTransitionParams": {
          "comment": "A set of parameters to describe how to transition between viewtargets.",
          "properties": {
            "BlendExp": {
              "comment": "Exponent, used by certain blend functions to control the shape of the curve."
            },
            "BlendFunction": {
              "comment": "Function to apply to the blend parameter"
            },
            "BlendTime": {
              "comment": "Total duration of blend to pending view target. 0 means no blending."
            },
            "bLockOutgoing": {
              "comment": "If TRUE, lock outgoing viewtarget to last frame's camera position for the remainder of the blend."
            }
          }
        }
      }
    },
    "CameraActor": {
      "properties": {
        "CamOverridePostProcessAlpha<ClampMin=0.0|ClampMax=1.0>": {
          "comment": "Blend value for CamOverridePostProcess. 0.f means it's ignored, 1.f means use it exclusively."
        }
      },
      "functions": {
        "DisplayDebug": {
          "comment": "list important CameraActor variables on canvas. HUD will call DisplayDebug() on the current ViewTarget when\n the ShowDebug exec is used",
          "params": {
            "HUD": "HUD with canvas to draw on\n \n@input out_YL - Height of the current font\n \n@input out_YPos - Y position on Canvas. out_YPos += out_YL, gives position to draw text for next debug line."
          }
        },
        "GetCameraView": {
          "comment": "Returns camera's Point of View.\n Called by Camera.uc class. Subclass and postprocess to add any effects."
        }
      }
    },
    "CameraAnim": {
      "properties": {
        "AnimLength": {
          "comment": "Length, in seconds."
        },
        "BaseFOV": {
          "comment": "The"
        },
        "BasePPSettings": {
          "comment": "The \"base\" postprocess settings to use, to support non-animating settings."
        },
        "BoundingBox": {
          "comment": "AABB in local space."
        },
        "CameraInterpGroup": {
          "comment": "The InterpGroup that holds our actual interpolation data."
        }
      }
    },
    "CameraAnimInst": {
      "properties": {
        "BasePlayScale": {
          "comment": "\"Intensity\" scalar. This is the scale at which the anim was first played."
        },
        "bAutoReleaseWhenFinished": {
          "comment": "True if it's ok for the system to auto-release this instance upon completion."
        },
        "bBlendingIn": {
          "comment": "True if currently blending in."
        },
        "bBlendingOut": {
          "comment": "True if currently blending out."
        },
        "bFinished": {
          "comment": "True if the animation has finished, false otherwise."
        },
        "BlendInTime": {
          "comment": "Time to interpolate in from zero, for smooth starts."
        },
        "BlendOutTime": {
          "comment": "Time to interpolate out to zero, for smooth finishes."
        },
        "bLooping": {
          "comment": "True if the animation should loop, false otherwise."
        },
        "CamAnim": {
          "comment": "which CameraAnim this is an instance of"
        },
        "CurBlendInTime": {
          "comment": "Current time for the blend-in. I.e. how long we have been blending."
        },
        "CurBlendOutTime": {
          "comment": "Current time for the blend-out. I.e. how long we have been blending."
        },
        "CurTime": {
          "comment": "Current time for the animation"
        },
        "InterpGroupInst": {
          "comment": "the InterpGroupInst used to do the interpolation"
        },
        "LastCameraLoc": {
          "comment": "Camera Anim debug variable to trace back to previous location"
        },
        "LastPPSettings": {
          "comment": "PP settings stored for this inst, to be applied at the proper time"
        },
        "MoveTrack": {
          "comment": "cached movement track from the currently playing anim so we don't have to go find it every frame"
        },
        "PlayRate": {
          "comment": "Multiplier for playback rate. 1.0 = normal."
        },
        "RemainingTime": {
          "comment": "How much longer to play the anim, if a specific duration is desired. Has no effect if 0."
        },
        "SourceAnimNode": {
          "comment": "Ref to the AnimNodeSequence that's instigating this anim. Can be None."
        },
        "TransientScaleModifier": {
          "comment": "A supplemental scale factor, allowing external systems to scale this anim as necessary. This is reset to 1.f each frame."
        },
        "UserPlaySpaceMatrix": {
          "comment": "The user-defined space for CAPS_UserDefined"
        }
      },
      "functions": {
        "AdvanceAnim": {
          "comment": "advances the animation by the specified time - updates any modified interp properties, moves the group actor, etc"
        },
        "ApplyTransientScaling": {
          "comment": "Applies given scaling factor to the playing animation for the next update only."
        },
        "Play": {
          "comment": "Starts this instance playing the specified CameraAnim.\n CamAnim: The animation that should play on this instance.\n CamActor: The Actor that will be modified by this animation.\n InRate: How fast to play the animation. 1.f is normal.\n InScale: How intense to play the animation. 1.f is normal.\n InBlendInTime: Time over which to linearly ramp in.\n InBlendInTime: Time over which to linearly ramp out.\n bInLoop: Whether or not to loop the animation.\n bRandomStartTime: Whether or not to choose a random time to start playing. Only really makes sense for bLoop = TRUE;\n Duration: optional specific playtime for this animation. This is total time, including blends."
        },
        "SetPlaySpace": {
          "comment": "Sets this anim to play in an alternate playspace"
        },
        "Stop": {
          "comment": "Stops this instance playing whatever animation it is playing."
        },
        "Update": {
          "comment": "Update this instance with new parameters."
        }
      }
    },
    "CameraModifier": {
      "properties": {
        "Alpha": {
          "comment": "Current blend alpha"
        },
        "AlphaInTime": {
          "comment": "When blending in, alpha proceeds from 0 to 1 over this time"
        },
        "AlphaOutTime": {
          "comment": "When blending out, alpha proceeds from 1 to 0 over this time"
        },
        "bExclusive": {
          "comment": "This modifier can only be used exclusively - no modifiers of same priority allowed"
        },
        "CameraOwner": {
          "comment": "Camera this object is attached to"
        },
        "Priority": {
          "comment": "Priority of this modifier - determines where it is added in the modifier list.\n 0 = highest priority, 255 = lowest"
        },
        "TargetAlpha": {
          "comment": "Desired alpha we are interpolating towards."
        }
      },
      "functions": {
        "AddCameraModifier": {
          "comment": "Camera modifier evaluates itself vs the given camera's modifier list\n and decides whether to add itself or not. Handles adding by priority and avoiding \n adding the same modifier twice.",
          "params": {
            "Camera": "reference to camera actor we want add this modifier to"
          }
        },
        "DisableModifier": {
          "comment": "Accessor functions for changing disable flag",
          "params": {
            "bImmediate": "TRUE to disable with no blend out, FALSE (default) to allow blend out"
          }
        },
        "Init": {
          "comment": "Allow anything to happen right after creation"
        },
        "IsDisabled": {
          "comment": "Accessor function to check if modifier is inactive"
        },
        "ModifyCamera": {
          "comment": "Directly modifies variables in the camera actor",
          "params": {
            "Camera": "reference to camera actor we are modifying",
            "DeltaTime": "Change in time since last update",
            "OutPOV": "current Point of View, to be updated."
          }
        },
        "ProcessViewRotation": {
          "comment": "Allow this modifier a chance to change view rotation and deltarot\n Default just returns ViewRotation unchanged"
        },
        "RemoveCameraModifier": {
          "comment": "Camera modifier removes itself from given camera's modifier list",
          "params": {
            "Camera": "reference to camara actor we want to remove this modifier from"
          }
        },
        "UpdateAlpha": {
          "comment": "Responsible for updating alpha blend value.",
          "params": {
            "Camera": "Camera that is being updated",
            "DeltaTime": "Amount of time since last update"
          }
        }
      }
    },
    "CameraModifier_CameraShake": {
      "comment": "Camera modifier that provides support for code-based oscillating camera shakes.",
      "properties": {
        "ActiveShakes": {
          "comment": "Active CameraShakes array"
        },
        "SplitScreenShakeScale": {
          "comment": "Scalar applied to all camera shakes in splitscreen. Normally used to dampen, since shakes feel more intense in a smaller viewport."
        }
      },
      "functions": {
        "AddCameraShake": {
          "comment": "Add a new screen shake to the list"
        },
        "InitializeOffset": {
          "comment": "For situational scaling of individual shakes."
        },
        "InitializeShake": {
          "comment": "Initialize camera shake structure"
        },
        "ModifyCamera": {
          "comment": "@see CameraModifer::ModifyCamera"
        },
        "UpdateCameraShake": {
          "comment": "Update a CameraShake"
        }
      },
      "structs": {
        "CameraShakeInstance": {
          "properties": {
            "bBlendingIn": {
              "comment": "blend vars"
            },
            "LocSinOffset": {
              "comment": "Current offsets."
            },
            "OscillatorTimeRemaining": {
              "comment": "<0.f means play infinitely."
            },
            "PlaySpace": {
              "comment": "What space to play the shake in before applying to the camera. Affects Anim and Oscillation both."
            },
            "SourceShake": {
              "comment": "source shake"
            },
            "SourceShakeName": {
              "comment": "Used to identify shakes when single instances are desired"
            },
            "UserPlaySpaceMatrix": {
              "comment": "Matrix defining the playspace, used when PlaySpace == CAPS_UserDefined"
            }
          }
        }
      }
    },
    "CameraShake": {
      "comment": "Object that encapsulates parameters for defining a camera shake.\n a code-driven (oscillating) screen shake.",
      "properties": {
        "Anim": {
          "comment": "Parameters for defining CameraAnim-driven camera shakes"
        },
        "AnimBlendInTime<ClampMin=0.0>": {
          "comment": "Linear blend-in time."
        },
        "AnimBlendOutTime<ClampMin=0.0>": {
          "comment": "Linear blend-out time."
        },
        "AnimPlayRate<ClampMin=0.001>": {
          "comment": "Scalar defining how fast to play the anim."
        },
        "AnimScale<ClampMin=0.0>": {
          "comment": "Scalar defining how \"intense\" to play the anim."
        },
        "bRandomAnimSegment": {
          "comment": "If TRUE, play a random snippet of the animation of length Duration. Implies bLoop and bRandomStartTime = TRUE for the CameraAnim.\n If FALSE, play the full anim once, non-looped."
        },
        "RandomAnimSegmentDuration<ClampMin=0.0|EditCondition=bRandomAnimSegment>": {
          "comment": "When bRandomAnimSegment=true, this defines how long the anim should play."
        },
        "bSingleInstance": {
          "comment": "TRUE to only allow a single instance of this shake to play at any given time. \n Subsequents attempts to play this shake will simply restart the timer."
        },
        "FOVOscillation": {
          "comment": "FOV oscillation"
        },
        "LocOscillation": {
          "comment": "Positional oscillation"
        },
        "OscillationDuration": {
          "comment": "Duration in seconds of current screen shake. <0 means indefinite, 0 means no oscillation"
        },
        "RotOscillation": {
          "comment": "Rotational oscillation"
        }
      },
      "structs": {
        "FOscillator": {
          "comment": "Defines oscillation of a single number."
        },
        "ROscillator": {
          "comment": "Defines rotator oscillation."
        },
        "VOscillator": {
          "comment": "Defines vector oscillation."
        }
      }
    },
    "Canvas": {
      "functions": {
        "CreateFontRenderInfo": {
          "comment": "constructor for FontRenderInfo"
        },
        "DeProject": {
          "comment": "transforms 2D screen coordinates into a 3D world-space origin and direction",
          "params": {
            "ScreenPos": "screen coordinates in pixels",
            "WorldOrigin": "(out) - world-space origin vector",
            "WorldDirection": "(out) - world-space direction vector"
          }
        },
        "DrawDebugGraph": {
          "comment": "Draws a graph comparing 2 variables. Useful for visual debugging and tweaking.",
          "params": {
            "Title": "Label to draw on the graph, or \"\" for none",
            "ValueX": "X-axis value of the point to plot",
            "ValueY": "Y-axis value of the point to plot",
            "UL_X": "X screen coord of the upper-left corner of the graph",
            "UL_Y": "Y screen coord of the upper-left corner of the graph",
            "W": "Width of the graph, in pixels",
            "H": "Height of the graph, in pixels",
            "RangeX": "Range of values expressed by the X axis of the graph",
            "RangeY": "Range of values expressed by the Y axis of the graph"
          }
        },
        "DrawIcon": {
          "comment": "Draw a CanvasIcon at the desired canvas position."
        },
        "DrawMaterialTile": {
          "comment": "Draws the emissive channel of a material to an axis-aligned quad at CurX,CurY.",
          "params": {
            "Mat": "The material which contains the emissive expression to render.",
            "XL": "The width of the quad in pixels.",
            "YL": "The height of the quad in pixels.",
            "U": "The U coordinate of the quad's upper left corner, in normalized coordinates.",
            "V": "The V coordinate of the quad's upper left corner, in normalized coordinates.",
            "UL": "The range of U coordinates which is mapped to the quad.",
            "VL": "The range of V coordinates which is mapped to the quad.",
            "bClipTile": "Whether to clip the texture (FALSE by default)."
          }
        },
        "DrawScaledIcon": {
          "comment": "Draw a CanvasIcon at the desired canvas position."
        },
        "DrawTile": {
          "comment": "Draws a texture to an axis-aligned quad at CurX,CurY.",
          "params": {
            "Tex": "The texture to render.",
            "XL": "The width of the quad in pixels.",
            "YL": "The height of the quad in pixels.",
            "U": "The U coordinate of the quad's upper left corner, in normalized coordinates.",
            "V": "The V coordinate of the quad's upper left corner, in normalized coordinates.",
            "UL": "The range of U coordinates which is mapped to the quad.",
            "VL": "The range of V coordinates which is mapped to the quad.",
            "LColor": "Color to colorize this texture.",
            "bClipTile": "Whether to clip the texture (FALSE by default)."
          }
        },
        "DrawTris": {
          "comment": "Draw a number of triangles on the canvas",
          "params": {
            "Tex": "Texture to apply to triangles",
            "Triangles": "Array of triangles to render"
          }
        },
        "MakeIcon": {
          "comment": "Fake CanvasIcon constructor."
        },
        "PopTransform": {
          "comment": "Pops the topmost matrix from the canvas transform stack."
        },
        "PreOptimizeDrawTiles": {
          "comment": "Optimization call to pre-allocate vertices and triangles for future DrawTile() calls.\n NOTE: Num is number of subsequent DrawTile() calls that will be made in a row with the \n same Texture and Blend settings. If other draws (Text, different textures, etc) are\n done before the Num DrawTile calls, the optimization will not work and will only waste memory.",
          "params": {
            "Num": "The number of DrawTile calls that will follow this function call",
            "Tex": "The texture that will be used to render tiles.",
            "Blend": "The blend mode that will be used for tiles."
          }
        },
        "Project": {
          "comment": "Convert a 3D vector to a 2D screen coords."
        },
        "PushTranslationMatrix": {
          "comment": "Pushes a translation matrix onto the canvas.",
          "params": {
            "TranslationVector": "Translation vector to use to create the translation matrix."
          }
        },
        "SetDrawColorStruct": {
          "comment": "Set the draw color using a color struct"
        }
      },
      "structs": {
        "CanvasIcon": {
          "comment": "Holds texture information with UV coordinates as well.",
          "properties": {
            "Texture": {
              "comment": "Source texture"
            },
            "U": {
              "comment": "UV coords"
            },
            "UL": {
              "comment": "UV coords"
            },
            "V": {
              "comment": "UV coords"
            },
            "VL": {
              "comment": "UV coords"
            }
          }
        },
        "CanvasUVTri": {
          "comment": "Simple 2d triangle with UVs",
          "properties": {
            "V0_Pos": {
              "comment": "Position of first vertex"
            },
            "V0_UV": {
              "comment": "UV of first vertex"
            },
            "V1_Pos": {
              "comment": "Position of second vertex"
            },
            "V1_UV": {
              "comment": "UV of second vertex"
            },
            "V2_Pos": {
              "comment": "Position of third vertex"
            },
            "V2_UV": {
              "comment": "UV of third vertex"
            }
          }
        },
        "DepthFieldGlowInfo": {
          "comment": "info for glow when using depth field rendering",
          "properties": {
            "bEnableGlow": {
              "comment": "whether to turn on the outline glow (depth field fonts only)"
            },
            "GlowColor": {
              "comment": "base color to use for the glow"
            },
            "GlowInnerRadius": {
              "comment": "if bEnableGlow, outline glow inner radius (0 to 1, 0.5 is edge of character silhouette)\n glow influence will be 1 at GlowInnerRadius.X and 0 at GlowInnerRadius.Y"
            },
            "GlowOuterRadius": {
              "comment": "if bEnableGlow, outline glow outer radius (0 to 1, 0.5 is edge of character silhouette)\n glow influence will be 0 at GlowOuterRadius.X and 1 at GlowOuterRadius.Y"
            }
          }
        },
        "FontRenderInfo": {
          "comment": "information used in font rendering",
          "properties": {
            "bClipText": {
              "comment": "whether to clip text"
            },
            "bEnableShadow": {
              "comment": "whether to turn on shadowing"
            },
            "GlowInfo": {
              "comment": "depth field glow parameters (only usable if font was imported with a depth field)"
            }
          }
        },
        "TextSizingParameters": {
          "comment": "General purpose data structure for grouping all parameters needed when sizing or wrapping a string",
          "properties": {
            "DrawFont": {
              "comment": "the font to use for sizing/wrapping the string"
            },
            "DrawX": {
              "comment": "a pixel value representing the horizontal screen location to begin rendering the string"
            },
            "DrawXL": {
              "comment": "a pixel value representing the width of the area available for rendering the string"
            },
            "DrawY": {
              "comment": "a pixel value representing the vertical screen location to begin rendering the string"
            },
            "DrawYL": {
              "comment": "a pixel value representing the height of the area available for rendering the string"
            },
            "Scaling": {
              "comment": "A value between 0.0 and 1.0, which represents how much the width/height should be scaled,\n where 1.0 represents 100% scaling."
            },
            "SpacingAdjust": {
              "comment": "Horizontal spacing adjustment between characters and vertical spacing adjustment between wrapped lines"
            },
            "ViewportHeight": {
              "comment": "the current height of the viewport; needed to support multifont"
            }
          }
        },
        "WrappedStringElement": {
          "comment": "Used by UUIString::WrapString to track information about each line that is generated as the result of wrapping.",
          "properties": {
            "LineExtent": {
              "comment": "the size (in pixels) that it will take to render this string"
            },
            "Value": {
              "comment": "the string associated with this line"
            }
          }
        }
      }
    },
    "CheatManager": {
      "properties": {
        "DebugCameraControllerRef": {
          "comment": "Debug camera - used to have independent camera without stopping gameplay"
        }
      },
      "functions": {
        "Avatar": {
          "comment": "Possess a pawn of the requested class"
        },
        "DebugPause": {
          "comment": "Dumps the pause state of the game"
        },
        "DestroyFractures": {
          "comment": "Util for fracturing meshes within an area of the player."
        },
        "DrawUnsupportingEdges": {
          "comment": "debug command, will draw all edges that are not supported for the passed pawn class"
        },
        "DumpCoverStats": {
          "comment": "debug command which prints out stats about memory usage by covernodes"
        },
        "DumpOnlineSessionState": {
          "comment": "Logs the current session state for the game type and online layer"
        },
        "EnableDebugCamera": {
          "comment": "Switch controller to debug camera without locking gameplay and with locking\n local player controller input"
        },
        "FractureAllMeshes": {
          "comment": "Util for ensuring at least one piece is broken of each FSM in level"
        },
        "FractureAllMeshesToMaximizeMemoryUsage": {
          "comment": "This will break all Fractured meshes in the map in a way to maximize memory usage"
        },
        "FXPlay": {
          "comment": "Finds the nearest pawn of the given class (excluding the owner's pawn) and\n plays the specified FaceFX animation."
        },
        "FXStop": {
          "comment": "Finds the nearest pawn of the given class (excluding the owner's pawn) and\n stops any currently playing FaceFX animation."
        },
        "GiveWeapon": {
          "comment": "Give a specified weapon to the Pawn.\n If weapon is not carried by player, then it is created.\n Weapon given is returned as the function's return parmater."
        },
        "InitCheatManager": {
          "comment": "This is not an actor, so we need a stand in for PostBeginPlay"
        },
        "LogParticleActivateSystemCalls": {
          "comment": "This will have all ActivateSystem function calls emit a warnf so you can see that name of"
        },
        "LogPlaySoundCalls": {
          "comment": "This will have all PlaySound function calls emit a warnf so you can see that name of \n the soundcue being played."
        },
        "NavMeshVerification": {
          "comment": "enables a timer to do periodic navmesh verification"
        },
        "PrintAllPathObjectEdges": {
          "comment": "debug command, prints all navmesh pathobject edges"
        },
        "PrintNavMeshObstacles": {
          "comment": "debug command, prints all active navmesh obstaces"
        },
        "SetLevelStreamingStatus": {
          "comment": "streaming level debugging"
        },
        "SetOnlineDebugLevel": {
          "comment": "Changes the OS specific logging level",
          "params": {
            "DebugLevel": "the new debug level to use"
          }
        },
        "TestNavMeshPath": {
          "comment": "tries to path from the player's current position to the position the player is looking at"
        },
        "ToggleAILogging": {
          "comment": "toggles AI logging"
        },
        "ToggleDebugCamera": {
          "comment": "Toggle between debug camera/player camera without locking gameplay and with locking\n local player controller input."
        },
        "VerifyNavMeshCoverRefs": {
          "comment": "debug command, verifies all cover references"
        },
        "VerifyNavMeshObjects": {
          "comment": "debug command, verifies that all path objects and path obstacls are valid \n (E.G.) that they haven't been deleted, but left registered"
        }
      }
    },
    "ClipPadEntry": {
      "properties": {
        "Text": {
          "comment": "The text copied/pasted"
        },
        "Title": {
          "comment": "User specified name"
        }
      }
    },
    "CodecMovie": {
      "properties": {
        "PlaybackDuration": {
          "comment": "Cached script accessible playback duration of movie."
        }
      }
    },
    "CodecMovieFallback": {
      "properties": {
        "CurrentTime": {
          "comment": "seconds since start of playback"
        }
      }
    },
    "ColorScaleVolume": {
      "properties": {
        "ColorScale": {
          "comment": "Desired color scale upon entering volume"
        },
        "InterpTime": {
          "comment": "Interpolation time for the color scale"
        }
      }
    },
    "Console": {
      "properties": {
        "AutoCompleteIndex": {
          "comment": "Currently selected auto complete index"
        },
        "AutoCompleteIndices": {
          "comment": "Current list of matching commands for auto-complete, @see UpdateCompleteIndices()"
        },
        "AutoCompleteList": {
          "comment": "Full list of auto-complete commands and info"
        },
        "bAutoCompleteLocked": {
          "comment": "Is the current auto-complete selection locked"
        },
        "bCaptureKeyInput": {
          "comment": "Indicates that InputChar events should be captured to prevent them from being passed on to other interactions. Reset\n when the another keydown event is received."
        },
        "bCtrl": {
          "comment": "True while a control key is pressed."
        },
        "bIsRuntimeAutoCompleteUpToDate": {
          "comment": "Do we need to rebuild auto complete?"
        },
        "bNavigatingHistory": {
          "comment": "tracks whether the user is using arrows keys to navigate the history, so that auto-complete doesn't override"
        },
        "bRequireCtrlToNavigateAutoComplete": {
          "comment": "Should the user be required to hold ctrl to use the up/down arrows when navigating auto-complete"
        },
        "ConsoleKey": {
          "comment": "The key which opens the console."
        },
        "ConsoleTargetPlayer": {
          "comment": "The player which the next console command should be executed in the context of. If NULL, execute in the viewport."
        },
        "HistoryBot": {
          "comment": "index into the History array for the earliest command that was entered"
        },
        "HistoryCur": {
          "comment": "the index of the current position in the History array"
        },
        "HistoryTop": {
          "comment": "index into the History array for the latest command that was entered"
        },
        "History[MaxHistory]": {
          "comment": "tracks previously entered console commands"
        },
        "ManualAutoCompleteList": {
          "comment": "Manual list of auto-complete commands and info specified in BaseInput.ini"
        },
        "MaxScrollbackSize": {
          "comment": "Visible Console stuff"
        },
        "SBHead": {
          "comment": "Where in the scrollback buffer are we"
        },
        "SBPos": {
          "comment": "Where in the scrollback buffer are we"
        },
        "Scrollback": {
          "comment": "Holds the scrollback buffer"
        },
        "TypedStr": {
          "comment": "The command the user is currently typing."
        },
        "TypeKey": {
          "comment": "The key which opens the typing bar."
        }
      },
      "functions": {
        "AppendInputText": {
          "comment": "appends the specified text to the string of typed text"
        },
        "ClearOutput": {
          "comment": "Clears the console output buffer."
        },
        "ConsoleCommand": {
          "comment": "Executes a console command.",
          "params": {
            "Command": "The command to execute."
          }
        },
        "FlushPlayerInput": {
          "comment": "Clears out all pressed keys from the player's input object."
        },
        "Initialized": {
          "comment": "Called when the Console is added to the GameViewportClient's Interactions array."
        },
        "InputChar": {
          "comment": "Process a character input event (typing) routed through unrealscript from another object. This method is assigned as the value for the\n OnRecievedNativeInputKey delegate so that native input events are routed to this unrealscript function.",
          "params": {
            "ControllerId": "the controller that generated this character input event",
            "Unicode": "the character that was typed"
          }
        },
        "InputKey": {
          "comment": "Process an input key event routed through unrealscript from another object. This method is assigned as the value for the\n OnRecievedNativeInputKey delegate so that native input events are routed to this unrealscript function.",
          "params": {
            "ControllerId": "the controller that generated this input key event",
            "Key": "the name of the key which an event occured for (KEY_Up, KEY_Down, etc.)",
            "EventType": "the type of event which occured (pressed, released, etc.)",
            "AmountDepressed": "for analog keys, the depression percent."
          }
        },
        "OutputText": {
          "comment": "Prints a (potentially multi-line) string of text to the console.\n The text is split into separate lines and passed to OutputTextLine.",
          "params": {
            "Text": "Text to display on the console."
          }
        },
        "OutputTextLine": {
          "comment": "Prints a single line of text to the console.",
          "params": {
            "Text": "A line of text to display on the console."
          }
        },
        "ProcessControlKey": {
          "comment": "looks for Control key presses and the copy/paste combination that apply to both the console bar and the full open console"
        },
        "PurgeCommandFromHistory": {
          "comment": "Searches console command history and removes any entries matching the specified command.",
          "params": {
            "Command": "The command to search for and purge from the history."
          }
        },
        "StartTyping": {
          "comment": "Opens the typing bar with text already entered.",
          "params": {
            "Text": "The text to enter in the typing bar."
          }
        }
      },
      "structs": {
        "AutoCompleteNode": {
          "comment": "Node for storing an auto-complete tree based on each char in the command",
          "properties": {
            "AutoCompleteListIndices": {
              "comment": "Indicies into AutoCompleteList for commands that match to this level"
            },
            "ChildNodes": {
              "comment": "Children for further matching"
            },
            "IndexChar": {
              "comment": "Char for node in the tree"
            }
          }
        }
      }
    },
    "Controller": {
      "properties": {
        "bAltFire": {
          "comment": "If true, the controlled pawn will attempt to alt fire"
        },
        "bForceStrafe": {
          "comment": "Used by AI, set true to force AI to use serpentine/strafing movement when possible."
        },
        "bOverrideSearchStart": {
          "comment": "Override search start position for navhandle path cache info"
        },
        "bPreciseDestination": {
          "comment": "Forces all velocity to be directed towards reaching Destination"
        },
        "bSeeFriendly": {
          "comment": "Do visibility checks, call SeePlayer events() for pawns on same team as self. Setting to true will result in a lot more AI visibility line checks."
        },
        "bUsingPathLanes": {
          "comment": "indicates that the AI is within a lane in its CurrentPath (like a road)\n to avoid ramming other Pawns also using that path\n set by MoveToward() when it detects multiple AI pawns using the same path\n when this is true, serpentine movement and cutting corners are disabled"
        },
        "FailedMoveTarget": {
          "comment": "used for discovering navigation failures"
        },
        "HighJumpNodeCostModifier": {
          "comment": "additive modifier to cost of NavigationPoints that require high jumping"
        },
        "InUseNodeCostMultiplier": {
          "comment": "multiplier to cost of NavigationPoints that another Pawn is currently anchored to"
        },
        "LaneOffset": {
          "comment": "the offset from the center of CurrentPath to the center of the lane in use (the Pawn's CollisionRadius defines the extent)\n positive values are to the Pawn's right, negative to the Pawn's left"
        },
        "MaxMoveTowardPawnTargetTime": {
          "comment": "Max time when moving toward a pawn target before latent movetoward returns (allowing reassessment of movement)"
        },
        "NavigationHandleClass": {
          "comment": "Navigation handle used for pathing when using NavMesh"
        },
        "NavMeshPath_SearchExtent_Modifier": {
          "comment": "allows easy modification of the search extent provided by setuppathfindingparams()"
        },
        "OldBasedRotation": {
          "comment": "Used for reversing rejected mover base movement"
        },
        "Pawn": {
          "comment": "Pawn currently being controlled by this controller. Use Pawn.Possess() to take control of a pawn"
        },
        "PlayerReplicationInfo": {
          "comment": "PlayerReplicationInfo containing replicated information about the player using this controller (only exists if bIsPlayer is true)."
        },
        "RouteCache": {
          "comment": "Cached list of nodes filled in by the last call to FindPathXXX"
        }
      },
      "functions": {
        "BeginAnimControl": {
          "comment": "Called when we start an AnimControl track operating on this Actor. Supplied is the set of AnimSets we are going to want to play from."
        },
        "CurrentLevelUnloaded": {
          "comment": "Called when the level this controller is in is unloaded via streaming."
        },
        "DisplayDebug": {
          "comment": "list important Controller variables on canvas. HUD will call DisplayDebug() on the current ViewTarget when\n the ShowDebug exec is used",
          "params": {
            "HUD": "HUD with canvas to draw on\n \n@input out_YL - Height of the current font\n \n@input out_YPos - Y position on Canvas. out_YPos += out_YL, gives position to draw text for next debug line."
          }
        },
        "FinishAnimControl": {
          "comment": "Called when we are done with the AnimControl track."
        },
        "GetActorEyesViewPoint": {
          "comment": "returns the point of view of the actor.\n note that this doesn't mean the camera, but the 'eyes' of the actor.\n For example, for a Pawn, this would define the eye height location,\n and view rotation (which is different from the pawn rotation which has a zeroed pitch component).\n A camera first person view will typically use this view point. Most traces (weapon, AI) will be done from this view point.\n @output out_Location, location of view point\n @output out_Rotation, view rotation of actor."
        },
        "GetAdjustedAimFor": {
          "comment": "Adjusts weapon aiming direction.\n Gives controller a chance to modify the aiming of the pawn. For example aim error, auto aiming, adhesion, AI help...\n Requested by weapon prior to firing.",
          "params": {
            "W,": "weapon about to fire",
            "StartFireLoc,": "world location of weapon fire start trace, or projectile spawn loc."
          }
        },
        "GetDestinationPosition": {
          "comment": "Retrive the final position that controller should be moving to"
        },
        "GetFocalPoint": {
          "comment": "Retrive the final position that controller should be looking at"
        },
        "GetPlayerViewPoint": {
          "comment": "Returns Player's Point of View\n For the AI this means the Pawn's 'Eyes' ViewPoint\n For a Human player, this means the Camera's ViewPoint\n @output out_Location, view location of player\n @output out_rotation, view rotation of player"
        },
        "HandlePathObstruction": {
          "comment": "called when a ReachSpec the AI wants to use is blocked by a dynamic obstruction\n gives the AI an opportunity to do something to get rid of it instead of trying to find another path\n \n@note MoveTarget is the actor the AI wants to move toward, CurrentPath the ReachSpec it wants to use",
          "params": {
            "BlockedBy": "the object blocking the path"
          }
        },
        "InitNavigationHandle": {
          "comment": "spawn and init Navigation Handle"
        },
        "InitPlayerReplicationInfo": {
          "comment": "spawns and initializes the PlayerReplicationInfo for this Controller"
        },
        "InterpolationFinished": {
          "comment": "called when a SeqAct_Interp action finished interpolating this Actor\n \n@note this function is called on clients for actors that are interpolated clientside via MatineeActor",
          "params": {
            "InterpAction": "the SeqAct_Interp that was affecting the Actor"
          }
        },
        "IsAimingAt": {
          "comment": "This will return whether or not this controller is aiming at the passed in actor.\n We are defining AIMing to mean that you are attempting to target the actor. Not just looking in the\n direction of the actor."
        },
        "IsInCombat": {
          "comment": "Returns if controller is in combat"
        },
        "IsLocalController": {
          "comment": "returns whether this controller is a local controller.\n @RETURN true always for non-playercontroller"
        },
        "IsLocalPlayerController": {
          "comment": "returns whether this Controller is a locally controlled PlayerController\n @note not valid until the Controller is completely spawned (i.e, unusable in Pre/PostBeginPlay())"
        },
        "IsSpectating": {
          "comment": "Returns true if controller is spectating"
        },
        "LandingShake": {
          "comment": "LandingShake()\nreturns true if controller wants landing view shake"
        },
        "MoveUnreachable": {
          "comment": "Called by APawn::moveToward when the point is unreachable\n due to obstruction or height differences."
        },
        "NotifyAddInventory": {
          "comment": "Called when an inventory item is given to our Pawn\n (owning client only)",
          "params": {
            "NewItem": "the Inventory item that was added"
          }
        },
        "NotifyCoverAdjusted": {
          "comment": "Called when a slot is adjusted with this controller as the current owner."
        },
        "NotifyCoverClaimViolation": {
          "comment": "Called when cover that AI had claimed is claimed forceably by someone else (usually a player)"
        },
        "NotifyCoverDisabled": {
          "comment": "Called when a slot is disabled with this controller as the current owner."
        },
        "NotifyPathChanged": {
          "comment": "this event is called when an edge is deleted that this controller's handle is actively using"
        },
        "OnModifyHealth": {
          "comment": "Redirect to pawn."
        },
        "OnPossess": {
          "comment": "Kismet Action to possess a Pawn or a vehicle"
        },
        "OnSetPhysics": {
          "comment": "Redirects SetPhysics kismet action to the pawn"
        },
        "OnSetVelocity": {
          "comment": "Redirects SetVelocity kismet action to the pawn"
        },
        "OnTeleport": {
          "comment": "Overridden to redirect to pawn, since teleporting the controller\n would be useless.\n If Action == None, this was called from the Pawn already"
        },
        "OnToggleGodMode": {
          "comment": "Sets god mode based on the activated link."
        },
        "OnToggleHidden": {
          "comment": "Overridden to redirect to the pawn if available."
        },
        "PlayActorFaceFXAnim": {
          "comment": "Play FaceFX animations on this Actor.\n Returns TRUE if succeeded, if failed, a log warning will be issued."
        },
        "ReachedPreciseDestination": {
          "comment": "Called when our pawn reaches Controller.Destination after setting bPreciseDestination = TRUE"
        },
        "RouteCache_Empty": {
          "comment": "Route Cache Operations\n Allows operations on nodes in the route while modifying route (ie before emptying the cache)\n Should override in subclasses as needed"
        },
        "SetAnimPosition": {
          "comment": "Called each from while the Matinee action is running, with the desired sequence name and position we want to be at."
        },
        "SetDestinationPosition": {
          "comment": "Set Destination as absolute position or offset from base"
        },
        "SetFocalPoint": {
          "comment": "Set FocalPoint as absolute position or offset from base"
        },
        "SetMorphWeight": {
          "comment": "Called each frame by Matinee to update the weight of a particular MorphNodeWeight."
        },
        "SetSkelControlScale": {
          "comment": "Called each frame by Matinee to update the scaling on a SkelControl."
        },
        "StopActorFaceFXAnim": {
          "comment": "Stop any matinee FaceFX animations on this Actor."
        },
        "UnderLift": {
          "comment": "Called when the this Controller's Pawn gets hit by an InterpActor interpolating downward while this Controller has Lift\n set as its PendingMover",
          "params": {
            "Lift": "the LiftCenter associated with the InterpActor that hit the Pawn"
          }
        },
        "WarnProjExplode": {
          "comment": "Notification from given projectil that it is about to explode"
        }
      },
      "structs": {
        "VisiblePortalInfo": {
          "comment": "List of destinations whose source portals are visible to this Controller",
          "properties": {
            "Destination": {
              "comment": "destination actor of portal"
            },
            "Source": {
              "comment": "source actor of portal"
            }
          }
        }
      }
    },
    "CoverGroup": {
      "properties": {
        "AutoSelectHeight": {
          "comment": "Z distance below group actor to select nodes"
        },
        "AutoSelectRadius": {
          "comment": "Radius around group actor to select nodes"
        },
        "CoverLinkRefs": {
          "comment": "List of cover links in the group"
        }
      }
    },
    "CoverLink": {
      "properties": {
        "AlignDist": {
          "comment": "Distance used when aligning to nearby surfaces"
        },
        "AutoCoverSlotInterval": {
          "comment": "Minimum distance to place between non-essential cover slots when auto-generating a cover link"
        },
        "bDynamicCover": {
          "comment": "This cover is dynamic"
        },
        "CircularOrigin": {
          "comment": "Origin for circular cover"
        },
        "CircularRadius": {
          "comment": "Radius for circular cover"
        },
        "Claims": {
          "comment": "List of all players using this cover"
        },
        "DynamicLinkInfos": {
          "comment": "Array of src and target location for dynamic links"
        },
        "GLOBAL_bUseSlotMarkers": {
          "comment": "Global flag: Whether coverlinks should create slot markers for navigation\n Should be FALSE if using navigation mesh, where cover navigation info will be built into the mesh"
        },
        "LeanTraceDist": {
          "comment": "How far auto adjust code traces forward from lean fire point"
        },
        "MidHeight": {
          "comment": "Min height for nearby geometry to categorize as mid-level cover"
        },
        "NextCoverLink": {
          "comment": "Used for the WorldInfo.CoverList linked list"
        },
        "SlipDist": {
          "comment": "Forward distance for checking cover slip links"
        },
        "StandHeight": {
          "comment": "Min height for nearby geometry to categorize as standing cover"
        },
        "TurnDist": {
          "comment": "Lateral distance for checking swat turn links"
        },
        "bAutoAdjust": {
          "comment": "Allow auto-adjusting of the Slots orientation/position and covertype?"
        },
        "bAutoSort": {
          "comment": "Allow auto-sorting of the Slots array"
        },
        "bCircular": {
          "comment": "Is this circular cover?"
        },
        "bClaimAllSlots": {
          "comment": "Claim all slots when someone claims one - used for cover that needs more than one slot, but slots overlap"
        },
        "bDisabled": {
          "comment": "Whether cover link is disabled"
        },
        "bDoAutoSlotDensityFixup": {
          "comment": "Should we automatically insert slots when there is too big of a gap?"
        },
        "bFractureOnTouch": {
          "comment": "This cover fractures when it is interacted with"
        },
        "bLooped": {
          "comment": "Cover is looped, first slot and last slot should be reachable direclty"
        },
        "bPlayerOnly": {
          "comment": "Is this cover restricted to player use?"
        },
        "DangerScale": {
          "comment": "Scale applied to danger cost during path finding for slots of this link"
        },
        "InvalidateDistance": {
          "comment": "Distance link must move to invalidate it's info"
        },
        "LocationDescription": {
          "comment": "Description for the entire CoverLink. Can be overridden per-slot."
        },
        "MaxFireLinkDist": {
          "comment": "Max trace dist for fire links to check"
        },
        "Slots": {
          "comment": "All slots linked to this node"
        },
        "bDebug_CoverGen": {
          "comment": "when enabled, extra info will be drawn and printed to the log related to generation of cover information for this link"
        }
      },
      "functions": {
        "AutoAdjustSlot": {
          "comment": "Auto-adjusts the slot orientation/location to the nearest geometry, as well\n as determine leans and cover type. Returns TRUE if the cover type changed."
        },
        "BreakFracturedMeshes": {
          "comment": "Applies an impulse to all nearby fractureable objects, if this coverlink is set to fracture on touch",
          "params": {
            "Origin": "Origin of fracture pulse",
            "Radius": "Radius around origin to apply the fracturable pulse. All parts in radius will fracture",
            "RBStrength": "strength to apply to fractureable parts",
            "DamageType": "DamageType to use as the fracturable pulse, potentially ignored by certain fractureable objects"
          }
        },
        "Claim": {
          "comment": "Asserts a claim on this link by the specified controller."
        },
        "FindSlots": {
          "comment": "Finds the current set of slots the specified point is between. Returns true\n if a valid slot set was found."
        },
        "GetFireLinkTo": {
          "comment": "Searches for a fire link to the specified cover/slot and returns the cover actions."
        },
        "GetSlotActions": {
          "comment": "Returns a list of AI actions possible from this slot"
        },
        "GetSlotLocation": {
          "comment": "Returns the world location of the requested slot."
        },
        "GetSlotRotation": {
          "comment": "Returns the world rotation of the requested slot."
        },
        "GetSlotViewPoint": {
          "comment": "Returns the world location of the default viewpoint for the specified slot."
        },
        "HasFireLinkTo": {
          "comment": "Searches for a valid fire link to the specified cover/slot.\n NOTE: marked noexport until 'optional out int' is fixed in the exporter"
        },
        "IsEdgeSlot": {
          "comment": "Return true if the specified slot is an edge, signifying \"End Of Cover\"."
        },
        "IsStationarySlot": {
          "comment": "Checks to see if the specified slot support stationary cover actions."
        },
        "IsValidClaim": {
          "comment": "Returns true if the specified controller is able to claim the slot."
        },
        "OnModifyCover": {
          "comment": "Handle modify action by enabling/disabling the list of slots, or auto adjusting."
        },
        "OnToggle": {
          "comment": "Overridden to disable all slots when toggled off."
        },
        "PackFireLinkInteractionInfo": {
          "comment": "Packs fire link item info into a single byte\n SrcType/DestType - only allow CT_Standing/CT_MidLevel \n SrcAction/DestAction - only allow CA_LeanLeft/CA_LeanRight/CA_PopUp/CA_Default(destonly)"
        },
        "SetDisabled": {
          "comment": "Enable/disable the entire CoverLink."
        },
        "SetSlotEnabled": {
          "comment": "Enable/disable a particular cover slot."
        },
        "SetSlotPlayerOnly": {
          "comment": "Enable/disable playersonly on a particular cover slot."
        },
        "UnClaim": {
          "comment": "Removes any claims the specified controller has on this link."
        }
      },
      "structs": {
        "CoverInfo": {
          "comment": "Utility struct for referencing cover link slots."
        },
        "CoverReference": {
          "properties": {
            "SlotIdx": {
              "comment": "Slot referenced in the link"
            }
          }
        },
        "CoverSlot": {
          "comment": "Contains information for a cover slot that a player can occupy",
          "properties": {
            "Actions": {
              "comment": "List of actions possible from this slot"
            },
            "bAllowClimbUp": {
              "comment": "Is climbing up allowed here?"
            },
            "bAllowCoverSlip": {
              "comment": "Is cover slip allowed?"
            },
            "bAllowMantle": {
              "comment": "Is mantling allowed here?"
            },
            "bAllowPopup": {
              "comment": "Is popping up allowed for midlevel/crouching cover?"
            },
            "bAllowSwatTurn": {
              "comment": "Is swat turn allowed?"
            },
            "bCanClimbUp": {
              "comment": "Can we mantle up?"
            },
            "bCanMantle": {
              "comment": "Can we mantle over this cover?"
            },
            "bCanSwatTurn_Left": {
              "comment": "Can swat turn at this slot?"
            },
            "bCanSwatTurn_Right": {
              "comment": "Can swat turn at this slot?"
            },
            "bEnabled": {
              "comment": "Is this slot currently enabled?"
            },
            "bFailedToFindSurface": {
              "comment": "Map Error: Cover slot failed to find surface to align to"
            },
            "bForceCanCoverSlip_Left": {
              "comment": "Can cover slip at this slot?"
            },
            "bForceCanCoverSlip_Right": {
              "comment": "Can cover slip at this slot?"
            },
            "bForceCanPopUp": {
              "comment": "Can we popup?"
            },
            "bForceNoGroundAdjust": {
              "comment": "if this is on ground adjustments will be skipped"
            },
            "bLeanLeft": {
              "comment": "Can we lean left/right to shoot from this slot?"
            },
            "bLeanRight": {
              "comment": "Can we lean left/right to shoot from this slot?"
            },
            "bPlayerOnly": {
              "comment": "Slot can only be used by players, not AI"
            },
            "bSelected": {
              "comment": "Is this slot currently selected for editing?"
            },
            "CoverType": {
              "comment": "Type of cover this slot provides"
            },
            "ExposedCoverPackedProperties": {
              "comment": "ExposedCover Packed Properties\n CoverRefIdx (Bits 0 - 15) - Index into Levels CoverIndexPairs array\n ExposedScale (Bits 16 - 23) - Scale of how dangerous this exposure is\n (0,255] -- ~0 = not very dangerous, 255 = extremely dangerous"
            },
            "FireLinks": {
              "comment": "List of all attackable nodes"
            },
            "ForceCoverType": {
              "comment": "Gives LDs ability to force the type - CT_None == auto find"
            },
            "LocationDescription": {
              "comment": "Per-slot description tag. If _None, fall back to the description in the CoverLink."
            },
            "LocationOffset": {
              "comment": "Offset from node location for this slot"
            },
            "OverlapClaimsList": {
              "comment": "List of cover slots that should be claimed when this slot is claimed"
            },
            "RejectedFireLinks": {
              "comment": "List of coverlinks/slots that couldn't be shot at - used by COVERLINK_DYNAMIC"
            },
            "RotationOffset": {
              "comment": "Offset from node rotation for this slot"
            },
            "SlipRefs": {
              "comment": "Info about where cover slip can move to"
            },
            "SlotOwner": {
              "comment": "Current owner of this slot"
            },
            "SlotValidAfterTime": {
              "comment": "Slot is invalid until world.timeseconds is >= this value (allows temporary disabling of slots)"
            },
            "TurnTargetPackedProperties": {
              "comment": "Link/slot info about where swat turn evade can move to \n Packs left/right index into Level CoverIndexPair \n left turn target into bits 0-15, right turn target into 16-31"
            }
          }
        },
        "CovPosInfo": {
          "comment": "Utility struct to reference a position in cover",
          "properties": {
            "Link": {
              "comment": "CoverLink holding cover position"
            },
            "Location": {
              "comment": "Location in cover"
            },
            "LtSlotIdx": {
              "comment": "Index of left bounding slot"
            },
            "LtToRtPct": {
              "comment": "Pct of distance Location is, between left and right slots"
            },
            "Normal": {
              "comment": "Normal vector, used to define direction. Pointing from Location away from Wall."
            },
            "RtSlotIdx": {
              "comment": "Index of right bounding slot"
            },
            "Tangent": {
              "comment": "Tangent vector, gives alignement of cover. With multiple slots cover, this gives the direction from Left to Right slots."
            }
          }
        },
        "DynamicLinkInfo": {
          "comment": "Updated DynamicLinkInfos array if source or destination is dynamic",
          "properties": {
            "LastSrcLocation": {
              "comment": "Location of the src when this FireLink was created/updated (Used for tracking CoverLink_Dynamic)"
            },
            "LastTargetLocation": {
              "comment": "Location of the target when this FireLink was created/updated (Used for tracking CoverLink_Dynamic)"
            }
          }
        },
        "ExposedLink": {
          "comment": "Contains information about other cover nodes this node is exposed to\n (ie flanked by)",
          "properties": {
            "ExposedScale": {
              "comment": "Scale of how dangerous this exposure is"
            },
            "TargetActor": {
              "comment": "Slot that is dangerous to this link"
            }
          }
        },
        "FireLink": {
          "comment": "Contains information about what other cover nodes this node is\n capable of firing on.",
          "properties": {
            "bDynamicIndexInited": {
              "comment": "Whether DynamicLinkInfoIndex has been initialized"
            },
            "bFallbackLink": {
              "comment": "Is this link considered a fallback link? (Shouldn't be desired, but is acceptable)"
            },
            "Interactions": {
              "comment": "List of fire link interactions"
            },
            "PackedProperties_CoverPairRefAndDynamicInfo": {
              "comment": "Packed properties\n CoverRefIdx (Bits 0 - 15) - Index into Levels CoverIndexPairs array\n DynamicLinkInfoIndex (Bits 16 - 31) - Index into this CoverLinks DynamicLinkInfos array"
            }
          }
        },
        "FireLinkItem": {
          "comment": "Contains specific links between SOURCE actions/postures to DEST actions/postures",
          "properties": {
            "DestAction": {
              "comment": "Action for source"
            },
            "DestType": {
              "comment": "CT_Standing/CT_MidLevel for source"
            },
            "SrcAction": {
              "comment": "Action for source"
            },
            "SrcType": {
              "comment": "CT_Standing/CT_MidLevel for source"
            }
          }
        }
      }
    },
    "CoverMeshComponent": {
      "properties": {
        "bShowWhenNotSelected": {
          "comment": "Allows the LDs to show all cover in a level without editing the cover"
        },
        "LocationOffset": {
          "comment": "Base offset applied to all meshes"
        }
      }
    },
    "CoverReplicator": {
      "comment": "this handles replicating cover changes to a client\n can't use variable replication on the CoverLinks because the slots list is a dynamic array\n also, that could potentially be a whole lot of channels if LDs mess with a lot of cover via Kismet, so this is more efficient",
      "functions": {
        "ClientReceiveAdjustedSlots": {
          "comment": "client receives just the auto-adjusted slots for the given CoverLink"
        },
        "ClientReceiveDisabledSlots": {
          "comment": "client receives just the disabled slots for the given CoverLink"
        },
        "ClientReceiveEnabledSlots": {
          "comment": "client receives just the enabled slots for the given CoverLink"
        },
        "ClientReceiveInitialCoverReplicationInfo": {
          "comment": "replicates the information for one CoverReplicationData entry\n bDone indicates whether or not there is more data coming for this entry (because some arrays have more than 8 elements)"
        },
        "ClientReceiveManualCoverTypeSlots": {
          "comment": "client receives just the manual adjusted slots for the given CoverLink"
        },
        "NotifyAutoAdjustSlots": {
          "comment": "notification that the slots on the given CoverLink have been auto-adjusted"
        },
        "NotifyDisabledSlots": {
          "comment": "notification that the slots on the given CoverLink have been disabled"
        },
        "NotifyEnabledSlots": {
          "comment": "notification that slots on the given CoverLink have been enabled"
        },
        "NotifySetManualCoverTypeForSlots": {
          "comment": "notification that the slots on the given CoverLink have been manually adjusted"
        },
        "PurgeOldEntries": {
          "comment": "removes entries that are no longer valid (i.e. the CoverLink has been streamed out)"
        },
        "ReplicateInitialCoverInfo": {
          "comment": "copies and starts replicating already changed cover info"
        },
        "ServerSendAdjustedSlots": {
          "comment": "send just the auto-adjusted slots for the CoverLink at the given index"
        },
        "ServerSendDisabledSlots": {
          "comment": "send just the disabled slots for the CoverLink at the given index"
        },
        "ServerSendEnabledSlots": {
          "comment": "send just the enabled slots for the CoverLink at the given index"
        },
        "ServerSendInitialCoverReplicationInfo": {
          "comment": "sends info for one CoverReplicationData to the client"
        },
        "ServerSendManualCoverTypeSlots": {
          "comment": "send just the manual adjusted slots for the CoverLink at the given index"
        }
      },
      "structs": {
        "CoverReplicationInfo": {
          "properties": {
            "Link": {
              "comment": "CoverLink that was changed"
            },
            "SlotsAdjusted": {
              "comment": "indices of slots that were adjusted"
            },
            "SlotsCoverTypeChanged": {
              "comment": "slots that have had cover type manually set"
            },
            "SlotsDisabled": {
              "comment": "indices of slots that were disabled"
            },
            "SlotsEnabled": {
              "comment": "indices of slots that were enabled"
            }
          }
        }
      }
    },
    "CrowdAgentBase": {
      "functions": {
        "NotifyPathChanged": {
          "comment": "returns the offset from the edge move point this entity should move toward (e.g. how high off the ground we should move to)",
          "params": {
            "Edge": "the edge we're moving to"
          }
        }
      }
    },
    "CullDistanceVolume": {
      "properties": {
        "bEnabled": {
          "comment": "Whether the volume is currently enabled or not."
        },
        "CullDistances": {
          "comment": "Array of size and cull distance pairs. The code will calculate the sphere diameter of a primitive's BB and look for a best\n fit in this array to determine which cull distance to use."
        }
      },
      "structs": {
        "CullDistanceSizePair": {
          "comment": "Helper structure containing size and cull distance pair.",
          "properties": {
            "CullDistance": {
              "comment": "Cull distance associated with size."
            },
            "Size": {
              "comment": "Size to associate with cull distance."
            }
          }
        }
      }
    },
    "CurveEdPresetCurve": {
      "properties": {
        "Points": {
          "comment": "The points of the curve"
        },
        "CurveName": {
          "comment": "Name of the curve"
        }
      },
      "structs": {
        "PresetGeneratedPoint": {
          "comment": "Preset Generated Point"
        }
      }
    },
    "CylinderComponent": {
      "properties": {
        "bAlwaysRenderIfSelected": {
          "comment": "If TRUE, this cylinder will always draw when the actor is selected."
        },
        "bDrawBoundingBox": {
          "comment": "Whether to draw the red bounding box for this cylinder."
        },
        "bDrawNonColliding": {
          "comment": "If TRUE, this cylinder will always draw when SHOW_Collision is on, even if CollideActors is FALSE."
        },
        "CylinderColor": {
          "comment": "Color used to draw the cylinder."
        }
      }
    },
    "DamageType": {
      "properties": {
        "DamagedFFWaveform": {
          "comment": "The forcefeedback waveform to play when you take damage"
        },
        "FracturedMeshDamage": {
          "comment": "Damage imparted by this damage type to fracturable meshes. Scaled by config WorldInfo.FracturedMeshWeaponDamage."
        },
        "KilledFFWaveform": {
          "comment": "The forcefeedback waveform to play when you are killed by this damage type"
        },
        "VehicleDamageScaling": {
          "comment": "multiply damage by this for vehicles"
        },
        "VehicleMomentumScaling": {
          "comment": "multiply momentum by this for vehicles"
        },
        "bCausesFracture": {
          "comment": "Can break bits off FracturedStaticMeshActors."
        },
        "bRadialDamageVelChange": {
          "comment": "When applying radial impulses, whether to treat as impulse or velocity change."
        },
        "RadialDamageImpulse": {
          "comment": "Size of impulse to apply when doing radial damage."
        }
      }
    },
    "DataStoreClient": {
      "properties": {
        "GlobalDataStoreClasses": {
          "comment": "List of global data store class names to create when the data store client is created."
        },
        "GlobalDataStores": {
          "comment": "The list of global persistent data stores."
        },
        "PlayerDataStoreClasses": {
          "comment": "Stores the list of dynamic player data store classes that were loaded from PlayerDataStoreClassNames."
        },
        "PlayerDataStoreClassNames": {
          "comment": "List of data store class names that should be loaded at initialization time, but not created. Instances of these data\n stores will be created as they are needed (i.e. PlayerOwner, etc.)"
        },
        "PlayerDataStores": {
          "comment": "the list of dynamic data stores that are created per-player."
        }
      },
      "functions": {
        "CreateDataStore": {
          "comment": "Creates and initializes an instance of the data store class specified.",
          "params": {
            "DataStoreClass": "the data store class to create an instance of. DataStoreClass should be a child class\n of UUIDataStore"
          }
        },
        "FindDataStore": {
          "comment": "Finds the data store indicated by DataStoreTag and returns a pointer to it.",
          "params": {
            "DataStoreTag": "A name corresponding to the 'Tag' property of a data store",
            "PlayerOwner": "used for resolving the correct data stores in split-screen games."
          }
        },
        "FindDataStoreClass": {
          "comment": "Searches the data store client's data store class arrays for a child of the specified meta class.",
          "params": {
            "RequiredMetaClass": "the data store base class to search for."
          }
        },
        "FindPlayerDataStoreIndex": {
          "comment": "Finds the index into the PlayerDataStores array for the data stores associated with the specified player.",
          "params": {
            "PlayerOwner": "the player to search for associated data stores for."
          }
        },
        "GetPlayerDataStoreClasses": {
          "comment": "Accessor for grabbing the list of player data store classes."
        },
        "NotifyGameSessionEnded": {
          "comment": "Called when the current map is being unloaded. Cleans up any references which would prevent garbage collection."
        },
        "RegisterDataStore": {
          "comment": "Adds a new data store to the GlobalDataStores array.",
          "params": {
            "DataStore": "the data store to add",
            "PlayerOwner": "if specified, the data store will be added to the list of PlayerDataStores, rather than the list of global data stores"
          }
        },
        "UnregisterDataStore": {
          "comment": "Removes a data store from the GlobalDataStores array.",
          "params": {
            "DataStore": "the data store to remove"
          }
        }
      },
      "structs": {
        "PlayerDataStoreGroup": {
          "comment": "Represents a collection of data stores that are linked to a specific player.",
          "properties": {
            "DataStores": {
              "comment": "the list of data stores registered for this player."
            },
            "PlayerOwner": {
              "comment": "the player that this group is associated with."
            }
          }
        }
      }
    },
    "DebugCameraController": {
      "properties": {
        "bShowSelectedInfo": {
          "comment": "Whether to show information about the selected actor on the debug camera HUD."
        },
        "PrimaryKey": {
          "comment": "The key that triggers PrimarySelect()."
        },
        "SecondaryKey": {
          "comment": "The key that triggers SecondarySelect()."
        },
        "UnselectKey": {
          "comment": "The key that triggers Unselect()."
        }
      },
      "functions": {
        "ConsoleCommand": {
          "comment": "Overridden to potentially pipe commands to regular PlayerController"
        },
        "NativeInputKey": {
          "comment": "Called from DebugCameraInput\n Process an input key event routed through unrealscript from another object. This method is assigned as the value for the\n OnRecievedNativeInputKey delegate so that native input events are routed to this unrealscript function.",
          "params": {
            "ControllerId": "the controller that generated this input key event",
            "Key": "the name of the key which an event occured for (KEY_Up, KEY_Down, etc.)",
            "EventType": "the type of event which occured (pressed, released, etc.)",
            "AmountDepressed": "for analog keys, the depression percent."
          }
        },
        "OnDeactivate": {
          "comment": "Function called on deactivation debug camera controller"
        },
        "PrimarySelect": {
          "comment": "Called when an actor has been selected with the primary key (e.g. left mouse button).",
          "params": {
            "HitLoc": "World-space position of the selection point.",
            "HitNormal": "World-space normal of the selection point.",
            "HitInfo": "Info struct for the selection point."
          }
        },
        "SecondarySelect": {
          "comment": "Called when an actor has been selected with the secondary key (e.g. right mouse button).",
          "params": {
            "HitLoc": "World-space position of the selection point.",
            "HitNormal": "World-space normal of the selection point.",
            "HitInfo": "Info struct for the selection point."
          }
        },
        "Unselect": {
          "comment": "Called when the user pressed the unselect key, just before the selected actor is cleared."
        }
      }
    },
    "DebugCameraInput": {
      "functions": {
        "InputKey": {
          "comment": "Process an input key event routed through unrealscript from another object. This method is assigned as the value for the\n OnRecievedNativeInputKey delegate so that native input events are routed to this unrealscript function.",
          "params": {
            "ControllerId": "the controller that generated this input key event",
            "Key": "the name of the key which an event occured for (KEY_Up, KEY_Down, etc.)",
            "EventType": "the type of event which occured (pressed, released, etc.)",
            "AmountDepressed": "for analog keys, the depression percent."
          }
        }
      }
    },
    "DecalComponent": {
      "properties": {
        "bFlipBackfaceDirection": {
          "comment": "If TRUE, invert the direction considered to be backfacing receiver triangles. Set e.g. when decal actors are mirrored."
        },
        "bHasBeenAttached": {
          "comment": "TRUE if the decal has already been attached once. Allows for static decals to be reattached"
        },
        "bMovableDecal": {
          "comment": "If TRUE, then the decal will recompute its receivers whenever its transform is updated. Allowing for dynamic movable decals"
        },
        "bStaticDecal": {
          "comment": "TRUE for decals created in the editor, FALSE for decals created at runtime."
        },
        "DecalReceivers": {
          "comment": "List of receivers to which this decal is attached."
        },
        "DecalTransform": {
          "comment": "Determines how the Location/Orientation of the decal are used"
        },
        "FieldOfView": {
          "comment": "Horizontal field of view."
        },
        "FracturedStaticMeshComponentIndex": {
          "comment": "If not -1, specifies the index of the FracturedStaticMeshComponent we hit"
        },
        "HitBinormal": {
          "comment": "Decal's impact binormal, as computed by eg weapon trace."
        },
        "HitBone": {
          "comment": "The name of hit bone."
        },
        "HitComponent": {
          "comment": "If non-NULL, consider HitComponent only when computing receivers."
        },
        "HitLevelIndex": {
          "comment": "If not -1, specifies the level into the world's level array of the BSP node that was hit."
        },
        "HitLocation": {
          "comment": "Decal's impact location, as computed by eg weapon trace."
        },
        "HitNodeIndex": {
          "comment": "If not -1, specifies the index of the BSP node that was hit."
        },
        "HitNodeIndices": {
          "comment": "Used to pass information of which BSP nodes where hit"
        },
        "HitNormal": {
          "comment": "Decal's impact normal, as computed by eg weapon trace."
        },
        "HitTangent": {
          "comment": "Decal's impact tangent, as computed by eg weapon trace."
        },
        "Location": {
          "comment": "Decal's frustum location, set in code or copied from DecalActor in UnrealEd."
        },
        "Orientation": {
          "comment": "Decal's frustum orientation, set in code or copied from DecalActor in UnrealEd."
        },
        "ParentRelLocRotMatrix": {
          "comment": "Decal location/orientation relative to parent transform when first attached"
        },
        "Planes": {
          "comment": "Ortho planes."
        },
        "ReleaseResourcesFence": {
          "comment": "Command fence used to shut down properly."
        },
        "StaticReceivers": {
          "comment": "List of receivers for static decals. Empty if the decal has bStaticDecal=FALSE."
        },
        "bNoClip": {
          "comment": "If FALSE (the default), use precise clipping to compute the decal geometry.\n If TRUE, decal geometry generation is faster, but the decal material will have\n to use clamped texture coordinates."
        },
        "DecalMaterial": {
          "comment": "Decal material."
        },
        "DecalRotation": {
          "comment": "Decal in-plane rotation, in degrees."
        },
        "FarPlane": {
          "comment": "Far plane clip distance."
        },
        "Height": {
          "comment": "Decal world space height."
        },
        "NearPlane": {
          "comment": "Near plane clip distance."
        },
        "OffsetX": {
          "comment": "Decal offset along the tangent."
        },
        "OffsetY": {
          "comment": "Decal offset along the binormal."
        },
        "TileX": {
          "comment": "Decal tiling along the tangent."
        },
        "TileY": {
          "comment": "Decal tiling along the binormal."
        },
        "Width": {
          "comment": "Decal world space width."
        },
        "bProjectOnBackfaces": {
          "comment": "If FALSE (the default), don't project decal onto back-facing polygons."
        },
        "bProjectOnBSP": {
          "comment": "If FALSE, don't project decal onto BSP."
        },
        "bProjectOnHidden": {
          "comment": "If FALSE (the default), don't project decal onto hidden receivers."
        },
        "bProjectOnSkeletalMeshes": {
          "comment": "If FALSE, don't project decal onto skeletal meshes."
        },
        "bProjectOnStaticMeshes": {
          "comment": "If FALSE, don't project decal onto static meshes."
        },
        "bProjectOnTerrain": {
          "comment": "If FALSE, don't project decal onto terrain."
        },
        "Filter": {
          "comment": "Component filter."
        },
        "FilterMode": {
          "comment": "Current filter application mode."
        },
        "ReceiverImages": {
          "comment": "@hack: Gears hack to avoid an octree look-up for level-placed decals. To be replaced with receiver serialization after ship."
        },
        "BackfaceAngle": {
          "comment": "Dot product of the minimum angle that surfaces can make with the decal normal to be considered backfacing."
        },
        "BlendRange": {
          "comment": "Start/End blend range specified as an angle in degrees. Controls where to start blending out the decal on a surface"
        },
        "ParentRelativeLocation": {
          "comment": "Decal location relative to parent transform used with DecalTransform_OwnerRelative mode"
        },
        "ParentRelativeOrientation": {
          "comment": "Decal orientation vector relative to parent transform used with DecalTransform_OwnerRelative mode"
        },
        "SortOrder": {
          "comment": "Controls the order in which decal elements are rendered. Higher values draw later (on top)."
        }
      },
      "functions": {
        "GetDecalMaterial": {
          "comment": "Accessor for decal material"
        },
        "IsWaitingForResetToDefaultsToComplete": {
          "comment": "Needed for proper synchronization of pooled decals"
        },
        "ResetToDefaults": {
          "comment": "detaches the component and resets the component's properties to the values of its template"
        },
        "SetDecalMaterial": {
          "comment": "setting decal material on decal component. This will force the decal to reattach"
        }
      },
      "structs": {
        "DecalReceiver": {
          "comment": "A decal receiver and its associated render data."
        }
      }
    },
    "DecalManager": {
      "properties": {
        "DecalBlendRange": {
          "comment": "default decal blend range"
        },
        "DecalDepthBias": {
          "comment": "default depth bias offset"
        },
        "DecalLifeSpan": {
          "comment": "default lifetime for decals"
        },
        "DecalTemplate": {
          "comment": "template to base pool components off of - should not be used for decals or attached to anything"
        },
        "MaxActiveDecals": {
          "comment": "maximum allowed active components - if this is greater than 0 and is exceeded, the oldest active decal is taken"
        },
        "PoolDecals": {
          "comment": "components currently in the pool"
        }
      },
      "functions": {
        "DecalFinished": {
          "comment": "Called when the given decal's lifetime has run out\n @note: caller responsible for removing from ActiveDecals array (this is to prevent code iterating the array from having dependencies on this function)"
        },
        "SetDecalParameters": {
          "comment": "This will set all of the various decal parameters. This is the function that should be updated when there are new\n Decal Paramaters that exist that should be updated by game code",
          "params": {
            "InExistingDecal": "If you have an existing decal that you want to set all the params on.",
            "DecalMaterial": "the material to use for the decal",
            "Width": "decal width",
            "Height": "decal height",
            "Thickness": "decal thickness (used to calculate the nearplane/farplane values)",
            "bNoClip": "if true, use the bNoClip code path for decal generation (requires DecalMaterial to have clamped texture coordinates)",
            "DecalRotation": "rotation of the decal in degrees",
            "HitComponent": "if specified, will only project on this component (optimization)",
            "bProjectOnTerrain": "whether decal can project on skeletal meshes (default false)",
            "HitBone": "if HitComponent is a skeletal mesh, the bone that was hit",
            "HitNodeIndex": "if HitComponent is BSP, the node that was hit",
            "HitLevelIndex": "if HitComponent is BSP, the index of the level whose BSP was hit",
            "InFracturedStaticMeshComponentIndex": "The index of the FracturedMesh component. -1/INDEX_NONE if the decal should project onto both the shell and core of the FracturedMeshActor",
            "DepthBias": "depth bias offset to control z-fighting",
            "BlendRange": "Start/End blend range specified as an angle in degrees. Controls where to start blending out the decal on a surface"
          }
        },
        "SpawnDecal": {
          "comment": "Spawns a decal with the given parameters, taking a component from the pool or creating as necessary.\n \n@note: the component is returned so the caller can perform any additional modifications (parameters, etc),\n but it shouldn't keep the reference around as the component will be returned to the pool as soon as the lifetime runs out",
          "params": {
            "DecalMaterial": "the material to use for the decal",
            "Width": "decal width",
            "Height": "decal height",
            "Thickness": "decal thickness (used to calculate the nearplane/farplane values)",
            "bNoClip": "if true, use the bNoClip code path for decal generation (requires DecalMaterial to have clamped texture coordinates)",
            "DecalRotation": "(opt) rotation of the decal in degrees",
            "HitComponent": "(opt) if specified, will only project on this component (optimization)",
            "bProjectOnTerrain": "(opt) whether decal can project on skeletal meshes (default false)",
            "HitBone": "(opt) if HitComponent is a skeletal mesh, the bone that was hit",
            "HitNodeIndex": "(opt) if HitComponent is BSP, the node that was hit",
            "HitLevelIndex": "(opt) if HitComponent is BSP, the index of the level whose BSP was hit",
            "InDecalLifeSpan": "lifetime for the decal",
            "InFracturedStaticMeshComponentIndex": "The index of the FracturedMesh component. -1/INDEX_NONE if the decal should project onto both the shell and core of the FracturedMeshActor",
            "DepthBias": "depth bias offset to control z-fighting",
            "BlendRange": "Start/End blend range specified as an angle in degrees. Controls where to start blending out the decal on a surface"
          }
        }
      },
      "structs": {
        "ActiveDecalInfo": {
          "comment": "components currently active in the world and how much longer they will be"
        }
      }
    },
    "DirectionalLightComponent": {
      "properties": {
        "TraceDistance": {
          "comment": "Trace distance for static lighting. Objects further than TraceDistance away from an object won't be taken into \n account for static shadowing applied to said object. This is used to work around floating point consistency\n issues in the collision code with regard to very long traces. The old default was WORLD_MAX."
        },
        "CascadeDistributionExponent": {
          "comment": "Exponent that is applied to the cascade transition distances as a fraction of WholeSceneDynamicShadowRadius.\n An exponent of 1 means that cascade transitions will happen at a distance proportional to their resolution.\n A value greater than 1 brings transitions closer to the camera."
        },
        "NumWholeSceneDynamicShadowCascades": {
          "comment": "Number of cascades to split the view frustum into for the whole scene dynamic shadow. \n More cascades result in better shadow resolution and allow WholeSceneDynamicShadowRadius to be further, but add rendering cost."
        },
        "WholeSceneDynamicShadowRadius": {
          "comment": "Radius of the whole scene dynamic shadow centered on the viewer, which replaces the precomputed shadows based on distance from the camera. \n A Radius of 0 disables the dynamic shadow. This feature is currently only supported on dominant directional lights."
        },
        "LightmassSettings<ScriptOrder=true>": {
          "comment": "The Lightmass settings for this object."
        }
      },
      "functions": {
        "OnUpdatePropertyBrightness": {
          "comment": "Called from matinee code when Brightness property changes."
        },
        "OnUpdatePropertyLightColor": {
          "comment": "Called from matinee code when LightColor property changes."
        }
      }
    },
    "DistributionFloatConstant": {
      "properties": {
        "Constant": {
          "comment": "This float will be returned for all values of time."
        }
      }
    },
    "DistributionFloatConstantCurve": {
      "properties": {
        "ConstantCurve": {
          "comment": "Keyframe data for how output constant varies over time."
        }
      }
    },
    "DistributionFloatUniform": {
      "properties": {
        "Max": {
          "comment": "High end of output float distribution."
        },
        "Min": {
          "comment": "Low end of output float distribution."
        }
      }
    },
    "DistributionFloatUniformCurve": {
      "properties": {
        "ConstantCurve": {
          "comment": "Keyframe data for how output constant varies over time."
        }
      }
    },
    "DistributionVectorConstant": {
      "properties": {
        "bLockAxes": {
          "comment": "If true, X == Y == Z ie. only one degree of freedom. If false, each axis is picked independently."
        },
        "Constant": {
          "comment": "This vector will be returned for all input times."
        }
      }
    },
    "DistributionVectorConstantCurve": {
      "properties": {
        "bLockAxes": {
          "comment": "If true, X == Y == Z ie. only one degree of freedom. If false, each axis is picked independently."
        },
        "ConstantCurve": {
          "comment": "Keyframe data for each component (X,Y,Z) over time."
        }
      }
    },
    "DistributionVectorUniform": {
      "properties": {
        "bLockAxes": {
          "comment": "If true, X == Y == Z ie. only one degree of freedom. If false, each axis is picked independently."
        },
        "Max": {
          "comment": "Upper end of vector magnitude range."
        },
        "Min": {
          "comment": "Lower end of vector magnitude range."
        }
      }
    },
    "DistributionVectorUniformCurve": {
      "properties": {
        "bLockAxes1": {
          "comment": "If true, X == Y == Z ie. only one degree of freedom. If false, each axis is picked independently."
        },
        "ConstantCurve": {
          "comment": "Keyframe data for how output constant varies over time."
        }
      }
    },
    "DMC_Base": {
      "functions": {
        "AddComponent": {
          "comment": "Create a new component give the template.\n Not marked k2call, as there is a special K2 node type that knows it can call this function."
        }
      }
    },
    "DMC_Prototype": {
      "properties": {
        "DefaultPropText": {
          "comment": "Text string that holds default properties for this class"
        },
        "FunctionCode": {
          "comment": "String indicating script functions for this class"
        },
        "GeneratedClass": {
          "comment": "Pointer to 'most recent' version of generated class"
        },
        "ParentClass": {
          "comment": "Pointer to the parent class that the generated class should derive from"
        },
        "NewVars": {
          "comment": "Array of new variables to be added to generated class"
        }
      },
      "structs": {
        "DMCNewVar": {
          "comment": "Struct indicating a new variable added to this generated class",
          "properties": {
            "VarName": {
              "comment": "Name of new variable"
            },
            "VarType": {
              "comment": "Type of the new variable"
            }
          }
        }
      }
    },
    "DOFAndBloomEffect": {
      "comment": "Depth of Field post process effect",
      "properties": {
        "SceneMultiplier": {
          "comment": "A multiplier applied to all reads of scene color."
        },
        "BloomScale": {
          "comment": "A scale applied to blooming colors."
        },
        "BloomScreenBlendThreshold": {
          "comment": "Scene color luminance must be less than this to receive bloom. \n This behaves like Photoshop's screen blend mode and prevents over-saturation from adding bloom to already bright areas.\n The default value of 1 means that a pixel with a luminance of 1 won't receive any bloom, but a pixel with a luminance of .5 will receive half bloom."
        },
        "BloomThreshold": {
          "comment": "Any component of a pixel's color must be larger than this to contribute bloom."
        },
        "BloomTint": {
          "comment": "Multiplies against the bloom color."
        },
        "BlurBloomKernelSize": {
          "comment": "the radius of the bloom effect 0..64"
        },
        "BokehTexture": {
          "comment": "only used if BokehDOF is enabled"
        },
        "DepthOfFieldQuality": {
          "comment": "Allows to specify the quality of the chose Depth of Field Type.\n This meaning depends heavily on the current implementation and that might change.\n If performance is important the lowest acceptable quality should be used."
        },
        "DepthOfFieldType": {
          "comment": "Allows to specify the depth of field type. Choose depending on performance and quality needs.\n \"SimpleDOF\" blurs the out of focus content and recombines that with the unblurred scene (fast, almost constant speed).\n \"ReferenceDOF\" makes use of dynamic branching in the pixel shader and features circular Bokeh shape effects (slow for big Kernel Size).\n \"BokehDOF\" allows to specify a Bokeh texture and a bigger radius (requires D3D11, slow when using a lot of out of focus content)"
        }
      }
    },
    "DOFBloomMotionBlurEffect": {
      "properties": {
        "CameraRotationThreshold": {
          "comment": "Threshhold for when to turn off motion blur when the camera rotates swiftly during a single frame (in degrees)."
        },
        "CameraTranslationThreshold": {
          "comment": "Threshhold for when to turn off motion blur when the camera translates swiftly during a single frame (in world units)."
        },
        "FullMotionBlur": {
          "comment": "Whether everything (static/dynamic objects) should motion blur or not. If disabled, only moving objects may blur."
        },
        "MaxVelocity": {
          "comment": "Maximum blur velocity amount. This is a clamp on the amount of blur."
        },
        "MotionBlurAmount": {
          "comment": "This is a scale that could be considered as the \"sensitivity\" of the blur."
        }
      }
    },
    "DOFEffect": {
      "comment": "Depth of Field post process effect",
      "properties": {
        "BlurKernelSize": {
          "comment": "affects the radius of the DepthOfField bohek / how blurry the scene gets"
        },
        "FalloffExponent": {
          "comment": "exponent to apply to blur amount after it has been normalized to [0,1]"
        },
        "FocusDistance": {
          "comment": "used when FOCUS_Distance is enabled"
        },
        "FocusInnerRadius": {
          "comment": "inner focus radius"
        },
        "FocusPosition": {
          "comment": "used when FOCUS_Position is enabled"
        },
        "FocusType": {
          "comment": "control how the focus point is determined"
        },
        "MaxFarBlurAmount": {
          "comment": "[0,1] value for clamping how much blur to apply to items behind the focus plane"
        },
        "MaxNearBlurAmount": {
          "comment": "[0,1] value for clamping how much blur to apply to items in front of the focus plane"
        },
        "MinBlurAmount": {
          "comment": "[0,1] value for clamping how much blur to apply"
        }
      }
    },
    "DominantDirectionalLightComponent": {
      "properties": {
        "DominantLightShadowMap": {
          "comment": "Array of depths to the furthest shadow casting geometry in each shadowmap cell, quantized to a WORD and stored relative to LightSpaceImportanceBounds.Min.Z."
        }
      }
    },
    "DominantSpotLightComponent": {
      "properties": {
        "DominantLightShadowMap": {
          "comment": "Array of depths to the furthest shadow casting geometry in each shadowmap cell, quantized to a WORD and stored relative to LightSpaceImportanceBounds.Min.Z."
        }
      }
    },
    "DoorMarker": {
      "comment": "used to mark a door; handles the usability of paths through it and any special actions needed to open it",
      "properties": {
        "bDoorOpen": {
          "comment": "whether or not the door is currently open"
        },
        "bTempDisabledCollision": {
          "comment": "internal - used in path building"
        },
        "bBlockedWhenClosed": {
          "comment": "if true, don't even try to go through this path if door is closed"
        },
        "bInitiallyClosed": {
          "comment": "if true, means that the initial position of the mover blocks navigation"
        },
        "bWaitUntilCompletelyOpened": {
          "comment": "if true, AI should wait until the door has completely finished opening before trying to move through"
        },
        "DoorTrigger": {
          "comment": "trigger for the door; if specified, the opening action will be done to the trigger instead of the door"
        },
        "DoorType": {
          "comment": "how do we open this door?"
        },
        "MyDoor": {
          "comment": "the door mover associated with this marker"
        }
      },
      "functions": {
        "SuggestMovePreparation": {
          "comment": "tell Other what to do to open the door",
          "params": {
            "Other": "the Controller to tell what to do"
          }
        }
      }
    },
    "DownloadableContentEnumerator": {
      "comment": "This object is responsible for the enumeration of downloadable content bundles",
      "properties": {
        "DLCBundles": {
          "comment": "The set of DLC this enumerator is aware of"
        },
        "DLCRootDir": {
          "comment": "The root directory to look for DLC in"
        },
        "FindDLCDelegates": {
          "comment": "List of listeners for the find DLC event"
        }
      },
      "functions": {
        "AddFindDLCDelegate": {
          "comment": "Adds a delegate to the list of listeners",
          "params": {
            "InDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFindDLCDelegate": {
          "comment": "Removes a delegate from the list of listeners",
          "params": {
            "InDelegate": "the delegate to use for notifications"
          }
        },
        "DeleteDLC": {
          "comment": "Removes a DLC bundle from the local machine. This is not an uninstall, so choose wisely",
          "params": {
            "DLCName": "the name of the DLC bundle to delete"
          }
        },
        "FindDLC": {
          "comment": "Looks for DLC and populates the DLC bundles with the information"
        },
        "InstallAllDLC": {
          "comment": "Adds the list of DLC bundles to the DLC manager"
        },
        "InstallDLC": {
          "comment": "Installs the named DLC via the DLC manager",
          "params": {
            "DLCName": "the name of the DLC bundle to install"
          }
        },
        "TriggerFindDLCDelegates": {
          "comment": "Triggers the FindDLC delegates"
        }
      }
    },
    "DownloadableContentManager": {
      "comment": "This object is responsible for the installation and removal of\n downloadable content",
      "properties": {
        "ClassesToReload": {
          "comment": "The list of classes that need reloading due to a config change"
        },
        "DLCConfigCacheChanges": {
          "comment": "The list of DLC config cache changes made by the installed DLC"
        },
        "GameEngine": {
          "comment": "The owning game engine"
        },
        "InstalledDLC": {
          "comment": "The list of installed DLC bundles"
        },
        "ObjectsToReload": {
          "comment": "The list of per object config objects that need updating due to a config change"
        },
        "TextureCachePathMap": {
          "comment": "Maps the TFC file name to the full path to its location"
        }
      },
      "functions": {
        "AddPackagesToFullyLoad": {
          "comment": "Parses the specified section for the key/value set to use for fully loading packages",
          "params": {
            "FileName": "the file name to parse the information from"
          }
        },
        "AddSectionToObjectList": {
          "comment": "Adds the specified section to the classes to update list or to the per object config\n objects to update depending on whether they are found",
          "params": {
            "Section": "the section name being reloaded"
          }
        },
        "ClearDLC": {
          "comment": "Clears the DLC cache and restores the config cache to its pre-DLC state"
        },
        "GetDLCTextureCachePath": {
          "comment": "Determines the texture cache file path associated with the name",
          "params": {
            "TextureCacheName": "the bundle that is to be installed",
            "Path": "receives the full path to the texture cache"
          }
        },
        "Init": {
          "comment": "Registers the callback events with the online subsystem that it cares about"
        },
        "InstallDLC": {
          "comment": "Installs a DLC bundle",
          "params": {
            "DLCBundle": "the bundle that is to be installed"
          }
        },
        "InstallDLCs": {
          "comment": "Installs a set of DLC bundles",
          "params": {
            "DLCBundles": "the set of bundles that are to be installed"
          }
        },
        "InstallNonPackageFiles": {
          "comment": "Installs the list of non-packages (ini, loc, sha, etc.) for the DLC",
          "params": {
            "DLCBundle": "the bundle that is being installed"
          }
        },
        "InstallPackages": {
          "comment": "Installs the list of packages for the DLC",
          "params": {
            "DLCBundle": "the bundle that is being installed"
          }
        },
        "MarkPerObjectConfigPendingKill": {
          "comment": "Looks to see if the section is a per object config section that was removed so the\n object also needs to be destroyed",
          "params": {
            "Section": "the section name being unloaded"
          }
        },
        "OnContentChange": {
          "comment": "Called when new DLC is installed. Here so game specific implementations can easily overload"
        },
        "OnLoginChange": {
          "comment": "Delegate called when a player logs in/out, so we can clear/refresh DLC",
          "params": {
            "LocalUserNum": "the player that logged in/out"
          }
        },
        "OnStorageDeviceChange": {
          "comment": "Called when a storage device is inserted/removed. Here so game specific implementations can easily overload"
        },
        "RefreshDLC": {
          "comment": "Delegate used when content is changed (add or deletion) for any user or\n when any storage devices are changed"
        },
        "RefreshDLCEnumComplete": {
          "comment": "Installs the DLC when the enumeration is complete"
        },
        "UpdateObjectLists": {
          "comment": "Reloads config and localization on both of the object lists and empties them"
        }
      }
    },
    "DrawFrustumComponent": {
      "properties": {
        "FrustumAngle": {
          "comment": "Angle of longest dimension of view shape."
        },
        "FrustumAspectRatio": {
          "comment": "Ratio of horizontal size over vertical size."
        },
        "FrustumColor": {
          "comment": "Color to draw the wireframe frustum."
        },
        "FrustumEndDist": {
          "comment": "Distance from origin to stop drawing the frustum."
        },
        "FrustumStartDist": {
          "comment": "Distance from origin to start drawing the frustum."
        },
        "Texture": {
          "comment": "optional texture to show on the near plane"
        }
      }
    },
    "DrawQuadComponent": {
      "properties": {
        "Height": {
          "comment": "Height of quad face"
        },
        "Texture": {
          "comment": "Texture source to draw on quad face"
        },
        "Width": {
          "comment": "Width of quad face"
        }
      }
    },
    "DroppedPickup": {
      "functions": {
        "GiveTo": {
          "comment": "give pickup to player"
        },
        "RecheckValidTouch": {
          "comment": "Pickup was touched through a wall. Check to see if touching pawn is no longer obstructed"
        },
        "SetPickupMesh": {
          "comment": "Set Pickup mesh to use.\n Replicated through InventoryClass to remote clients using Inventory.DroppedPickup component as default mesh."
        },
        "SetPickupParticles": {
          "comment": "Set Pickup particles to use.\n Replicated through InventoryClass to remote clients using Inventory.DroppedPickup component as default mesh."
        }
      }
    },
    "DynamicAnchor": {
      "comment": "a dynamic anchor is a NavigationPoint temporarily added to the navigation network during gameplay, when the AI is trying\n to get on the network but there is no directly reachable NavigationPoint available. It tries to find something else that is\n reachable (for example, part of a ReachSpec) and places one of these there and connects it to the network. Doing it this way\n allows us to handle these situations without any special high-level code; as far as script is concerned, the AI is moving\n along a perfectly normal NavigationPoint connected to the network just like any other.\n DynamicAnchors handle destroying themselves and cleaning up any connections when they are no longer in use.",
      "properties": {
        "CurrentUser": {
          "comment": "current controller that's using us to navigate"
        }
      }
    },
    "DynamicBlockingVolume": {
      "comment": "This is a movable blocking volume. It can be moved by matinee, being based on\n dynamic objects, etc.",
      "properties": {
        "bEnabled": {
          "comment": "Is the volume enabled by default?"
        }
      },
      "functions": {
        "PostBeginPlay": {
          "comment": "Overriden to set the default collision state."
        }
      },
      "structs": {
        "CheckpointRecord": {
          "comment": "Force TRACE_LevelGeometry to still work with us even though bWorldGeometry is cleared\n bWorldGeometry is cleared so that actors can base properly on moving volumes\n \n \n@param Primitive - the primitive to trace against\n \n \n@param SourceActor - the actor doing the trace\n \n \n@param TraceFlags - misc flags describing the trace"
        }
      }
    },
    "DynamicLightEnvironmentComponent": {
      "properties": {
        "AmbientGlow": {
          "comment": "Ambient color added in addition to the level's lighting."
        },
        "AmbientShadowColor": {
          "comment": "The color of the ambient shadow."
        },
        "AmbientShadowSourceDirection": {
          "comment": "The direction of the ambient shadow source."
        },
        "bAffectedBySmallDynamicLights": {
          "comment": "Whether to be affected by small dynamic lights (like muzzle flashes) which may expose artifacts since the whole DLE will be lit up by them. \n If FALSE, dynamic lights smaller than the DLE will not affect the DLE."
        },
        "bCompositeShadowsFromDynamicLights": {
          "comment": "Whether the light environment's shadow includes the effect of dynamic lights."
        },
        "bForceAllowLightEnvSphericalHarmonicLights": {
          "comment": "This is to allow individual DLEs to force override and get and SH light. We need this for levels which have their\n worldinfo's bAllowLightEnvSphericalHarmonicLights set to FALSE but then have cinematic levels added which were lit needing SH lights\n to look good."
        },
        "bForceCompositeAllLights": {
          "comment": "Whether to represent all lights with the light environment, including dominant lights which are usually rendered separately."
        },
        "bIsCharacterLightEnvironment": {
          "comment": "Whether this light environment is being applied to a character \n And should be affected by character specific lighting like WorldInfo's CharacterLightingContrastFactor."
        },
        "BouncedLightingFactor": {
          "comment": "The intensity of the simulated bounced light, as a fraction of the LightComponent's bounced lighting settings."
        },
        "BoundsMethod": {
          "comment": "Accumulates the bounds of attached components on any actor using this DLE. \n This is useful when the DLE is lighting something whose Owner is placed in the world, like a pool actor.\n This method only works when the components using this DLE are attached before the DLE is updated."
        },
        "bRequiresNonLatentUpdates": {
          "comment": "Whether this is an actor that can't tolerate latency in lighting updates; a full lighting update is done every frame."
        },
        "bShadowFromEnvironment": {
          "comment": "Whether the light environment should be shadowed by the static environment."
        },
        "bSynthesizeDirectionalLight": {
          "comment": "Whether a directional light should be used to synthesize the dominant lighting in the environment."
        },
        "DominantShadowTransitionEndDistance": {
          "comment": "The distance from the dominant light shadow transition at which to end fading out the DLE's modulated shadow and primary light. \n This must be smaller than DominantShadowTransitionStartDistance."
        },
        "DominantShadowTransitionStartDistance": {
          "comment": "The distance from the dominant light shadow transition at which to start fading out the DLE's modulated shadow and primary light. \n This must be larger than DominantShadowTransitionEndDistance."
        },
        "InvisibleUpdateTime": {
          "comment": "The number of seconds between light environment updates for actors which aren't visible."
        },
        "LightDesaturation": {
          "comment": "Desaturation percentage of level lighting, which can be used to help team colored characters stand out better under colored lighting."
        },
        "LightDistance": {
          "comment": "The distance to create the light from the owner's origin, in radius units."
        },
        "LightShadowMode": {
          "comment": "The type of shadowing to use for the environment's shadow."
        },
        "MaxModulatedShadowColor": {
          "comment": "Brightest ModulatedShadowColor allowed for the shadow. This can be used to limit the DLE's shadow to a specified darkness."
        },
        "MaxShadowResolution": {
          "comment": "Override for max square dimensions (in texels) allowed for rendering shadow subject depths.\n A value of 0 defaults to MaxShadowResolution in SystemSettings."
        },
        "MinShadowAngle": {
          "comment": "The minimum angle to allow between the shadow direction and horizontal. An angle > 0 constrains the shadow to never be cast from a light\n below horizontal."
        },
        "MinShadowResolution": {
          "comment": "Override for min dimensions (in texels) allowed for rendering shadow subject depths.\n This also controls shadow fading, once the shadow resolution reaches MinShadowResolution it will be faded out completely.\n A value of 0 defaults to MinShadowResolution in SystemSettings."
        },
        "MinTimeBetweenFullUpdates": {
          "comment": "Minimum amount of time that needs to pass between full environment updates."
        },
        "ModShadowFadeoutExponent": {
          "comment": "Exponent that controls mod shadow fadeout curve."
        },
        "ModShadowFadeoutTime": {
          "comment": "Time since the caster was last visible at which the mod shadow will fade out completely."
        },
        "OverriddenLightComponents": {
          "comment": "Light components which override lights in GWorld, useful for rendering light environments in preview scenes."
        },
        "ShadowDistance": {
          "comment": "The distance for the shadow to project beyond the owner's origin, in radius units."
        },
        "ShadowFadeResolution": {
          "comment": "Resolution in texels below which shadows begin to be faded out. \n Once the shadow resolution reaches MinShadowResolution it will be faded out completely.\n A value of 0 defaults to ShadowFadeResolution in SystemSettings."
        },
        "ShadowFilterQuality": {
          "comment": "Quality of shadow buffer filtering to use on the light environment"
        },
        "ShadowInterpolationSpeed": {
          "comment": "Speed to interpolate the current shadow to the newly captured shadow. \n A value of .01 means the interpolation will be complete after the DLE moves 100 Unreal Units."
        },
        "State": {
          "comment": "The current state of the light environment."
        },
        "bCastShadows": {
          "comment": "Whether the light environment should cast shadows"
        },
        "bDynamic": {
          "comment": "Whether the light environment should be dynamically updated."
        },
        "bSynthesizeSHLight": {
          "comment": "Whether a SH light should be used to synthesize all light not accounted for by the synthesized directional light.\n If not, a sky light is used instead. Using an SH light gives higher quality secondary lighting, but at a steeper performance cost."
        },
        "bUseBooleanEnvironmentShadowing": {
          "comment": "Whether to use cheap on/off shadowing from the environment or allow a dynamic preshadow."
        },
        "LightingBoundsScale": {
          "comment": "Scales the bounds used for light environment calculations."
        },
        "NumVolumeVisibilitySamples": {
          "comment": "The number of visibility samples to use within the primitive's bounding volume."
        }
      },
      "functions": {
        "ResetEnvironment": {
          "comment": "Adds lights that affect this DLE to RelevantLightList."
        }
      }
    },
    "DynamicPhysicsVolume": {
      "comment": "This is a movable physics volume. It can be moved by matinee, being based on\n dynamic objects, etc.",
      "properties": {
        "bEnabled": {
          "comment": "Is the volume enabled by default?"
        }
      },
      "functions": {
        "PostBeginPlay": {
          "comment": "Overriden to set the default collision state."
        }
      }
    },
    "DynamicPylon": {
      "functions": {
        "FlushDynamicEdges": {
          "comment": "will remove all dynamic edges associated with this pylon"
        },
        "RebuildDynamicEdges": {
          "comment": "will wipe all dynamic edges for this pylon, and rebuild them from the currently position (use this sparingly, it's not cheap)\n good time to call this is after the pylon is finished moving, or comes to rest"
        }
      }
    },
    "DynamicSMActor": {
      "properties": {
        "bForceStaticDecals": {
          "comment": "used to replicate StaticMeshComponent.bForceStaticDecals"
        },
        "ReplicatedMaterial0": {
          "comment": "used to replicate the materials in indices 0 and 1"
        },
        "ReplicatedMaterial1": {
          "comment": "used to replicate the materials in indices 0 and 1"
        },
        "ReplicatedMesh": {
          "comment": "Used to replicate mesh to clients"
        },
        "ReplicatedMeshTranslation": {
          "comment": "Extra component properties to replicate"
        },
        "bPawnCanBaseOn": {
          "comment": "If a Pawn can be 'based' on this KActor. If not, they will 'bounce' off when they try to."
        },
        "bSafeBaseIfAsleep": {
          "comment": "Pawn can base on this KActor if it is asleep -- Pawn will disable KActor physics while based"
        }
      },
      "functions": {
        "Attach": {
          "comment": "If pawn is attached while asleep, turn off physics while pawn is on it"
        },
        "CanBasePawn": {
          "comment": "Query to see if this DynamicSMActor can base the given Pawn"
        },
        "Detach": {
          "comment": "If pawn is detached, turn back on physics (make sure no other pawns are based on it)"
        },
        "SetLightEnvironmentToNotBeDynamic": {
          "comment": "This will turn \"off\" the light environment so it will no longer update.\n This is useful for having a Timer call this once something has come to a stop and doesn't need 100% correct lighting."
        }
      }
    },
    "DynamicTriggerVolume": {
      "comment": "This is a movable trigger volume. It can be moved by matinee, being based on\n dynamic objects, etc.",
      "properties": {
        "bEnabled": {
          "comment": "Is the volume enabled by default?"
        }
      },
      "functions": {
        "PostBeginPlay": {
          "comment": "Overriden to set the default collision state."
        }
      }
    },
    "EdCoordSystem": {
      "properties": {
        "M": {
          "comment": "The matrix that defines this coordinate system."
        }
      }
    },
    "Emitter": {
      "properties": {
        "bCurrentlyActive": {
          "comment": "used to update status of toggleable level placed emitters on clients"
        }
      },
      "functions": {
        "HideSelf": {
          "comment": "Function used to have the emitter hide itself and put itself into stasis"
        },
        "OnParticleEventGenerator": {
          "comment": "Handling ParticleEventGenerator event from Kismet.\n - Does nothing... just here to stop Kismet from complaining"
        },
        "OnSetParticleSysParam": {
          "comment": "Kismet handler for setting particle instance parameters."
        },
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        },
        "SetTemplate": {
          "comment": "Called to reset the emitter actor in the level.\n Intended for use in editor only"
        }
      }
    },
    "EmitterCameraLensEffectBase": {
      "properties": {
        "BaseCamera": {
          "comment": "Camera this emitter is attached to, will be notified when emitter is destroyed"
        },
        "BaseFOV": {
          "comment": "In order to get the particle effect looking correct we need to have a base FOV which we just to move the particle closer/further from the camera"
        },
        "EmittersToTreatAsSame": {
          "comment": "If an emitter class in this array is currently playing, do not play this effect.\n Useful for preventing multiple similar or expensive camera effects from playing simultaneously."
        },
        "PS_CameraEffect": {
          "comment": "Particle System to use"
        },
        "PS_CameraEffectNonExtremeContent": {
          "comment": "The effect to use for non extreme content"
        },
        "bAllowMultipleInstances": {
          "comment": "TRUE if multiple instances of this emitter can exist simultaneously, FALSE otherwise."
        },
        "DistFromCamera": {
          "comment": "How far in front of the camera this emitter should live, assuming an FOV of 80 degrees. \n Note that the actual distance will be automatically adjusted to account for the actual FOV."
        }
      },
      "functions": {
        "ActivateLensEffect": {
          "comment": "This will actually activate the lens Effect. We want this separated from PostBeginPlay so we can cache these emitters"
        },
        "NotifyRetriggered": {
          "comment": "Called when this emitter is re-triggered, for bAllowMultipleInstances=FALSE emitters."
        },
        "RegisterCamera": {
          "comment": "Tell the emitter what camera it is attached to."
        },
        "UpdateLocation": {
          "comment": "Given updated camera information, adjust this effect to display appropriately."
        }
      }
    },
    "EmitterPool": {
      "properties": {
        "ActiveComponents": {
          "comment": "components currently active"
        },
        "bLogPoolOverflow": {
          "comment": "option to log out the names of all active effects when the pool overflows"
        },
        "FreeMatInstConsts": {
          "comment": "The free MaterialInstanceConstants used by emitters in this pool"
        },
        "FreeSMComponents": {
          "comment": "The free StaticMeshComponents used by emitters in this pool"
        },
        "IdealStaticMeshComponents": {
          "comment": "The ideal number of StaticMeshComponents and MaterialInstanceConstants.\n If their counts are greater than this for more than ReductionTime, then\n they will be chopped down to their respective settings."
        },
        "MaxActiveEffects": {
          "comment": "maximum allowed active components - if this is greater than 0 and is exceeded, the oldest active effect is taken"
        },
        "PoolComponents": {
          "comment": "components currently in the pool"
        },
        "PSCTemplate": {
          "comment": "template to base pool components off of - should not be used for effects or attached to anything"
        },
        "SMC_MIC_ReductionTime": {
          "comment": "The amount of time to allow the SMC and MIC arrays to be beyond their ideals."
        }
      },
      "functions": {
        "ClearPoolComponents": {
          "comment": "Cleans up the pool components, removing any unused",
          "params": {
            "bClearActive": "If TRUE, clear active as well as inactive pool components"
          }
        },
        "FreeMaterialInstanceConstants": {
          "comment": "internal - moves the MIConstants from given SMComponent to the pool free list"
        },
        "FreeStaticMeshComponents": {
          "comment": "internal - moves the SMComponents from given PSC to the pool free list"
        },
        "GetFreeMatInstConsts": {
          "comment": "internal - retrieves a MaterialInstanceConstant from the pool free list",
          "params": {
            "bCreateNewObject": "If TRUE, create an MIC w/ the pool as its outer"
          }
        },
        "GetFreeStaticMeshComponent": {
          "comment": "internal - retrieves a SMComponent from the pool free list",
          "params": {
            "bCreateNewObject": "If TRUE, create an SMC w/ the pool as its outer"
          }
        },
        "GetPooledComponent": {
          "comment": "internal - helper for spawning functions\n gets a component from the appropriate pool array (checks PerEmitterPools)\n includes creating a new one if necessary as well as taking one from the active list if the max number active has been exceeded"
        },
        "OnParticleSystemFinished": {
          "comment": "set to each pool component's finished delegate to return it to the pool\n for custom lifetime PSCs, must be called manually when done with the component"
        },
        "ReturnToPool": {
          "comment": "internal - detaches the given PSC and returns it to the pool"
        },
        "SpawnEmitter": {
          "comment": "plays the specified effect at the given location and rotation, taking a component from the pool or creating as necessary\n \n@note: the component is returned so the caller can perform any additional modifications (parameters, etc),\n but it shouldn't keep the reference around as the component will be returned to the pool as soon as the effect is complete",
          "params": {
            "EmitterTemplate": "particle system to create",
            "SpawnLocation": "location to place the effect in world space",
            "SpawnRotation": "(opt) - rotation to place the effect in world space",
            "AttachToActor": "(opt) - if specified, component will move along with this Actor",
            "InInstigator": "(opt) - if specified and the particle system is lit, the new component will only share particle light environments with other components with matching instigators",
            "MaxDLEPooledReuses": "(opt) - if specified, limits how many components can use the same particle light environment. This is effectively a tradeoff between performance and particle lighting update rate.",
            "bInheritScaleFromBase": "(opt) - if TRUE scale from the base actor will be applied"
          }
        },
        "SpawnEmitterCustomLifetime": {
          "comment": "spawns a pooled component that has a custom lifetime (controlled by the caller)\n the caller is responsible for attaching/detaching the component\n as well as calling our OnParticleSystemFinished() function when it is done with the component\n the pool may take the component back early - if it does, it will trigger the component's OnSystemFinished delegate\n so the caller can guarantee that it will be triggered",
          "params": {
            "EmitterTemplate": "particle system to create",
            "bSkipAutoActivate": "if TRUE, do not autoactivate the component when retrieving it from the pool"
          }
        },
        "SpawnEmitterMeshAttachment": {
          "comment": "spawns a particle system attached to a SkeletalMeshComponent instead of to another Actor or to nothing\n as with SpawnEmitter(), the caller should avoid persistent references to the returned component as it will\n get automatically reclaimed when the effect is complete\n \n@note: if the owning Actor is destroyed before the effect completes, the ParticleSystemComponent will end up\n being marked pending kill and therefore eventually destroyed as well. The pool handles this gracefully,\n although it's obviously suboptimal.",
          "params": {
            "EmitterTemplate": "particle system to create",
            "Mesh": "mesh component to attach to",
            "AttachPointName": "bone or socket to attach to",
            "bAttachToSocket": "(opt) - whether AttachPointName is a socket or bone name",
            "RelativeLoc": "(opt) - offset from bone location to place the effect (not used when attaching to socket)",
            "RelativeRot": "(opt) - offset from bone rotation to place the effect (not used when attaching to socket)"
          }
        }
      },
      "structs": {
        "EmitterBaseInfo": {
          "comment": "list of components that should be relative to an Actor"
        }
      }
    },
    "Engine": {
      "properties": {
        "AdditionalFonts": {
          "comment": "Any additional fonts that script may use without hard-referencing the font."
        },
        "ApexDamageParams": {
          "comment": "Optional damage mapping for Apex destructbile actors"
        },
        "bAllowMatureLanguage": {
          "comment": "whether mature language is allowed"
        },
        "bAreConstraintsDirty": {
          "comment": "Keeps track whether actors moved via PostEditMove and therefore constraint syncup should be performed."
        },
        "bCheckParticleRenderSize": {
          "comment": "If TRUE, then perform particle size checks in non FINAL_RELEASE builds."
        },
        "bCombineSimilarMappings": {
          "comment": "True if we should combine light/shadow maps together if they're very similar to one another"
        },
        "bCookSeparateSharedMPGameContent": {
          "comment": "if set, cook game classes into standalone packages (as defined in [Cooker.MPGameContentCookStandalone]) and load the appropriate\n one at game time depending on the gametype specified on the URL\n (the game class should then not be referenced in the maps themselves)"
        },
        "bDisableAILogging": {
          "comment": "determines whether AI logging should be processed or not"
        },
        "bDisablePhysXHardwareSupport": {
          "comment": "Do not use Ageia PhysX hardware"
        },
        "BeginUPTryCount": {
          "comment": "The number of times to attempt the Begin*UP call before assuming the GPU is hosed"
        },
        "bEmulateMobileRendering": {
          "comment": "If TRUE, the engine will attempt to emulate mobile rendering on PC when using D3D. Mostly, this means disabling gamma correction."
        },
        "bEnableColorClear": {
          "comment": "By default, each frame's initial scene color clear is disabled.\n This flag can be toggled at runtime to enable clearing for development."
        },
        "bEnableKismetLogging": {
          "comment": "whether kismet logging is enabled."
        },
        "bEnableOnScreenDebugMessages": {
          "comment": "If TRUE, then disable OnScreenDebug messages. Can be toggled in real-time."
        },
        "bEnableOnScreenDebugMessagesDisplay": {
          "comment": "If TRUE, then disable the display of OnScreenDebug messages (used when running)"
        },
        "bForceCPUSkinning": {
          "comment": "Force to CPU skinning only for skeletal mesh rendering"
        },
        "bHasPendingGlobalReattach": {
          "comment": "TRUE if the engine needs to perform a delayed global component reattach (really just for editor)"
        },
        "BoneWeightMaterial": {
          "comment": "Material used to render bone weights on skel meshes"
        },
        "bOnScreenKismetWarnings": {
          "comment": "whether to send Kismet warning messages to the screen (via PlayerController::ClientMessage())"
        },
        "bPauseOnLossOfFocus": {
          "comment": "Whether to pause the game if focus is lost."
        },
        "bRenderLightMapDensityGrayscale": {
          "comment": "If TRUE, then render grayscale density."
        },
        "bRenderTerrainCollisionAsOverlay": {
          "comment": "Terrain collision viewing - If TRUE, overlay collion level else render it and overlay terrain."
        },
        "bShouldGenerateSimpleLightmaps": {
          "comment": "Whether or not the simple lightmaps should be generated during lighting rebuilds."
        },
        "bSmoothFrameRate": {
          "comment": "Whether to enable framerate smoothing."
        },
        "bSuppressMapWarnings": {
          "comment": "If TRUE, then skip drawing map warnings on screen even in non FINAL_RELEASE builds"
        },
        "bTriggerTextureStreaming": {
          "comment": "Triggers a call to GStreamingManager->StreamAllResources(TRUE) the next Tick, to stream all textures."
        },
        "BuildingQuadStaticMesh": {
          "comment": "Mesh used when we need a quad"
        },
        "bUsePostProcessEffects": {
          "comment": "Whether to use post processing effects or not"
        },
        "CameraRotationThreshold": {
          "comment": "camera rotation (deg) beyond which occlusion queries are ignored from previous frame (because they are likely not valid)"
        },
        "CameraTranslationThreshold": {
          "comment": "camera movement beyond which occlusion queries are ignored from previous frame (because they are likely not valid)"
        },
        "Client": {
          "comment": "Abstract interface to platform-specific subsystems"
        },
        "ConsoleClass": {
          "comment": "The class to use for the game console."
        },
        "CrossMaterial": {
          "comment": "Material used for drawing a cross mark."
        },
        "DataStoreClientClass": {
          "comment": "The class to use for managing the global data stores"
        },
        "DefaultDecalMaterial": {
          "comment": "The decal material used for fallback case of decals"
        },
        "DefaultFogVolumeMaterial": {
          "comment": "The default fog volume material"
        },
        "DefaultHoveredMaterialColor": {
          "comment": "Default color of hovered objects in the level viewport (additive)"
        },
        "DefaultMaterial": {
          "comment": "The material used when no material is explicitly applied."
        },
        "DefaultPhysMaterial": {
          "comment": "PhysicalMaterial to use if none is defined for a particular object."
        },
        "DefaultPostProcess": {
          "comment": "Default engine post process chain used for the game and main editor view if none is specified in the WorldInfo"
        },
        "DefaultSelectedMaterialColor": {
          "comment": "Default color of selected objects in the level viewport (additive)"
        },
        "DefaultSound": {
          "comment": "White noise sound"
        },
        "DefaultTexture": {
          "comment": "A global default texture."
        },
        "DefaultUICaretMaterial": {
          "comment": "Material used for drawing meshes when their collision is missing."
        },
        "DefaultUIScenePostProcess": {
          "comment": "post process chain used for rendering the UI"
        },
        "DeferredCommands": {
          "comment": "Array of deferred command strings/ execs that get executed at the end of the frame"
        },
        "DynamicCoverMeshComponentName": {
          "comment": "Overridable class for cover mesh rendering in-game, used to get around the editoronly restrictions needed by the base CoverMeshComponent"
        },
        "EditorBrushMaterial": {
          "comment": "A material used to render the sides of the builder brush/volumes/etc."
        },
        "EmissiveTexturedMaterial": {
          "comment": "A textured material with an instance parameter for the texture."
        },
        "FacebookIntegration": {
          "comment": "Object used to interface with Facebook"
        },
        "FluidSimulationTimeLimit": {
          "comment": "Time limit (in milliseconds) for a fluid simulation update, to avoid spiraling into a bad\n feedback-loop with slower and slower framerate. This value is doubled in debug builds."
        },
        "ForcePowerOfTwoProcBuildingLODTextures": {
          "comment": "Whether to force use of power-of-two LOD textures (uses more memory, but may have better performance)"
        },
        "GamePlayers": {
          "comment": "Viewports for all players in all game instances (all PIE windows, for example)"
        },
        "GameViewport": {
          "comment": "the viewport representing the current game instance"
        },
        "GameViewportClientClass": {
          "comment": "The class to use for the game viewport client."
        },
        "GeomMaterial": {
          "comment": "A translucent material used to render things in geometry mode."
        },
        "HACK_EnableDMC": {
          "comment": "Enable experimental DMC feature"
        },
        "HACK_UseTickFrequency": {
          "comment": "Whether or not to use the TickFrequency code path (c.f. AActor::Tick()"
        },
        "HeatmapMaterial": {
          "comment": "Material used to render game stat heatmaps."
        },
        "IdealLightMapDensity": {
          "comment": "Ideal lightmap density value for coloring."
        },
        "IgnoreSimulatedFuncWarnings": {
          "comment": "If DevAbsorbFuncs logging is unsuppressed and _DEBUG is defined in native, functions listed in this array will not throw a warning when they are absorbed for not being simulated on clients. Useful for functions like Tick, where this behaviour is intentional"
        },
        "ImageGrainNoiseTexture": {
          "comment": "Texture used to get random image grain values for post processing"
        },
        "ImageReflectionTextureSize": {
          "comment": "Size of the texture generated by ImageReflectionSceneCapture actors."
        },
        "LevelColorationLitMaterial": {
          "comment": "Material used for visualizing level membership in lit viewport modes."
        },
        "LevelColorationUnlitMaterial": {
          "comment": "Material used for visualizing level membership in unlit viewport modes."
        },
        "LightComplexityColors": {
          "comment": "The colors used to render light complexity."
        },
        "LightingTexelDensityMaterial": {
          "comment": "Material used for visualizing lighting only w/ lightmap texel density."
        },
        "LightMapDensityNormal": {
          "comment": "Texture used to display LightMapDensity"
        },
        "LightMapDensitySelectedColor": {
          "comment": "The color to render selected objects in for LightMap Density view mode."
        },
        "LightMapDensityTexture": {
          "comment": "Texture used to display LightMapDensity"
        },
        "LightMapDensityVertexMappedColor": {
          "comment": "The color to render vertex mapped objects in for LightMap Density view mode."
        },
        "LocalPlayerClass": {
          "comment": "The class to use for local players."
        },
        "MaxFluidNumVerts": {
          "comment": "The most vertices a fluid surface can have. The number of verts is clamped to avoid running out of memory and exposing driver bugs."
        },
        "MaxLightMapDensity": {
          "comment": "Maximum lightmap density value for coloring."
        },
        "MaxOcclusionPixelsFraction": {
          "comment": "Max screen pixel fraction where retesting when unoccluded is worth the GPU time."
        },
        "MaxParticleResize": {
          "comment": "The maximum allowed size to a ParticleEmitterInstance::Resize call.\n If larger, the function will return without resizing."
        },
        "MaxParticleResizeWarn": {
          "comment": "If the resize request is larger than this, spew out a warning to the log"
        },
        "MaxParticleVertexMemory": {
          "comment": "The maximum amount of memory any single emitter is allowed to take for its vertices"
        },
        "MaxPixelShaderAdditiveComplexityCount": {
          "comment": "Complexity limits for the various complexity viewmode combinations.\n These limits are used to map instruction counts to ShaderComplexityColors."
        },
        "MaxProcBuildingLODColorTextureSize": {
          "comment": "Maximum size of a building LOD color texture"
        },
        "MaxProcBuildingLODLightingTextureSize": {
          "comment": "Maximum size of a building LOD lighting texture"
        },
        "MaxRMSDForCombiningMappings": {
          "comment": "Maximum root mean square deviation of the image difference allowed for mappings to be combined. Requires bCombineSimilarLightAndShadowMappings to be enabled."
        },
        "MaxSmoothedFrameRate": {
          "comment": "Maximum framerate to smooth. Code will try to not go over via waiting."
        },
        "MaxTrackedOcclusionIncrement": {
          "comment": "The largest step-size allowed for lens flare occlusion results\n before using the incremental step method."
        },
        "MeshLODRange": {
          "comment": "Level of detail range control for meshes"
        },
        "MinLightMapDensity": {
          "comment": "Minimum lightmap density value for coloring."
        },
        "MinSmoothedFrameRate": {
          "comment": "Minimum framerate smoothing will kick in."
        },
        "MinTextureDensity": {
          "comment": "Range for the texture density viewmode."
        },
        "MobileMaterialEmulator": {
          "comment": "Pointer to a support class to handle mobile material emulation (created on demand)"
        },
        "NetClientTicksPerSecond": {
          "comment": "Number of times to tick each client per second"
        },
        "OnlineSubsystemClass": {
          "comment": "OnlineSubsystem class to use for netplay"
        },
        "PercentUnoccludedRequeries": {
          "comment": "The percent of previously unoccluded primitives which are requeried every frame."
        },
        "PrimitiveProbablyVisibleTime": {
          "comment": "The amount of time a primitive is considered to be probably visible after it was last actually visible."
        },
        "ProcBuildingLODColorTexelsPerWorldUnit": {
          "comment": "Roughly how many texels per world unit when generating a building LOD color texture"
        },
        "ProcBuildingLODLightingTexelsPerWorldUnit": {
          "comment": "Roughly how many texels per world unit when generating a building LOD lighting texture"
        },
        "ProcBuildingSimpleMaterial": {
          "comment": "Material used to render the low detail version of procedural buildings"
        },
        "RandomAngleTexture": {
          "comment": "Texture used to get random angles per-pixel by the Branching PCF implementation"
        },
        "RandomMirrorDiscTexture": {
          "comment": "Texture used to get random rotation per-pixel"
        },
        "RandomNormalTexture": {
          "comment": "Texture used to get random normals per-pixel"
        },
        "RemoteControlExec": {
          "comment": "Entry point for RemoteControl, the in-game UI for the exec system."
        },
        "RemoveSurfaceMaterial": {
          "comment": "Material used to indicate that the associated BSP surface should be removed."
        },
        "RenderLightMapDensityColorScale": {
          "comment": "The scale factor when rendering color density."
        },
        "RenderLightMapDensityGrayscaleScale": {
          "comment": "The scale factor when rendering grayscale density."
        },
        "SceneCaptureCubeActorMaterial": {
          "comment": "Material used for visualizing the cube map scene captures on a mesh"
        },
        "SceneCaptureReflectActorMaterial": {
          "comment": "Material used for visualizing the reflection scene captures on a surface"
        },
        "ScoutClassName": {
          "comment": "Class name of the scout to use for path building"
        },
        "ScreenDoorNoiseTexture": {
          "comment": "Texture used to get random opacity values per-pixel for screen-door fading"
        },
        "ScreenSaverInhibitor": {
          "comment": "Thread preventing screen saver from kicking. Suspend most of the time."
        },
        "ScreenSaverInhibitorSemaphore": {
          "comment": "Semaphore to control screen saver inhibitor thread access."
        },
        "SelectedMaterialColor": {
          "comment": "Color of selected objects in the level viewport (additive)"
        },
        "ShadedLevelColorationLitMaterial": {
          "comment": "Material used for visualizing level membership in lit viewport modes. Uses shading to show axis directions."
        },
        "ShadedLevelColorationUnlitMaterial": {
          "comment": "Material used for visualizing level membership in unlit viewport modes. Uses shading to show axis directions."
        },
        "ShaderComplexityColors": {
          "comment": "The colors used to render shader complexity."
        },
        "TangentColorMaterial": {
          "comment": "Material used to render tangents on skel meshes"
        },
        "TerrainErrorMaterial": {
          "comment": "The material used when terrain compilation is too complex."
        },
        "TerrainTessellationCheckCount": {
          "comment": "This is the number of frames that are used between terrain tessellation re-calculations"
        },
        "TerrainTessellationCheckDistance": {
          "comment": "The radius from the view origin that terrain tessellation checks should be performed.\n If 0.0, every component will be checked for tessellation changes each frame."
        },
        "ThumbnailMaterialPostProcess": {
          "comment": "post process chain used for material thumbnails"
        },
        "ThumbnailParticleSystemPostProcess": {
          "comment": "post process chain used for particle system thumbnails"
        },
        "ThumbnailSkeletalMeshPostProcess": {
          "comment": "post process chain used for skeletal mesh thumbnails"
        },
        "TickMaterial": {
          "comment": "Material used for drawing a tick mark."
        },
        "TrackedOcclusionStepSize": {
          "comment": "The incremental step size for the above."
        },
        "TransitionDescription": {
          "comment": "The current transition description text."
        },
        "TransitionGameType": {
          "comment": "The gametype for the destination map"
        },
        "TransitionType": {
          "comment": "The current transition type."
        },
        "UnselectedMaterialColor": {
          "comment": "Color of unselected objects in the level viewport (additive)"
        },
        "UseProcBuildingLODTextureCropping": {
          "comment": "Whether to crop building LOD textures to rectangular textures to reduce wasted memory"
        },
        "VertexColorMaterial": {
          "comment": "Material that renders vertex colour as emissive."
        },
        "VertexColorViewModeMaterial_AlphaAsColor": {
          "comment": "Material for visualizing vertex colors on meshes in the scene (alpha channel as color)"
        },
        "VertexColorViewModeMaterial_BlueOnly": {
          "comment": "Material for visualizing vertex colors on meshes in the scene (blue only)"
        },
        "VertexColorViewModeMaterial_ColorOnly": {
          "comment": "Material for visualizing vertex colors on meshes in the scene (color only, no alpha)"
        },
        "VertexColorViewModeMaterial_GreenOnly": {
          "comment": "Material for visualizing vertex colors on meshes in the scene (green only)"
        },
        "VertexColorViewModeMaterial_RedOnly": {
          "comment": "Material for visualizing vertex colors on meshes in the scene (red only)"
        },
        "WeightMapPlaceholderTexture": {
          "comment": "Texture used as a placeholder for terrain weight-maps to give the material the correct texture format."
        },
        "WireframeMaterial": {
          "comment": "The material used to render wireframe meshes."
        },
        "bForceStaticTerrain": {
          "comment": "Flag for forcing terrain to be 'static' (MinTessellationLevel = MaxTesselationLevel)\n Game time only..."
        },
        "bSubtitlesEnabled": {
          "comment": "Flag for completely disabling subtitles for localized sounds."
        },
        "bSubtitlesForcedOff": {
          "comment": "Flag for forcibly disabling subtitles even if you try to turn them back on they will be off"
        },
        "bUseBackgroundLevelStreaming": {
          "comment": "Whether to allow background level streaming."
        },
        "StreamingDistanceFactor": {
          "comment": "Fudge factor for tweaking the distance based miplevel determination"
        },
        "TimeBetweenPurgingPendingKillObjects": {
          "comment": "Time in seconds (game time) we should wait between purging object references to objects that are pending kill"
        }
      },
      "functions": {
        "AddOverlay": {
          "comment": "Adds a text overlay to the movie",
          "params": {
            "Font": "Font to use to display (must be in the root set so this will work during loads)",
            "Text": "Text to display",
            "X": "X location in resolution-independent coordinates (ignored if centered)",
            "Y": "Y location in resolution-independent coordinates",
            "ScaleX": "Text horizontal scale",
            "ScaleY": "Text vertical scale",
            "bIsCentered": "TRUE if the text should be centered"
          }
        },
        "AddOverlayWrapped": {
          "comment": "Adds a wrapped text overlay to the movie",
          "params": {
            "Font": "Font to use to display (must be in the root set so this will work during loads)",
            "Text": "Text to display",
            "X": "X location in resolution-independent coordinates (ignored if centered)",
            "Y": "Y location in resolution-independent coordinates",
            "ScaleX": "Text horizontal scale",
            "ScaleY": "Text vertical scale",
            "WrapWidth": "Number of pixels before text should wrap"
          }
        },
        "AddTextureStreamingSlaveLoc": {
          "comment": "adds a world location as a secondary view location for purposes of texture streaming\n lasts one frame",
          "params": {
            "InLoc": "location to add to texture streaming for this frame"
          }
        },
        "BasicLoadObject": {
          "comment": "Loads an object from a file (saved with the BasicSaveObject function). It should already be\n allocated just like the original object was allocated",
          "params": {
            "Obj": "The object to serialize",
            "Pathname": "The path to the file to read and create the object from",
            "bIsSaveGame": "If TRUE, FILEREAD_SaveGame will be used to create the file reader",
            "Version": "A version number to match with the version saved in the archive, so that we can safely fail when loading old versioned files"
          }
        },
        "BasicSaveObject": {
          "comment": "Serializes an object to a file (object pointers to non-always loaded objects are not supported)",
          "params": {
            "Obj": "The object to serialize",
            "Pathname": "The path to the file to save",
            "bIsSaveGame": "If TRUE, FILEWRITE_SaveGame will be used to create the file writer",
            "Version": "A version number to save with the archive, so that we can safely fail when loading old versioned files"
          }
        },
        "GetAdditionalFont": {
          "comment": "Returns the specified additional font.",
          "params": {
            "AdditionalFontIndex": "Index into the AddtionalFonts array."
          }
        },
        "GetBuildDate": {
          "comment": "Returns version info from the engine"
        },
        "GetCurrentWorldInfo": {
          "comment": "Returns a pointer to the current world."
        },
        "GetEngine": {
          "comment": "returns GEngine"
        },
        "GetLargeFont": {
          "comment": "Returns the engine's default large font"
        },
        "GetMediumFont": {
          "comment": "Returns the engine's default medium font"
        },
        "GetSmallFont": {
          "comment": "Returns the engine's default small font"
        },
        "GetSubtitleFont": {
          "comment": "Returns the engine's default subtitle font"
        },
        "GetTinyFont": {
          "comment": "Returns the engine's default tiny font"
        },
        "GetWorldPostProcessChain": {
          "comment": "Returns the post process chain to be used with the world."
        },
        "PlayLoadMapMovie": {
          "comment": "Play one of the LoadMap loading movies as configured by ini file"
        },
        "RemoveAllOverlays": {
          "comment": "Removes all overlays from displaying"
        },
        "StopMovie": {
          "comment": "Stops the current movie",
          "params": {
            "bDelayStopUntilGameHasRendered": "If TRUE, the engine will delay stopping the movie until after the game has rendered at least one frame"
          }
        }
      },
      "structs": {
        "DropNoteInfo": {
          "comment": "Info about one note dropped in the map during PIE.",
          "properties": {
            "Comment": {
              "comment": "Text to assign to Note actor in edited level."
            },
            "Location": {
              "comment": "Location to create Note actor in edited level."
            },
            "Rotation": {
              "comment": "Rotation to create Note actor in edited level."
            }
          }
        }
      }
    },
    "EngineBaseTypes": {
      "comment": "This file is for shared structs and enums that need to be declared before the rest of Engine.\n The typical use case is for structs used in the renderer and also in script code.",
      "structs": {
        "RenderingPerformanceOverrides": {
          "comment": "Overrides for rendering settings that can be used to increase performance."
        }
      }
    },
    "EngineTypes": {
      "comment": "This will hold all of our enums and types and such that we need to\n use in multiple files where the enum can'y be mapped to a specific file.",
      "structs": {
        "DominantShadowInfo": {
          "properties": {
            "LightSpaceImportanceBounds": {
              "comment": "Bounding box of the area that the DominantLightShadowMap entries are stored for, in the coordinate space defined by WorldToLight."
            },
            "LightToWorld": {
              "comment": "Inverse of WorldToLight"
            },
            "ShadowMapSizeX": {
              "comment": "Dimensions of DominantLightShadowMap"
            },
            "WorldToLight": {
              "comment": "Transform from world space to the coordinate space that the DominantLightShadowMap entries are stored in."
            }
          }
        },
        "LightmassDebugOptions": {
          "comment": "Debug options for Lightmass",
          "properties": {
            "bColorBordersGreen": {
              "comment": "If TRUE, a green border will be placed around the edges of mappings"
            },
            "bColorByExecutionTime": {
              "comment": "If TRUE, Lightmass will overwrite lightmap data with a shade of red relating to\n how long it took to calculate the mapping (Red = Time / ExecutionTimeDivisor)"
            }
          }
        },
        "LightmassDirectionalLightSettings": {
          "comment": "Direcitonal light settings for Lightmass",
          "properties": {
            "LightSourceAngle": {
              "comment": "Angle that the directional light's emissive surface extends relative to a receiver, affects penumbra sizes."
            }
          }
        },
        "LightmassLightSettings": {
          "comment": "Per-light settings for Lightmass",
          "properties": {
            "IndirectLightingSaturation<UIMin=0.0|UIMax=4.0>": {
              "comment": "0 will be completely desaturated, 1 will be unchanged"
            },
            "IndirectLightingScale<UIMin=0.0|UIMax=4.0>": {
              "comment": "Scale factor for the indirect lighting"
            },
            "ShadowExponent<UIMin=0.1|UIMax=4.0>": {
              "comment": "Controls the falloff of shadow penumbras"
            }
          }
        },
        "LightmassPointLightSettings": {
          "comment": "Point/spot settings for Lightmass",
          "properties": {
            "LightSourceRadius<UIMin=8.0|UIMax=1024.0>": {
              "comment": "The radius of the light's emissive surface, not the light's influence."
            }
          }
        },
        "LightmassPrimitiveSettings": {
          "comment": "Per-object settings for Lightmass",
          "properties": {
            "bShadowIndirectOnly": {
              "comment": "If TRUE, this object will only shadow indirect lighting."
            },
            "bUseEmissiveForStaticLighting": {
              "comment": "If TRUE, allow using the emissive for static lighting."
            },
            "bUseTwoSidedLighting": {
              "comment": "If TRUE, this object will be lit as if it receives light from both sides of its polygons."
            },
            "DiffuseBoost": {
              "comment": "Scales the diffuse contribution of all materials applied to this object."
            },
            "EmissiveBoost": {
              "comment": "Scales the emissive contribution of all materials applied to this object."
            },
            "EmissiveLightExplicitInfluenceRadius": {
              "comment": "Direct lighting influence radius.\n The default is 0, which means the influence radius should be automatically generated based on the emissive light brightness.\n Values greater than 0 override the automatic method."
            },
            "EmissiveLightFalloffExponent": {
              "comment": "Direct lighting falloff exponent for mesh area lights created from emissive areas on this primitive."
            },
            "FullyOccludedSamplesFraction": {
              "comment": "Fraction of samples taken that must be occluded in order to reach full occlusion."
            },
            "SpecularBoost": {
              "comment": "Scales the specular contribution of all materials applied to this object."
            }
          }
        },
        "LocalizedSubtitle": {
          "comment": "A subtitle localized to a specific language.",
          "properties": {
            "bManualWordWrap": {
              "comment": "TRUE if the subtitles have been split manually."
            },
            "bMature": {
              "comment": "TRUE if this sound is considered to contain mature content."
            },
            "LanguageExt": {
              "comment": "The 3-letter language for this subtitle"
            },
            "Subtitles": {
              "comment": "Subtitle cues. If empty, use SoundNodeWave's SpokenText as the subtitle. Will often be empty,\n as the contents of the subtitle is commonly identical to what is spoken."
            }
          }
        },
        "MaterialReferenceList": {
          "comment": "used by matinee material parameter tracks to hold material references to modify"
        },
        "PostProcessMaterialRef": {
          "comment": "reference to a specific material in a MaterialEffect"
        },
        "PrimitiveMaterialRef": {
          "comment": "reference to a specific material in a PrimitiveComponent"
        },
        "RootMotionCurve": {
          "comment": "Contains precomputed curve of root motion for a particular animation",
          "properties": {
            "AnimName": {
              "comment": "Name of the animation this curve is associated with"
            },
            "Curve": {
              "comment": "List of vectors offset from the start of the curve"
            },
            "MaxCurveTime": {
              "comment": "The max input value of the curve"
            }
          }
        },
        "SubtitleCue": {
          "comment": "A line of subtitle text and the time at which it should be displayed.",
          "properties": {
            "Text": {
              "comment": "The text too appear in the subtitle."
            },
            "Time": {
              "comment": "The time at which the subtitle is to be displayed, in seconds relative to the beginning of the line."
            }
          }
        },
        "SwarmDebugOptions": {
          "comment": "Debug options for Swarm",
          "properties": {
            "bDistributionEnabled": {
              "comment": "If TRUE, Swarm will distribute jobs.\n If FALSE, only the local machine will execute the jobs."
            },
            "bForceContentExport": {
              "comment": "If TRUE, Swarm will force content to re-export rather than using the cached version.\n If FALSE, Swarm will attempt to use the cached version."
            }
          }
        }
      }
    },
    "EnvironmentVolume": {
      "comment": "Used to define certain gameplay areas, and has optional support for interacting with the NavMesh\n (To block some types of enemies from pathing through it).",
      "properties": {
        "bSplitNavMesh": {
          "comment": "Keep track is NavMesh is split by this volume to affect AI pathing."
        }
      },
      "functions": {
        "SetSplitNavMesh": {
          "comment": "Should this volume register and split the NavMesh to affect AI pathing?"
        }
      }
    },
    "ExponentialHeightFog": {
      "properties": {
        "bEnabled": {
          "comment": "replicated copy of ExponentialHeightFogComponent's bEnabled property"
        }
      }
    },
    "ExponentialHeightFogComponent": {
      "properties": {
        "FogHeight": {
          "comment": "z-height for the fog plane - updated by the owning actor"
        },
        "bEnabled": {
          "comment": "True if the fog is enabled."
        },
        "FogDensity": {
          "comment": "Global density factor."
        },
        "FogHeightFalloff": {
          "comment": "Height density factor, controls how the density increases as height decreases. \n Smaller values make the visible transition larger."
        },
        "FogMaxOpacity": {
          "comment": "Maximum opacity of the fog. \n A value of 1 means the fog can become fully opaque at a distance and replace scene color completely,\n A value of 0 means the fog color will not be factored in at all."
        },
        "LightInscatteringBrightness": {
          "comment": "Scales LightInscatteringColor."
        },
        "LightInscatteringColor": {
          "comment": "Fog Color used for the direction of the dominant directional light."
        },
        "LightTerminatorAngle": {
          "comment": "LightInscatteringColor is used in the direction of the dominant directional light, and OppositeLightColor is used in the opposite direction.\n LightTerminatorAngle is the angle in degrees from the dominant directional light that an even amount of OppositeLightColor and LightInscatteringColor are used for the final fog color.\n If there is no dominant directional light enabled, LightInscatteringColor will correspond to up in world space."
        },
        "OppositeLightBrightness": {
          "comment": "Scales OppositeLightColor."
        },
        "OppositeLightColor": {
          "comment": "Fog Color used for the opposite direction from the dominant directional light."
        },
        "StartDistance": {
          "comment": "Distance from the camera that the fog will start, in world units."
        }
      },
      "functions": {
        "SetEnabled": {
          "comment": "Changes the enabled state of the height fog component.",
          "params": {
            "bSetEnabled": "The new value for bEnabled."
          }
        }
      }
    },
    "FacebookIntegration": {
      "comment": "This is the base class for Facebook integration (each platform has a subclass",
      "properties": {
        "AccessToken": {
          "comment": "Access token as retrieved from FB"
        },
        "AppID": {
          "comment": "The application ID to link to"
        },
        "AuthorizationDelegates": {
          "comment": "Delegates to call when all async initialization and authorization has completed"
        },
        "FacebookRequestCompleteDelegates": {
          "comment": "Delegates to call when a facebook request has completed"
        },
        "UserId": {
          "comment": "Id of the current user"
        },
        "Username": {
          "comment": "Username of the current user"
        },
        "WebRequestCompleteDelegates": {
          "comment": "Delegates to call when a web request has completed"
        }
      },
      "functions": {
        "AddAuthorizationCompleteDelegate": {
          "comment": "Adds a delegate to the list of listeners",
          "params": {
            "InDelegate": "the delegate to use for notifications"
          }
        },
        "AddFacebookRequestCompleteDelegate": {
          "comment": "Adds a delegate to the list of listeners",
          "params": {
            "InDelegate": "the delegate to use for notifications"
          }
        },
        "AddWebRequestCompleteDelegate": {
          "comment": "Adds a delegate to the list of listeners",
          "params": {
            "InDelegate": "the delegate to use for notifications"
          }
        },
        "Authorize": {
          "comment": "Starts the process of allowing the app to use Facebook"
        },
        "ClearAuthorizationCompleteDelegate": {
          "comment": "Removes a delegate from the list of listeners",
          "params": {
            "InDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFacebookRequestCompleteDelegate": {
          "comment": "Removes a delegate from the list of listeners",
          "params": {
            "InDelegate": "the delegate to use for notifications"
          }
        },
        "ClearWebRequestCompleteDelegate": {
          "comment": "Removes a delegate from the list of listeners",
          "params": {
            "InDelegate": "the delegate to use for notifications"
          }
        },
        "Disconnect": {
          "comment": "Call this to disconnect from Facebook. Next time authorization happens, the auth webpage\n will be shown again"
        },
        "FacebookRequest": {
          "comment": "Kicks off a Facebook GraphAPI request (response will come via delegate)",
          "params": {
            "GraphRequest": "The request to make (like \"me/friends\")"
          }
        },
        "Init": {
          "comment": "Perform any needed initialization"
        },
        "WebRequest": {
          "comment": "Kicks off a generic web request (response will come via delegate call)",
          "params": {
            "URL": "The URL for the request, can be http or https (if the current platform supports sending https)",
            "POSTPayload": "If specified, the request will use the POST method, and the given string will be the payload (as UTF8)"
          }
        }
      }
    },
    "FaceFXAnimSet": {
      "properties": {
        "InternalFaceFXAnimSet": {
          "comment": "Internal use. FaceFX representation of this AnimSet."
        },
        "NumLoadErrors": {
          "comment": "Internal use. The number of errors generated during load."
        },
        "RawFaceFXAnimSetBytes": {
          "comment": "Internal use. Raw bytes of the FaceFX AnimSet. \n This only stays loaded in the editor."
        },
        "RawFaceFXMiniSessionBytes": {
          "comment": "Internal use. Raw bytes of the FaceFX Studio mini session for this AnimSet. \n This only stays loaded in the editor."
        },
        "ReferencedSoundCues": {
          "comment": "Array of SoundCue objects that the FaceFXAnimSet references."
        },
        "DefaultFaceFXAsset": {
          "comment": "Default FaceFXAsset to use when editing this FaceFXAnimSet etc. \n Is the one that was used as the basis for creating this AnimSet."
        }
      }
    },
    "FaceFXAsset": {
      "properties": {
        "DefaultSkelMesh": {
          "comment": "Default skeletal mesh to use when previewing this FaceFXAsset etc. \n Is the one that was used as the basis for creating this Asset."
        },
        "FaceFXActor": {
          "comment": "Internal use. FaceFX representation of this asset."
        },
        "MountedFaceFXAnimSets": {
          "comment": "Array of currently mounted FaceFXAnimSets.\n We only track this if GIsEditor!"
        },
        "NumLoadErrors": {
          "comment": "Internal use. The number of errors generated during load."
        },
        "RawFaceFXActorBytes": {
          "comment": "Internal use. Raw bytes of the FaceFX Actor for this asset. \n This only stays loaded in the editor."
        },
        "RawFaceFXSessionBytes": {
          "comment": "Internal use. Raw bytes of the FaceFX Studio session for this asset. \n This only stays loaded in the editor."
        },
        "ReferencedSoundCues": {
          "comment": "Array of SoundCue objects that the FaceFXAsset references."
        },
        "PreviewMorphSets": {
          "comment": "MorphTargetSets used when previewing this FaceFXAsset in FaceFX Studio.\n Note that these are only valid in the editor."
        }
      },
      "functions": {
        "MountFaceFXAnimSet": {
          "comment": "Mounts the specified FaceFXAnimSet into this FaceFXAsset."
        },
        "UnmountFaceFXAnimSet": {
          "comment": "Internal use. Unmounts the specified FaceFXAnimSet from this FaceFXAsset."
        }
      }
    },
    "FileLog": {
      "functions": {
        "CloseLog": {
          "comment": "Closes the log file."
        },
        "OpenLog": {
          "comment": "Opens the actual file using the specified name.",
          "params": {
            "LogFilename": "name of file to open",
            "extension": "optional file extension to use, defaults to\n .txt if none is specified",
            "bUnique": "Makes sure the file is unique"
          }
        }
      }
    },
    "FileWriter": {
      "comment": "This is a simple class that allows for secure writing of output files from within Script. The directory to which it writes\n files is determined by the file type member variable.",
      "properties": {
        "ArchivePtr": {
          "comment": "Internal FArchive pointer"
        },
        "bFlushEachWrite": {
          "comment": "Whether we should flush to disk every time something is written.\n if false, only flush when the memory buffer is full or when the file is closed"
        },
        "bWantsAsyncWrites": {
          "comment": "Whether to use async writes (if available) or not. Overrides bFlushEachWrite"
        },
        "Filename": {
          "comment": "File name, created via OpenFile()"
        },
        "FileType": {
          "comment": "Holds the file type for this file."
        }
      },
      "functions": {
        "CloseFile": {
          "comment": "Closes the log file."
        },
        "Destroyed": {
          "comment": "Overridden to automatically close the logfile on destruction."
        },
        "Logf": {
          "comment": "Logs the given string to the log file.",
          "params": {
            "logString": "string to dump"
          }
        },
        "OpenFile": {
          "comment": "Opens the actual file using the specified name.",
          "params": {
            "InFilename": "name of file to open",
            "InFileType": "the type of file being written",
            "InExtension": "optional file extension to use, defaults to .txt if none is specified",
            "bUnique": "whether to make unique or not",
            "bIncludeTimeStamp": "whether to include timestamps or not"
          }
        }
      }
    },
    "FluidInfluenceActor": {
      "properties": {
        "bActive": {
          "comment": "replicated flags to pass to component"
        },
        "bToggled": {
          "comment": "replicated flags to pass to component"
        },
        "FlowDirection": {
          "comment": "Direction of a flow influence."
        }
      },
      "functions": {
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        }
      }
    },
    "FluidInfluenceComponent": {
      "properties": {
        "bIsToggleTriggered": {
          "comment": "The \"toggle\" Kismet event will set this to true, which will enable/disable the influence for 1 tick, then automatically go back to its previous state."
        },
        "CurrentFluidActor": {
          "comment": "The currently affected FluidSurfaceActor."
        },
        "FlowFrequency": {
          "comment": "Frequency of up/down and sideways motion of each ripple."
        },
        "FlowNumRipples": {
          "comment": "Number of flow ripples generated on the fluid surface."
        },
        "FlowSideMotionRadius": {
          "comment": "How much each flow ripple should oscillate sideways while moving down that flow direction."
        },
        "FlowSpeed": {
          "comment": "How fast the flow moves thru the fluid, in world space units per second."
        },
        "FlowStrength": {
          "comment": "Strength of each wave ripple."
        },
        "FlowWaveRadius": {
          "comment": "Radius of each flow wave, in world space units."
        },
        "bActive": {
          "comment": "Whether the effect is active and applying forces to the fluid."
        },
        "FluidActor": {
          "comment": "If a specific FluidSurfaceActor is set, this influence won't automatically affect any other fluid and MaxDistance is ignored."
        },
        "InfluenceType": {
          "comment": "Type of fluid influence (a flow of waves, raindrops, or a single wave)."
        },
        "MaxDistance": {
          "comment": "Maximum distance (from the fluid plane) from where this influence will affect a fluid."
        },
        "RaindropAreaRadius": {
          "comment": "Radius of the area where raindrops fall."
        },
        "RaindropFillEntireFluid": {
          "comment": "Whether raindrops should fill the entire fluid (TRUE), or just in a circular area around the influenceactor (FALSE)."
        },
        "RaindropRadius": {
          "comment": "Radius of each raindrop, in world space units."
        },
        "RaindropRate": {
          "comment": "Number of raindrops per second."
        },
        "RaindropStrength": {
          "comment": "Strength of each raindrop."
        },
        "SphereInnerRadius": {
          "comment": "Inner radius of the 3D sphere. While inside this radius, the force will decrease as it moves closer to the fluid plane."
        },
        "SphereOuterRadius": {
          "comment": "Outer radius of the 3D sphere. While inside this radius, the force will increase as it moves closer to the fluid plane."
        },
        "SphereStrength": {
          "comment": "Strength of the force applied by the sphere."
        },
        "WaveFrequency": {
          "comment": "Wave frequency (can be 0 for a standing wave)."
        },
        "WavePhase": {
          "comment": "Angular phase, in 0-360 degrees."
        },
        "WaveRadius": {
          "comment": "Radius of the wave, in world space units."
        },
        "WaveStrength": {
          "comment": "Strength of the influencing force."
        }
      }
    },
    "FluidSurfaceActor": {
      "properties": {
        "ProjectileEntryEffect": {
          "comment": "Particle effect to play when projectile hits water"
        }
      }
    },
    "FluidSurfaceComponent": {
      "comment": "Utility component for drawing an interactive body of fluid.\n Origin is at the component location.",
      "properties": {
        "ClampMap": {
          "comment": "Stores a 1 for each clamped vertex that should not be simulated, and a 0 for each vertex that should be simulated."
        },
        "FluidSimulation": {
          "comment": "All transient member variables are contained inside the FFluidSurfaceInfo object."
        },
        "LightMap": {
          "comment": "Reference to the texture lightmap resource."
        },
        "DeactivationDistance": {
          "comment": "Distance between the camera and the closest fluid edge where the fluid will deactivate and start rendering as a simple flat quad."
        },
        "EnableDetail": {
          "comment": "Whether the detail simulation grid should be used or not"
        },
        "EnableSimulation": {
          "comment": "Whether the vertex positions in the simulation grid should be animated or not"
        },
        "FluidDamping": {
          "comment": "How much to dampen the amplitude of waves in the fluid (0.0-30.0)"
        },
        "FluidHeightScale": {
          "comment": "Wave height scale - higher value produces higher waves"
        },
        "FluidTravelSpeed": {
          "comment": "Wave travel speed factor for the simulation grid (0.0-1.0)"
        },
        "FluidUpdateRate": {
          "comment": "Fluid update rate in number of updates per second"
        },
        "ForceContinuous": {
          "comment": "How much ripple to make when an Actor moves through the fluid."
        },
        "ForceImpact": {
          "comment": "How much ripple to make when fluid is hit by a weapon or touched by a object for the first time."
        },
        "GPUTessellationFactor": {
          "comment": "How much the GPU should tessellate the fluid grid. (Only used on platforms that completely supports GPU tessellation.)"
        },
        "GridSpacing": {
          "comment": "The size of a grid cell in the vertex simulation (in world space units)"
        },
        "GridSpacingLowRes": {
          "comment": "Fluids automatically draw a low-resolution grid when they are deactivated. A reasonable value is needed for vertex fogging to work when the fluid is translucent. A maximum of 65000 vertices are allowed before GridSpacingLowRes is clamped."
        },
        "LightingContrast": {
          "comment": "Increasing this value adds more contrast to the lighting by exaggerating the curvature for the fluid normals."
        },
        "SimulationQuadsX": {
          "comment": "Number of quads in the simulated grid (along the X-axis)"
        },
        "SimulationQuadsY": {
          "comment": "Number of quads in the simulated grid (along the Y-axis)"
        },
        "TargetDetail": {
          "comment": "Target actor which the detail texture will center around. If none is provided, the detail texture will center around the active camera."
        },
        "TargetSimulation": {
          "comment": "Target actor which the simulation grid will center around. If none is provided, the simulation grid will center around the active camera."
        },
        "bPause": {
          "comment": "Whether to update the fluid or pause it"
        },
        "bShowDetailNormals": {
          "comment": "Whether to render an overlay of the detail normal for debugging"
        },
        "bShowDetailPosition": {
          "comment": "Whether to visualize the placement of the detail texture"
        },
        "bShowFluidDetail": {
          "comment": "Whether to show the detail normalmap on the fluid"
        },
        "bShowFluidSimulation": {
          "comment": "Whether to visualize the height of the main fluid grid"
        },
        "bShowSimulationNormals": {
          "comment": "Whether to render lines for normals"
        },
        "bShowSimulationPosition": {
          "comment": "Whether to visualize the placement of the simulated grid"
        },
        "bTestRipple": {
          "comment": "Whether to enable a force for debugging"
        },
        "bTestRippleCenterOnDetail": {
          "comment": "Whether the test ripple should center on the detail texture or the main grid."
        },
        "NormalLength": {
          "comment": "The length of the visualized normals, when bShowSimulationNormals is turned on"
        },
        "TestRippleFrequency": {
          "comment": "Number of seconds between each pling on the test ripple. 0 makes it continuous."
        },
        "TestRippleRadius": {
          "comment": "Radius of the test ripple, in world space"
        },
        "TestRippleSpeed": {
          "comment": "Angular speed of the test ripple"
        },
        "bTiling": {
          "comment": "Whether to make the detail simulation tiled."
        },
        "DetailDamping": {
          "comment": "How much to dampen the amplitude of waves in the detail texture (0.0-30.0)"
        },
        "DetailHeightScale": {
          "comment": "Wave height scale for the detail texture - higher value produces higher waves"
        },
        "DetailResolution": {
          "comment": "Number of simulation cells along each axis in the detail texture"
        },
        "DetailSize": {
          "comment": "World space size of one edge of the detail texture"
        },
        "DetailTransfer": {
          "comment": "How much of an applied force should be transferred to the detail texture (0.0-1.0)"
        },
        "DetailTravelSpeed": {
          "comment": "Wave travel speed factor for the detail texture (0.0-1.0)"
        },
        "DetailUpdateRate": {
          "comment": "Fluid update rate in number of updates per second"
        },
        "FluidMaterial": {
          "comment": "Surface material"
        },
        "LightmapResolution": {
          "comment": "Resolution of the fluid's texture lightmap."
        },
        "LightmassSettings<ScriptOrder=true>": {
          "comment": "The Lightmass settings for this object."
        }
      },
      "functions": {
        "ApplyForce": {
          "comment": "Apply a force to the fluid."
        },
        "SetDetailPosition": {
          "comment": "Set the position of the origin of the detail texture, within the fluid."
        },
        "SetSimulationPosition": {
          "comment": "Set the position of the origin of the simulation grid, within the fluid."
        }
      }
    },
    "FogVolumeConeDensityComponent": {
      "properties": {
        "PreviewCone": {
          "comment": "A preview component for visualizing the cone in the editor."
        },
        "ConeAxis": {
          "comment": "Direction of the cone"
        },
        "ConeMaxAngle": {
          "comment": "Angle from the axis that limits the cone's volume"
        },
        "ConeRadius": {
          "comment": "The cone's radius."
        },
        "ConeVertex": {
          "comment": "The cone's vertex in world space."
        },
        "MaxDensity": {
          "comment": "This is the density at the center of the cone, which will be the maximum."
        }
      }
    },
    "FogVolumeConstantDensityComponent": {
      "properties": {
        "Density": {
          "comment": "The constant density coefficient"
        }
      }
    },
    "FogVolumeDensityComponent": {
      "properties": {
        "ApproxFogLightColor": {
          "comment": "Color used to approximate fog material color on transparency. \n Important: Set this color to match the overall color of the fog material, otherwise transparency will not be fogged correctly."
        },
        "bAffectsTranslucency": {
          "comment": "Controls whether the fog volume affects intersecting translucency. \n If FALSE, the fog volume will sort normally with translucency and not fog intersecting translucent objects."
        },
        "bEnabled": {
          "comment": "True if the fog is enabled."
        },
        "bOnlyAffectsTranslucency": {
          "comment": "Controls whether the fog volume affects opaque pixels, or just intersecting translucency."
        },
        "FogMaterial": {
          "comment": "Fog Material to use on the AutomaticComponent. This will not be used on FogVolumeActors, they will use their existing materials."
        },
        "FogVolumeActors": {
          "comment": "Optional array of actors that will define the shape of the fog volume. \n These actors will not be moved along with the fog volume, and they can be selected directly."
        },
        "MaxDistance": {
          "comment": "MaxDistance can be tweaked to be as low as it can go without making the fog noticeably less opaque, \n And that will greatly improve the anti aliasing effect on opaque geometry in the foreground."
        },
        "SimpleLightColor": {
          "comment": "Sets the 'EmissiveColor' Vector Parameter of FogMaterial.\n This will have no effect if FogMaterial has been overridden with a material that does not have a 'EmissiveColor' parameter."
        },
        "StartDistance": {
          "comment": "Distance from the camera that the fog should start, in world units."
        }
      },
      "functions": {
        "SetEnabled": {
          "comment": "Changes the enabled state of the height fog component.",
          "params": {
            "bSetEnabled": "The new value for bEnabled."
          }
        }
      }
    },
    "FogVolumeDensityInfo": {
      "properties": {
        "bEnabled": {
          "comment": "replicated copy of HeightFogComponent's bEnabled property"
        },
        "AutomaticMeshComponent": {
          "comment": "The automatic mesh component, which sizes with this fog volume actor. This mesh component gets rendered with FogMaterial.\n It is optional, and individual actors can be specified using the FogVolumeActors array instead."
        },
        "DensityComponent": {
          "comment": "The fog component which stores data specific to each density function."
        }
      }
    },
    "FogVolumeLinearHalfspaceDensityComponent": {
      "properties": {
        "HalfspacePlane": {
          "comment": "The plane that defines the fogged halfspace. The normal of this plane faces away from the fogged halfspace."
        },
        "PlaneDistanceFactor": {
          "comment": "The linear distance based density coefficient"
        }
      }
    },
    "FogVolumeSphericalDensityComponent": {
      "properties": {
        "PreviewSphereRadius": {
          "comment": "A preview component for visualizing the sphere in the editor."
        },
        "SphereCenter": {
          "comment": "The sphere's center in world space."
        },
        "SphereRadius": {
          "comment": "The sphere's radius."
        },
        "MaxDensity": {
          "comment": "This is the density at the center of the sphere, which will be the maximum."
        }
      }
    },
    "Font": {
      "properties": {
        "CharRemap": {
          "comment": "When IsRemapped is true, this array maps unicode values to entries in the Characters array"
        },
        "IsRemapped": {
          "comment": "True if font is 'remapped'. That is, the character array is not a direct mapping to unicode values. Instead,"
        },
        "MaxCharHeight": {
          "comment": "The maximum height of a character in this font. For multi-fonts, this array will contain a maximum\ncharacter height for each multi-font, otherwise the array will contain only a single element. This is"
        },
        "NumCharacters": {
          "comment": "Number of characters in the font, not including multiple instances of the same character (for multi-fonts)."
        },
        "Textures": {
          "comment": "Textures that store this font's glyph image data"
        },
        "Characters": {
          "comment": "List of characters in the font. For a MultiFont, this will include all characters in all sub-fonts! Thus,"
        },
        "EmScale": {
          "comment": "Font metrics."
        },
        "ImportOptions": {
          "comment": "Options used when importing this font"
        },
        "Kerning": {
          "comment": "Default horizontal spacing between characters when rendering text with this font"
        }
      },
      "functions": {
        "GetAuthoredViewportHeight": {
          "comment": "Determine the height of the mutli-font resolution page which will be used for the specified resolution.",
          "params": {
            "ViewportHeight": "the height (in pixels) of the viewport being rendered to."
          }
        },
        "GetMaxCharHeight": {
          "comment": "Returns the maximum height for any character in this font"
        },
        "GetResolutionPageIndex": {
          "comment": "Calulate the index for the texture page containing the multi-font character set to use, based on the specified screen resolution.",
          "params": {
            "HeightTest": "the height (in pixels) of the viewport being rendered to."
          }
        },
        "GetScalingFactor": {
          "comment": "Calculate the amount of scaling necessary to match the multi-font subfont which most closely matches the specified resolution.",
          "params": {
            "HeightTest": "the height (in pixels) of the viewport being rendered to."
          }
        },
        "GetStringHeightAndWidth": {
          "comment": "Determines the height and width for the passed in string."
        }
      },
      "structs": {
        "FontCharacter": {
          "comment": "this struct is serialized using binary serialization so any changes to it require a package version bump"
        }
      }
    },
    "FontImportOptions": {
      "properties": {
        "Data<FullyExpand=true>": {
          "comment": "The actual data for this object. We wrap it in a struct so that we can copy it around between objects."
        }
      },
      "structs": {
        "FontImportOptionsData": {
          "comment": "Font import options",
          "properties": {
            "bUseDistanceFieldAlpha": {
              "comment": "If TRUE then the alpha channel of the font textures will store a distance field instead of a color mask"
            },
            "DistanceFieldScaleFactor<EditCondition=bUseDistanceFieldAlpha>": {
              "comment": "Scale factor determines how big to scale the font bitmap during import when generating distance field values \n Note that higher values give better quality but importing will take much longer."
            },
            "DistanceFieldScanRadiusScale<ClampMin=0.0|ClampMax=4.0>": {
              "comment": "Shrinks or expands the scan radius used to determine the silhouette of the font edges."
            }
          }
        }
      }
    },
    "ForceFeedbackManager": {
      "properties": {
        "bAllowsForceFeedback": {
          "comment": "Whether the player has disabled gamepad rumble or not (TCR C5-3)"
        },
        "bIsPaused": {
          "comment": "Whether it was paused by the player controller or not"
        },
        "CurrentSample": {
          "comment": "The current waveform sample being played"
        },
        "ElapsedTime": {
          "comment": "The amount of time elapsed since the start of this waveform"
        },
        "FFWaveform": {
          "comment": "The currently playing waveform"
        },
        "ScaleAllWaveformsBy": {
          "comment": "The amount to scale all waveforms by (user settable) (TCR C5-3)"
        },
        "WaveformInstigator": {
          "comment": "Used with max waveform distance on the waveform to determine waveform attenuation"
        }
      },
      "functions": {
        "PauseWaveform": {
          "comment": "Pauses/unpauses the playback of the waveform for the gamepad",
          "params": {
            "bPause": "True to pause, False to resume"
          }
        },
        "PlayForceFeedbackWaveform": {
          "comment": "Sets the waveform to play for the gamepad",
          "params": {
            "ForceFeedbackWaveform": "The waveform data to play",
            "Instigator": "the actor causing the rumble"
          }
        },
        "StopForceFeedbackWaveform": {
          "comment": "Stops the waveform by nulling out the waveform"
        }
      }
    },
    "ForceFeedbackWaveform": {
      "properties": {
        "bIsLooping": {
          "comment": "Whether this waveform should be looping or not"
        },
        "MaxWaveformDistance": {
          "comment": "The distance at which the waveform is no longer felt"
        },
        "Samples": {
          "comment": "The list of samples that make up this waveform"
        },
        "WaveformFalloffStartDistance": {
          "comment": "The distance at which the waveform starts to falloff in strength"
        }
      },
      "structs": {
        "WaveformSample": {
          "comment": "Holds a single sample's information",
          "properties": {
            "Duration": {
              "comment": "The amount of time this sample plays"
            },
            "LeftAmplitude": {
              "comment": "Use a byte with a range of 0 to 100 to represent the percentage of\n \"on\". This cuts the data needed to store the waveforms in half."
            },
            "LeftFunction": {
              "comment": "For function generated samples, the type of function"
            }
          }
        }
      }
    },
    "FracturedBaseComponent": {
      "properties": {
        "bInitialVisibilityValue": {
          "comment": "Initial visibility value for this component."
        },
        "bResetStaticMesh": {
          "comment": "TRUE whenever the static mesh is being reset during Reattach"
        },
        "bUseDynamicIBWithHiddenFragments": {
          "comment": "If true, bUseDynamicIndexBuffer will be enabled when at least one fragment is hidden, otherwise it will be disabled.\n If false, bUseDynamicIndexBuffer will not be overridden."
        },
        "bUseDynamicIndexBuffer": {
          "comment": "If true, each element will be rendered with one draw call by using a dynamic index buffer that is repacked when visibility changes.\n If false, each element will be rendered with n draw calls, where n is the number of consecutive index ranges, and there will be no memory overhead."
        },
        "bVisibilityHasChanged": {
          "comment": "If true, VisibleFragments has changed since the last attach and the dynamic index buffer needs to be updated."
        },
        "bVisibilityReset": {
          "comment": "True if VisibleFragments was reset to bInitialVisibilityValue since the last component attach."
        },
        "ComponentBaseResources": {
          "comment": "This component's index buffer, used for rendering when bUseDynamicIndexBuffer is true."
        },
        "NumResourceIndices": {
          "comment": "Number of indices in the resource's index buffer the last time the component index buffer was built. \n Used to detect when the resource's index buffer has changed and the component's index buffer should be rebuilt."
        },
        "ReleaseResourcesFence": {
          "comment": "A fence used to track when the rendering thread has released the component's resources."
        },
        "VisibleFragments": {
          "comment": "Stores non-zero for each fragment that is visible, and 0 otherwise."
        }
      },
      "functions": {
        "GetNumFragments": {
          "comment": "Get the number of chunks in the assigned fractured mesh."
        },
        "GetNumVisibleFragments": {
          "comment": "Get the number of chunks that are currently visible."
        },
        "GetVisibleFragments": {
          "comment": "Returns array of currently visible fragments."
        },
        "IsFragmentVisible": {
          "comment": "Returns whether the specified fragment is currently visible or not."
        },
        "SetStaticMesh": {
          "comment": "Change the StaticMesh used by this instance, and resets VisibleFragments to all be visible if NewMesh is valid.",
          "params": {
            "NewMesh": "StaticMesh to set. If this is not also a UFracturedStaticMesh, assignment will fail."
          }
        }
      }
    },
    "FracturedSkinnedMeshComponent": {
      "properties": {
        "bFragmentTransformsChanged": {
          "comment": "TRUE if fragment transforms have changed and the GPU should be refreshed"
        }
      }
    },
    "FracturedStaticMeshActor": {
      "properties": {
        "bHasShownMissingSoundWarning": {
          "comment": "Used so we only display the 'missing sound' warning once"
        },
        "ChunkHealth": {
          "comment": "Current health of each chunk"
        },
        "DeferredPartsToSpawn": {
          "comment": "Array of parts that are waiting to be spawned in an upcoming tick"
        },
        "ExplosionFractureSound": {
          "comment": "Cached sound for large fractures."
        },
        "MI_LoseChunkPreviousMaterial": {
          "comment": "This is the material that was set on this FracuredStaticMeshActor before we overrode it with LoseChunkOutsideMaterial"
        },
        "PartImpactEffect": {
          "comment": "Cached info for part impacts"
        },
        "SingleChunkFractureSound": {
          "comment": "Cached sound for single chunk fractures."
        },
        "SkinnedComponent": {
          "comment": "Skinned component which will handle rendering for FracturedStaticMeshComponent"
        },
        "bBreakChunksOnActorTouch": {
          "comment": "If true, detach parts when an Actor with bCanCauseFractureOnTouch contacts them. Actor must not be blocked by this FSMA."
        },
        "ChunkHealthScale": {
          "comment": "Allows controlling how much 'health' chunks have on a per-instance basis"
        },
        "FractureCullMaxDistance": {
          "comment": "Maximum distance from player where actor will be allowed to fracture (scaled by global settings.)"
        },
        "FractureCullMinDistance": {
          "comment": "Minimum distance from player where actor will ALWAYS fracture, even when outside the view frustum (scaled by global settings.)"
        },
        "FracturedByDamageType": {
          "comment": "Set of damage types that can cause pieces to break off this FSAM. If empty, all damage types can do this."
        },
        "MaxPartsToSpawnAtOnce": {
          "comment": "Maximum number of rigid body parts to spawn off per actor, per frame"
        },
        "OverrideFragmentDestroyEffects": {
          "comment": "Allows you to override particle effects to play when chunk is hidden for just this actor."
        }
      },
      "functions": {
        "BreakOffIsolatedIslands": {
          "comment": "Find all groups of chunks which are not connected to 'root' parts, and spawn them as new physics objects.\n Updates FragmentVis with new chunks that get hidden by the process."
        },
        "BreakOffPartsInRadius": {
          "comment": "Util to break off all parts within radius of the explosion"
        },
        "Explode": {
          "comment": "Break off all pieces in one go."
        },
        "FractureEffectIsRelevant": {
          "comment": "Specialized to handle explicit effect instigators. Also, handles None instigators -- these are special\nweapons (eg dummyfire) and are always relevant. Also, for fractured static meshes we only spawn effects if"
        },
        "HideFragmentsToMaximizeMemoryUsage": {
          "comment": "Hide some percentage of the fragments from this mesh to maximize memory usage - does not spawn physics pieces etc"
        },
        "HideOneFragment": {
          "comment": "Hide one fragment from this mesh - does not spawn physics pieces etc"
        },
        "IsFracturedByDamageType": {
          "comment": "Util for checking if this damage type will cause fracture."
        },
        "NotifyHitByExplosion": {
          "comment": "Let kismet know that we've been hit",
          "params": {
            "InstigatorController": "the player that caused the explosion",
            "DamageAmount": "how much damage was caused",
            "DmgType": "the type of damage caused"
          }
        },
        "RemoveDecals": {
          "comment": "This function will remove all of the currently attached decals from the object.\n Basically, we want to have decals attach to these objects and then on state change (due to damage usually), we will\n just detach them all with the big particle effect that occurs it should not be noticeable."
        },
        "ResetHealth": {
          "comment": "Used to init/reset health array."
        },
        "ResetVisibility": {
          "comment": "Unhides all fragments"
        },
        "SetLoseChunkReplacementMaterial": {
          "comment": "This will possibly set the material on the FracturedMesh after we have lost a chunk."
        },
        "SpawnDeferredParts": {
          "comment": "Gives the actor a chance to spawn chunks that may have been deferred"
        },
        "SpawnPart": {
          "comment": "Spawn one chunk of this mesh as its own Actor, with the supplied velocities and scale relative to this Actor."
        },
        "SpawnPartMulti": {
          "comment": "Does the same as SpawnPart, but takes an array of chunks to make part of the new part."
        },
        "TakeDamage": {
          "comment": "TakeDamage will hide/spawn chunks when they get shot."
        }
      },
      "structs": {
        "DeferredPartToSpawn": {
          "comment": "Info about a fracture part that should be spawned in an upcoming Tick",
          "properties": {
            "bExplosion": {
              "comment": "TRUE if this part was spawned because of an explosion"
            },
            "ChunkIndex": {
              "comment": "Index of the chunk to spawn"
            },
            "InitialAngVel": {
              "comment": "Exit angular velocity for this chunk"
            },
            "InitialVel": {
              "comment": "Exit velocity for this chunk"
            },
            "RelativeScale": {
              "comment": "Relative scale"
            }
          }
        }
      }
    },
    "FracturedStaticMeshComponent": {
      "properties": {
        "bUseSkinnedRendering": {
          "comment": "If true, all fragment visibility and transform information will be forwarded to SkinnedComponent, which will handle rendering."
        },
        "bUseVisibleVertsForBounds": {
          "comment": "If true, the only thing considered when calculating the bounds of this component are the graphics verts current visible.\n Using this and having simplified collision will cause unpredictable results."
        },
        "FragmentBoundsMaxZ": {
          "comment": "Z value of top of fractured piece bounds."
        },
        "FragmentBoundsMinZ": {
          "comment": "Z value of bottom of fractured piece bounds."
        },
        "FragmentNeighborsVisible": {
          "comment": "Stores non-zero for each fragment whose neighbors are all visible, and 0 otherwise."
        },
        "SkinnedComponent": {
          "comment": "Component which handles rendering if bUseSkinnedRendering is true."
        },
        "VisibleBox": {
          "comment": "Local space bounding box of visible fragments, updated on attach."
        },
        "bBottomFragmentsRootNonDestroyable": {
          "comment": "Allows per-instance override of chunk support/destroyable flags.\n Marks chunks at bottom of mesh as 'root' and 'non destroyable'."
        },
        "bTopFragmentsRootNonDestroyable": {
          "comment": "Allows per-instance override of chunk support/destroyable flags.\n Marks chunks at top of mesh as 'root' and 'non destroyable'."
        },
        "LoseChunkOutsideMaterialOverride": {
          "comment": "Allows overriding the LoseChunkOutsideMaterial on a per-instance basis."
        },
        "TopBottomFragmentDistThreshold": {
          "comment": "Threshold distance of fragment box from top/bottom of mesh to be considered for bTop/BottomFragmentsRootNonDestroyable"
        }
      },
      "functions": {
        "GetBoundaryHiddenFragments": {
          "comment": "Return set of fragments that are hidden, but who have at least one visible neighbour.",
          "params": {
            "AdditionalVisibleFragments": "Additional fragments to consider 'visible' when finding fragments. Will not end up in resulting array."
          }
        },
        "GetCoreFragmentIndex": {
          "comment": "Gets the index that is the 'core' of this mesh."
        },
        "GetFracturedMeshPhysMaterial": {
          "comment": "Util for getting the PhysicalMaterial applied to this mesh"
        },
        "GetFragmentAverageExteriorNormal": {
          "comment": "Returns average exterior normal of a particular chunk."
        },
        "GetFragmentBox": {
          "comment": "Get the bounding box of a specific chunk, in world space."
        },
        "GetFragmentGroups": {
          "comment": "Based on the hidden state of chunks, groups which are connected.",
          "params": {
            "IgnoreFragments": "Additional fragments to ignore when finding islands. These will not end up in any groups."
          }
        },
        "IsFragmentDestroyable": {
          "comment": "Returns if this fragment is destroyable."
        },
        "IsNoPhysFragment": {
          "comment": "Returns if this fragment should never spawn a physics object."
        },
        "IsRootFragment": {
          "comment": "Returns if this is a supporting 'root' fragment."
        },
        "RecreatePhysState": {
          "comment": "Re-create physics state - needed if hiding parts would change physics collision of the object."
        },
        "SetVisibleFragments": {
          "comment": "Change the set of visible fragments."
        }
      }
    },
    "FracturedStaticMeshPart": {
      "properties": {
        "AsleepRBChannel": {
          "comment": "If bChangeRBChannelWhenAsleep is TRUE, RBChannel to switch to when asleep."
        },
        "BaseFracturedMeshActor": {
          "comment": "Base FracturedStaticMeshActor that this part was spawned off of."
        },
        "bChangeRBChannelWhenAsleep": {
          "comment": "If TRUE, check when piece goes to sleep, and then change its RBChannel."
        },
        "bCompositeThatExplodesOnImpact": {
          "comment": "Indicates that this part consists of more than 1 chunk - and should explode upon impact."
        },
        "bHasBeenRecycled": {
          "comment": "Indicates whether this part has already been recycled and just needs to be initialized to be used again."
        },
        "CurrentVibrationLevel": {
          "comment": "If oldvel dot newvel < -DestroyVelChangeThresh, destroy piece."
        },
        "DestroyPartRadiusFactor": {
          "comment": "This part will be destroyed if it gets further than BaseFracturedMeshActor's radius * DestroyPartRadiusFactor from BaseFracturedMeshActor."
        },
        "FracPartGravScale": {
          "comment": "Additional gravity scaling for fracture pieces"
        },
        "LastImpactSoundTime": {
          "comment": "Time since last physics impact sound"
        },
        "LastSpawnTime": {
          "comment": "Last time that this pieces was spawned."
        },
        "OldVelocity": {
          "comment": "Used to store preview frames velocity, to look for sudden velocity changes."
        },
        "PartPoolIndex": {
          "comment": "Used to know index within pool in FractureManager, so we replace it in the free pool."
        }
      },
      "functions": {
        "BreakOffPartsInRadius": {
          "comment": "For broken off pieces, we only want to spawn more parts if its a shatterable composite."
        },
        "Initialize": {
          "comment": "Revive part, set physics to PHYS_RigidBody, enabled collision etc"
        },
        "RecyclePart": {
          "comment": "Reset state of this part - clear mesh reference, put in PHYS_None, disable collision etc"
        },
        "TakeDamage": {
          "comment": "Used so weapons etc move parts."
        },
        "TryToCleanUp": {
          "comment": "Try to clean up this part if its not seen or it's parent has been removed. If it is seen, keep trying until it isn't."
        }
      }
    },
    "FractureManager": {
      "properties": {
        "ActorsWithDeferredPartsToSpawn": {
          "comment": "List of actors that have fracture parts that have been deferred to spawn on upcoming frames"
        },
        "bEnableAntiVibration": {
          "comment": "If TRUE, look for vibrating FSM parts and kill them"
        },
        "bEnableSpawnChunkEffectForRadialDamage": {
          "comment": "If TRUE, spawn effect for chunks falling off when doing radial damage (ie removing many chunks at once)"
        },
        "DestroyMinAngVel": {
          "comment": "Min angular velocity of part to be killed by vibration detection code."
        },
        "DestroyVibrationLevel": {
          "comment": "How much vibration (defined as changes in angular velocity direction) must occur before part is killed."
        }
      },
      "functions": {
        "GetFSMDirectSpawnChanceScale": {
          "comment": "Returns a scalar to the percentage chance of a fractured static mesh spawning a rigid body after"
        },
        "GetFSMFractureCullDistanceScale": {
          "comment": "Returns a distance scale for whether a fractured static mesh should actually fracture when damaged"
        },
        "GetFSMPart": {
          "comment": "Grab a FSMP from the free pool, or forcibly recycle a suitable one from the world."
        },
        "GetFSMRadialSpawnChanceScale": {
          "comment": "Returns a scalar to the percentage chance of a fractured static mesh spawning a rigid body after"
        },
        "ResetPoolVisibility": {
          "comment": "Recycles any active parts"
        },
        "ReturnPartActor": {
          "comment": "Return a part to the pool."
        },
        "SpawnChunkDestroyEffect": {
          "comment": "Function use to spawn particle effect when a chunk is destroyed."
        },
        "SpawnPartActor": {
          "comment": "Function to actually spawn a FSMP. Allows game-specific pooling/capping of actors."
        },
        "Tick": {
          "comment": "Called every frame to update the object"
        }
      }
    },
    "FractureMaterial": {
      "properties": {
        "FractureEffect": {
          "comment": "Particle system effect to play at fracture location."
        },
        "FractureSound": {
          "comment": "Sound cue to play at fracture location."
        }
      }
    },
    "GameEngine": {
      "properties": {
        "AdManager": {
          "comment": "The singleton interface that manages ingame ads"
        },
        "bClearAnimSetLinkupCachesOnLoadMap": {
          "comment": "If true - clear all AnimSet LinkupCaches during map load.\n You need to do this is the set of skeletal meshes that you are playing anims on is not bounded."
        },
        "bShouldCommitPendingMapChange": {
          "comment": "If TRUE, commit map change the next frame."
        },
        "bStartedLoadMapMovie": {
          "comment": "TRUE if the loading movie was started during LoadMap()."
        },
        "bTriggerPostLoadMap": {
          "comment": "Triggers a call to PostLoadMap() the next Tick, turns off loading movie if LoadMap() has been called."
        },
        "bWorldWasLoadedThisTick": {
          "comment": "set for one tick after completely loading and initializing a new world\n (regardless of whether it's LoadMap() or seamless travel)"
        },
        "DLCEnumerator": {
          "comment": "The singleton interface that enumerates available DLC"
        },
        "DLCManager": {
          "comment": "The singleton interface that manages the installation and removal of DLC"
        },
        "DownloadableContentEnumeratorClassName": {
          "comment": "The name of the class to use for the DLC enumeration"
        },
        "DownloadableContentManagerClassName": {
          "comment": "The name of the class to use for the DLC manager"
        },
        "GPendingLevel": {
          "comment": "Static: Removes any special URL characters from the specified string\n \n@param Str String to be filtered"
        },
        "InGameAdManagerClassName": {
          "comment": "The name of the class to use for the Ad manager"
        },
        "LastRemoteURL": {
          "comment": "last server we connected to (for \"reconnect\" command)"
        },
        "LastURL": {
          "comment": "URL the last time we travelled"
        },
        "LevelsToLoadForPendingMapChange": {
          "comment": "Array of package/ level names that need to be loaded for the pending map change. First level in that array is\n going to be made a fake persistent one by using ULevelStreamingPersistent."
        },
        "LoadedLevelsForPendingMapChange": {
          "comment": "Array of already loaded levels. The ordering is arbitrary and depends on what is already loaded and such."
        },
        "MaxDeltaTime": {
          "comment": "Maximium delta time the engine uses to populate GDeltaTime. If 0, unbound."
        },
        "NamedNetDrivers": {
          "comment": "A list of named UNetDrivers"
        },
        "ObjectReferencers": {
          "comment": "Handles to object references; used by the engine to e.g. the prevent objects from being garbage collected."
        },
        "OnlineSubsystem": {
          "comment": "The singleton online interface for all game code to use"
        },
        "PackagesToFullyLoad": {
          "comment": "A list of tag/array pairs that is used at LoadMap time to fully load packages that may be needed for the map/game with DLC, but we can't use DynamicLoadObject to load from the packages"
        },
        "PendingLevelPlayerControllerClassName": {
          "comment": "The name of the class to spawn as the temporary pending level player controller"
        },
        "PendingLevelStreamingStatusUpdates": {
          "comment": "Constructors"
        },
        "PendingMapChangeFailureDescription": {
          "comment": "Human readable error string for any failure during a map change request. Empty if there were no failures."
        }
      },
      "functions": {
        "CreateNamedNetDriver": {
          "comment": "Creates a UNetDriver and associates a name with it.",
          "params": {
            "NetDriverName": "The name to associate with the driver."
          }
        },
        "DestroyNamedNetDriver": {
          "comment": "Destroys a UNetDriver based on its name.",
          "params": {
            "NetDriverName": "The name associated with the driver to destroy."
          }
        },
        "GetAdManager": {
          "comment": "Returns the AdManager object. This could be NULL depending on the platform"
        },
        "GetDLCEnumerator": {
          "comment": "Returns the DLC enumerator object pointer. This will be null for PIE"
        },
        "GetDLCManager": {
          "comment": "Returns the DLC manager object pointer. This will be null for PIE"
        },
        "GetOnlineSubsystem": {
          "comment": "Returns the global online subsytem pointer. This will be null for PIE"
        }
      },
      "structs": {
        "FullyLoadedPackagesInfo": {
          "comment": "Struct to help hold information about packages needing to be fully-loaded for DLC, etc",
          "properties": {
            "FullyLoadType": {
              "comment": "When to load these packages"
            },
            "LoadedObjects": {
              "comment": "List of objects that were loaded, for faster cleanup"
            },
            "PackagesToLoad": {
              "comment": "The list of packages that will be fully loaded when the above Map is loaded"
            },
            "Tag": {
              "comment": "When this map or gametype is loaded, the packages in the following array will be loaded and added to root, then removed from root when map is unloaded"
            }
          }
        },
        "LevelStreamingStatus": {
          "comment": "level streaming updates that should be applied immediately after committing the map change"
        },
        "NamedNetDriver": {
          "comment": "Struct to hold a UNetDriver and an assoicated name",
          "properties": {
            "NetDriver": {
              "comment": "A pointer to a UNetDriver"
            },
            "NetDriverName": {
              "comment": "The name associated with the driver"
            }
          }
        }
      }
    },
    "GameInfo": {
      "properties": {
        "AdjustedNetSpeed": {
          "comment": "Current adjusted net speed - Used for dynamically managing netspeed for listen servers"
        },
        "AnimTreePoolSize": {
          "comment": "Size of the AnimTree pool. System will keep this number of extra AnimTrees around per Template"
        },
        "ArbitratedLeaderboardId": {
          "comment": "The arbitrated leaderboard to write the stats to for skill/scoring"
        },
        "ArbitrationHandshakeTimeout": {
          "comment": "Amount of time a client can take for arbitration handshaking before being kicked"
        },
        "ArbitrationPCs": {
          "comment": "Holds the list of players that passed handshaking and require finalization\n of arbitration data written to the online subsystem"
        },
        "AutoTestManagerClass": {
          "comment": "Class of automated test manager used by this game class"
        },
        "BadPingThreshold": {
          "comment": "The point we determine the server is either delaying packets or has bad upstream"
        },
        "bFixedPlayerStart": {
          "comment": "Whether the game expects a fixed player start for profiling."
        },
        "bHasArbitratedHandshakeBegun": {
          "comment": "Whether the arbitrated handshaking has occurred or not.\n NOTE: The code will reject new connections once handshaking has started"
        },
        "bHasEndGameHandshakeBegun": {
          "comment": "Used to indicate when an arbitrated match has started its end sequence"
        },
        "bHasNetworkError": {
          "comment": "Tracks whether the server can travel due to a critical network error or not"
        },
        "bHasStandbyCheatTriggered": {
          "comment": "Used to determine whether we've already caught a cheat or not"
        },
        "bIsEndGameHandshakeComplete": {
          "comment": "Whether the arbitrated handshaking has completed or not."
        },
        "bIsStandbyCheckingEnabled": {
          "comment": "Used to determine if checking for standby cheats should occur"
        },
        "bIsStandbyCheckingOn": {
          "comment": "Tracks standby checking status"
        },
        "bNeedsEndGameHandshake": {
          "comment": "Whether the arbitrated handshaking has occurred or not."
        },
        "bNewOnlineSessionOnTravel": {
          "comment": "If true, destroy and recreate online sessions at mapchange (required for Steam, which can only update game server stats once per session)"
        },
        "bRequiresPushToTalk": {
          "comment": "Whether this game type requires voice to be push to talk or not"
        },
        "BugLocString": {
          "comment": "Currently stores the location string form"
        },
        "BugRotString": {
          "comment": "Currently stores the rotation in string form"
        },
        "bUseSeamlessTravel": {
          "comment": "perform map travels using SeamlessTravel() which loads in the background and doesn't disconnect clients\n @see WorldInfo::SeamlessTravel()"
        },
        "bUsingArbitration": {
          "comment": "Whether this match is going to use arbitration or not"
        },
        "CauseEventCommand": {
          "comment": "The causeevent= string that the game passed in This is separate from automatedPerfTesting which is going to probably spawn bots / effects"
        },
        "CoverReplicatorBase": {
          "comment": "Base copy of cover changes that need to be replicated to clients on join"
        },
        "CustomMapPrefixes": {
          "comment": "Used for loading appropriate game type if non-specified in URL"
        },
        "DefaultGameType": {
          "comment": "The default game type to use on a map"
        },
        "DefaultMapPrefixes": {
          "comment": "Used for loading appropriate game type if non-specified in URL"
        },
        "GameInterface": {
          "comment": "Cached online game interface variable"
        },
        "JoinInProgressStandbyWaitTime": {
          "comment": "The amount of time to wait before checking a connection for standby issues"
        },
        "LastNetSpeedUpdateTime": {
          "comment": "Last time netspeed was updated for server (by client entering or leaving)"
        },
        "LeaderboardId": {
          "comment": "The leaderboard to write the stats to for skill/scoring"
        },
        "MaxDynamicBandwidth": {
          "comment": "Maximum bandwidth dynamically set per connection"
        },
        "MaxTimeMargin": {
          "comment": "Max interval that client clock is allowed to get ahead of server clock before triggering speed hack detection"
        },
        "MinDynamicBandwidth": {
          "comment": "Minimum bandwidth dynamically set per connection"
        },
        "MinTimeMargin": {
          "comment": "Clamps how far behind server clock we let time margin get. Used to prevent speedhacks where client slows their clock down for a while then speeds it up."
        },
        "MyAutoTestManager": {
          "comment": "Instantiated AutoTestManager - only exists if requested by command-line"
        },
        "NumTravellingPlayers": {
          "comment": "number of players that are still travelling from a previous map"
        },
        "OnlineGameSettingsClass": {
          "comment": "The class to use when registering dedicated servers with the online service"
        },
        "OnlineStatsWriteClass": {
          "comment": "Class sent to clients to use to create and hold their stats"
        },
        "OnlineSub": {
          "comment": "Cached online subsystem variable"
        },
        "Pausers": {
          "comment": "The list of delegates to check before unpausing a game"
        },
        "PendingArbitrationPCs": {
          "comment": "List of player controllers we're awaiting handshakes with\n NOTE: Any PC in this list that does not complete the handshake within\n ArbitrationHandshakeTimeout will be kicked from the match"
        },
        "PercentForBadPing": {
          "comment": "The percentage of clients with bad ping before triggering the standby code"
        },
        "PercentMissingForRxStandby": {
          "comment": "The percentage of clients missing RX data before triggering the standby code"
        },
        "PercentMissingForTxStandby": {
          "comment": "The percentage of clients missing TX data before triggering the standby code"
        },
        "ServerOptions": {
          "comment": "The options to apply for dedicated server when it starts to register"
        },
        "StandbyRxCheatTime": {
          "comment": "The amount of time without packets before triggering the cheat code"
        },
        "StandbyTxCheatTime": {
          "comment": "The amount of time without packets before triggering the cheat code"
        },
        "TimeMarginSlack": {
          "comment": "How fast we allow client clock to drift from server clock over time without ever triggering speed hack detection"
        },
        "TotalNetBandwidth": {
          "comment": "Total available bandwidth for listen server, split dynamically across net connections"
        }
      },
      "functions": {
        "AddInactivePRI": {
          "comment": "AddInactivePRI()\n Add PRI to the inactive list, remove from the active list"
        },
        "ArbitrationRegistrationComplete": {
          "comment": "Callback from the server that starts the match if the registration was\n successful. If not, it goes back to the menu",
          "params": {
            "SessionName": "the name of the session this is for",
            "bWasSuccessful": "whether the registration worked or not"
          }
        },
        "ArbitrationTimeout": {
          "comment": "Handles kicking any clients that haven't completed handshaking"
        },
        "BeginBVT": {
          "comment": "This is for the QA team who don't use UFE nor commandline :-("
        },
        "BestNextHostSort": {
          "comment": "Sort the list of best hosts. Clients with the most peer connections come first.\n Then sort based on time of join so that newest players are preferred.",
          "params": {
            "A": "first item to compare",
            "B": "second item to compare"
          }
        },
        "CheckForSentinelRun": {
          "comment": "Asks AutoTestManager to start a sentinel run if needed\n Must be called by gameinfo subclass - not called in base implementation of GameInfo.StartMatch()"
        },
        "ChoosePlayerStart": {
          "comment": "ChoosePlayerStart()\n Return the 'best' player start for this player to start from. PlayerStarts are rated by RatePlayerStart().",
          "params": {
            "Player": "is the controller for whom we are choosing a playerstart",
            "InTeam": "specifies the Player's team (if the player hasn't joined a team yet)"
          }
        },
        "ClearAutoLoginDelegates": {
          "comment": "Clears the login delegates once the login process has passed or failed"
        },
        "ClearPause": {
          "comment": "Checks the list of delegates to determine if the pausing can be cleared. If\n the delegate says it's ok to unpause, that delegate is removed from the list\n and the rest are checked. The game is considered unpaused when the list is\n empty."
        },
        "DebugPause": {
          "comment": "Dumps the pause delegate list to track down who has the game paused"
        },
        "DiscardInventory": {
          "comment": "Discard a player's inventory after he dies."
        },
        "DisplayDebug": {
          "comment": "Use 'ShowGameDebug' console command to show this debug info\n Useful to show general debug info not tied to a particular actor physically in the level."
        },
        "DoNavFearCostFallOff": {
          "comment": "Update navigation point fear cost fall off."
        },
        "DoTravelTheWorld": {
          "comment": "function to start the world traveling"
        },
        "EnableStandbyCheatDetection": {
          "comment": "Turns standby detection on/off",
          "params": {
            "bIsEnabled": "true to turn it on, false to disable it"
          }
        },
        "EndOnlineGame": {
          "comment": "Tells the online system to end the game and tells all clients to do the same"
        },
        "FindInactivePRI": {
          "comment": "FindInactivePRI()\n returns the PRI associated with this re-entering player"
        },
        "FindPlayerStart": {
          "comment": "FindPlayerStart()\n Return the 'best' player start for this player to start from. PlayerStarts are rated by RatePlayerStart().",
          "params": {
            "Player": "is the controller for whom we are choosing a playerstart",
            "InTeam": "specifies the Player's team (if the player hasn't joined a team yet)",
            "IncomingName": "specifies the tag of a teleporter to use as the Playerstart"
          }
        },
        "ForceClearUnpauseDelegates": {
          "comment": "Forcibly removes an object's CanUnpause delegates from the list of pausers. If any of the object's CanUnpause delegate\n handlers were in the list, triggers a call to ClearPause().\n Called when the player controller is being destroyed to prevent the game from being stuck in a paused state when a PC that\n paused the game is destroyed before the game is unpaused."
        },
        "GameEventsPoll": {
          "comment": "Entry point of the stats code for custom game logging at a regular interval"
        },
        "GenericPlayerInitialization": {
          "comment": "handles all player initialization that is shared between the travel methods\n (i.e. called from both PostLogin() and HandleSeamlessTravelPlayer())"
        },
        "GetDefaultPlayerClass": {
          "comment": "Returns the default pawn class for the specified controller,",
          "params": {
            "C": "controller to figure out pawn class for"
          }
        },
        "GetMapCommonPackageName": {
          "comment": "Retrieve the name of the common package (if any) for the given map filename.",
          "params": {
            "InFilename": "The map file name",
            "OutCommonPackageName": "The nane of the common package for the given map"
          }
        },
        "GetSeamlessTravelActorList": {
          "comment": "called on server during seamless level transitions to get the list of Actors that should be moved into the new level\n PlayerControllers, Role < ROLE_Authority Actors, and any non-Actors that are inside an Actor that is in the list\n (i.e. Object.Outer == Actor in the list)\n are all autmoatically moved regardless of whether they're included here\n only dynamic (!bStatic and !bNoDelete) actors in the PersistentLevel may be moved (this includes all actors spawned during gameplay)\n this is called for both parts of the transition because actors might change while in the middle (e.g. players might join or leave the game)\n \n@see also PlayerController::GetSeamlessTravelActorList() (the function that's called on clients)",
          "params": {
            "bToEntry": "true if we are going from old level -> entry, false if we are going from entry -> new level",
            "ActorList": "(out) list of actors to maintain"
          }
        },
        "GetSupportedGameTypes": {
          "comment": "Retrieve the FGameTypePrefix struct for the given map filename.",
          "params": {
            "InFilename": "The map file name",
            "OutGameType": "The gametype prefix struct to fill in",
            "bCheckExt": "Optional parameter to check the extension of the InFilename to ensure it is a map"
          }
        },
        "GetTravelType": {
          "comment": "Returns true if we want to travel_absolute"
        },
        "HandleSeamlessTravelPlayer": {
          "comment": "handles reinitializing players that remained through a seamless level transition\n called from C++ for players that finished loading after the server",
          "params": {
            "C": "the Controller to handle"
          }
        },
        "MatineeCancelled": {
          "comment": "Called when this PC is in cinematic mode, and its matinee is cancelled by the user."
        },
        "ModifyScoreKill": {
          "comment": "For subclasses which don't call GameInfo.ScoreKill()"
        },
        "NotifyArbitratedMatchEnd": {
          "comment": "Tells all clients to disconnect and then goes to the menu"
        },
        "NotifyNavigationChanged": {
          "comment": "notification when a NavigationPoint becomes blocked or unblocked"
        },
        "NotifyPendingConnectionLost": {
          "comment": "Called when a connection closes before getting to PostLogin()"
        },
        "OnDestroyOnlineGameComplete": {
          "comment": "Used to create a new online session after the previous one has been destroyed after travelling",
          "params": {
            "SessionName": "The name of the game session (not used with Steamworks)",
            "bWasSuccesful": "Whether or not the session was succesfully destroyed"
          }
        },
        "OnEngineHasLoaded": {
          "comment": "Notifies the game code that the engine has finished loading. This\n function will only be called one time only."
        },
        "OnLoginChange": {
          "comment": "Used to tell the game when the autologin has completed",
          "params": {
            "LocalUserNum": "ignored"
          }
        },
        "OnLoginFailed": {
          "comment": "Called if the autologin fails",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "ErrorCode": "the async error code that occurred"
          }
        },
        "OnServerCreateComplete": {
          "comment": "Notifies us of the game being registered successfully or not",
          "params": {
            "SessionName": "the name of the session that was created",
            "bWasSuccessful": "flag telling us whether it worked or not"
          }
        },
        "OnStartOnlineGameComplete": {
          "comment": "Callback when the start completes",
          "params": {
            "SessionName": "the name of the session this is for",
            "bWasSuccessful": "true if it worked, false otherwise"
          }
        },
        "OverridePRI": {
          "comment": "OverridePRI()\n override as needed properties of NewPRI with properties from OldPRI which were assigned during the login process"
        },
        "PerformEndGameHandling": {
          "comment": "Does end of game handling for the online layer"
        },
        "PickupQuery": {
          "comment": "Called when pawn has a chance to pick Item up (i.e. when\n the pawn touches a weapon pickup). Should return true if\n he wants to pick it up, false if he does not want it.",
          "params": {
            "Other": "the Pawn that wants the item",
            "ItemClass": "the Inventory class the Pawn can pick up",
            "Pickup": "the Actor containing that item (this may be a PickupFactory or it may be a DroppedPickup)"
          }
        },
        "PostCommitMapChange": {
          "comment": "Called from C++'s CommitMapChange after unloading previous level and loading new level+sublevels"
        },
        "PostSeamlessTravel": {
          "comment": "called after a seamless level transition has been completed on the *new* GameInfo\n used to reinitialize players already in the game as they won't have *Login() called on them"
        },
        "PreBeginPlay": {
          "comment": "Allows for game classname remapping and/or aliasing (e.g. for shorthand names)"
        },
        "PreCommitMapChange": {
          "comment": "Called from C++'s CommitMapChange before unloading previous level",
          "params": {
            "PreviousMapName": "Name of the previous persistent level",
            "NextMapName": "Name of the persistent level being streamed to"
          }
        },
        "PreExit": {
          "comment": "Engine is shutting down."
        },
        "ProcessClientRegistrationCompletion": {
          "comment": "Removes the player controller from the pending list. Kicks that PC if it\n failed to register for arbitration. Starts the match if all clients have\n completed their registration",
          "params": {
            "PC": "the player controller to mark as done",
            "bWasSuccessful": "whether the PC was able to register for arbitration or not"
          }
        },
        "ProcessClientTravel": {
          "comment": "Notifies all clients to travel to the specified URL.",
          "params": {
            "URL": "a string containing the mapname (or IP address) to travel to, along with option key/value pairs",
            "NextMapGuid": "the GUID of the server's version of the next map",
            "bSeamless": "indicates whether the travel should use seamless travel or not.",
            "bAbsolute": "indicates which type of travel the server will perform (i.e. TRAVEL_Relative or TRAVEL_Absolute)"
          }
        },
        "ProcessServerLogin": {
          "comment": "Checks for the login parameters being passed on the command line. If\n present, it does an async login before starting the dedicated server\n registration process"
        },
        "RatePlayerStart": {
          "comment": "RatePlayerStart()\n Return a score representing how desireable a playerstart is.",
          "params": {
            "P": "is the playerstart being rated",
            "Team": "is the team of the player choosing the playerstart",
            "Player": "is the controller choosing the playerstart"
          }
        },
        "RecalculateSkillRating": {
          "comment": "Used by the game type to update the advertised skill for this game"
        },
        "RegisterServer": {
          "comment": "Registers the dedicated server with the online service"
        },
        "RegisterServerForArbitration": {
          "comment": "Does the registration for the server. This must be done last as it\n includes all the players info from their registration"
        },
        "ReplicateStreamingStatus": {
          "comment": "replicates the current level streaming status to the given PlayerController"
        },
        "ResetLevel": {
          "comment": "Resets level by calling Reset() on all actors"
        },
        "SetBandwidthLimit": {
          "comment": "Alters the synthetic bandwidth limit for a running game"
        },
        "SetPause": {
          "comment": "Adds the delegate to the list if the player controller has the right to pause\n the game. The delegate is called to see if it is ok to unpause the game, e.g.\n the reason the game was paused has been cleared.",
          "params": {
            "PC": "the player controller to check for admin privs",
            "CanUnpauseDelegate": "the delegate to query when checking for unpause"
          }
        },
        "ShouldRespawn": {
          "comment": "Return whether an item should respawn. Default implementation allows item respawning in multiplayer games."
        },
        "ShouldSpawnAtStartSpot": {
          "comment": "returns whether the given Controller StartSpot property should be used as the spawn location for its Pawn"
        },
        "SpawnDefaultPawnFor": {
          "comment": "Returns a pawn of the default pawn class",
          "params": {
            "NewPlayer": "Controller for whom this pawn is spawned",
            "StartSpot": "PlayerStart at which to spawn pawn"
          }
        },
        "SpawnPlayerController": {
          "comment": "spawns a PlayerController at the specified location; split out from Login()/HandleSeamlessTravelPlayer() for easier overriding"
        },
        "StandbyCheatDetected": {
          "comment": "Notifies the game code that a standby cheat was detected",
          "params": {
            "StandbyType": "the type of cheat detected"
          }
        },
        "StartArbitratedMatch": {
          "comment": "Called once arbitration has completed and kicks off the real start of the match"
        },
        "StartArbitrationRegistration": {
          "comment": "Kicks off the async tasks of having the clients register with\n arbitration before the server does. Sets a timeout for when\n all slow to respond clients get kicked"
        },
        "StartMatch": {
          "comment": "Tells all of the currently connected clients to register with arbitration.\n The clients will call back to the server once they have done so, which\n will tell this state to see if it is time for the server to register with\n arbitration."
        },
        "StartOnlineGame": {
          "comment": "Tells the online system to start the game and waits for the callback. Tells\n each connected client to mark their session as in progress"
        },
        "SwapPlayerControllers": {
          "comment": "used to swap a viewport/connection's PlayerControllers when seamless travelling and the new gametype's\n controller class is different than the previous\n includes network handling",
          "params": {
            "OldPC": "the old PC that should be discarded",
            "NewPC": "the new PC that should be used for the player"
          }
        },
        "TellClientsPartyHostIsLeaving": {
          "comment": "Send notification to clients that a party host is about to leave the match",
          "params": {
            "PartyHostPlayerId": "net id of the party host that is leaving"
          }
        },
        "TellClientsToReturnToPartyHost": {
          "comment": "Iterates the player controllers and tells them to return to their party"
        },
        "TellClientsToTravelToSession": {
          "comment": "Iterates the player controllers and tells remote players to travel to the specified session",
          "params": {
            "SessionName": "the name of the session to register",
            "SearchClass": "the search that should be populated with the session",
            "PlatformSpecificInfo": "the binary data to place in the platform specific areas"
          }
        },
        "UnregisterPlayer": {
          "comment": "Removes the player from the named session when they leave",
          "params": {
            "PC": "the player controller that just left"
          }
        },
        "UpdateBestNextHosts": {
          "comment": "Updates the list of best next hosts on the current server and also replicates this list to all clients."
        },
        "UpdateGameplayMuteList": {
          "comment": "Used to notify the game type that it is ok to update a player's gameplay\n specific muting information now. The playercontroller needs to notify\n the server when it is possible to do so or the unique net id will be\n incorrect and the muting not work.",
          "params": {
            "PC": "the playercontroller that is ready for updates"
          }
        },
        "UpdateGameSettings": {
          "comment": "Used to update any changes in game settings that need to be published to\n players that are searching for games"
        },
        "UpdateGameSettingsCounts": {
          "comment": "Updates the online subsystem's information for player counts so that\n LAN matches can show the correct player counts"
        },
        "WriteOnlinePlayerScores": {
          "comment": "If the match is arbitrated, tells all clients to write out their copies\n of the player scores. If not arbitrated, it only has the first local player\n write the scores."
        },
        "WriteOnlineStats": {
          "comment": "Tells all clients to write stats and then handles writing local stats"
        }
      },
      "structs": {
        "GameClassShortName": {
          "comment": "End standby cheat vars"
        },
        "GameTypePrefix": {
          "comment": "GameTypePrefix helper structure.\n Used to find valid gametypes for a map via its prefix.",
          "properties": {
            "AdditionalGameTypes": {
              "comment": "additional gametypes supported by this map prefix via the URL (used for cooking)"
            },
            "bUsesCommonPackage": {
              "comment": "if TRUE, generate a common package for the gametype"
            },
            "ForcedObjects": {
              "comment": "forced objects (and classes) that should go into the common package to avoid cooking into every map"
            },
            "GameType": {
              "comment": "gametype used if none specified on the URL"
            },
            "Prefix": {
              "comment": "map prefix, e.g. \"DM\""
            }
          }
        }
      }
    },
    "GameplayEvents": {
      "comment": "Gameplay event interface",
      "properties": {
        "ActorArray": {
          "comment": "The set of actors recorded during gameplay"
        },
        "Archive": {
          "comment": "FArchive pointer to serialize the data to/from disk"
        },
        "CurrentSessionInfo": {
          "comment": "Information specific to the session when it was run"
        },
        "DamageClassArray": {
          "comment": "The set of damage types recorded during gameplay"
        },
        "Header": {
          "comment": "Header of the gameplay events file"
        },
        "PawnClassArray": {
          "comment": "The set of pawns recorded during gameplay"
        },
        "PlayerList": {
          "comment": "Array of all players 'seen' by the game in this session"
        },
        "ProjectileClassArray": {
          "comment": "The set of projectiles recorded during gameplay"
        },
        "SoundCueArray": {
          "comment": "The set of sound cues encountered during gameplay"
        },
        "StatsFileName": {
          "comment": "The name of the file we are writing the data to (const so set only upon create natively)"
        },
        "SupportedEvents": {
          "comment": "The set of events that the game supports writing to disk"
        },
        "TeamList": {
          "comment": "Array of all teams 'seen' by the game in this session"
        },
        "WeaponClassArray": {
          "comment": "The set of weapons recorded during gameplay"
        }
      },
      "functions": {
        "CloseStatsFile": {
          "comment": "Closes and deletes the archive created\n clearing all data stored within"
        },
        "GetFilename": {
          "comment": "Retrieve the name of the file last in use by the gameplay event serializer, possibly empty"
        },
        "OpenStatsFile": {
          "comment": "Creates the archive that we are going to be manipulating",
          "params": {
            "Filename": "name of the file that will be open for serialization"
          }
        }
      },
      "structs": {
        "DamageClassEventData": {
          "comment": "Metadata describing the damage classes recorded during gameplay",
          "properties": {
            "DamageClassName": {
              "comment": "Name of the damage class used"
            }
          }
        },
        "GameplayEventMetaData": {
          "comment": "Holds the information describing a gameplay event",
          "properties": {
            "EventDataType": {
              "comment": "Type of data associated with this event"
            },
            "EventID": {
              "comment": "The unique id of the event (16 bits clamped)"
            },
            "EventName": {
              "comment": "Human readable name of the event"
            },
            "StatGroup": {
              "comment": "Group that this stat belongs to, for filtering"
            }
          }
        },
        "GameplayEventsHeader": {
          "comment": "Basic file header when writing to disk",
          "properties": {
            "AggregateOffset": {
              "comment": "Offset into the file for aggregate data"
            },
            "EngineVersion": {
              "comment": "Version of engine at the time of writing the file"
            },
            "FileSize": {
              "comment": "File size on disk"
            },
            "FilterClass": {
              "comment": "What filter class is being used on the data, if any"
            },
            "Flags": {
              "comment": "Various settings"
            },
            "FooterOffset": {
              "comment": "Offset into the file where the metadata is written"
            },
            "StatsWriterVersion": {
              "comment": "Version of the stats format at the time of writing the file"
            },
            "StreamOffset": {
              "comment": "Offset into the file for the stream data"
            },
            "TotalStreamSize": {
              "comment": "Amount of data in the stream (not including header/footer data)"
            }
          }
        },
        "GameSessionInformation": {
          "comment": "Game stats session information recorded at log start",
          "properties": {
            "AppTitleID": {
              "comment": "Unique title identifier"
            },
            "bGameplaySessionInProgress": {
              "comment": "Is a session currently in progress"
            },
            "GameClassName": {
              "comment": "Name of the game class used"
            },
            "GameplaySessionEndTime": {
              "comment": "Time this session was ended (game time)"
            },
            "GameplaySessionID": {
              "comment": "Unique session ID"
            },
            "GameplaySessionStartTime": {
              "comment": "Time this session was started (game time)"
            },
            "GameplaySessionTimestamp": {
              "comment": "Time this session was begun (real time)"
            },
            "GameTypeId": {
              "comment": "Gametype ID"
            },
            "Language": {
              "comment": "Language the session was run in"
            },
            "MapName": {
              "comment": "Name of map at time of session"
            },
            "MapURL": {
              "comment": "Game URL at time of session"
            },
            "OwningNetId": {
              "comment": "UniqueID of player logging stats"
            },
            "PlatformType": {
              "comment": "Platform the session was run on"
            },
            "SessionInstance": {
              "comment": "Value used to distinguish between contiguous sections"
            }
          }
        },
        "GameStatGroup": {
          "properties": {
            "Group": {
              "comment": "Group stat belongs to"
            },
            "Level": {
              "comment": "Level of the stat"
            }
          }
        },
        "PawnClassEventData": {
          "comment": "Metadata describing the pawn classes recorded during gameplay",
          "properties": {
            "PawnClassName": {
              "comment": "Name of the pawn class used"
            }
          }
        },
        "PlayerInformation": {
          "comment": "List of player information cached in case the player logs out and GC collects the objects",
          "properties": {
            "bIsBot": {
              "comment": "Whether the player is a bot or not"
            },
            "ControllerName": {
              "comment": "Name of Controller object"
            },
            "PlayerName": {
              "comment": "Controller.PlayerReplicationInfo.PlayerName"
            },
            "UniqueId": {
              "comment": "UniqueID of the player"
            }
          }
        },
        "ProjectileClassEventData": {
          "comment": "Metadata describing the projectile classes recorded during gameplay",
          "properties": {
            "ProjectileClassName": {
              "comment": "name of the projectile class used"
            }
          }
        },
        "TeamInformation": {
          "comment": "List of team information cached during the play session",
          "properties": {
            "MaxSize": {
              "comment": "Max size during the game"
            },
            "TeamColor": {
              "comment": "Color of the team"
            },
            "TeamIndex": {
              "comment": "Index of the team in game"
            },
            "TeamName": {
              "comment": "Name of the team"
            }
          }
        },
        "WeaponClassEventData": {
          "comment": "Metadata describing the weapon classes recorded during gameplay",
          "properties": {
            "WeaponClassName": {
              "comment": "Name of the weapon class used"
            }
          }
        }
      }
    },
    "GameplayEventsHandler": {
      "comment": "Interface for processing events as they are read out of the game stats stream",
      "properties": {
        "EventIDFilter": {
          "comment": "Array of event types that will be ignored"
        },
        "GroupFilter": {
          "comment": "Array of groups to filter, expands out into EventIDFilter above"
        },
        "Reader": {
          "comment": "Reference to the reader for access to metadata, etc"
        }
      },
      "functions": {
        "AddFilter": {
          "comment": "Add an event id to ignore while processing"
        },
        "PostProcessStream": {
          "comment": "A chance to do something after the stream ends"
        },
        "PreProcessStream": {
          "comment": "A chance to do something before the stream starts"
        },
        "RemoveFilter": {
          "comment": "Remove an event id to ignore while processing"
        },
        "ResolveGroupFilters": {
          "comment": "Iterate over all events, checking to see if they should be filtered out by their group"
        },
        "SetReader": {
          "comment": "Set the reader on this handler"
        }
      }
    },
    "GameplayEventsReader": {
      "comment": "Streams gameplay events recorded during a session to disk",
      "properties": {
        "RegisteredHandlers": {
          "comment": "Array of handlers for this file when it processes"
        }
      },
      "functions": {
        "CloseStatsFile": {
          "comment": "Closes and deletes the archive being read from\n clearing all data stored within"
        },
        "GetPlatform": {
          "comment": "Return the platform the data was recorded on"
        },
        "GetSessionDuration": {
          "comment": "Return the total time the session lasted"
        },
        "GetSessionEnd": {
          "comment": "Get the time the session ended"
        },
        "GetSessionID": {
          "comment": "Return the unique session ID"
        },
        "GetSessionStart": {
          "comment": "Get the time the session started"
        },
        "GetSessionTimestamp": {
          "comment": "Return the timestamp the session started recording"
        },
        "GetTitleID": {
          "comment": "Return the title ID of the recorded session"
        },
        "OpenStatsFile": {
          "comment": "Loads a stat file from disk",
          "params": {
            "Filename": "name of the file that will be open for serialization"
          }
        },
        "ProcessStream": {
          "comment": "Read / process stream data from the file"
        },
        "ProcessStreamEnd": {
          "comment": "Signal end of stream processing"
        },
        "ProcessStreamStart": {
          "comment": "Signal start of stream processing"
        },
        "RegisterHandler": {
          "comment": "Register a handler with this reader"
        },
        "SerializeHeader": {
          "comment": "Serialize the contents of the file header"
        },
        "UnregisterHandler": {
          "comment": "Unregister a handler with this reader"
        }
      }
    },
    "GameplayEventsWriter": {
      "comment": "Streams gameplay events recorded during a session to disk",
      "properties": {
        "Game": {
          "comment": "Reference to the game (set by StartLogging/EndLogging)"
        }
      },
      "functions": {
        "CloseStatsFile": {
          "comment": "Closes and deletes the archive that was being written to\n clearing all data stored within"
        },
        "EndLogging": {
          "comment": "Mark the end of a logging session\n closes file, stops polling, etc"
        },
        "GetGenericParamListEntry": {
          "comment": "will return a generic param list entry that can then have params set on it before commiting to disk"
        },
        "IsSessionInProgress": {
          "comment": "Returns whether or not a logging session has been started"
        },
        "LogAllPlayerPositionsEvent": {
          "comment": "Logs the location of all players when this event occurred",
          "params": {
            "EventId": "the event being logged"
          }
        },
        "LogDamageEvent": {
          "comment": "Logs damage with the amount that was done and to whom it was done",
          "params": {
            "EventId": "the event being logged",
            "Player": "the player that triggered the event",
            "DmgType": "the damage type that was done",
            "Target": "the player being damaged",
            "Amount": "the amount of damage done"
          }
        },
        "LogGameFloatEvent": {
          "comment": "Logs a float based game event",
          "params": {
            "EventId": "the event being logged",
            "Value": "the value associated with the event"
          }
        },
        "LogGameIntEvent": {
          "comment": "Logs an int base game event",
          "params": {
            "EventId": "the event being logged",
            "Value": "the value associated with the event"
          }
        },
        "LogGamePositionEvent": {
          "comment": "Logs a position based game event",
          "params": {
            "EventId": "the event being logged",
            "Position": "the position of the event",
            "Value": "the value associated with the event"
          }
        },
        "LogGameStringEvent": {
          "comment": "Logs a string based game event",
          "params": {
            "EventId": "the event being logged",
            "Value": "the value associated with the event"
          }
        },
        "LogPlayerFloatEvent": {
          "comment": "Logs an event with an float value associated with it",
          "params": {
            "EventId": "the event being logged",
            "Player": "the player that triggered the event",
            "Value": "the value for this event"
          }
        },
        "LogPlayerIntEvent": {
          "comment": "Logs an event with an integer value associated with it",
          "params": {
            "EventId": "the event being logged",
            "Player": "the player that triggered the event",
            "Value": "the value for this event"
          }
        },
        "LogPlayerKillDeath": {
          "comment": "Logs a player killing and a player being killed",
          "params": {
            "EventId": "the event that should be written",
            "KillType": "the additional information about a kill",
            "Killer": "the player that did the killing",
            "DmgType": "the damage type that was done",
            "Dead": "the player that was killed"
          }
        },
        "LogPlayerLoginChange": {
          "comment": "Logs when a player leaves/joins a session",
          "params": {
            "EventId": "the login/logout event for the player",
            "Player": "the player that joined/left",
            "PlayerName": "the name of the player in question",
            "PlayerId": "the net id of the player in question",
            "bSplitScreen": "whether the player is on splitscreen"
          }
        },
        "LogPlayerPlayerEvent": {
          "comment": "Logs a player to player event",
          "params": {
            "EventId": "the event that should be written",
            "Player": "the player that triggered the event",
            "Target": "the player that was the recipient"
          }
        },
        "LogPlayerSpawnEvent": {
          "comment": "Logs a spawn event for a player (team, class, etc)",
          "params": {
            "EventId": "the event being logged",
            "Player": "the player that triggered the event",
            "PawnClass": "the pawn this player spawned with",
            "Team": "the team the player is on"
          }
        },
        "LogPlayerStringEvent": {
          "comment": "Logs an event with an string value associated with it",
          "params": {
            "EventId": "the event being logged",
            "Player": "the player that triggered the event",
            "EventString": "the value for this event"
          }
        },
        "LogProjectileIntEvent": {
          "comment": "Logs a projectile event with an integer value associated with it",
          "params": {
            "EventId": "the event being logged",
            "Player": "the player that triggered the event",
            "Proj": "the projectile class associated with the event",
            "Value": "the value for this event"
          }
        },
        "LogSystemPollEvents": {
          "comment": "Log various system properties like memory usage, network usage, etc."
        },
        "LogTeamFloatEvent": {
          "comment": "Logs a float based team event",
          "params": {
            "EventId": "the event being logged",
            "Team": "the team associated with this event",
            "Value": "the value associated with the event"
          }
        },
        "LogTeamIntEvent": {
          "comment": "Logs a int based team event",
          "params": {
            "EventId": "the event being logged",
            "Team": "the team associated with this event",
            "Value": "the value associated with the event"
          }
        },
        "LogTeamStringEvent": {
          "comment": "Logs a string based team event",
          "params": {
            "EventId": "the event being logged",
            "Team": "the team associated with this event",
            "Value": "the value associated with the event"
          }
        },
        "LogWeaponIntEvent": {
          "comment": "Logs a weapon event with an integer value associated with it",
          "params": {
            "EventId": "the event being logged",
            "Player": "the player that triggered the event",
            "WeaponClass": "the weapon class associated with the event",
            "Value": "the value for this event"
          }
        },
        "OpenStatsFile": {
          "comment": "Creates the archive that we are going to write to",
          "params": {
            "Filename": "name of the file that will be open for serialization"
          }
        },
        "Poll": {
          "comment": "Heartbeat function to record various stats (player location, etc)"
        },
        "ResetLogging": {
          "comment": "Resets the session, clearing all event data, but keeps the session ID/Timestamp intact",
          "params": {
            "HeartbeatDelta": "polling frequency (0 turns it off)"
          }
        },
        "ResolvePlayerIndex": {
          "comment": "Turns a controller into a player index, possibly adding new information to the player array"
        },
        "SerializeFooter": {
          "comment": "Serialize the contents of the file footer"
        },
        "SerializeHeader": {
          "comment": "Serialize the contents of the file header"
        },
        "StartLogging": {
          "comment": "Mark a new session, clear existing events, etc",
          "params": {
            "HeartbeatDelta": "polling frequency (0 turns it off)"
          }
        }
      }
    },
    "GameReplicationInfo": {
      "properties": {
        "bMatchHasBegun": {
          "comment": "Match is in progress (replicated)"
        },
        "bMatchIsOver": {
          "comment": "Match is over (replicated)"
        },
        "bStopCountDown": {
          "comment": "If true, stop RemainingTime countdown"
        },
        "ElapsedTime": {
          "comment": "Used for counting down time in time limited games"
        },
        "GameClass": {
          "comment": "Class of the server's gameinfo, assigned by GameInfo."
        },
        "GoalScore": {
          "comment": "Replicates scoring goal for this match"
        },
        "InactivePRIArray": {
          "comment": "This list mirrors the GameInfo's list of inactive PRI objects"
        },
        "PRIArray": {
          "comment": "Array of all PlayerReplicationInfos, maintained on both server and clients (PRIs are always relevant)"
        },
        "RemainingMinute": {
          "comment": "Used for counting down time in time limited games"
        },
        "RemainingTime": {
          "comment": "Used for counting down time in time limited games"
        },
        "Teams": {
          "comment": "Replicated list of teams participating in this match"
        },
        "TimeLimit": {
          "comment": "Replicates time limit for this match"
        },
        "Winner": {
          "comment": "Match winner. Set by gameinfo when game ends"
        },
        "ServerName": {
          "comment": "Name of the server, i.e.: Bob's Server."
        }
      },
      "functions": {
        "EndGame": {
          "comment": "Called on the server when the match is over\n Network - Server and Client (Via ReplicatedEvent)"
        },
        "IsCoopMultiplayerGame": {
          "comment": "Is the current gametype a coop multiplayer game?"
        },
        "IsMultiplayerGame": {
          "comment": "Is the current gametype a multiplayer game?"
        },
        "OnSameTeam": {
          "comment": "Checks to see if two actors are on the same team."
        },
        "ReceivedGameClass": {
          "comment": "Called when the GameClass property is set (at startup for the server, after the variable has been replicated on clients)"
        },
        "SetTeam": {
          "comment": "Assigns the specified TeamInfo to the location specified.",
          "params": {
            "Index": "location in the Teams array to place the new TeamInfo.",
            "TI": "the TeamInfo to assign"
          }
        },
        "ShouldShowGore": {
          "comment": "Should players show gore?"
        },
        "StartMatch": {
          "comment": "Called on the server when the match has begin\n Network - Server and Client (Via ReplicatedEvent)"
        }
      }
    },
    "GameUISceneClient": {
      "properties": {
        "AxisInputKeys": {
          "comment": "The list of axis input keys to check input support for"
        },
        "bCaptureUnprocessedInput": {
          "comment": "Controls whether the UI system should prevent the game from recieving input whenever it's active. For games with\n interactive menus that remain on-screen during gameplay, you'll want to change this value to FALSE."
        },
        "bEnableDebugInput": {
          "comment": "Controls whether debug input commands are accepted"
        },
        "bRenderDebugInfo": {
          "comment": "Controls whether debug information about the scene is rendered"
        },
        "bUpdateInputProcessingStatus": {
          "comment": "Indicates that the input processing status of the UI has potentially changed; causes UpdateInputProcessingStatus to be called\n in the next Tick()."
        },
        "bUpdateSceneViewportSizes": {
          "comment": "Indicates that the viewport size being used by one or more scenes is out of date; triggers a call to NotifyViewportResized during the\n next tick."
        },
        "DoubleClickStartPosition": {
          "comment": "The location of the mouse the last time a key press was received. Used to determine when to simulate a double-click\n event."
        },
        "DoubleClickStartTime": {
          "comment": "The time (in seconds) that the last \"key down\" event was recieved from a key that can trigger double-click events"
        },
        "InitialPressedKeys": {
          "comment": "map of controllerID to list of keys which were pressed when the UI began processing input\n used to ignore the initial \"release\" key event from keys which were already pressed when the UI began processing input."
        },
        "LatestDeltaTime": {
          "comment": "Cached DeltaTime value from the last Tick() call"
        },
        "NavAliases": {
          "comment": "The list of navigation aliases to check input support for"
        }
      },
      "functions": {
        "CanUnpauseInternalUI": {
          "comment": "Callback which allows the UI to prevent unpausing if scenes which require pausing are still active.\n @see PlayerController.SetPause"
        },
        "FindLocalPlayerIndex": {
          "comment": "Helper function to deduce the PlayerIndex of a Player",
          "params": {
            "P": "The LocalPlayer for whom you wish to deduce their PlayerIndex"
          }
        },
        "NotifyClientTravel": {
          "comment": "Called when the local player is about to travel to a new URL. This callback should be used to perform any preparation\n tasks, such as updating status text and such. All cleanup should be done from NotifyGameSessionEnded, as that function\n will be called in some cases where NotifyClientTravel is not.",
          "params": {
            "TravellingPlayer": "the player that received the call to ClientTravel",
            "TravelURL": "a string containing the mapname (or IP address) to travel to, along with option key/value pairs",
            "TravelType": "indicates whether the player will clear previously added URL options or not.",
            "bIsSeamlessTravel": "indicates whether seamless travelling will be used."
          }
        },
        "NotifyGameSessionEnded": {
          "comment": "Called when the current map is being unloaded. Cleans up any references which would prevent garbage collection."
        },
        "NotifyPlayerAdded": {
          "comment": "Called when a new player has been added to the list of active players (i.e. split-screen join)",
          "params": {
            "PlayerIndex": "the index [into the GamePlayers array] where the player was inserted",
            "AddedPlayer": "the player that was added"
          }
        },
        "NotifyPlayerRemoved": {
          "comment": "Called when a player has been removed from the list of active players (i.e. split-screen players)",
          "params": {
            "PlayerIndex": "the index [into the GamePlayers array] where the player was located",
            "RemovedPlayer": "the player that was removed"
          }
        },
        "PauseGame": {
          "comment": "Wrapper for pausing the game.",
          "params": {
            "bDesiredPauseState": "TRUE indicates that the game should be paused.",
            "PlayerIndex": "the index [into Engine GamePlayers array] for the player that should be used for pausing the game; can\n affect whether the game is actually paused or not (i.e. if the player is an admin in a multi-player match,\n for example)."
          }
        },
        "RequestInputProcessingUpdate": {
          "comment": "Triggers a call to UpdateInputProcessingStatus on the next Tick()."
        }
      }
    },
    "GameViewportClient": {
      "properties": {
        "ActiveSplitscreenType": {
          "comment": "The splitscreen type that is actually being used; takes into account the number of players and other factors (such as cinematic mode)\n that could affect the splitscreen mode that is actually used."
        },
        "bDebugNoGFxUI": {
          "comment": "DEBUG: If TRUE, the GFx UI will NOT be rendered at runtime. Note that to REMOVE GFx functionality permanently, you should compile with WITH_GFx set to 0. This bool is for debugging only."
        },
        "bDisableWorldRendering": {
          "comment": "set to disable world rendering"
        },
        "bDisplayingUIMouseCursor": {
          "comment": "Indicates whether the UI is currently displaying a mouse cursor. Prevents GameEngine::Tick() from recapturing\n mouse input while the UI has active scenes that mouse input."
        },
        "bIsPlayInEditorViewport": {
          "comment": "If TRUE, this viewport is a play in editor viewport"
        },
        "bShowSystemMouseCursor": {
          "comment": "If TRUE, we will show the OS mouse cursor at all times (only applies to PIE viewports)"
        },
        "bShowTitleSafeZone": {
          "comment": "if TRUE then the title safe border is drawn"
        },
        "bUIMouseCaptureOverride": {
          "comment": "Indicates that the UI needs to receive all mouse input events. Usually enabled when the user is interacting with a\n draggable widget, such as a scrollbar or slider."
        },
        "bUseHardwareCursorWhenWindowed": {
          "comment": "A temporary workaround for seeing dobule cursors in UDK Game. We need a complete solution that handles this robustly for all GFx UIs"
        },
        "Default2PSplitType": {
          "comment": "Defaults for intances where there are multiple configs for a certain number of players"
        },
        "DesiredSplitscreenType": {
          "comment": "The splitscreen layout type that the player wishes to use; this value usually comes from places like the player's profile"
        },
        "GlobalInteractions": {
          "comment": "A list of interactions which have a chance at all input before the player's interactions."
        },
        "LoadingMessage": {
          "comment": "@name Localized transition messages."
        },
        "ScaleformInteraction": {
          "comment": "Stores the pointer to any data needed for scaleform (if defined)"
        },
        "ShowFlags": {
          "comment": "The show flags used by the viewport's players."
        },
        "SplitscreenInfo": {
          "comment": "Array of the screen data needed for all the different splitscreen configurations"
        },
        "TitleSafeZone": {
          "comment": "border of safe area"
        },
        "UIController": {
          "comment": "The viewport's UI controller"
        },
        "UIControllerClass": {
          "comment": "The class for the UI controller"
        },
        "Viewport": {
          "comment": "The platform-specific viewport which this viewport client is attached to."
        },
        "ViewportConsole": {
          "comment": "The viewport's console. Might be null on consoles"
        },
        "ViewportFrame": {
          "comment": "The platform-specific viewport frame which this viewport is contained by."
        }
      },
      "functions": {
        "AddLocalPlayer": {
          "comment": "Adds a LocalPlayer to the local and global list of Players.",
          "params": {
            "NewPlayer": "the player to add"
          }
        },
        "BecomePrimaryPlayer": {
          "comment": "Makes a player the primary player",
          "params": {
            "PlayerIndex": "The index of the player to be made into the primary player"
          }
        },
        "CalculateSafeZoneValues": {
          "comment": "Calculate the amount of safezone needed for a single side for both vertical and horizontal dimensions"
        },
        "ConsoleCommand": {
          "comment": "Executes a console command in the context of this viewport.",
          "params": {
            "Command": "The command to execute."
          }
        },
        "ConvertLocalPlayerToGamePlayerIndex": {
          "comment": "Convert a LocalPlayer to it's index in the GamePlayer array\n Returns -1 if the index could not be found."
        },
        "CreateInitialPlayer": {
          "comment": "Create the game's initial player at startup. First search for a player that is signed into the OnlineSubsystem; if none are found,\n create a player with a ControllerId of 0.",
          "params": {
            "OutError": "receives the error string if an error occurs while creating the player."
          }
        },
        "CreatePlayer": {
          "comment": "Adds a new player.",
          "params": {
            "ControllerId": "The controller ID the player should accept input from.",
            "OutError": "If no player is returned, OutError will contain a string describing the reason.",
            "SpawnActor": "True if an actor should be spawned for the new player."
          }
        },
        "DebugCreatePlayer": {
          "comment": "Debug console command to create a player.",
          "params": {
            "ControllerId": "The controller ID the player should accept input from."
          }
        },
        "DebugRemovePlayer": {
          "comment": "Debug console command to remove the player with a given controller ID.",
          "params": {
            "ControllerId": "The controller ID to search for."
          }
        },
        "DebugSetUISystemEnabled": {
          "comment": "DEBUG: function to easily allow script to turn on / off the two UI systems for developing during the transition from the old UI to the new GFx UI"
        },
        "DisplayProgressMessage": {
          "comment": "display progress messages in center of screen"
        },
        "DrawTitleSafeArea": {
          "comment": "Draw the safe area using the current TitleSafeZone settings"
        },
        "DrawTransition": {
          "comment": "Displays the transition screen.",
          "params": {
            "Canvas": "The canvas to use for rendering."
          }
        },
        "DrawTransitionMessage": {
          "comment": "Print a centered transition message with a drop shadow."
        },
        "FindPlayerByControllerId": {
          "comment": "Finds a player by controller ID.",
          "params": {
            "ControllerId": "The controller ID to search for."
          }
        },
        "FixupOwnerReferences": {
          "comment": "Called after the primary player has been changed so that the UI references to the owner are switched"
        },
        "GameSessionEnded": {
          "comment": "Called when the current map is being unloaded. Cleans up any references which would prevent garbage collection."
        },
        "GetCustomInteractionClass": {
          "comment": "Defining the above mentioned custom interactions"
        },
        "GetNumCustomInteractions": {
          "comment": "Function that allow for custom numbers of interactions dictated in code"
        },
        "GetPixelSizeOfScreen": {
          "comment": "Get the total pixel size of the screen.\n This is different from the pixel size of the viewport since we could be in splitscreen"
        },
        "GetPlayerOwner": {
          "comment": "Retrieves a reference to a LocalPlayer.",
          "params": {
            "PlayerIndex": "if specified, returns the player at this index in the GamePlayers array. Otherwise, returns\n the player associated with the owner scene."
          }
        },
        "GetSubtitleRegion": {
          "comment": "called before rending subtitles to allow the game viewport to determine the size of the subtitle area",
          "params": {
            "Min": "top left bounds of subtitle region (0 to 1)",
            "Max": "bottom right bounds of subtitle region (0 to 1)"
          }
        },
        "GetViewportSize": {
          "comment": "Retrieve the size of the main viewport.",
          "params": {
            "out_ViewportSize": "[out] will be filled in with the size of the main viewport"
          }
        },
        "HasBottomSafeZone": {
          "comment": "Whether the player at LocalPlayerIndex's viewport has a \"bottom of viewport\" safezone or not."
        },
        "HasLeftSafeZone": {
          "comment": "Whether the player at LocalPlayerIndex's viewport has a \"left of viewport\" safezone or not."
        },
        "HasRightSafeZone": {
          "comment": "Whether the player at LocalPlayerIndex's viewport has a \"right of viewport\" safezone or not."
        },
        "HasTopSafeZone": {
          "comment": "Whether the player at LocalPlayerIndex's viewport has a \"top of viewport\" safezone or not."
        },
        "Init": {
          "comment": "Initialize the game viewport.",
          "params": {
            "OutError": "If an error occurs, returns the error description."
          }
        },
        "InsertInteraction": {
          "comment": "Inserts an interaction into the GlobalInteractions array at the specified index",
          "params": {
            "NewInteraction": "the interaction that should be inserted into the array",
            "Index": "the position in the GlobalInteractions array to insert the element.\n if no value (or -1) is specified, inserts the interaction at the end of the array"
          }
        },
        "LayoutPlayers": {
          "comment": "Called before rendering to allow the game viewport to allocate subregions to players."
        },
        "NotifyConnectionError": {
          "comment": "Notifies the player that an attempt to connect to a remote server failed, or an existing connection was dropped.",
          "params": {
            "MessageType": "EProgressMessageType of current connection error",
            "Message": "a description of why the connection was lost",
            "Title": "the title to use in the connection failure message."
          }
        },
        "NotifyPlayerAdded": {
          "comment": "Notifies all interactions that a new player has been added to the list of active players.",
          "params": {
            "PlayerIndex": "the index [into the GamePlayers array] where the player was inserted",
            "AddedPlayer": "the player that was added"
          }
        },
        "NotifyPlayerRemoved": {
          "comment": "Notifies all interactions that a new player has been added to the list of active players.",
          "params": {
            "PlayerIndex": "the index [into the GamePlayers array] where the player was located",
            "RemovedPlayer": "the player that was removed"
          }
        },
        "NotifySplitscreenLayoutChanged": {
          "comment": "Function to notify GFx of a change in the splitscreen layout"
        },
        "OnPrimaryPlayerSwitch": {
          "comment": "Called after a new primary player has been made"
        },
        "PostRender": {
          "comment": "Called after rendering the player views and HUDs to render menus, the console, etc.\n This is the last rendering call in the render loop",
          "params": {
            "Canvas": "The canvas to use for rendering."
          }
        },
        "RemoveLocalPlayer": {
          "comment": "Removes a LocalPlayer from the local and global list of Players.",
          "params": {
            "ExistingPlayer": "the player to remove"
          }
        },
        "RemovePlayer": {
          "comment": "Removes a player.",
          "params": {
            "Player": "The player to remove."
          }
        },
        "SetConsoleTarget": {
          "comment": "Sets the player which console commands will be executed in the context of."
        },
        "SetCustomInteractionObject": {
          "comment": "Passing the custom interaction object back to native code to do with it as it likes"
        },
        "SetProgressMessage": {
          "comment": "handler for global state messages, generally network connection related (failures, download progress, etc)"
        },
        "SetSplit": {
          "comment": "debug test for testing splitscreens"
        },
        "SetSplitscreenConfiguration": {
          "comment": "Sets the screen layout configuration that the player wishes to use when in split-screen mode."
        },
        "ShouldForceFullscreenViewport": {
          "comment": "Determine whether a fullscreen viewport should be used in cases where there are multiple players."
        },
        "ShowTitleSafeArea": {
          "comment": "Exec for toggling the display of the title safe area"
        },
        "SSSwapControllers": {
          "comment": "Rotates controller ids among gameplayers, useful for testing splitscreen with only one controller."
        },
        "Tick": {
          "comment": "Called every frame to allow the game viewport to update time based state.",
          "params": {
            "DeltaTime": "The time since the last call to Tick."
          }
        },
        "UpdateActiveSplitscreenType": {
          "comment": "Sets the value of ActiveSplitscreenConfiguration based on the desired split-screen layout type, current number of players, and any other\n factors that might affect the way the screen should be layed out."
        }
      },
      "structs": {
        "DebugDisplayProperty": {
          "comment": "debug property display functionality\n to interact with this, use \"display\", \"displayall\", \"displayclear\"",
          "properties": {
            "bSpecialProperty": {
              "comment": "whether PropertyName is a \"special\" value not directly mapping to a real property (e.g. state name)"
            },
            "Obj": {
              "comment": "the object whose property to display. If this is a class, all objects of that class are drawn."
            },
            "PropertyName": {
              "comment": "name of the property to display"
            }
          }
        },
        "ExportShowFlags_Mirror": {
          "comment": "This empty struct is here so we have a non-native struct that can be exported to the header properly"
        },
        "PerPlayerSplitscreenData": {
          "comment": "Structure to store splitscreen data."
        },
        "ShowFlags_Mirror": {
          "comment": "This struct needs to be the same size as EShowFlags"
        },
        "SplitscreenData": {
          "comment": "Structure containing all the player splitscreen datas per splitscreen configuration."
        },
        "TitleSafeZoneArea": {
          "comment": "Max/Recommended screen viewable extents as a percentage"
        }
      }
    },
    "Goal_AtActor": {
      "properties": {
        "bKeepPartial": {
          "comment": "Should keep track of cheapest path even if don't reach goal"
        },
        "GoalActor": {
          "comment": "Actor to reach"
        },
        "GoalDist": {
          "comment": "Within this acceptable distance"
        }
      }
    },
    "Goal_Null": {
      "comment": "this goal eval will not stop until its out of paths, and will simply return the node with the least cost"
    },
    "GravityVolume": {
      "properties": {
        "GravityZ": {
          "comment": "Gravity along Z axis applied to objects inside this volume."
        }
      }
    },
    "HeadTrackingComponent": {
      "comment": "When you attach this class, make sure you don't have any other HeadTrackingComponent \n That will create conflict. It will warn if it already has headtrackingcomponent",
      "properties": {
        "CurrentActorMap": {
          "comment": "Array of actor information"
        },
        "RootMeshLocation": {
          "comment": "Cached value for where mesh location/rotation is at this tick"
        },
        "SkeletalMeshComp": {
          "comment": "SkeletalMeshComponent who owns this"
        },
        "TrackControls": {
          "comment": "Look at control"
        },
        "bDisableBeyondLimit": {
          "comment": "Interp back to zero strength if limit surpassed"
        },
        "LookAtActorRadius": {
          "comment": "Will pick up actor within this radius"
        },
        "MaxInterestTime": {
          "comment": "Once entered the radius, how long do I really care to look ? This affects rating. It will give benefit to the person who just entered"
        },
        "MaxLookAtTime": {
          "comment": "How long can one person to look at one"
        },
        "MinLookAtTime": {
          "comment": "At least this time to look at one"
        },
        "TrackControllerName": {
          "comment": "SkelControlLookAt name in the AnimTree of the SkeletalMesh"
        },
        "ActorClassesToLookAt": {
          "comment": "Actor classes to look at as 0 index being the highest priority if you have anything specific"
        },
        "TargetBoneNames": {
          "comment": "Target Bone Names, where to look at - priority from top to bottom, if not found, it will continue search"
        }
      },
      "structs": {
        "ActorToLookAt": {
          "comment": "Actor to look at information"
        }
      }
    },
    "HeightFog": {
      "properties": {
        "bEnabled": {
          "comment": "replicated copy of HeightFogComponent's bEnabled property"
        }
      }
    },
    "HeightFogComponent": {
      "properties": {
        "Height": {
          "comment": "z-height for the fog plane - updated by the owning actor"
        },
        "bEnabled": {
          "comment": "True if the fog is enabled."
        },
        "Density": {
          "comment": "affects the scale for the fog layer's thickness"
        },
        "ExtinctionDistance": {
          "comment": "The distance at which light passing through the fog is 100% extinguished."
        },
        "LightBrightness": {
          "comment": "affects the inscattering color"
        },
        "LightColor": {
          "comment": "Fog color to blend with the scene"
        },
        "StartDistance": {
          "comment": "distance at which fog starts affecting the scene"
        }
      },
      "functions": {
        "SetEnabled": {
          "comment": "Changes the enabled state of the height fog component.",
          "params": {
            "bSetEnabled": "The new value for bEnabled."
          }
        }
      }
    },
    "HUD": {
      "properties": {
        "bLostFocusPaused": {
          "comment": "Tells whether the game was paused due to lost focus"
        },
        "bShowOverlays": {
          "comment": "If true, render actor overlays"
        },
        "Canvas": {
          "comment": "Canvas to Draw HUD on."
        },
        "CenterX": {
          "comment": "Center of Viewport"
        },
        "CenterY": {
          "comment": "Center of Viewport"
        },
        "LastHUDRenderTime": {
          "comment": "Used to create DeltaTime"
        },
        "PostRenderedActors": {
          "comment": "Holds a list of Actors that need PostRender calls"
        },
        "RatioX": {
          "comment": "Ratio of viewport compared to native resolution 1024x768"
        },
        "RatioY": {
          "comment": "Ratio of viewport compared to native resolution 1024x768"
        },
        "RenderDelta": {
          "comment": "Time since last render"
        },
        "SizeX": {
          "comment": "Size of ViewPort in pixels"
        },
        "SizeY": {
          "comment": "Size of ViewPort in pixels"
        }
      },
      "functions": {
        "AddConsoleMessage": {
          "comment": "Add a new console message to display."
        },
        "AddLocalizedMessage": {
          "comment": "Add the actual message to the array. Made easier to tweak in a subclass\n @Param Index The index in to the LocalMessages array to place it.\n @Param InMessageClass Class of the message\n @Param CriticialString String of the message\n @Param Switch The message switch\n @Param Position Where on the screen is the message\n @Param LifeTime How long does this message live\n @Param FontSize How big is the message\n @Param DrawColor The Color of the message"
        },
        "AddPostRenderedActor": {
          "comment": "AddPostRenderedActor()\nadd an actor to the PostRenderedActors array"
        },
        "DisplayConsoleMessages": {
          "comment": "Display current messages"
        },
        "DrawHUD": {
          "comment": "The Main Draw loop for the hud. Gets called before any messaging. Should be subclassed"
        },
        "OnLostFocusPause": {
          "comment": "Pauses or unpauses the game due to main window's focus being lost.",
          "params": {
            "Enable": "tells whether to enable or disable the pause state"
          }
        },
        "PlayerOwnerDied": {
          "comment": "Called when the player owner has died."
        },
        "PostRender": {
          "comment": "PostRender is the main draw loop."
        },
        "PreCalcValues": {
          "comment": "Pre-Calculate most common values, to avoid doing 1200 times the same operations"
        },
        "RemovePostRenderedActor": {
          "comment": "RemovePostRenderedActor()\nremove an actor from the PostRenderedActors array"
        },
        "SetShowScores": {
          "comment": "sets bShowScores to a specific value (not toggle)"
        },
        "ShowDebug": {
          "comment": "Toggles displaying properties of player's current ViewTarget\n DebugType input values supported by base engine include \"AI\", \"physics\", \"weapon\", \"net\", \"camera\", and \"collision\""
        },
        "ShowDebugInfo": {
          "comment": "Entry point for basic debug rendering on the HUD. Activated and controlled via the \"showdebug\" console command. Can be overridden to display custom debug per-game."
        }
      }
    },
    "ImageBasedReflectionComponent": {
      "properties": {
        "bEnabled": {
          "comment": "Whether to render the reflection."
        },
        "bTwoSided": {
          "comment": "Whether the reflection should be visible from the back."
        },
        "ReflectionColor": {
          "comment": "Color that will be multiplied against ReflectionTexture. Alpha is a brightness control."
        },
        "ReflectionTexture": {
          "comment": "Texture that will be applied to this reflection. \n This texture will be used in a texture array and therefore must have the same size, number of mips, texture group settings and format \n As the ReflectionTexture of every ImageBasedReflectionComponent that can be loaded at the same time."
        }
      },
      "functions": {
        "OnUpdatePropertyReflectionColor": {
          "comment": "Called from matinee code when ReflectionColor property changes."
        },
        "SetEnabled": {
          "comment": "Changes the enabled state of the image reflection component.",
          "params": {
            "bSetEnabled": "The new value for bEnabled."
          }
        }
      }
    },
    "ImageReflection": {
      "properties": {
        "bEnabled": {
          "comment": "replicated copy of ImageBasedReflectionComponent's bEnabled property"
        },
        "ReflectionComponent": {
          "comment": "Image reflection component"
        },
        "ImageReflectionComponent": {
          "comment": "Image reflection component"
        }
      }
    },
    "ImageReflectionSceneCapture": {
      "properties": {
        "ColorRange": {
          "comment": "Maximum linear space color value that will be stored in the generated texture."
        },
        "DepthRange": {
          "comment": "Distance in world units from the image plane that defines the depth range that will be captured. \n Anything outside of the depth range will be clipped away. \n Changes will be propagated on the next lighting build."
        }
      }
    },
    "ImageReflectionShadowPlane": {
      "properties": {
        "bEnabled": {
          "comment": "replicated copy of ImageReflectionShadowPlaneComponent's bEnabled property"
        },
        "ReflectionShadowComponent": {
          "comment": "Image reflection component"
        }
      }
    },
    "ImageReflectionShadowPlaneComponent": {
      "properties": {
        "bEnabled": {
          "comment": "Whether to render the reflection."
        }
      },
      "functions": {
        "SetEnabled": {
          "comment": "Changes the enabled state of the image reflection component.",
          "params": {
            "bSetEnabled": "The new value for bEnabled."
          }
        }
      }
    },
    "InGameAdManager": {
      "comment": "This object is responsible for the display and callbacks associated\n with handling ingame advertisements",
      "properties": {
        "bShouldPauseWhileAdOpen": {
          "comment": "If true, the game will pause when the user clicks on the ad, which could take over the screen"
        },
        "ClickedBannerDelegates": {
          "comment": "Delegates to call when the user clicks on a banner ad"
        },
        "ClosedAdDelegates": {
          "comment": "Delegates to call when the user closes an opened ad"
        }
      },
      "functions": {
        "AddClickedBannerDelegate": {
          "comment": "Adds a delegate to the list of listeners",
          "params": {
            "InDelegate": "the delegate to use for notifications"
          }
        },
        "AddClosedAdDelegate": {
          "comment": "Adds a delegate to the list of listeners",
          "params": {
            "InDelegate": "the delegate to use for notifications"
          }
        },
        "ClearClickedBannerDelegate": {
          "comment": "Removes a delegate from the list of listeners",
          "params": {
            "InDelegate": "the delegate to use for notifications"
          }
        },
        "ClearClosedAdDelegate": {
          "comment": "Removes a delegate from the list of listeners",
          "params": {
            "InDelegate": "the delegate to use for notifications"
          }
        },
        "ForceCloseAd": {
          "comment": "If the game absolutely must close an opened (clicked on) advertisement, call this function.\n This may lead to loss of revenue, so don't do it unnecessarily."
        },
        "HideBanner": {
          "comment": "Hides the advertisement banner shown with ShowInGameAdvertisementBanner. If the ad is currently open\n (ie, the user is interacting with the ad), the ad will be forcibly closed (see ForceCloseInGameAdvertisement)"
        },
        "Init": {
          "comment": "Perform any needed initialization"
        },
        "SetPauseWhileAdOpen": {
          "comment": "Sets the value of bShouldPauseWhileAdOpen"
        },
        "ShowBanner": {
          "comment": "Allows the platform to put up an advertisement on top of the viewport. Note that \n this will not resize the viewport, simply cover up a portion of it.",
          "params": {
            "bShowOnBottomOfScreen": "If TRUE, advertisement will be shown on the bottom, otherwise, the top"
          }
        }
      }
    },
    "IniLocPatcher": {
      "comment": "This class reads a set of files from Live/NP servers and uses it to\n update the game.",
      "properties": {
        "Files": {
          "comment": "The list of files to request from the online service"
        },
        "TitleFileInterface": {
          "comment": "Cached access to the system interface"
        }
      },
      "functions": {
        "AddFileToDownload": {
          "comment": "Adds a loc/ini file to download",
          "params": {
            "FileName": "the file to download"
          }
        },
        "AddReadFileDelegate": {
          "comment": "Adds the specified delegate to the registered downloader. Since the file read can come from\n different objects, this method hides that detail, but still lets callers get notifications",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to set"
          }
        },
        "ClearCachedFiles": {
          "comment": "Tells any subclasses to clear their cached file data"
        },
        "ClearReadFileDelegate": {
          "comment": "Clears the specified delegate from any registered downloaders",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to remove from the downloader"
          }
        },
        "DownloadFiles": {
          "comment": "Reads the set of files from the online service"
        },
        "Init": {
          "comment": "Initializes the patcher, sets delegates, vars, etc."
        },
        "OnReadFileComplete": {
          "comment": "Notifies us when the download of a file is complete",
          "params": {
            "bWasSuccessful": "true if the download completed ok, false otherwise",
            "FileName": "the file that was downloaded (or failed to)"
          }
        },
        "ProcessIniLocFile": {
          "comment": "Takes the data, merges with the INI/Loc system, and then reloads the config for the\n affected objects",
          "params": {
            "FileName": "the name of the file being merged",
            "FileData": "the file data to merge with the config cache"
          }
        },
        "UpdateLocFileName": {
          "comment": "Gets the proper language extension for the loc file",
          "params": {
            "FileName": "the file name being modified"
          }
        }
      },
      "structs": {
        "IniLocFileEntry": {
          "comment": "Holds the list of files to download and their download state",
          "properties": {
            "Filename": {
              "comment": "The file to read from the online service"
            },
            "ReadState": {
              "comment": "The state of that read"
            }
          }
        }
      }
    },
    "Input": {
      "properties": {
        "PressedKeys": {
          "comment": "list of keys which this interaction handled a pressed event for"
        }
      },
      "functions": {
        "ResetInput": {
          "comment": "Resets this input object, flushing all pressed keys and clearing all player 'input' variables."
        }
      },
      "structs": {
        "KeyBind": {
          "properties": {
            "bIgnoreAlt": {
              "comment": "if true, the bind will not be activated if the corresponding key is held down"
            },
            "bIgnoreCtrl": {
              "comment": "if true, the bind will not be activated if the corresponding key is held down"
            },
            "bIgnoreShift": {
              "comment": "if true, the bind will not be activated if the corresponding key is held down"
            }
          }
        }
      }
    },
    "InstancedStaticMeshComponent": {
      "properties": {
        "CachedMappings": {
          "comment": "The mappings for all the instances of this component"
        },
        "ComponentJoinKey": {
          "comment": "A key for deciding which components are compatible when joining components together after a lighting build. \n Will default to the staticmesh pointer when SetStaticMesh is called, so this must be set after calling\n SetStaticMesh on the component"
        },
        "NumPendingLightmaps": {
          "comment": "Number of pending lightmaps still to be calculated (Apply()'d)"
        },
        "PerInstanceData": {
          "comment": "Deprecated array of instances, script serialized"
        },
        "PerInstanceSMData": {
          "comment": "Array of instances, bulk serialized"
        },
        "InstancingRandomSeed": {
          "comment": "Value used to seed the random number stream that generates random numbers for each of this mesh's instances.\nThe random number is stored in a buffer accessible to materials through the PerInstanceRandom expression. If"
        }
      }
    },
    "Interaction": {
      "functions": {
        "Init": {
          "comment": "Called when the interaction is added to the GlobalInteractions array."
        },
        "Initialized": {
          "comment": "default handler for OnInitialize delegate. Here so that child classes can override the default behavior easily"
        },
        "NotifyGameSessionEnded": {
          "comment": "Called when the current map is being unloaded. Cleans up any references which would prevent garbage collection."
        },
        "NotifyPlayerAdded": {
          "comment": "Called when a new player has been added to the list of active players (i.e. split-screen join)",
          "params": {
            "PlayerIndex": "the index [into the GamePlayers array] where the player was inserted",
            "AddedPlayer": "the player that was added"
          }
        },
        "NotifyPlayerRemoved": {
          "comment": "Called when a player has been removed from the list of active players (i.e. split-screen players)",
          "params": {
            "PlayerIndex": "the index [into the GamePlayers array] where the player was located",
            "RemovedPlayer": "the player that was removed"
          }
        },
        "PostRender": {
          "comment": "Called once a frame to allow the interaction to draw to the canvas",
          "params": {
            "Canvas": "Canvas object to draw to"
          }
        },
        "Tick": {
          "comment": "Called once a frame to update the interaction's state.",
          "params": {
            "DeltaTime": "The time since the last frame."
          }
        }
      }
    },
    "InteractiveFoliageActor": {
      "properties": {
        "CylinderComponent": {
          "comment": "Collision cylinder"
        },
        "FoliageVelocity": {
          "comment": "Simulated physics state"
        },
        "TouchingActorEntryPosition": {
          "comment": "Position of the last actor to enter the collision cylinder.\n This currently does not handle multiple actors affecting the foliage simultaneously."
        },
        "FoliageDamageImpulseScale": {
          "comment": "Scales forces applied from damage events."
        },
        "FoliageDamping": {
          "comment": "Determines the amount of energy lost by the spring as it oscillates.\n This force is similar to air friction."
        },
        "FoliageStiffness": {
          "comment": "Determines how strong the force that pushes toward the spring's center will be."
        },
        "FoliageStiffnessQuadratic": {
          "comment": "Same as FoliageStiffness, but the strength of this force increases with the square of the distance to the spring's center.\n This force is used to prevent the spring from extending past a certain point due to touch and damage forces."
        },
        "FoliageTouchImpulseScale": {
          "comment": "Scales forces applied from touch events."
        },
        "MaxDamageImpulse": {
          "comment": "Clamps the magnitude of each damage force applied."
        },
        "MaxForce": {
          "comment": "Clamps the magnitude of combined forces applied each update."
        },
        "MaxTouchImpulse": {
          "comment": "Clamps the magnitude of each touch force applied."
        }
      }
    },
    "Interface_NavigationHandle": {
      "functions": {
        "NotifyPathChanged": {
          "comment": "this event is called when an edge is deleted that this handle is actively using"
        }
      }
    },
    "Interface_NavMeshPathSwitch": {
      "functions": {
        "AIActivateSwitch": {
          "comment": "called after edge creation is complete for each pylon to allow this PO to add edges for itself",
          "params": {
            "Py": "the pylon which we are creating edges for"
          }
        }
      }
    },
    "Interface_Speaker": {
      "functions": {
        "Speak": {
          "comment": "Very simple for now."
        }
      }
    },
    "InterpActor": {
      "properties": {
        "AmbientSoundComponent": {
          "comment": "component for looping sounds"
        },
        "bIsLift": {
          "comment": "If true, have a liftcenter associated with this interpactor, so it is being used as a lift"
        },
        "bMonitorMover": {
          "comment": "true when AI is waiting for us to finish moving"
        },
        "bMonitorZVelocity": {
          "comment": "if true, call MoverFinished() event on all Controllers with us as their PendingMover when we reach peak Z velocity"
        },
        "bShouldSaveForCheckpoint": {
          "comment": "whether this should be saved in checkpoints"
        },
        "MaxZVelocity": {
          "comment": "set while monitoring lift movement"
        },
        "MyMarker": {
          "comment": "NavigationPoint associated with this actor for sending AI related notifications (could be a LiftCenter or DoorMarker)"
        },
        "StayOpenTime": {
          "comment": "delay after mover finishes interpolating before it notifies any mover events"
        },
        "bContinueOnEncroachPhysicsObject": {
          "comment": "if set, this mover keeps going if it encroaches an Actor in PHYS_RigidBody."
        },
        "bDestroyProjectilesOnEncroach": {
          "comment": "if set this mover blows up projectiles when it encroaches them"
        },
        "bShouldShadowParentAllAttachedActors": {
          "comment": "This is used for having the Actor ShadowParent all of the components that are \"SetBased\" onto it. This allows LDs to\n take InterpActors in the level and then SetBase a ton of other meshes to them and not incur multiple shadow casters."
        },
        "bStopOnEncroach": {
          "comment": "true by default, prevents mover from completing the movement that would leave it encroaching another actor"
        },
        "ClosedSound": {
          "comment": "sound played when mover finished moving backward"
        },
        "CloseSound": {
          "comment": "sound played when the mover is interpolated in reverse"
        },
        "ClosingAmbientSound": {
          "comment": "looping sound while closing"
        },
        "OpenedSound": {
          "comment": "sound played when mover finished moving forward"
        },
        "OpeningAmbientSound": {
          "comment": "looping sound while opening"
        },
        "OpenSound": {
          "comment": "sound played when the mover is interpolated forward"
        }
      },
      "functions": {
        "CreateCheckpointRecord": {
          "comment": "Called when this actor is being saved in a checkpoint, records pertinent information for restoration via ApplyCheckpointRecord."
        },
        "FinishedOpen": {
          "comment": "called on a timer StayOpenTime seconds after the mover has finished opening (forward matinee playback)"
        },
        "Restart": {
          "comment": "checks if anything is still attached to the mover, and if so notifies Kismet so that it may restart it if desired"
        },
        "SetShadowParentOnAllAttachedComponents": {
          "comment": "This will look over the set of all attached of components that are SetBased on this Actor\n and then ShadowParent them to our StaticMeshComponent"
        }
      },
      "structs": {
        "CheckpointRecord": {
          "comment": "Data relevant to checkpoint save/load, see CreateCheckpointRecord/ApplyCheckpointRecord below"
        }
      }
    },
    "InterpData": {
      "comment": "InterpData\n\n Actual interpolation data, containing keyframe tracks, event tracks etc.\n This does not contain any Actor references or state, so can safely be stored in\n packages, shared between multiple Actors/SeqAct_Interps etc.",
      "properties": {
        "CachedDirectorGroup": {
          "comment": "Cached version of the director group, if any, for easy access while in game"
        },
        "CurveEdSetup": {
          "comment": "Used for curve editor to remember curve-editing setup. Only loaded in editor."
        },
        "DefaultFilters": {
          "comment": "Array of default filters."
        },
        "EdSectionEnd": {
          "comment": "Used in editor for defining sections to loop, stretch etc."
        },
        "EdSectionStart": {
          "comment": "Used in editor for defining sections to loop, stretch etc."
        },
        "InterpFilters": {
          "comment": "Used for filtering which tracks are currently visible."
        },
        "InterpGroups": {
          "comment": "Actual interpolation data. Groups of InterpTracks."
        },
        "InterpLength": {
          "comment": "Duration of interpolation sequence - in seconds."
        },
        "PathBuildTime": {
          "comment": "Position in Interp to move things to for path-building in editor."
        },
        "SelectedFilter": {
          "comment": "The currently selected filter."
        },
        "BakeAndPruneStatus": {
          "comment": "AnimSets referenced by this matinee, and whether to allow bake and prune on them during cooking."
        },
        "bShouldBakeAndPrune": {
          "comment": "If TRUE, then the matinee should be baked and pruned at cook time."
        }
      },
      "structs": {
        "AnimSetBakeAndPruneStatus": {
          "properties": {
            "AnimSetName": {
              "comment": "Name of the anim set referenced in Matinee"
            },
            "bReferencedButUnused": {
              "comment": "If TRUE, the animation is in a GroupAnimSets array, but is unused"
            },
            "bSkipBakeAndPrune": {
              "comment": "If TRUE, skip BakeAndPrune on this anim set during cooking"
            }
          }
        }
      }
    },
    "InterpFilter": {
      "properties": {
        "Caption": {
          "comment": "Caption for this filter."
        }
      }
    },
    "InterpFilter_Classes": {
      "properties": {
        "ClassToFilterBy": {
          "comment": "Which class to filter groups by."
        },
        "TrackClasses": {
          "comment": "List of allowed track classes. If empty, then all track classes will be included. Only groups that"
        }
      }
    },
    "InterpFilter_Custom": {
      "properties": {
        "GroupsToInclude": {
          "comment": "Which groups are included in this filter."
        }
      }
    },
    "InterpGroup": {
      "properties": {
        "bCollapsed": {
          "comment": "Whether or not this group is folded away in the editor."
        },
        "bIsFolder": {
          "comment": "When enabled, this group is treated like a folder in the editor, which should only be used for organization. Folders are never associated with actors and don't have a presence in the Kismet graph."
        },
        "bIsParented": {
          "comment": "When true, this group is considered a 'visual child' of another group. This doesn't at all affect the behavior of the group, it's only for visual organization. Also, it's implied that the parent is the next prior group in the array that doesn't have a parent."
        },
        "bIsSelected": {
          "comment": "When enabled, this group will be selected in the interp editor."
        },
        "bVisible": {
          "comment": "Whether or not this group is visible in the editor."
        },
        "GroupName": {
          "comment": "Within an InterpData, all GroupNames must be unique. \n Used for naming Variable connectors on the Action in Kismet and finding each groups object."
        },
        "GroupAnimSets": {
          "comment": "The AnimSets that are used by any AnimControl tracks. \n These will be passed to the Actor when the cinematic begins, and sequences named in the tracks should be found in them."
        },
        "GroupColor": {
          "comment": "Colour used for drawing tracks etc. related to this group."
        }
      },
      "structs": {
        "InterpEdSelKey": {
          "comment": "Util for determining how many AnimControl tracks within this group are using the Slot with the supplied name."
        }
      }
    },
    "InterpGroupAI": {
      "properties": {
        "bRecreatePreviewPawn": {
          "comment": "Editor only variable to mark dirty for instance to update when neede"
        },
        "bDisableWorldCollision": {
          "comment": "Disable World Collision during Matine"
        },
        "bIgnoreLegacyHeightAdjust": {
          "comment": "Ignore old legacy height adjust for pawn - TODO: REMOVE THIS BEFORE 2012"
        },
        "bNoEncroachmentCheck": {
          "comment": "Disable Collision Check when initializing first tim"
        },
        "PreviewPawnClass": {
          "comment": "Preview Pawn class for this track"
        },
        "SnapToRootBoneLocationWhenFinished": {
          "comment": "Snap AI to root bone location when finished"
        },
        "StageMarkGroup": {
          "comment": "Name of Stage Mark Group - used for locator"
        }
      }
    },
    "InterpGroupInst": {
      "properties": {
        "Group": {
          "comment": "InterpGroup within the InterpData that this is an instance of."
        },
        "GroupActor": {
          "comment": "Actor that this Group instance is acting upon.\n NB: that this may be set to NULL at any time as a result of the Actor being destroyed."
        },
        "TrackInst": {
          "comment": "Array if InterpTrack instances. TrackInst.Num() == InterpGroup.InterpTrack.Num() must be true."
        }
      }
    },
    "InterpGroupInstAI": {
      "properties": {
        "AIGroup": {
          "comment": "Cache data to AIGroup"
        },
        "PreviewPawn": {
          "comment": "Preview Pawn for only editor - in game it should be AI"
        },
        "SavedPhysics": {
          "comment": "Saved Physics state to go back to"
        },
        "StageMarkActor": {
          "comment": "Stage Mark Actor - from StageMark Group"
        }
      }
    },
    "InterpTrack": {
      "comment": "Abstract base class for a track of interpolated data. Contains the actual data.\n The Outer of an InterpTrack is the InterpGroup.",
      "properties": {
        "bDirGroupOnly": {
          "comment": "If this track can only exist inside the Director group."
        },
        "bDisableTrack": {
          "comment": "Whether or not this track should actually update the target actor."
        },
        "bIsAnimControlTrack": {
          "comment": "If true, the Actor this track is working on will have BeginAnimControl/FinishAnimControl called on it."
        },
        "bIsCollapsed": {
          "comment": "If this track is collapsed. (Only applies to tracks with subtracks)."
        },
        "bIsRecording": {
          "comment": "Whether or not this track is recording in the editor."
        },
        "bIsSelected": {
          "comment": "Whether or not this track is selected in the editor."
        },
        "bOnePerGroup": {
          "comment": "Whether there may only be one of this track in an InterpGroup."
        },
        "bSubTrackOnly": {
          "comment": "If this track can only exist as a sub track."
        },
        "bVisible": {
          "comment": "Whether or not this track is visible in the editor."
        },
        "CurveEdVTable": {
          "comment": "FCurveEdInterface virtual function table."
        },
        "SubTrackGroups": {
          "comment": "A list of subtrack groups (for editor UI organization only)"
        },
        "SubTracks": {
          "comment": "A list of subtracks that belong to this track"
        },
        "SupportedSubTracks": {
          "comment": "A list of supported tracks that can be a subtrack of this track."
        },
        "TrackTitle": {
          "comment": "Title of track type."
        },
        "ActiveCondition": {
          "comment": "Sets the condition that must be met for this track to be enabled"
        }
      },
      "structs": {
        "SubTrackGroup": {
          "comment": "A small structure holding data for grouping subtracks. (For UI drawing purposes)",
          "properties": {
            "bIsCollapsed": {
              "comment": "If this group is collapsed"
            },
            "bIsSelected": {
              "comment": "If this group is selected"
            },
            "GroupName": {
              "comment": "Name of the subtrack group"
            },
            "TrackIndices": {
              "comment": "Indices to tracks in the parent track subtrack array."
            }
          }
        },
        "SupportedSubTrackInfo": {
          "comment": "Helper struct for creating sub tracks supported by this track",
          "properties": {
            "GroupIndex": {
              "comment": "Index into the any subtrack group this subtrack belongs to (can be -1 for no group)"
            },
            "SubTrackName": {
              "comment": "The name of the subtrack"
            },
            "SupportedClass": {
              "comment": "The sub track class which is supported by this track"
            }
          }
        }
      }
    },
    "InterpTrackAnimControl": {
      "properties": {
        "AnimSeqs": {
          "comment": "Track of different animations to play and when to start playing them."
        },
        "AnimSets": {
          "comment": "DEPRECATED! USE UInterpGroup::GroupAnimSets instead now."
        },
        "bEnableRootMotion": {
          "comment": "Enable root motion. This only works if you delete Movement Track to avoid conflicts"
        },
        "bSkipAnimNotifiers": {
          "comment": "Skip all anim notifiers"
        },
        "SlotName": {
          "comment": "Name of slot to use when playing animation. Passed to Actor. \n When multiple tracks use the same slot name, they are each given a different ChannelIndex when SetAnimPosition is called."
        }
      },
      "structs": {
        "AnimControlTrackKey": {
          "comment": "Structure used for holding information for one animation played on the Anim Control track.",
          "properties": {
            "AnimEndOffset": {
              "comment": "Time to end playing the AnimSequence at."
            },
            "AnimPlayRate": {
              "comment": "Playback speed of this animation."
            },
            "AnimSeqName": {
              "comment": "Name of AnimSequence to play."
            },
            "AnimStartOffset": {
              "comment": "Time to start playing AnimSequence at."
            },
            "bLooping": {
              "comment": "Should this animation loop."
            },
            "bReverse": {
              "comment": "Whether to play the animation in reverse or not."
            },
            "StartTime": {
              "comment": "Position in the Matinee sequence to start playing this animation."
            }
          }
        }
      }
    },
    "InterpTrackBoolProp": {
      "properties": {
        "BoolTrack": {
          "comment": "Array of booleans to set."
        },
        "PropertyName": {
          "comment": "Name of property in Group Actor which this track will modify over time."
        }
      },
      "structs": {
        "BoolTrackKey": {
          "comment": "Information for one event in the track."
        }
      }
    },
    "InterpTrackColorProp": {
      "properties": {
        "PropertyName": {
          "comment": "Name of property in Group Actor which this track mill modify over time."
        }
      }
    },
    "InterpTrackDirector": {
      "properties": {
        "CutTrack": {
          "comment": "Array of cuts between cameras."
        },
        "bSimulateCameraCutsOnClients": {
          "comment": "True to allow clients to simulate their own camera cuts. Can help with latency-induced timing issues."
        }
      },
      "structs": {
        "DirectorTrackCut": {
          "comment": "Information for one cut in this track.",
          "properties": {
            "TargetCamGroup": {
              "comment": "GroupName of InterpGroup to cut viewpoint to."
            },
            "Time": {
              "comment": "Time to perform the cut."
            },
            "TransitionTime": {
              "comment": "Time taken to move view to new camera."
            }
          }
        }
      }
    },
    "InterpTrackEvent": {
      "properties": {
        "EventTrack": {
          "comment": "Array of events to fire off."
        },
        "bFireEventsWhenBackwards": {
          "comment": "If events should be fired when passed playing the sequence backwards."
        },
        "bFireEventsWhenForwards": {
          "comment": "If events should be fired when passed playing the sequence forwards."
        },
        "bFireEventsWhenJumpingForwards": {
          "comment": "If true, events on this track are fired even when jumping forwads through a sequence - for example, skipping a cinematic."
        }
      },
      "structs": {
        "EventTrackKey": {
          "comment": "Information for one event in the track."
        }
      }
    },
    "InterpTrackFaceFX": {
      "properties": {
        "CachedActorFXAsset": {
          "comment": "In Matinee, cache a pointer to the Actor's FaceFXAsset, so we can get info like anim lengths."
        },
        "FaceFXSeqs": {
          "comment": "Track of different animations to play and when to start playing them."
        },
        "FaceFXSoundCueKeys": {
          "comment": "One key for each key in the associated FaceFX track's array of keys"
        },
        "FaceFXAnimSets": {
          "comment": "Extra sets of animation that you wish to use on this Group's Actor during the matinee sequence."
        }
      },
      "structs": {
        "FaceFXSoundCueKey": {
          "comment": "Structure used for holding information for one FaceFX animation played by the track.",
          "properties": {
            "FaceFXSoundCue": {
              "comment": "Sound cue associated with this key's FaceFX sequence. Currently this is maintained automatically by\nthe editor and saved out when the map is saved to disk. The game requires the sound cue reference"
            }
          }
        },
        "FaceFXTrackKey": {
          "comment": "Structure used for holding information for one FaceFX animation played by the track.",
          "properties": {
            "FaceFXGroupName": {
              "comment": "Name of FaceFX group containing sequence to play."
            },
            "FaceFXSeqName": {
              "comment": "Name of FaceFX sequence to play."
            },
            "StartTime": {
              "comment": "Position in the Matinee sequence to start playing this FaceFX animation."
            }
          }
        }
      }
    },
    "InterpTrackFloatBase": {
      "properties": {
        "FloatTrack": {
          "comment": "Actually track data containing keyframes of float as it varies over time."
        },
        "CurveTension": {
          "comment": "Tension of curve, used for keypoints using automatic tangents."
        }
      }
    },
    "InterpTrackFloatMaterialParam": {
      "properties": {
        "bNeedsMaterialRefsUpdate": {
          "comment": "@compatibility: indicates we need to gather material references on first use\n (can't do in PostLoad() because Actors initialize components array in their own PostLoad() which might not have been called yet)"
        },
        "Materials": {
          "comment": "materials whose parameters we want to change and the references to those materials\n that need to be given MICs in the same level, compiled at save time"
        },
        "ParamName": {
          "comment": "Name of parameter in the MaterialInstance which this track will modify over time."
        }
      }
    },
    "InterpTrackFloatParticleParam": {
      "properties": {
        "ParamName": {
          "comment": "Name of property in the Emitter which this track mill modify over time."
        }
      }
    },
    "InterpTrackFloatProp": {
      "properties": {
        "PropertyName": {
          "comment": "Name of property in Group Actor which this track mill modify over time."
        }
      }
    },
    "InterpTrackHeadTracking": {
      "properties": {
        "HeadTrackingTrack": {
          "comment": "Array of keys ."
        },
        "bDisableBeyondLimit": {
          "comment": "Interp back to zero strength if limit surpassed"
        },
        "LookAtActorRadius": {
          "comment": "Will pick up actor within this radius"
        },
        "MaxInterestTime": {
          "comment": "Once entered the radius, how long do I really care to lok ? This affects rating. It will give benefit to the person who just entered"
        },
        "MaxLookAtTime": {
          "comment": "How long can one person to look at one"
        },
        "MinLookAtTime": {
          "comment": "At least this time to look at one"
        },
        "TrackControllerName": {
          "comment": "SkelControlLookAt name in the AnimTree of the SkeletalMesh"
        },
        "ActorClassesToLookAt": {
          "comment": "Actor classes to look at as 0 index being the highest priority if you have anything specific"
        },
        "bLookAtPawns": {
          "comment": "Quick check box for allowing it to look Pawn - due to Pawn not being listed in the Actor class"
        },
        "TargetBoneNames": {
          "comment": "Target Bone Names, where to look at - priority from top to bottom, if not found, it will continue search"
        }
      },
      "structs": {
        "HeadTrackingKey": {
          "comment": "Information for one toggle in the track."
        }
      }
    },
    "InterpTrackInstAnimControl": {
      "properties": {
        "LastUpdatePosition": {
          "comment": "Called when interpolation is done. Should not do anything else with this TrackInst after this."
        }
      }
    },
    "InterpTrackInstBoolProp": {
      "properties": {
        "BoolProp": {
          "comment": "Pointer to boolean property in TrackObject."
        },
        "ResetBool": {
          "comment": "Saved value for restoring state when exiting Matinee."
        }
      }
    },
    "InterpTrackInstColorProp": {
      "properties": {
        "ColorProp": {
          "comment": "Pointer to color property in TrackObject."
        },
        "ResetColor": {
          "comment": "Saved value for restoring state when exiting Matinee."
        }
      }
    },
    "InterpTrackInstDirector": {
      "properties": {
        "OldRenderingOverrides": {
          "comment": "Rendering overrides that were active on the player camera, used to restore settings when the director track ends in game."
        }
      }
    },
    "InterpTrackInstEvent": {
      "properties": {
        "LastUpdatePosition": {
          "comment": "Position we were in last time we evaluated Events. \n During UpdateTrack, events between this time and the current time will be fired."
        }
      }
    },
    "InterpTrackInstFloatMaterialParam": {
      "properties": {
        "InstancedTrack": {
          "comment": "track we are an instance of - used in the editor to propagate changes to the track's Materials array immediately"
        }
      },
      "structs": {
        "FloatMaterialParamMICData": {
          "comment": "list of MICs we are using and optionally also the original value of the parameter we're editing\n array size should match owner track's Materials array",
          "properties": {
            "MICResetFloats": {
              "comment": "saved values for restoring state when exiting Matinee - size of array should match MICs"
            },
            "MICs": {
              "comment": "MICs we're using to set the desired parameter on PrimitiveComponents - size of array should match track's AffectedMaterialRefs"
            }
          }
        }
      }
    },
    "InterpTrackInstFloatParticleParam": {
      "properties": {
        "ResetFloat": {
          "comment": "Saved value for restoring state when exiting Matinee."
        }
      }
    },
    "InterpTrackInstFloatProp": {
      "properties": {
        "FloatProp": {
          "comment": "Pointer to float property in TrackObject."
        },
        "ResetFloat": {
          "comment": "Saved value for restoring state when exiting Matinee."
        }
      }
    },
    "InterpTrackInstHeadTracking": {
      "properties": {
        "CurrentActorMap": {
          "comment": "Array of actor information"
        },
        "LastUpdatePosition": {
          "comment": "Position we were in last time we evaluated.\n During UpdateTrack, events between this time and the current time will be processed."
        },
        "Mesh": {
          "comment": "SkeletalMeshComponent who owns this"
        },
        "TrackControls": {
          "comment": "Look at control"
        }
      }
    },
    "InterpTrackInstLinearColorProp": {
      "properties": {
        "ColorProp": {
          "comment": "Pointer to color property in TrackObject."
        },
        "ResetColor": {
          "comment": "Saved value for restoring state when exiting Matinee."
        }
      }
    },
    "InterpTrackInstMove": {
      "properties": {
        "InitialQuat": {
          "comment": "Orientation of group's actor when sequence was started. @see InitialTM"
        },
        "InitialTM": {
          "comment": "Transform of group's actor when sequence was started. This is used to reset sequence and also as basis when using IMF_RelativeToInitial."
        },
        "ResetLocation": {
          "comment": "Saved position. Used in editor for resetting when quitting Matinee."
        },
        "ResetRotation": {
          "comment": "Saved rotation. Used in editor for resetting when quitting Matinee."
        }
      }
    },
    "InterpTrackInstParticleReplay": {
      "properties": {
        "LastUpdatePosition": {
          "comment": "Position we were in last time we evaluated.\n During UpdateTrack, events between this time and the current time will be processed."
        }
      }
    },
    "InterpTrackInstProperty": {
      "properties": {
        "PropertyOuterObjectInst": {
          "comment": "Pointer to the UObject instance that is the outer of the color property we are interpolating on, this is used to process the property update callback."
        },
        "PropertyUpdateCallback": {
          "comment": "Function to call after updating the value of the color property."
        }
      }
    },
    "InterpTrackInstSlomo": {
      "properties": {
        "OldTimeDilation": {
          "comment": "Backup of initial LevelInfo TimeDilation setting when interpolation started."
        }
      }
    },
    "InterpTrackInstToggle": {
      "properties": {
        "bSavedActiveState": {
          "comment": "Cached 'active' state for the toggleable actor before we possessed it; restored when Matinee exits"
        },
        "LastUpdatePosition": {
          "comment": "Position we were in last time we evaluated.\n During UpdateTrack, toggles between this time and the current time will be processed."
        }
      }
    },
    "InterpTrackInstVectorMaterialParam": {
      "properties": {
        "InstancedTrack": {
          "comment": "track we are an instance of - used in the editor to propagate changes to the track's Materials array immediately"
        }
      },
      "structs": {
        "VectorMaterialParamMICData": {
          "comment": "list of MICs we are using and optionally also the original value of the parameter we're editing\n array size should match owner track's Materials array",
          "properties": {
            "MICResetVectors": {
              "comment": "saved values for restoring state when exiting Matinee - size of array should match MICs"
            },
            "MICs": {
              "comment": "MICs we're using to set the desired parameter on PrimitiveComponents - size of array should match track's AffectedMaterialRefs"
            }
          }
        }
      }
    },
    "InterpTrackInstVectorProp": {
      "properties": {
        "ResetVector": {
          "comment": "Saved value for restoring state when exiting Matinee."
        },
        "VectorProp": {
          "comment": "Pointer to vector property in TrackObject."
        }
      }
    },
    "InterpTrackInstVisibility": {
      "properties": {
        "LastUpdatePosition": {
          "comment": "Position we were in last time we evaluated.\n During UpdateTrack, events between this time and the current time will be processed."
        }
      }
    },
    "InterpTrackLinearColorBase": {
      "properties": {
        "LinearColorTrack": {
          "comment": "Actually track data containing keyframes of a vector as it varies over time."
        },
        "CurveTension": {
          "comment": "Tension of curve, used for keypoints using automatic tangents."
        }
      }
    },
    "InterpTrackLinearColorProp": {
      "properties": {
        "PropertyName": {
          "comment": "Name of property in Group Actor which this track mill modify over time."
        }
      }
    },
    "InterpTrackMorphWeight": {
      "properties": {
        "MorphNodeName": {
          "comment": "Name of property in Group Actor which this track mill modify over time."
        }
      }
    },
    "InterpTrackMove": {
      "properties": {
        "EulerTrack": {
          "comment": "Actual rotation keyframe data, stored as Euler angles in degrees, for easy editing on curve."
        },
        "PosTrack": {
          "comment": "Actual position keyframe data."
        },
        "AngCurveTension": {
          "comment": "Controls the tightness of the curve for the rotation path."
        },
        "bDisableMovement": {
          "comment": "Disable previewing of this track - will always position Actor at Time=0.0. Useful when keyframing an object relative to this group."
        },
        "bHide3DTrack": {
          "comment": "If true, 3D representation of this track in the 3D viewport is disabled."
        },
        "bShowArrowAtKeys": {
          "comment": "In the editor, show a small arrow at each keyframe indicating the rotation at that key."
        },
        "bShowRotationOnCurveEd": {
          "comment": "If false, when this track is displayed on the Curve Editor in Matinee, do not show the Rotation tracks."
        },
        "bShowTranslationOnCurveEd": {
          "comment": "If false, when this track is displayed on the Curve Editor in Matinee, do not show the Translation tracks."
        },
        "bUseQuatInterpolation": {
          "comment": "Use a Quaternion linear interpolation between keys. \n This is robust and will find the 'shortest' distance between keys, but does not support ease in/out."
        },
        "LinCurveTension": {
          "comment": "Controls the tightness of the curve for the translation path."
        },
        "LookAtGroupName": {
          "comment": "When using IMR_LookAtGroup, specifies the Group which this track should always point its actor at."
        },
        "MoveFrame": {
          "comment": "Indicates what the movement track should be relative to."
        },
        "RotMode": {
          "comment": "Do not change rotation. Ignore it."
        }
      },
      "structs": {
        "InterpLookupPoint": {
          "comment": "Array of group names to retrieve position and rotation data from instead of using the datastored in the keyframe. \n A value of NAME_None means to use the PosTrack and EulerTrack data for the keyframe.\n There needs to be the same amount of elements in this array as there are keyframes."
        },
        "InterpLookupTrack": {
          "properties": {
            "Points": {
              "comment": "Move a keypoint to a new In value. This may change the index of the keypoint, so the new key index is returned."
            }
          }
        }
      }
    },
    "InterpTrackMoveAxis": {
      "properties": {
        "LookupTrack": {
          "comment": "Lookup track to use when looking at different groups for transform information"
        },
        "MoveAxis": {
          "comment": "The axis which this track will use when transforming an actor"
        }
      }
    },
    "InterpTrackParticleReplay": {
      "properties": {
        "bIsCapturingReplay": {
          "comment": "True in the editor if track should be used to capture replay frames instead of play them back"
        },
        "FixedTimeStep": {
          "comment": "Current replay fixed time quantum between frames (one over frame rate)"
        },
        "TrackKeys": {
          "comment": "Array of keys"
        }
      },
      "structs": {
        "ParticleReplayTrackKey": {
          "comment": "Data for a single key in this track",
          "properties": {
            "ClipIDNumber": {
              "comment": "Replay clip ID number that identifies the clip we should capture to or playback from"
            },
            "Duration": {
              "comment": "Time length this clip should be captured/played for"
            },
            "Time": {
              "comment": "Position along timeline"
            }
          }
        }
      }
    },
    "InterpTrackSkelControlScale": {
      "properties": {
        "SkelControlName": {
          "comment": "Name of property in Group Actor which this track mill modify over time."
        }
      }
    },
    "InterpTrackSound": {
      "properties": {
        "Sounds": {
          "comment": "Array of sounds to play at specific times."
        },
        "bContinueSoundOnMatineeEnd": {
          "comment": "If true, sounds on this track will not be forced to finish when the matinee sequence finishes."
        },
        "bPlayOnReverse": {
          "comment": "if set, sound plays only when playing the matinee in reverse instead of when the matinee plays forward"
        },
        "bSuppressSubtitles": {
          "comment": "If TRUE, don't show subtitles for sounds played by this track."
        },
        "bTreatAsDialogue": {
          "comment": "If true and track is controlling a pawn, makes the pawn \"speak\" the given audio."
        }
      },
      "structs": {
        "SoundTrackKey": {
          "comment": "Information for one sound in the track."
        }
      }
    },
    "InterpTrackToggle": {
      "properties": {
        "ToggleTrack": {
          "comment": "Array of events to fire off."
        },
        "bActivateSystemEachUpdate": {
          "comment": "If true, the track will call ActivateSystem on the emitter each update (the old 'incorrect' behavior).\n If false (the default), the System will only be activated if it was previously inactive."
        },
        "bActivateWithJustAttachedFlag": {
          "comment": "If true, the track will activate the system w/ the 'Just Attached' flag."
        },
        "bFireEventsWhenBackwards": {
          "comment": "If events should be fired when passed playing the sequence backwards."
        },
        "bFireEventsWhenForwards": {
          "comment": "If events should be fired when passed playing the sequence forwards."
        },
        "bFireEventsWhenJumpingForwards": {
          "comment": "If true, events on this track are fired even when jumping forwads through a sequence - for example, skipping a cinematic."
        }
      },
      "structs": {
        "ToggleTrackKey": {
          "comment": "Information for one toggle in the track."
        }
      }
    },
    "InterpTrackVectorBase": {
      "properties": {
        "VectorTrack": {
          "comment": "Actually track data containing keyframes of a vector as it varies over time."
        },
        "CurveTension": {
          "comment": "Tension of curve, used for keypoints using automatic tangents."
        }
      }
    },
    "InterpTrackVectorMaterialParam": {
      "properties": {
        "bNeedsMaterialRefsUpdate": {
          "comment": "@compatibility: indicates we need to gather material references on first use\n (can't do in PostLoad() because Actors initialize components array in their own PostLoad() which might not have been called yet)"
        },
        "Materials": {
          "comment": "materials whose parameters we want to change and the references to those materials\n that need to be given MICs in the same level, compiled at save time"
        },
        "ParamName": {
          "comment": "Name of parameter in the MaterialInstance which this track will modify over time."
        }
      }
    },
    "InterpTrackVectorProp": {
      "properties": {
        "PropertyName": {
          "comment": "Name of property in Group Actor which this track mill modify over time."
        }
      }
    },
    "InterpTrackVisibility": {
      "properties": {
        "VisibilityTrack": {
          "comment": "Array of events to fire off."
        },
        "bFireEventsWhenBackwards": {
          "comment": "If events should be fired when passed playing the sequence backwards."
        },
        "bFireEventsWhenForwards": {
          "comment": "If events should be fired when passed playing the sequence forwards."
        },
        "bFireEventsWhenJumpingForwards": {
          "comment": "If true, events on this track are fired even when jumping forwads through a sequence - for example, skipping a cinematic."
        }
      },
      "structs": {
        "VisibilityTrackKey": {
          "comment": "Information for one toggle in the track.",
          "properties": {
            "ActiveCondition": {
              "comment": "Condition that must be satisfied for this key event to fire"
            }
          }
        }
      }
    },
    "Inventory": {
      "properties": {
        "bDropOnDeath": {
          "comment": "if true, this inventory item should be dropped if the owner dies"
        }
      },
      "functions": {
        "ClientGivenTo": {
          "comment": "This Inventory Item has just been given to this Pawn\n (owning client only)",
          "params": {
            "thisPawn": "new Inventory owner",
            "bDoNotActivate": "If true, this item will not try to activate"
          }
        },
        "DenyPickupQuery": {
          "comment": "DenyPickupQuery\nFunction which lets existing items in a pawn's inventory\nprevent the pawn from picking something up.",
          "params": {
            "ItemClass": "Class of Inventory our Owner is trying to pick up",
            "Pickup": "the Actor containing that item (this may be a PickupFactory or it may be a DroppedPickup)"
          }
        },
        "DropFrom": {
          "comment": "Drop this item out in to the world",
          "params": {
            "StartLocation": "The World Location to drop this item from",
            "StartVelocity": "The initial velocity for the item when dropped"
          }
        },
        "GivenTo": {
          "comment": "This Inventory Item has just been given to this Pawn\n (server only)",
          "params": {
            "thisPawn": "new Inventory owner",
            "bDoNotActivate": "If true, this item will not try to activate"
          }
        },
        "ItemRemovedFromInvManager": {
          "comment": "Event called when Item is removed from Inventory Manager.\n Network: Authority"
        }
      }
    },
    "InventoryManager": {
      "properties": {
        "bMustHoldWeapon": {
          "comment": "if true, don't allow player to put down weapon without switching to another one"
        },
        "InventoryChain": {
          "comment": "First inventory item in inventory linked list"
        },
        "PendingFire": {
          "comment": "Holds the current \"Fire\" status for both firing modes"
        },
        "PendingWeapon": {
          "comment": "Player will switch to PendingWeapon, once the current weapon has been put down.\n @fixme laurent -- PendingWeapon should be made protected, because too many bugs result by setting this variable directly.\n It's only safe to read it, but to change it, SetCurrentWeapon() should be used."
        }
      },
      "functions": {
        "AddInventory": {
          "comment": "Adds an existing inventory item to the list.\n Returns true to indicate it was added, false if it was already in the list.",
          "params": {
            "NewItem": "Item to add to inventory manager."
          }
        },
        "CancelWeaponChange": {
          "comment": "Prevents player from being without a weapon."
        },
        "ChangedWeapon": {
          "comment": "ChangedWeapon is called when the current weapon is finished being deactivated"
        },
        "ClearPendingWeapon": {
          "comment": "Clear pending weapon, put it in a good state."
        },
        "ClientWeaponSet": {
          "comment": "Weapon just given to a player, check if player should switch to this weapon\n Network: LocalPlayer\n Called from Weapon.ClientWeaponSet()"
        },
        "CreateInventory": {
          "comment": "Spawns a new Inventory actor of NewInventoryItemClass type, and adds it to the Inventory Manager.",
          "params": {
            "NewInventoryItemClass": "Class of inventory item to spawn and add."
          }
        },
        "Destroyed": {
          "comment": "Event called when inventory manager is destroyed, called from Pawn.Destroyed()"
        },
        "DiscardInventory": {
          "comment": "Discard full inventory, generally because the owner died"
        },
        "DrawHud": {
          "comment": "Hook called from HUD actor. Gives access to HUD and Canvas",
          "params": {
            "H": "HUD"
          }
        },
        "FindInventoryType": {
          "comment": "returns the inventory item of the requested class if it exists in this inventory manager.",
          "params": {
            "DesiredClass": "class of inventory item we're trying to find.",
            "bAllowSubclass": "whether subclasses of the desired class are acceptable"
          }
        },
        "GetBestWeapon": {
          "comment": "returns the best weapon for this Pawn in loadout"
        },
        "GetWeaponRatingFor": {
          "comment": "Returns a weight reflecting the desire to use the\n given weapon, used for AI and player best weapon\n selection.",
          "params": {
            "Weapon": "W"
          }
        },
        "HandlePickupQuery": {
          "comment": "Handle Pickup. Can Pawn pickup this item?",
          "params": {
            "ItemClass": "Class of Inventory our Owner is trying to pick up",
            "Pickup": "the Actor containing that item (this may be a PickupFactory or it may be a DroppedPickup)"
          }
        },
        "InventoryActors": {
          "comment": "returns all Inventory Actors of class BaseClass",
          "params": {
            "BaseClass": "Inventory actors returned are of, or childs of, this base class.\n \n@output Inv Inventory actors returned.\n \n@note this iterator bails if it encounters more than 100 items, since temporary loops in linked list may sometimes be created\n on network clients while link pointers are being replicated. For performance reasons you shouldn't have that many inventory items anyway."
          }
        },
        "NextWeapon": {
          "comment": "Switches to Next weapon\n Network: Client"
        },
        "OwnerDied": {
          "comment": "called when our owner is killed"
        },
        "PrevWeapon": {
          "comment": "Switches to Previous weapon\n Network: Client"
        },
        "RemoveFromInventory": {
          "comment": "Attempts to remove an item from the inventory list if it exists.",
          "params": {
            "Item": "Item to remove from inventory"
          }
        },
        "ServerSetCurrentWeapon": {
          "comment": "ServerSetCurrentWeapon begins the Putdown sequence on the server. This function makes\n the assumption that if TryPutDown succeeded on the client, it will succeed on the server.\n This function shouldn't be called from anywhere except SetCurrentWeapon\n Network: Dedicated Server"
        },
        "SetCurrentWeapon": {
          "comment": "Set DesiredWeapon as Current (Active) Weapon.\n Network: LocalPlayer",
          "params": {
            "DesiredWeapon,": "Desired weapon to assign to player"
          }
        },
        "SetPendingWeapon": {
          "comment": "Set the pending weapon for switching.\n This shouldn't be called outside of SetCurrentWeapon()"
        },
        "SetupFor": {
          "comment": "Setup Inventory for Pawn P.\n Override this to change inventory assignment (from a pawn to another)\n Network: Server only"
        },
        "SwitchToBestWeapon": {
          "comment": "Switch to best weapon available in loadout\n Network: LocalPlayer"
        }
      }
    },
    "JsonObject": {
      "comment": "This is a generic JSON object in unrealscript",
      "properties": {
        "ValueMap": {
          "comment": "// COMMENT!!"
        }
      },
      "functions": {
        "DecodeJson": {
          "comment": "Decodes a Json string into an object hierarchy (all needed objects will be created)",
          "params": {
            "Str": "A Json string (probably received from the web)"
          }
        },
        "EncodeJson": {
          "comment": "Encodes an object hierarchy to a string suitable for sending over the web",
          "params": {
            "Root": "The toplevel object in the hierarchy"
          }
        },
        "GetIntValue": {
          "comment": "Helper functions to convert special strings that the decoder will make from numbers"
        },
        "GetObject": {
          "comment": "Looks up an object with the given key in the ObjectMap",
          "params": {
            "Key": "The key to search for"
          }
        },
        "GetStringValue": {
          "comment": "Looks up a value with the given key in the ObjectMap. If it was a number\n in the Json string, this will be prepended with \\# (see below helpers)",
          "params": {
            "Key": "The key to search for"
          }
        },
        "SetIntValue": {
          "comment": "Helper functions to make special strings that the encoder will turn into numbers"
        },
        "SetObject": {
          "comment": "Set an object"
        }
      }
    },
    "K2NodeBase": {
      "properties": {
        "Inputs": {
          "comment": "List of input connectors"
        },
        "NodePosX": {
          "comment": "X position of node in the editor"
        },
        "NodePosY": {
          "comment": "Y position of node in the editor"
        },
        "Outputs": {
          "comment": "List of output connectors"
        }
      }
    },
    "K2Node_FuncBase": {
      "properties": {
        "Function": {
          "comment": "Pointer to the function that this node will generate a call to"
        }
      }
    },
    "K2Node_Func_NewComp": {
      "properties": {
        "ComponentTemplate": {
          "comment": "Template object used by this function (duplicated) to create a new component."
        }
      }
    },
    "KActor": {
      "properties": {
        "bDisableClientSidePawnInteractions": {
          "comment": "Set TRUE to disable collisions with Pawn rigid bodies on clients. Set this to true if using optimizations that\n could cause the server to miss or ignore contacts that the client might dtect with this KActor, which could cause\n vibration, rubberbanding, and general visual badness."
        },
        "bNeedsRBStateReplication": {
          "comment": "whether we need to replicate RBState - used to avoid it for bNoDelete KActors that haven't moved or been awakened yet\n as in that case the client should already have the same data"
        },
        "ReplicatedDrawScale3D": {
          "comment": "replicated version of DrawScale3D"
        },
        "bDamageAppliesImpulse": {
          "comment": "Function that gets called from within Map_Check to allow this actor to check itself\n for any potential errors and register them with map check dialog."
        },
        "bLimitMaxPhysicsVelocity": {
          "comment": "If TRUE limit the maximum speed this object can move."
        },
        "MaxPhysicsVelocity": {
          "comment": "If bLimitMaxPhysicsVelocity is TRUE, this is how fast the object can move."
        },
        "bEnableStayUprightSpring": {
          "comment": "Enable 'Stay upright' torque, that tries to keep Z axis of KActor pointing along world Z"
        },
        "StayUprightMaxTorque": {
          "comment": "Max torque that can be applied to try and keep KActor horizontal"
        },
        "StayUprightTorqueFactor": {
          "comment": "Torque applied to try and keep KActor horizontal."
        }
      },
      "functions": {
        "FellOutOfWorld": {
          "comment": "called when the actor falls out of the world 'safely' (below KillZ and such)"
        },
        "GetKActorPhysMaterial": {
          "comment": "Util for getting the PhysicalMaterial applied to this KActor's StaticMesh."
        },
        "OnTeleport": {
          "comment": "Called upon receiving a SeqAct_Teleport action. Grabs\n the first destination available and attempts to teleport\n this actor.",
          "params": {
            "inAction": "teleport action that was activated"
          }
        },
        "OnToggle": {
          "comment": "If this KActor receives a Toggle ON event from Kismet, wake the physics up."
        },
        "ResolveRBState": {
          "comment": "Forces the resolve the RBState regardless of wether the actor is sleeping"
        },
        "SpawnedByKismet": {
          "comment": "Makes sure these properties get set up on spawned meshes. Factories do not set the mesh before PostBeginPlay is called."
        },
        "TakeDamage": {
          "comment": "Default behaviour when shot is to apply an impulse and kick the KActor."
        },
        "TakeRadiusDamage": {
          "comment": "Respond to radial damage as well."
        }
      }
    },
    "KActorFromStatic": {
      "properties": {
        "MaxImpulseSpeed": {
          "comment": "Max speed from an impulse"
        },
        "MyStaticMeshActor": {
          "comment": "Actor from whome this static mesh came"
        }
      },
      "functions": {
        "ApplyImpulse": {
          "comment": "Figure out velocity change here so we can bound it."
        },
        "BecomeStatic": {
          "comment": "If still asleep, make static"
        },
        "Bump": {
          "comment": "Bump event is only called for KActorFromStatic if Other is a Pawn"
        },
        "DisablePrecomputedLighting": {
          "comment": "Disable precomputed lighting when become dynamic"
        },
        "MakeDynamic": {
          "comment": "@PARAM MovableMesh: Move this StaticMeshComponent to a KActorFromStatic\n @RETURNS a KActorSpawnable actor with MovableMesh as its mesh (removing MovableMesh from its current owner)"
        },
        "MakeStatic": {
          "comment": "Move the StaticMeshComponent back to its original actor owner (MyStaticMeshActor), and fix its position again."
        },
        "OnSleepRBPhysics": {
          "comment": "A little while after it goes to sleep, make the static mesh static again"
        },
        "OnWakeRBPhysics": {
          "comment": "Cancel becoming static"
        },
        "ReceiveImpulse": {
          "comment": "Bumped or touched by pawn, so take impulse from it."
        },
        "TakeRadiusDamage": {
          "comment": "Respond to radial damage as well."
        },
        "Tick": {
          "comment": "Delay disabling lightmaps by one tick to avoid lighting pop"
        },
        "Touch": {
          "comment": "Pawns will Touch rather than Bump"
        }
      }
    },
    "KActorSpawnable": {
      "properties": {
        "bRecycleScaleToZero": {
          "comment": "If this is true then the KActor will scale to zero before hiding self"
        },
        "bScalingToZero": {
          "comment": "Whether or not we are scaling to zero (in C++ TickSpecial())"
        }
      },
      "functions": {
        "Recycle": {
          "comment": "This will reset the KActorSpawnable to its default state either first scaling to zero or by just hiding the object."
        },
        "RecycleInternal": {
          "comment": "This will reset the KActorSpawnable to its default state. This is useful for pooling."
        },
        "ResetComponents": {
          "comment": "Used when the actor is pulled from a cache for use."
        }
      }
    },
    "KAsset": {
      "properties": {
        "ReplicatedMesh": {
          "comment": "Used to replicate mesh to clients"
        },
        "ReplicatedPhysAsset": {
          "comment": "Used to replicate physics asset to clients"
        },
        "bBlockPawns": {
          "comment": "Whether this KAsset should block Pawns."
        }
      },
      "functions": {
        "DoKismetAttachment": {
          "comment": "Performs actual attachment. Can be subclassed for class specific behaviors."
        },
        "OnToggle": {
          "comment": "If this KAsset receives a Toggle ON event from Kismet, wake the physics up."
        },
        "PostBeginPlay": {
          "comment": "Function that gets called from within Map_Check to allow this actor to check itself\n for any potential errors and register them with map check dialog."
        },
        "SetMeshAndPhysAsset": {
          "comment": "Sets the new mesh and physics asset, along with the replicated properties for clients."
        },
        "TakeDamage": {
          "comment": "Default behaviour when shot is to apply an impulse and kick the KActor."
        },
        "TakeRadiusDamage": {
          "comment": "Take Radius Damage",
          "params": {
            "InstigatedBy,": "instigator of the damage",
            "Base": "Damage",
            "Damage": "Radius (from Origin)",
            "DamageType": "class",
            "Momentum": "(float)",
            "HurtOrigin,": "origin of the damage radius.",
            "DamageCauser": "the Actor that directly caused the damage (i.e. the Projectile that exploded, the Weapon that fired, etc)"
          }
        }
      }
    },
    "KismetBookMark": {
      "comment": "Simple class to represent bookmarks in Kismet.",
      "properties": {
        "BookMarkSequencePathName": {
          "comment": "Name of the sequence the bookmark applies to"
        }
      }
    },
    "KMeshProps": {
      "structs": {
        "KAggregateGeom": {
          "properties": {
            "bSkipCloseAndParallelChecks": {
              "comment": "Collision against this geom will not specially handle the \"close and parallel\" case. Special-case."
            }
          }
        },
        "KBoxElem": {
          "properties": {
            "bNoRBCollision": {
              "comment": "Disable rigid body collision for this shape."
            },
            "bPerPolyShape": {
              "comment": "Check against this shape even when per-poly collision is being used."
            }
          }
        },
        "KConvexElem": {
          "comment": "One convex hull, used for simplified collision.",
          "properties": {
            "EdgeDirections": {
              "comment": "All different directions of edges in this hull."
            },
            "ElemBox": {
              "comment": "Bounding box of this convex hull."
            },
            "FaceNormalDirections": {
              "comment": "All different directions of face normals in this hull."
            },
            "FacePlaneData": {
              "comment": "Array of the planes that make up this convex hull."
            },
            "FaceTriData": {
              "comment": "Index buffer for triangles making up the faces of this convex hull."
            },
            "PermutedVertexData": {
              "comment": "Array of planes holding the vertex data in SIMD order"
            },
            "VertexData": {
              "comment": "Array of indices that make up the convex hull."
            }
          }
        },
        "KSphereElem": {
          "properties": {
            "bNoRBCollision": {
              "comment": "Disable rigid body collision for this shape."
            },
            "bPerPolyShape": {
              "comment": "Check against this shape even when per-poly collision is being used."
            }
          }
        },
        "KSphylElem": {
          "properties": {
            "bNoRBCollision": {
              "comment": "Disable rigid body collision for this shape."
            },
            "bPerPolyShape": {
              "comment": "Check against this shape even when per-poly collision is being used."
            }
          }
        }
      }
    },
    "LadderVolume": {
      "properties": {
        "WallDirArrow": {
          "comment": "Editor visual cue for the direction of the wall"
        }
      }
    },
    "Landscape": {
      "properties": {
        "ComponentSizeQuads": {
          "comment": "Data set at creation time"
        },
        "LayerNames": {
          "comment": "Layers that can be painted on the landscape"
        },
        "XYtoAddCollisionMap": {
          "comment": "Map of the SectionBaseX/Y component offets to the newly added collison components. Only available near valid LandscapeComponents. Valid in editor only."
        },
        "XYtoCollisionComponentMap": {
          "comment": "Map of the SectionBaseX/Y component offets (in heightmap space) to the collison components. Valid in editor only."
        },
        "XYtoComponentMap": {
          "comment": "Map of the SectionBaseX/Y component offets (in heightmap space) to the component. Valid in editor only."
        },
        "LandscapeMaterial": {
          "comment": "Combined material used to render the landscape"
        },
        "MaxLODLevel": {
          "comment": "Max LOD level to use when rendering"
        },
        "StreamingDistanceMultiplier": {
          "comment": "Allows artists to adjust the distance where textures using UV 0 are streamed in/out.\n 1.0 is the default, whereas a higher value increases the streamed-in resolution."
        },
        "LightmassSettings<ScriptOrder=true>": {
          "comment": "The Lightmass settings for this object."
        }
      },
      "structs": {
        "LandscapeAddCollision": {
          "comment": "Structure storing Collision for LandscapeComponent Add"
        },
        "LandscapeLayerInfo": {
          "comment": "Structure storing Layer Data"
        }
      }
    },
    "LandscapeComponent": {
      "properties": {
        "CachedBoxSphereBounds": {
          "comment": "Cached bounds, created at heightmap update time"
        },
        "CollisionMipLevel": {
          "comment": "Heightfield mipmap used to generate collision"
        },
        "EditToolRenderData": {
          "comment": "Pointer to data shared with the render therad, used by the editor tools"
        },
        "HeightmapScaleBias": {
          "comment": "UV offset to Heightmap data from component local coordinates"
        },
        "HeightmapSubsectionOffset": {
          "comment": "U or V offset into the heightmap for the first subsection, in texture UV space"
        },
        "HeightmapTexture": {
          "comment": "Heightmap texture reference"
        },
        "IrrelevantLights": {
          "comment": "INTERNAL: Array of lights that don't apply to the terrain component."
        },
        "LayerUVPan": {
          "comment": "UV offset for layer texturing to match adjacent components"
        },
        "LightingGuid": {
          "comment": "Unique ID for this component, used for caching during distributed lighting"
        },
        "LightMap": {
          "comment": "Reference to the texture lightmap resource."
        },
        "PlatformData": {
          "comment": "Platform-specific data"
        },
        "PlatformDataSize": {
          "comment": "Platform-specific data size"
        },
        "ShadowMaps": {
          "comment": "Array of shadow maps for this component."
        },
        "StaticLightingResolution": {
          "comment": "The resolution to cache lighting at, in texels/patch.\n A separate shadow-map is used for each terrain component, which is\n (SectionSizeQuads * StaticLightingResolution + 1) pixels on a side."
        },
        "WeightmapLayerAllocations": {
          "comment": "List of layers, and the weightmap and channel they are stored"
        },
        "WeightmapScaleBias": {
          "comment": "UV offset to component's weightmap data from component local coordinates"
        },
        "WeightmapSubsectionOffset": {
          "comment": "U or V offset into the weightmap for the first subsection, in texture UV space"
        },
        "WeightmapTextures": {
          "comment": "Weightmap texture reference"
        }
      },
      "structs": {
        "WeightmapLayerAllocationInfo": {
          "comment": "Stores information about which weightmap texture and channel each layer is stored"
        }
      }
    },
    "LandscapeHeightfieldCollisionComponent": {
      "properties": {
        "CachedBoxSphereBounds": {
          "comment": "Cached bounds, created at heightmap update time"
        },
        "CollisionHeightData": {
          "comment": "The collision height values."
        },
        "CollisionQuadFlags": {
          "comment": "The flags for each collision quad. See ECollisionQuadFlags."
        },
        "CollisionScale": {
          "comment": "Collision scale: (ComponentSizeQuads+1) / (CollisionSizeQuads+1)"
        },
        "CollisionSizeQuads": {
          "comment": "Size of component in collision quads"
        },
        "RBHeightfield": {
          "comment": "Physics engine version of heightfield data."
        },
        "SectionBaseX": {
          "comment": "Offset of component in landscape quads"
        }
      }
    },
    "LandscapeProxy": {
      "properties": {
        "CollisionComponents": {
          "comment": "Array of LandscapeHeightfieldCollisionComponent"
        },
        "LandscapeComponents": {
          "comment": "The array of LandscapeComponent that are used by the landscape"
        },
        "MaterialInstanceConstantMap": {
          "comment": "Map of material instance constants used to for the components. Key is generated with ULandscapeComponent::GetLayerAllocationKey()"
        },
        "WeightmapUsageMap": {
          "comment": "Map of weightmap usage"
        },
        "StaticLightingResolution": {
          "comment": "The resolution to cache lighting at, in texels/patch.\n A separate shadow-map is used for each terrain component, which is up to\n (MaxComponentSize * StaticLightingResolution + 1) pixels on a side.\n Must be a power of two, 1 <= StaticLightingResolution <= MaxTesselationLevel."
        }
      },
      "structs": {
        "LandscapeWeightmapUsage": {
          "comment": "Structure storing channel usage for weightmap textures"
        }
      }
    },
    "LensFlare": {
      "properties": {
        "CurveEdSetup": {
          "comment": "Used for curve editor to remember curve-editing setup."
        },
        "ReflectionCount": {
          "comment": "Internal variable used to initialize new entries in the Reflectsions array"
        },
        "Reflections": {
          "comment": "The individual reflection elements of the lens flare"
        },
        "SourceDPG": {
          "comment": "The scene depth priority group to draw the source primitive in."
        },
        "SourceElement": {
          "comment": "The Source of the lens flare"
        },
        "ThumbnailAngle": {
          "comment": "The angle to use when rendering the thumbnail image"
        },
        "ThumbnailDistance": {
          "comment": "The distance to place the system when rendering the thumbnail image"
        },
        "ThumbnailImage": {
          "comment": "Internal: The thumbnail image"
        },
        "ThumbnailImageOutOfDate": {
          "comment": "Internal: Indicates the thumbnail image is out of date"
        },
        "bUseFixedRelativeBoundingBox": {
          "comment": "If TRUE, use the given bounds.\n If FALSE and a static mesh is set for the source, the static mesh bounds will be used.\n If FALSE and no static mesh is set, it will use the default bounds (likely not a good thing)."
        },
        "FixedRelativeBoundingBox": {
          "comment": "The fixed bounding box to use when bUseFixedRelativeBoundingBox is TRUE"
        },
        "bRenderDebugLines": {
          "comment": "Debugging helpers"
        },
        "ScreenPercentageMap": {
          "comment": "The mapping of screen coverage percentage (the result returned by occlusion checks)\n to the value passed into the materials for LensFlareOcclusion."
        },
        "ReflectionsDPG": {
          "comment": "The scene depth priority group to draw the reflection primitive(s) in."
        },
        "SourceMesh": {
          "comment": "The StaticMesh to use as the source (optional)"
        },
        "OuterCone": {
          "comment": "Viewing cone angles."
        }
      },
      "structs": {
        "LensFlareElement": {
          "comment": "LensFlare Element",
          "properties": {
            "Alpha": {
              "comment": "Alpha (passed to the element material via the VertexColor expression)"
            },
            "AxisScaling": {
              "comment": "Anamorphic scaling."
            },
            "bIsEnabled": {
              "comment": "Whether the element is enabled or not"
            },
            "bModulateColorBySource": {
              "comment": "Whether the element color value should be scaled by the source color."
            },
            "bNormalizeRadialDistance": {
              "comment": "Whether the radial distance should be normalized to a unit value.\n Without this, the radial distance will be 0..1 in the horizontal and vertical cases.\n It will be 0..1.4 in the corners."
            },
            "bOrientTowardsSource": {
              "comment": "If TRUE, always rotate the element to orient towards the source"
            },
            "bUseSourceDistance": {
              "comment": "Whether the element value look ups should use the radial distance\n from the center to the edge of the screen or the ratio of the distance\n from the source element."
            },
            "Color": {
              "comment": "Color (passed to the element material via the VertexColor expression)"
            },
            "DistMap_Alpha": {
              "comment": "Value to scale the Alpha by. Uses source to camera distance to look up the value (in Unreal units)"
            },
            "DistMap_Color": {
              "comment": "Value to scale the Color by. Uses source to camera distance to look up the value (in Unreal units)"
            },
            "DistMap_Scale": {
              "comment": "Value to scale the AxisScaling by. Uses source to camera distance to look up the value (in Unreal units)"
            },
            "ElementName": {
              "comment": "The name of the element. (Optional)"
            },
            "LFMaterialIndex": {
              "comment": "Index of the material to use from the LFMaterial array."
            },
            "LFMaterials": {
              "comment": "The material(s) to use for the flare element."
            },
            "Offset": {
              "comment": "Offset."
            },
            "RayDistance": {
              "comment": "The position along the ray from the source to the viewpoint to render the flare at.\n 0.0 = At the source\n 1.0 = The source point reflected about the view center.\n < 0 = The point along the ray going away from the center past the source.\n > 1 = The point along the ray beyond the 'end point' of the ray reflection."
            },
            "Rotation": {
              "comment": "Rotation."
            },
            "Scaling": {
              "comment": "Global scaling."
            },
            "Size": {
              "comment": "The 'base' size of the element"
            }
          }
        },
        "LensFlareElementCurvePair": {
          "comment": "Helper for getting curves from distributions"
        }
      }
    },
    "LensFlareComponent": {
      "properties": {
        "bIsActive": {
          "comment": "Internal variables"
        },
        "bVisibleForMobile": {
          "comment": "Storage for mobile as to whether this lens flare was visible based on a line check on previous check"
        },
        "Materials": {
          "comment": "Per-element material overrides. These must NOT be set directly or a race condition can occur between GC and the rendering thread."
        },
        "NextTraceTime": {
          "comment": "Used to determine when to trace on mobile platforms"
        },
        "OuterCone": {
          "comment": "Viewing cone angles."
        },
        "ReleaseResourcesFence": {
          "comment": "Command fence used to shut down properly"
        },
        "bAutoActivate": {
          "comment": "If TRUE, automatically enable this flare when it is attached"
        },
        "SourceColor": {
          "comment": "The color of the source"
        }
      }
    },
    "LensFlareSource": {
      "properties": {
        "bCurrentlyActive": {
          "comment": "used to update status of toggleable level placed lens flares on clients"
        }
      },
      "functions": {
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        },
        "SetActorParameter": {
          "comment": "local linearcolor c;\nif (LensFlareComp != none)\n{\nc.r = Red;\nc.g = Green;\nc.b = Blue;\nc.a = Alpha;\nLensFlareComp.SetColorParameter(ParameterName, C);\n}\nelse\n{\n`log(\"Warning: Attempting to set a parameter on \"$self$\" when the PSC does not exist\");"
        },
        "SetColorParameter": {
          "comment": "if (LensFlareComp != none)\n{\nLensFlareComp.SetVectorParameter(ParameterName, Param);\n}\nelse\n{\n`log(\"Warning: Attempting to set a parameter on \"$self$\" when the PSC does not exist\");"
        },
        "SetExtColorParameter": {
          "comment": "if (LensFlareComp != none)\n{\nLensFlareComp.SetColorParameter(ParameterName, Param);\n}\nelse\n{\n`log(\"Warning: Attempting to set a parameter on \"$self$\" when the PSC does not exist\");"
        },
        "SetTemplate": {
          "comment": "Function that gets called from within Map_Check to allow this actor to check itself\n for any potential errors and register them with map check dialog."
        },
        "SetVectorParameter": {
          "comment": "if (LensFlareComp != none)\n{\nLensFlareComp.SetFloatParameter(ParameterName, Param);\n}\nelse\n{\n`log(\"Warning: Attempting to set a parameter on \"$self$\" when the PSC does not exist\");"
        }
      }
    },
    "LevelGridVolume": {
      "properties": {
        "CellConvexElem": {
          "comment": "Grid cell convex shape, used for fast distance tests"
        },
        "CellShape": {
          "comment": "Shape of the cells this grid is composed of"
        },
        "KeepLoadedRange": {
          "comment": "Extra distance before the LoadingDistance which levels should stay loaded. This can be used to prevent a level from continuously being loaded and unloaded as the viewer's distance to the cell crosses the LoadingDistance threshold."
        },
        "LevelGridVolumeName": {
          "comment": "Name of this level grid volume, which is also the prefix for level names created for volume. If empty, the level grid volume actor's name will be used instead. You should set this name before placing any actors into the level, and never change it afterwards!"
        },
        "LoadingDistance": {
          "comment": "Minimum distance between a grid cell and the viewer before a cell's level will be queued to stream in"
        },
        "Subdivisions[3]": {
          "comment": "The number of streaming volumes should the grid be subdivided into along each axis. Be careful when changing this after actors have been added to the level grid volume!"
        }
      },
      "structs": {
        "LevelGridCellCoordinate": {
          "comment": "Structure contains coordinates for a single grid cell",
          "properties": {
            "X": {
              "comment": "Cell X coordinate"
            },
            "Y": {
              "comment": "Cell Y coordinate"
            },
            "Z": {
              "comment": "Cell Z coordinate"
            }
          }
        }
      }
    },
    "LevelStreaming": {
      "properties": {
        "bBoundingBoxVisible": {
          "comment": "Whether this level's bounding box should be visible in the Editor."
        },
        "bHasLoadRequestPending": {
          "comment": "Whether we currently have a load request pending."
        },
        "bHasUnloadRequestPending": {
          "comment": "Whether we currently have an unload request pending."
        },
        "bIsRequestingUnloadAndRemoval": {
          "comment": "Whether this level streaming object's level should be unloaded and the object be removed from the level list."
        },
        "bIsVisible": {
          "comment": "Whether the level is currently visible/ associated with the world"
        },
        "bShouldBeLoaded": {
          "comment": "Whether the level should be loaded"
        },
        "bShouldBeVisible": {
          "comment": "Whether the level should be visible if it is loaded"
        },
        "bShouldBlockOnLoad": {
          "comment": "Whether we want to force a blocking load"
        },
        "Keywords": {
          "comment": "List of keywords to filter on in the level browser"
        },
        "LastVolumeUnloadRequestTime": {
          "comment": "Time of last volume unload request. Used in preventing spurious unload requests."
        },
        "LoadedLevel": {
          "comment": "Pointer to Level object if currently loaded/ streamed in."
        },
        "OldOffset": {
          "comment": "Current/ old offset required for changing the offset at runtime, e.g. in the Editor."
        },
        "bDrawOnLevelStatusMap": {
          "comment": "If TRUE, will be drawn on the 'level streaming status' map (STAT LEVELMAP console command)"
        },
        "bIsFullyStatic": {
          "comment": "Whether this level is fully static - if it is, then assumptions can be made about it, ie it doesn't need to be reloaded since nothing could have changed"
        },
        "bLocked": {
          "comment": "Whether this level is locked; that is, its actors are read-only."
        },
        "bShouldBeVisibleInEditor": {
          "comment": "Whether this level should be visible in the Editor"
        },
        "DrawColor": {
          "comment": "The level's color; used to make the level easily identifiable in the level browser, for actor level visulization, etc."
        },
        "EditorGridVolume": {
          "comment": "The grid volume bound to this level, if any"
        },
        "EditorStreamingVolumes": {
          "comment": "The level streaming volumes bound to this level."
        },
        "GridPosition[3]": {
          "comment": "Row, column and depth of this streaming level in a streaming grid network"
        },
        "MinTimeBetweenVolumeUnloadRequests": {
          "comment": "Cooldown time in seconds between volume-based unload requests. Used in preventing spurious unload requests."
        },
        "Offset": {
          "comment": "Offset applied to actors after loading."
        },
        "PackageName": {
          "comment": "Name of the level package name used for loading."
        }
      }
    },
    "LevelStreamingAlwaysLoaded": {
      "properties": {
        "bIsProceduralBuildingLODLevel": {
          "comment": "Determines whether or not his Always loaded level is one that was auto created for a Procedural Building LOD level."
        }
      }
    },
    "LevelStreamingDistance": {
      "properties": {
        "MaxDistance": {
          "comment": "Maximum distance to viewer at which the level still is streamed in"
        },
        "Origin": {
          "comment": "Origin of level used for distance calculation to viewer"
        }
      }
    },
    "LevelStreamingVolume": {
      "comment": "Used to affect level streaming in the game and level visibility in the editor.",
      "properties": {
        "bDisabled": {
          "comment": "If TRUE, this streaming volume is ignored by the streaming volume code. Used to either\n disable a level streaming volume without disassociating it from the level, or to toggle\n the control of a level's streaming between Kismet and volume streaming."
        },
        "bEditorPreVisOnly": {
          "comment": "If TRUE, this streaming volume should only be used for editor streaming level previs."
        },
        "bTestDistanceToVolume": {
          "comment": "If TRUE, level will stream when closer than TestVolumeDistance to the volume."
        },
        "StreamingLevels": {
          "comment": "Levels affected by this level streaming volume."
        },
        "StreamingUsage": {
          "comment": "Determines what this volume is used for, e.g. whether to control loading, loading and visibility or just visibilty (blocking on load)"
        },
        "TestVolumeDistance": {
          "comment": "If bTestDistanceToVolume is TRUE, level will stream in if closer than this to volume."
        }
      },
      "functions": {
        "OnToggle": {
          "comment": "Kismet support for toggling bDisabled."
        }
      }
    },
    "LiftCenter": {
      "properties": {
        "LiftTrigger": {
          "comment": "if specified, must touch this to start the lift"
        }
      },
      "functions": {
        "SpecialHandling": {
          "comment": "SpecialHandling is called by the navigation code when the next path has been found.\nIt gives that path an opportunity to modify the result based on any special considerations\nHere, we check if the mover needs to be triggered"
        }
      }
    },
    "Light": {
      "properties": {
        "bEnabled": {
          "comment": "replicated copy of LightComponent's bEnabled property"
        }
      }
    },
    "LightComponent": {
      "properties": {
        "bAllowCompositingIntoDLE": {
          "comment": "Whether this light can be combined into the DLE normally. Overriden to false in the case of muzzle flashes to prevent SH artifacts"
        },
        "bAllowPreShadow": {
          "comment": "Whether to allow preshadows (the static environment casting dynamic shadows on dynamic objects) from this light."
        },
        "bCanAffectDynamicPrimitivesOutsideDynamicChannel": {
          "comment": "Whether the light can affect dynamic primitives even though the light is not affecting the dynamic channel."
        },
        "bExplicitlyAssignedLight": {
          "comment": "Whether this light is being used as the OverrideLightComponent on a primitive and shouldn't affect any other primitives."
        },
        "bHasLightEverBeenBuiltIntoLightMap": {
          "comment": "Whether light has ever been built into a lightmap"
        },
        "bOnlyAffectSameAndSpecifiedLevels": {
          "comment": "Whether to only affect primitives that are in the same level/ share the same GetOutermost() or are in the set of additionally specified ones."
        },
        "bPrecomputedLightingIsValid": {
          "comment": "The precomputed lighting for that light source is valid. It might become invalid if some properties change (e.g. position, brightness)."
        },
        "bUseVolumes": {
          "comment": "Whether to use the inclusion/ exclusion volumes."
        },
        "ExclusionConvexVolumes": {
          "comment": "Array of convex exclusion volumes, populated from ExclusionVolumes by PostEditChange."
        },
        "ExclusionVolumes": {
          "comment": "Array of volumes used by AffectsBounds if bUseVolumes is set. Light will only affect primitives if they neither touching nor are\n contained by at least one volume. Exclusion overrides inclusion."
        },
        "InclusionConvexVolumes": {
          "comment": "Array of convex inclusion volumes, populated from InclusionVolumes by PostEditChange."
        },
        "InclusionVolumes": {
          "comment": "Array of volumes used by AffectsBounds if bUseVolumes is set. Light will only affect primitives if they are touching or are contained\n by at least one volume. Exclusion overrides inclusion."
        },
        "LightEnvironment": {
          "comment": "The light environment which the light affects.\n NULL represents an implicit default light environment including all primitives and lights with LightEnvironment=NULL."
        },
        "LightEnv_BouncedLightBrightness": {
          "comment": "The intensity of bounced lighting from this light in DynamicLightEnvironments."
        },
        "LightEnv_BouncedModulationColor": {
          "comment": "The color of bounced lighting from this light in DynamicLightEnvironments."
        },
        "LightGuid": {
          "comment": "GUID used to associate a light component with precomputed shadowing information across levels.\n The GUID changes whenever the light position changes."
        },
        "LightListIndex": {
          "comment": "The munged index of this light in the light list \n \n > 0 == static light list\n 0 == not part of any light list\n < 0 == dynamic light list"
        },
        "LightmapGuid": {
          "comment": "GUID used to associate a light component with precomputed shadowing information across levels.\n The GUID changes whenever any of the lighting relevant properties changes."
        },
        "ModShadowFadeoutExponent": {
          "comment": "Exponent that controls mod shadow fadeout curve."
        },
        "ModShadowFadeoutTime": {
          "comment": "Time since the caster was last visible at which the mod shadow will fade out completely."
        },
        "OtherLevelsToAffect": {
          "comment": "Array of other levels to affect if bOnlyAffectSameAndSpecifiedLevels is TRUE, own level always implicitly part of array."
        },
        "ShadowProjectionTechnique": {
          "comment": "Type of shadow projection to use for this light"
        },
        "bUseImageReflectionSpecular<bShowOnlyWhenTrue=bShowD3D11Properties>": {
          "comment": "Whether to replace this light's analytical specular with image based specular on materials that support it."
        },
        "ReflectionSpecularBrightness<bShowOnlyWhenTrue=bShowD3D11Properties>": {
          "comment": "Scales the contribution of the reflection specular highlight."
        },
        "bAffectCompositeShadowDirection": {
          "comment": "If bCastCompositeShadow=TRUE, whether the light should affect the composite shadow direction."
        },
        "bCastCompositeShadow": {
          "comment": "True if the light should cast shadow from primitives which use a composite light environment."
        },
        "bEnabled": {
          "comment": "Is this light enabled?"
        },
        "bForceDynamicLight": {
          "comment": "True if this light should use dynamic shadows for all primitives."
        },
        "bNonModulatedSelfShadowing": {
          "comment": "If enabled and the light casts modulated shadows, this will cause self-shadowing of shadows rendered from this light to use normal shadow blending. \n This is useful to get better quality self shadowing while still having a shadow on the lightmapped environment. \n When enabled it incurs most of the rendering overhead of both approaches combined."
        },
        "bSelfShadowOnly": {
          "comment": "Forces shadows from this light to only self shadow."
        },
        "CastDynamicShadows": {
          "comment": "True if the light can be blocked by dynamic shadow casting primitives.\n controls whether the light should cast shadows from objects that cannot receive static shadowing"
        },
        "CastShadows": {
          "comment": "True if the light can be blocked by shadow casting primitives.\n controls whether the light should cast shadows"
        },
        "CastStaticShadows": {
          "comment": "True if the light can be blocked by static shadow casting primitives.\n controls whether the light should cast shadows from objects that can receive static shadowing"
        },
        "LightAffectsClassification": {
          "comment": "This is the classification of this light. This is used for placing a light for an explicit\n purpose. Basically you can now have \"type\" information with lights and understand the\n intent of why a light was placed. This is very useful for content people getting maps\n from others and understanding why there is a dynamic affect light in the middle of the world\n with a radius of 32k! And also useful for being able to do searches such as the following:\n show me all lights which effect dynamic objects. Now show me the set of lights which are\n not explicitly set as Dynamic Affecting lights."
        },
        "LightingChannels": {
          "comment": "Lighting channels controlling light/ primitive interaction. Only allows interaction if at least one channel is shared"
        },
        "LightShadowMode": {
          "comment": "Type of shadowing to apply for the light"
        },
        "MaxShadowResolution": {
          "comment": "Override for max square dimensions (in texels) allowed for rendering shadow subject depths.\n A value of 0 defaults to MaxShadowResolution in SystemSettings."
        },
        "MinShadowResolution": {
          "comment": "Override for min dimensions (in texels) allowed for rendering shadow subject depths.\n This also controls shadow fading, once the shadow resolution reaches MinShadowResolution it will be faded out completely.\n A value of 0 defaults to MinShadowResolution in SystemSettings."
        },
        "ModShadowColor": {
          "comment": "Shadow color for modulating entire scene"
        },
        "ShadowFadeResolution": {
          "comment": "Resolution in texels below which shadows begin to be faded out. \n Once the shadow resolution reaches MinShadowResolution it will be faded out completely.\n A value of 0 defaults to ShadowFadeResolution in SystemSettings."
        },
        "ShadowFilterQuality": {
          "comment": "Quality of shadow buffer filtering to use on this light"
        },
        "UseDirectLightMap": {
          "comment": "Set to True to store the direct flux of this light in a light-map."
        },
        "BloomScale": {
          "comment": "Scales additive color near the light source. A value of 0 will result in no additive term. \n If BloomScale is 0 and OcclusionMaskDarkness is 1, light shafts will effectively be disabled."
        },
        "BloomScreenBlendThreshold": {
          "comment": "Scene color luminance must be less than this to receive bloom from light shafts. \n This behaves like Photoshop's screen blend mode and prevents over-saturation from adding bloom to already bright areas.\n The default value of 1 means that a pixel with a luminance of 1 won't receive any bloom, but a pixel with a luminance of .5 will receive half bloom."
        },
        "BloomThreshold": {
          "comment": "Scene color luminance must be larger than this to create bloom in light shafts."
        },
        "BloomTint": {
          "comment": "Multiplies against scene color to create the bloom color."
        },
        "bRenderLightShafts": {
          "comment": "Whether to render light shafts from this light. Only non-static lights can render light shafts (toggleable, movable or dominant types)."
        },
        "OcclusionDepthRange": {
          "comment": "Everything closer to the camera than this distance will occlude light shafts for directional lights."
        },
        "OcclusionMaskDarkness": {
          "comment": "Controls how dark the occlusion masking is, a value of .5 would mean that an occlusion of 0 only darkens underlying color by half. \n A value of 1 results in no darkening term. If BloomScale is 0 and OcclusionMaskDarkness is 1, light shafts will effectively be disabled."
        },
        "RadialBlurPercent": {
          "comment": "100 is maximum blur length, 0 is no blur."
        }
      },
      "functions": {
        "GetDirection": {
          "comment": "Script interface to retrieve light direction."
        },
        "GetOrigin": {
          "comment": "Script interface to retrieve light location."
        },
        "OnUpdatePropertyBloomScale": {
          "comment": "Called from matinee code when BloomScale property changes."
        },
        "OnUpdatePropertyBloomTint": {
          "comment": "Called from matinee code when BloomTint property changes."
        },
        "OnUpdatePropertyBrightness": {
          "comment": "Called from matinee code when Brightness property changes."
        },
        "OnUpdatePropertyLightColor": {
          "comment": "Called from matinee code when LightColor property changes."
        },
        "OnUpdatePropertyOcclusionMaskDarkness": {
          "comment": "Called from matinee code when OcclusionMaskDarkness property changes."
        },
        "SetEnabled": {
          "comment": "Toggles the light on or off",
          "params": {
            "bSetEnabled": "TRUE to enable the light or FALSE to disable it"
          }
        },
        "SetLightProperties": {
          "comment": "sets Brightness, LightColor, and/or LightFunction"
        },
        "UpdateColorAndBrightness": {
          "comment": "Script interface to update the color and brightness on the render thread."
        },
        "UpdateLightShaftParameters": {
          "comment": "Script interface to update light shaft parameters on the render thread."
        }
      },
      "structs": {
        "LightingChannelContainer": {
          "properties": {
            "bInitialized": {
              "comment": "Whether the lighting channel has been initialized. Used to determine whether UPrimitveComponent::Attach should set defaults."
            }
          }
        }
      }
    },
    "LightEnvironmentComponent": {
      "properties": {
        "AffectedComponents": {
          "comment": "Array of primitive components which are using this light environment and currently attached."
        },
        "AffectingDominantLight": {
          "comment": "The single dominant light that is allowed to affect this light environment."
        },
        "bAllowDynamicShadowsOnTranslucency": {
          "comment": "Whether lit translucency using this light environment is allowed to receive dynamic shadows from the static environment.\n When FALSE, cheaper on/off shadowing will be applied based on the distance to the dominant shadow transition."
        },
        "bAllowPreShadow": {
          "comment": "Whether primitives using this light environment will create a preshadow (dynamic shadow from the static environment onto a dynamic object)."
        },
        "bForceNonCompositeDynamicLights": {
          "comment": "Whether the light environment should override GSystemSettings.bUseCompositeDynamicLights, and never composite dynamic lights into the light environment."
        },
        "bTranslucencyShadowed": {
          "comment": "Contains the shadow factor used on translucency using this light environment when bAllowDynamicShadowsOnTranslucency is FALSE."
        },
        "DominantShadowFactor": {
          "comment": "Shadowing factor applied to AffectingDominantLight."
        },
        "bEnabled": {
          "comment": "Whether the light environment is used or treated the same as a LightEnvironment=NULL reference."
        }
      },
      "functions": {
        "IsEnabled": {
          "comment": "Returns whether the light environment is enabled"
        },
        "SetEnabled": {
          "comment": "Changes the value of bEnabled.",
          "params": {
            "bNewEnabled": "The value to assign to bEnabled."
          }
        }
      }
    },
    "LightFunction": {
      "properties": {
        "DisabledBrightness": {
          "comment": "Brightness factor applied to the light when the light function is specified but disabled, for example in scene captures that use SceneCapView_LitNoShadows. \n This should be set to the average brightness of the light function material's emissive input, which should be between 0 and 1."
        }
      }
    },
    "LightmappedSurfaceCollection": {
      "properties": {
        "SourceModel": {
          "comment": "The UModel these surfaces come from."
        },
        "Surfaces": {
          "comment": "An array of the surface indices grouped into a single static lighting mapping."
        }
      }
    },
    "LightmassLevelSettings": {
      "comment": "Persistent level settings for Lightmass",
      "properties": {
        "SpecularBoost<UIMin=0.0|UIMax=4.0>": {
          "comment": "Scales the specular contribution of all materials in the scene."
        },
        "DiffuseBoost<UIMin=0.0|UIMax=4.0>": {
          "comment": "Scales the diffuse contribution of all materials in the scene."
        },
        "EmissiveBoost<UIMin=0.0|UIMax=4.0>": {
          "comment": "Scales the emissive contribution of all materials in the scene."
        },
        "EnvironmentColor": {
          "comment": "Color that rays which miss the scene will pick up."
        },
        "NumIndirectLightingBounces": {
          "comment": "Number of times light is allowed to bounce off of surfaces, starting from the light source. \n 0 is direct lighting only, 1 is one bounce, etc. \n Bounce 1 takes the most time to calculate, followed by bounce 2. Successive bounces are nearly free."
        },
        "bUseAmbientOcclusion": {
          "comment": "If TRUE, AmbientOcclusion will be enabled."
        },
        "bVisualizeAmbientOcclusion": {
          "comment": "If TRUE, override normal direct and indirect lighting with just the AO term."
        },
        "DirectIlluminationOcclusionFraction": {
          "comment": "How much of the AO to apply to direct lighting."
        },
        "FullyOccludedSamplesFraction": {
          "comment": "Fraction of samples taken that must be occluded in order to reach full occlusion."
        },
        "IndirectIlluminationOcclusionFraction": {
          "comment": "How much of the AO to apply to indirect lighting."
        },
        "MaxOcclusionDistance": {
          "comment": "Maximum distance for an object to cause occlusion on another object."
        },
        "OcclusionExponent": {
          "comment": "Higher exponents increase contrast."
        }
      }
    },
    "LightmassPrimitiveSettingsObject": {
      "comment": "Primitive settings for Lightmass"
    },
    "LightVolume": {
      "comment": "Used to associate lights with volumes."
    },
    "LineBatchComponent": {
      "properties": {
        "FPrimitiveDrawInterfaceVfTable": {
          "comment": "These mirror the C++ side properties. I'm making a class here so"
        }
      }
    },
    "LocalMessage": {
      "functions": {
        "PartiallyDuplicates": {
          "comment": "RETURNS true if messages are similar enough to trigger \"partially unique\" check for HUD display"
        }
      }
    },
    "LocalPlayer": {
      "properties": {
        "ActivePPOverrides": {
          "comment": "Stack of active overrides. Restricting this to 1 \"active\" and have all others be fading out, though"
        },
        "AspectRatioAxisConstraint": {
          "comment": "How to constrain perspective viewport FOV"
        },
        "bSentSplitJoin": {
          "comment": "set when we've sent a split join request"
        },
        "bWantToResetToMapDefaultPP": {
          "comment": "Whether or not to use the next map's defaults and ditch the current pp settings"
        },
        "ControllerId": {
          "comment": "The controller ID which this player accepts input from."
        },
        "CurrentPPInfo": {
          "comment": "The Post Process value used"
        },
        "LastMap": {
          "comment": "The last map this player remembers being on. Used to determine if the map has changed and the pp needs to be reset to default"
        },
        "LastViewLocation": {
          "comment": "The location of the player's view the previous frame."
        },
        "LevelPPInfo": {
          "comment": "Baseline Level Post Process Info"
        },
        "Origin": {
          "comment": "The coordinates for the upper left corner of the master viewport subregion allocated to this player. 0-1"
        },
        "PlayerPostProcess": {
          "comment": "Chain of post process effects for this player view"
        },
        "Size": {
          "comment": "The size of the master viewport subregion allocated to this player. 0-1"
        },
        "TagContext": {
          "comment": "This Local Player's translation context. See GetTranslationContext() below."
        },
        "ViewportClient": {
          "comment": "The master viewport containing this player's view."
        }
      },
      "functions": {
        "ClearPostProcessSettingsOverride": {
          "comment": "Stop overriding post process settings.\n Will only affect active overrides -- in-progress blendouts are unaffected.",
          "params": {
            "BlendOutTime": "The amount of time you want to take to recover from the override you are clearing."
          }
        },
        "DeProject": {
          "comment": "transforms 2D screen coordinates into a 3D world-space origin and direction\n \n@note: use the Canvas version where possible as it already has the necessary information,\n whereas this function must gather it and is therefore slower",
          "params": {
            "ScreenPos": "relative screen coordinates (0 to 1, relative to this player's viewport region)",
            "WorldOrigin": "(out) - world-space origin vector",
            "WorldDirection": "(out) - world-space direction vector"
          }
        },
        "GetActorVisibility": {
          "comment": "Tests the visibility state of an actor in the most recent frame of this player's view to complete rendering.",
          "params": {
            "TestActor": "The actor to check visibility for."
          }
        },
        "GetNickname": {
          "comment": "retrieves this player's name/tag from the online subsytem\n if this function returns a non-empty string, the returned name will replace the \"Name\" URL parameter\n passed around in the level loading and connection code, which normally comes from DefaultEngine.ini"
        },
        "GetPostProcessChain": {
          "comment": "Get the PPChain at the given index.",
          "params": {
            "InIndex": "The index of the chain to retrieve."
          }
        },
        "GetTranslationContext": {
          "comment": "A TranslationContext is part of the system for managing translation tags in localization text.\n This system handles text with special tags. E.g.: Press to look at point of interest.\n A TranslationContext provides information that cannot be deduced from the text alone.\n In this case, it is used to differentiate between players 1 and 2."
        },
        "GetUniqueNetId": {
          "comment": "retrieves this player's unique net ID from the online subsystem"
        },
        "InsertPostProcessingChain": {
          "comment": "Add the given post process chain to the chain at the given index.",
          "params": {
            "InChain": "The post process chain to insert.",
            "InIndex": "The position to insert the chain in the complete chain.\n If -1, insert it at the end of the chain.",
            "bInClone": "If TRUE, create a deep copy of the chains effects before insertion."
          }
        },
        "OverridePostProcessSettings": {
          "comment": "Begins an override of the current post process settings."
        },
        "RemoveAllPostProcessingChains": {
          "comment": "Remove all post process chains."
        },
        "RemovePostProcessingChain": {
          "comment": "Remove the post process chain at the given index.",
          "params": {
            "InIndex": "The position to insert the chain in the complete chain."
          }
        },
        "SendSplitJoin": {
          "comment": "sends a splitscreen join command to the server to allow a splitscreen player to connect to the game\n the client must already be connected to a server for this function to work\n @note this happens automatically for all viewports that exist during the initial server connect\n so it's only necessary to manually call this for viewports created after that\n if the join fails (because the server was full, for example) all viewports on this client will be disconnected"
        },
        "SetControllerId": {
          "comment": "Changes the ControllerId for this player; if the specified ControllerId is already taken by another player, changes the ControllerId\n for the other player to the ControllerId currently in use by this player.",
          "params": {
            "NewControllerId": "the ControllerId to assign to this player."
          }
        },
        "SpawnPlayActor": {
          "comment": "Creates an actor for this player.",
          "params": {
            "URL": "The URL the player joined with.",
            "OutError": "If an error occurred, returns the error description."
          }
        },
        "TouchPlayerPostProcessChain": {
          "comment": "Forces the PlayerPostProcess chain to be rebuilt.\n This should be called if a PPChain is retrieved using the GetPostProcessChain,\n and is modified directly."
        }
      },
      "structs": {
        "CurrentPostProcessVolumeInfo": {
          "properties": {
            "BlendStartTime": {
              "comment": "Time when a new post process volume was set"
            },
            "LastBlendTime": {
              "comment": "Time when the settings blend was last updated."
            },
            "LastSettings": {
              "comment": "Last pp settings used when blending to the next set of volume values."
            },
            "LastVolumeUsed": {
              "comment": "The last post process volume that was applied to the scene"
            }
          }
        }
      }
    },
    "MantleReachSpec": {
      "properties": {
        "bClimbUp": {
          "comment": "This mantle spec climbs up a surface instead of jumping over"
        }
      }
    },
    "MapInfo": {
      "comment": "contains game-specific map data, attached to the WorldInfo"
    },
    "Material": {
      "properties": {
        "AnisotropicDirection": {
          "comment": "Specify a vector to use as anisotropic direction"
        },
        "bIsFallbackMaterial": {
          "comment": "Indicates that the material will be used as a fallback on sm2 platforms"
        },
        "bIsMasked": {
          "comment": "TRUE if Material is masked and uses custom opacity"
        },
        "bIsPreviewMaterial": {
          "comment": "TRUE if Material is the preview material used in the material editor."
        },
        "bUsedAsSpecialEngineMaterial": {
          "comment": "This is a special usage flag that allows a material to be assignable to any primitive type.\n This is useful for materials used by code to implement certain viewmodes, for example the default material or lighting only material.\n The cost is that nearly 20x more shaders will be compiled for the material than the average material, which will greatly increase shader compile time and memory usage.\n This flag should only be set when absolutely necessary, and is purposefully not exposed to the UI to prevent abuse."
        },
        "bUsesDistortion": {
          "comment": "TRUE if Material uses distortion"
        },
        "CustomLighting": {
          "comment": "Use a custom light transfer equation to be factored with light color, attenuation and shadowing. \n This is currently only used for Movable, Toggleable and Dominant light contribution.\n LightVector can be used in this material input and will be set to the tangent space light direction of the current light being rendered."
        },
        "CustomSkylightDiffuse": {
          "comment": "Use a custom diffuse factor for attenuation with lights that only support a diffuse term. \n This should only be the diffuse color coefficient, and must not depend on LightVector.\n This is currently used with skylights, SH lights, materials exported to lightmass and directional lightmap contribution."
        },
        "Distortion": {
          "comment": "Allows the material to distort background color by offsetting each background pixel by the amount of the distortion input for that pixel."
        },
        "EditorComments": {
          "comment": "Array of comments associated with this material; viewed in the material editor."
        },
        "EditorCompounds": {
          "comment": "Array of material expression compounds associated with this material; viewed in the material editor."
        },
        "Expressions": {
          "comment": "Array of material expressions, excluding Comments and Compounds. Used by the material editor."
        },
        "PhysicalMaterial": {
          "comment": "For backwards compatibility only."
        },
        "ReferencedTextures": {
          "comment": "Legacy texture references, now handled by FMaterial."
        },
        "SubsurfaceAbsorptionColor": {
          "comment": "Light from subsurface scattering is attenuated by SubsurfaceAbsorptionColor^Distance."
        },
        "SubsurfaceInscatteringColor": {
          "comment": "Modulates the local contribution to the subsurface scattered lighting of the material."
        },
        "SubsurfaceScatteringRadius": {
          "comment": "The maximum distance light from subsurface scattering will travel."
        },
        "TessellationFactors": {
          "comment": "Multiplies to the tessellation factors applied when a tessellation mode is set. X = Edges, Y = Inside"
        },
        "TwoSidedLightingColor": {
          "comment": "Modulates the lighting without the Lambertian term in two sided lighting."
        },
        "TwoSidedLightingMask": {
          "comment": "Lerps between lighting color (diffuse * attenuation * Lambertian) and lighting without the Lambertian term color (diffuse * attenuation * TwoSidedLightingColor)."
        },
        "WorldDisplacement": {
          "comment": "Offset in tangent space applied to tessellated vertices. A scalar connected to this input will be treated as the z component (float3(0,0,x))."
        },
        "WorldPositionOffset": {
          "comment": "Adds to world position in the vertex shader."
        },
        "bEnableMaskedAntialiasing<bShowOnlyWhenTrue=bShowD3D11Properties>": {
          "comment": "Indicates that the material should be rendered with antialiasing. Opacity is evaluated multiple times (for each MSAA sample)."
        },
        "bUseImageBasedReflections<bShowOnlyWhenTrue=bShowD3D11Properties>": {
          "comment": "Replaces analytical phong specular highlights on this material with an image based reflection,\n Specified by the ImageReflection actors placed in the world. Only works in D3D11."
        },
        "D3D11TessellationMode<bShowOnlyWhenTrue=bShowD3D11Properties>": {
          "comment": "The type of tessellation to apply to this object. Note D3D11 required for anything except MTM_NoTessellation."
        },
        "EnableSeparateTranslucency<bShowOnlyWhenTrue=bShowD3D11Properties>": {
          "comment": "Indicates that the material should be rendered in the SeparateTranslucency Pass (does not affect bloom, not affected by DOF)."
        },
        "EnableSubsurfaceScattering<bShowOnlyWhenTrue=bShowD3D11Properties>": {
          "comment": "Indicates that the material should be rendered with subsurface scattering."
        },
        "ImageReflectionNormalDampening<bShowOnlyWhenTrue=bShowD3D11Properties>": {
          "comment": "Values larger than 1 dampen the normal used for image reflections, values smaller than 1 exaggerate the normal used for image reflections."
        },
        "BlendMode": {
          "comment": "Determines how the material's color is blended with background colors."
        },
        "LightingModel": {
          "comment": "Determines how inputs are combined to create the material's final color."
        },
        "OpacityMaskClipValue": {
          "comment": "If BlendMode is BLEND_Masked or BLEND_SoftMasked, the surface is not rendered where OpacityMask < OpacityMaskClipValue."
        },
        "TwoSided": {
          "comment": "Indicates that the material should be rendered without backface culling and the normal should be flipped for backfaces."
        },
        "bAllowLightmapSpecular": {
          "comment": "Controls whether lightmap specular will be rendered or not. Can be disabled to reduce instruction count."
        },
        "bPerPixelCameraVector": {
          "comment": "When enabled, the camera vector will be computed in the pixel shader instead of the vertex shader which may improve the quality of the reflection. Enabling this setting also allows VertexColor expressions to be used alongside Transform expressions."
        },
        "ShadowDepthBias": {
          "comment": "Can be used to bias shadows away from the surface."
        },
        "bUsedWithDecals": {
          "comment": "WARNING: bUsedWithDecals is mutually exclusive with all other mesh type usage flags! A material with bUsedWithDecals=true will not work on any other mesh type."
        },
        "bUsedWithFogVolumes": {
          "comment": "Indicates that the material is used on fog volumes. This usage flag is mutually exclusive with all other mesh type usage flags!"
        },
        "BlackPhysicalMaterial": {
          "comment": "The physical material to use when a black pixel in the PhysMaterialMask texture is hit."
        },
        "PhysMaterial": {
          "comment": "Physical material to use for this graphics material. Used for sounds, effects etc."
        },
        "PhysMaterialMask": {
          "comment": "A 1 bit monochrome texture that represents a mask for what physical material should be used if the collided texel is black or white."
        },
        "PhysMaterialMaskUVChannel": {
          "comment": "The UV channel to use for the PhysMaterialMask."
        },
        "WhitePhysicalMaterial": {
          "comment": "The physical material to use when a white pixel in the PhysMaterialMask texture is hit."
        },
        "bAllowFog": {
          "comment": "Whether the material should allow fog or be unaffected by fog. This only has meaning for materials with translucent blend modes."
        },
        "bAllowTranslucencyDoF": {
          "comment": "Whether the material should allow Depth of Field or be unaffected by DoF. This only has meaning for materials with translucent blend modes."
        },
        "bCastLitTranslucencyShadowAsMasked": {
          "comment": "If this is set, lit translucent objects will cast shadow as if they were masked"
        },
        "bDisableDepthTest": {
          "comment": "Allows the material to disable depth tests, which is only meaningful with translucent blend modes.\n Disabling depth tests will make rendering significantly slower since no occluded pixels can get zculled."
        },
        "bSceneTextureRenderBehindTranslucency": {
          "comment": "If enabled and this material reads from scene texture, this material will be rendered behind all other translucency, \n Instead of the default behavior for materials that read from scene texture, which is for them to render in front of all other translucency in the same DPG.\n This is useful for placing large spheres around a level that read from scene texture to do chromatic aberration."
        },
        "bTranslucencyInheritDominantShadowsFromOpaque": {
          "comment": "Whether the material should inherit the dynamic shadows that dominant lights are casting on opaque and masked materials behind this material.\n This is useful for ground meshes using a translucent blend mode and depth biased alpha to hide seams."
        },
        "bTranslucencyReceiveDominantShadowsFromStatic": {
          "comment": "Whether the material should receive dynamic dominant light shadows from static objects when the material is being lit by a light environment. \n This is useful for character hair."
        },
        "bUseLitTranslucencyDepthPass": {
          "comment": "If this is set, a depth-only pass for will be rendered for solid (A=255) areas of dynamic lit translucency primitives. This improves hair sorting at the extra render cost."
        },
        "bUseLitTranslucencyPostRenderDepthPass": {
          "comment": "If this is set, a depth-only pass for will be rendered for any visible (A>0) areas of dynamic lit translucency primitives. This is necessary for correct fog and DoF of hair"
        },
        "bUseOneLayerDistortion": {
          "comment": "Whether the material should use one-layer distortion, which can be cheaper than normal distortion for some primitive types (mainly fluid surfaces).\n One layer distortion won't handle overlapping one layer distortion primitives correctly.\n This causes an extra scene color resolve for the first primitive that uses one layer distortion and so should only be used in very specific circumstances."
        },
        "TwoSidedSeparatePass": {
          "comment": "Indicates that the material should be rendered in its own pass. Used for hair renderering"
        },
        "bUsedWithGammaCorrection": {
          "comment": "Gamma corrects the output of the base pass using the current render target's gamma value. \n This must be set on materials used with UIScenes to get correct results."
        },
        "bUsedWithInstancedMeshParticles": {
          "comment": "Enables instancing for mesh particles. Use the \"Vertex Color\" node when enabled, not \"MeshEmit VertColor.\""
        },
        "bUsedWithScreenDoorFade": {
          "comment": "Enables support for screen door fading for primitives rendering with this material. This adds an extra texture lookup and a few extra instructions."
        },
        "bUsedWithSkeletalMesh": {
          "comment": "Indicates that the material and its instances can be assigned to skeletal meshes. \n This will result in the shaders required to support skeletal meshes being compiled which will increase shader compile time and memory usage."
        }
      }
    },
    "MaterialExpression": {
      "properties": {
        "bHidePreviewWindow": {
          "comment": "If TRUE, do not render the preview window for the expression"
        },
        "bIsParameterExpression": {
          "comment": "Indicates that this is a 'parameter' type of expression and should always be loaded (ie not cooked away) because we might want the default parameter."
        },
        "bNeedToUpdatePreview": {
          "comment": "If TRUE, we should update the preview next render. This is set when changing bRealtimePreview."
        },
        "bRealtimePreview": {
          "comment": "Set to TRUE by RecursiveUpdateRealtimePreview() if the expression's preview needs to be updated in realtime in the material editor."
        },
        "bShowOutputNameOnPin": {
          "comment": "If TRUE, use the output name as the label for the pin"
        },
        "bUsedByStaticParameterSet": {
          "comment": "If TRUE, this expression is used when generating the StaticParameterSet.\n It is important to set this correctly if the cooker is using the CleanupMaterials functionality.\n If it is not set correctly, the cleanup code will remove the expression and the StaticParameterSet\n will mismatch when verifying the shader map.\n The ClearInputExpression function should also be implement on expressions that set this as it\n will be called by the CleanupMaterials function to remove unrequired expressions."
        },
        "Compound": {
          "comment": "A reference to the compound expression this material expression belongs to."
        },
        "EditorX": {
          "comment": "This variable is conlficting with Materia var, making new ones (MaterialExpressionEditor), and then deprecating this"
        },
        "EditorY": {
          "comment": "This variable is conlficting with Materia var, making new ones (MaterialExpressionEditor), and then deprecating this"
        },
        "MenuCategories": {
          "comment": "Categories to sort this expression into..."
        },
        "Desc": {
          "comment": "A description that level designers can add (shows in the material editor UI)."
        }
      }
    },
    "MaterialExpressionAbs": {
      "properties": {
        "Input": {
          "comment": "Link to the input expression to be evaluated"
        }
      }
    },
    "MaterialExpressionCompound": {
      "comment": "A compound material expression representing several material expressions collapsed\n into one node. An editor-only concept; this node does not generate shader code.",
      "properties": {
        "MaterialExpressions": {
          "comment": "Array of material expressions encapsulated by this node."
        },
        "bExpanded": {
          "comment": "IF TRUE, the nodes encapsulated by compound expression are drawn in the material editor."
        },
        "Caption": {
          "comment": "Textual descrption for this compound expression; appears in the expression title."
        }
      }
    },
    "MaterialExpressionDepthBiasBlend": {
      "properties": {
        "Bias": {
          "comment": "The depth bias input\n This can be a constant, texture sample, etc.\n NOTE: No bias expression indicates a bias of 1.0f."
        },
        "BiasScale": {
          "comment": "The bias scale value"
        },
        "bNormalize": {
          "comment": "normalize the depth values to [near,far] -> [0,1]"
        }
      }
    },
    "MaterialExpressionDepthBiasedAlpha": {
      "properties": {
        "Alpha": {
          "comment": "The source alpha input"
        },
        "Bias": {
          "comment": "The depth bias input\n This can be a constant, texture sample, etc.\n NOTE: No bias expression indicates a bias of 1.0f."
        },
        "BiasScale": {
          "comment": "The bias scale value"
        },
        "bNormalize": {
          "comment": "normalize the depth values to [near,far] -> [0,1]"
        }
      }
    },
    "MaterialExpressionDepthBiasedBlend": {
      "properties": {
        "Alpha": {
          "comment": "The source alpha input\n NOT REQUIRED"
        },
        "Bias": {
          "comment": "The depth bias input\n This can be a constant, texture sample, etc.\n NOTE: No bias expression indicates a bias of 1.0f."
        },
        "RGB": {
          "comment": "The source color input"
        },
        "BiasScale": {
          "comment": "The bias scale value"
        },
        "bNormalize": {
          "comment": "normalize the depth values to [near,far] -> [0,1]"
        }
      }
    },
    "MaterialExpressionDepthOfFieldFunction": {
      "properties": {
        "Depth": {
          "comment": "usually nothing or PixelDepth"
        },
        "FunctionValue": {
          "comment": "Determines the mapping place to use on the terrain."
        }
      }
    },
    "MaterialExpressionDestDepth": {
      "properties": {
        "bNormalize": {
          "comment": "normalize the depth values to [near,far] -> [0,1]"
        }
      }
    },
    "MaterialExpressionDynamicParameter": {
      "comment": "A material expression that routes particle emitter parameters to the\n material.",
      "properties": {
        "ParamNames": {
          "comment": "The names of the parameters.\n These will show up in Cascade when editing a particle system\n that uses the material it is in..."
        }
      }
    },
    "MaterialExpressionFluidNormal": {
      "properties": {
        "Coordinates": {
          "comment": "Optional texture coordinates for the fluid normal. If not specified, the mesh's UV0 will be used."
        }
      }
    },
    "MaterialExpressionFontSample": {
      "properties": {
        "Font": {
          "comment": "font resource that will be sampled"
        },
        "FontTexturePage": {
          "comment": "allow access to the various font pages"
        }
      }
    },
    "MaterialExpressionFontSampleParameter": {
      "properties": {
        "ExpressionGUID": {
          "comment": "GUID that should be unique within the material, this is used for parameter renaming."
        },
        "ParameterName": {
          "comment": "name to be referenced when we want to find and set thsi parameter"
        }
      }
    },
    "MaterialExpressionFresnel": {
      "comment": "Allows the artists to quickly set up a Fresnel term. Returns:\n pow(1 - max(Normal dot Camera,0),Exponent)",
      "properties": {
        "Normal": {
          "comment": "The normal to dot with the camera vector"
        },
        "Exponent": {
          "comment": "The exponent to pass into the pow() function"
        }
      }
    },
    "MaterialExpressionLightmapUVs": {
      "comment": "A material expression that routes LightmapUVs to the material."
    },
    "MaterialExpressionParameter": {
      "properties": {
        "ExpressionGUID": {
          "comment": "GUID that should be unique within the material, this is used for parameter renaming."
        },
        "ParameterName": {
          "comment": "The name of the parameter"
        }
      }
    },
    "MaterialExpressionParticleMacroUV": {
      "comment": "This UV node generates texture coordinates in view space centered on the particle system's MacroUVPosition, with tiling controlled by the particle system's MacroUVRadius.\n It is useful for mapping a 'macro' noise texture in a continuous manner onto all particles of a particle system.",
      "properties": {
        "bUseViewSpace": {
          "comment": "Whether to calculate the UVs in View space, which gives a slightly different UV position based on depth and creates a parallax effect, at the cost of texture swimming."
        }
      }
    },
    "MaterialExpressionPixelDepth": {
      "properties": {
        "bNormalize": {
          "comment": "normalize the depth values to [near,far] -> [0,1]"
        }
      }
    },
    "MaterialExpressionSceneDepth": {
      "properties": {
        "Coordinates": {
          "comment": "texture coordinate inputt expression for this node"
        },
        "bNormalize": {
          "comment": "normalize the depth values to [near,far] -> [0,1]"
        }
      }
    },
    "MaterialExpressionSceneTexture": {
      "properties": {
        "Coordinates": {
          "comment": "texture coordinate inputt expression for this node"
        },
        "ScreenAlign": {
          "comment": "Matches [0,1] UVs to the view within the back buffer."
        }
      }
    },
    "MaterialExpressionScreenPosition": {
      "properties": {
        "ScreenAlign": {
          "comment": "applies the divide by w as well as [-1,1]->[1,1] mapping for screen alignment"
        }
      }
    },
    "MaterialExpressionTerrainLayerCoords": {
      "properties": {
        "MappingPanU": {
          "comment": "Offset to apply to the mapping along U."
        },
        "MappingPanV": {
          "comment": "Offset to apply to the mapping along V."
        },
        "MappingRotation": {
          "comment": "Rotation to apply to the mapping."
        },
        "MappingScale": {
          "comment": "Uniform scale to apply to the mapping."
        },
        "MappingType": {
          "comment": "Determines the mapping place to use on the terrain."
        }
      }
    },
    "MaterialExpressionTerrainLayerWeight": {
      "properties": {
        "ExpressionGUID": {
          "comment": "GUID that should be unique within the material, this is used for parameter renaming."
        }
      }
    },
    "MaterialExpressionTextureCoordinate": {
      "properties": {
        "CoordinateIndex": {
          "comment": "Texture coordinate index"
        },
        "UnMirrorU": {
          "comment": "Would like to unmirror U or V"
        },
        "UTiling": {
          "comment": "Controls how much the texture tiles horizontally, by scaling the U component of the vertex UVs by the specified amount."
        },
        "VTiling": {
          "comment": "Controls how much the texture tiles vertically, by scaling the V component of the vertex UVs by the specified amount."
        }
      }
    },
    "MaterialExpressionTextureSampleParameter": {
      "properties": {
        "ExpressionGUID": {
          "comment": "GUID that should be unique within the material, this is used for parameter renaming."
        }
      }
    },
    "MaterialExpressionTime": {
      "properties": {
        "bIgnorePause": {
          "comment": "This time continues advancing regardless of whether the game is paused."
        }
      }
    },
    "MaterialExpressionTransform": {
      "properties": {
        "Input": {
          "comment": "input expression for this transform"
        },
        "TransformSourceType": {
          "comment": "Source coordinate space of the vector"
        }
      }
    },
    "MaterialExpressionTransformPosition": {
      "properties": {
        "Input": {
          "comment": "input expression for this transform"
        },
        "TransformType": {
          "comment": "type of transform to apply to the input expression"
        }
      }
    },
    "MaterialInstance": {
      "properties": {
        "bHasStaticPermutationResource": {
          "comment": "indicates whether the instance has static permutation resources (which are required when static parameters are present)"
        },
        "bNeedsMaterialFlattening": {
          "comment": "This instance is dirty and needs to be flattened upon save or some other good time (like closing the MIC editor)"
        },
        "bStaticPermutationDirty": {
          "comment": "indicates whether the static permutation resource needs to be updated on PostEditChange()"
        },
        "ParentLightingGuid": {
          "comment": "Unique ID for this material, used for caching during distributed lighting"
        },
        "ReferencedTextures": {
          "comment": "Legacy texture references, now handled by FMaterial."
        },
        "Resources[3]": {
          "comment": "Second resource is used when selected."
        },
        "StaticParameters[2]": {
          "comment": "The set of static parameters that this instance will be compiled with.\n This is indexed by EMaterialShaderPlatform.\n Only the first entry is ever used now that SM2 is no longer supported, \n But the member is kept as an array to make adding future material platforms easier. \n The second entry is to work around the script compile error from having an array with one element."
        },
        "StaticPermutationResources[2]": {
          "comment": "The material resources for this instance.\n This is indexed by EMaterialShaderPlatform.\n Only the first entry is ever used now that SM2 is no longer supported, \n But the member is kept as an array to make adding future material platforms easier. \n The second entry is to work around the script compile error from having an array with one element."
        },
        "PhysMaterial": {
          "comment": "Physical material to use for this graphics material. Used for sounds, effects etc."
        },
        "BlackPhysicalMaterial": {
          "comment": "The physical material to use when a black pixel in the PhysMaterialMask texture is hit."
        },
        "PhysMaterialMask": {
          "comment": "A 1 bit monochrome texture that represents a mask for what physical material should be used if the collided texel is black or white."
        },
        "PhysMaterialMaskUVChannel": {
          "comment": "The UV channel to use for the PhysMaterialMask."
        },
        "WhitePhysicalMaterial": {
          "comment": "The physical material to use when a white pixel in the PhysMaterialMask texture is hit."
        }
      },
      "functions": {
        "ClearParameterValues": {
          "comment": "Removes all parameter values"
        },
        "IsInMapOrTransientPackage": {
          "comment": "Returns if this MI is either in a map package or the transient package\n During gameplay, Set..Parameter should only be called on MIs where this is TRUE -\n otherwise you are modifying an MI within a content package, that will persist across level reload etc."
        },
        "SetFontParameterValue": {
          "comment": "Sets the value of the given font parameter.",
          "params": {
            "ParameterName": "The name of the font parameter",
            "OutFontValue": "New font value to set for this MIC",
            "OutFontPage": "New font page value to set for this MIC"
          }
        },
        "SetParent": {
          "comment": "Returns the UV channel that should be used to look up physical material mask information. Tries to get the parents UV channel if not present here."
        }
      }
    },
    "MaterialInstanceActor": {
      "comment": "Utility class designed to allow you to connect a MaterialInterface to a Matinee action.",
      "properties": {
        "MatInst": {
          "comment": "Pointer to MaterialInterface that we want to control paramters of using Matinee."
        }
      }
    },
    "MaterialInstanceConstant": {
      "functions": {
        "ClearParameterValues": {
          "comment": "Removes all parameter values"
        },
        "SetFontParameterValue": {
          "comment": "Sets the value of the given font parameter.",
          "params": {
            "ParameterName": "The name of the font parameter",
            "OutFontValue": "New font value to set for this MIC",
            "OutFontPage": "New font page value to set for this MIC"
          }
        },
        "SetParent": {
          "comment": "Cleanup the TextureParameter lists in the instance",
          "params": {
            "InRefdTextureParamsMap": "Map of actual TextureParams used by the parent.\n NOTE: This is intended to be called only when cooking for stripped platforms!"
          }
        }
      }
    },
    "MaterialInstanceTimeVarying": {
      "properties": {
        "Duration": {
          "comment": "This sets how long the MITV will be around (i.e. this MITV is owned by a decal which lasts N seconds). It is used for bOffsetFromEnd functionality"
        },
        "bAutoActivateAll": {
          "comment": "causes all parameters to start playing immediately"
        }
      },
      "functions": {
        "ClearParameterValues": {
          "comment": "Removes all parameter values"
        },
        "GetMaxDurationFromAllParameters": {
          "comment": "This will interrogate all of the parameter and see what the max duration needed for them is. Useful for setting the Duration / or knowing how long this MITV will take"
        },
        "SetDuration": {
          "comment": "This sets how long the MITV will be around (i.e. this MITV is owned by a decal which lasts N seconds)"
        },
        "SetFontParameterValue": {
          "comment": "Sets the value of the given font parameter.",
          "params": {
            "ParameterName": "The name of the font parameter",
            "OutFontValue": "New font value to set for this MIC",
            "OutFontPage": "New font page value to set for this MIC"
          }
        },
        "SetParent": {
          "comment": "Cleanup the TextureParameter lists in the instance",
          "params": {
            "InRefdTextureParamsMap": "Map of actual TextureParams used by the parent.\n NOTE: This is intended to be called only when cooking for stripped platforms!"
          }
        },
        "SetScalarParameterValue": {
          "comment": "For MITVs you can utilize both single Scalar values and InterpCurve values.\n If there is any data in the InterpCurve, then the MITV will utilize that. Else it will utilize the Scalar value\n of the same name."
        },
        "SetScalarStartTime": {
          "comment": "This sets how long after the MITV has been spawned to start \"ticking\" the named Scalar InterpCurve"
        },
        "SetVectorStartTime": {
          "comment": "This sets how long after the MITV has been spawned to start \"ticking\" the named Scalar InterpCurve"
        }
      },
      "structs": {
        "FontParameterValueOverTime": {
          "comment": "Constructors"
        },
        "ParameterValueOverTime": {
          "properties": {
            "bAutoActivate": {
              "comment": "This will auto activate this param"
            },
            "bLoop": {
              "comment": "if true, then the CycleTime is the loop time and time loops"
            },
            "bNormalizeTime": {
              "comment": "if true, then the CycleTime is used to scale time so all keys are between zero and one"
            },
            "bOffsetFromEnd": {
              "comment": "When using OffsetTime it is nice to be able to offset from the end of the decal's lifetime (e.g. you want to fade out the decal, you want to change the color of the decal before it fades away etc.)"
            },
            "CycleTime": {
              "comment": "this controls time normalization and the loop time"
            },
            "OffsetTime": {
              "comment": "How much time this will wait before actually firing off. This is useful for keeping the curves being just the data for controlling the param and not a bunch of slack in the beginning (e.g. to wait N seconds then start fading)"
            },
            "StartTime": {
              "comment": "when this is parameter is to start \"ticking\" then this value will be set to the current game time"
            }
          }
        },
        "ScalarParameterValueOverTime": {
          "properties": {
            "ParameterValue": {
              "comment": "This allows MITVs to have both single scalar and curve values"
            },
            "ParameterValueCurve": {
              "comment": "This will automatically be used if there are any values in this Curve"
            }
          }
        },
        "VectorParameterValueOverTime": {
          "properties": {
            "ParameterValueCurve": {
              "comment": "This will automatically be used if there are any values in this Curve"
            }
          }
        }
      }
    },
    "MaterialInstanceTimeVaryingActor": {
      "properties": {
        "MatInst": {
          "comment": "Pointer to MaterialInterface that we want to activate"
        }
      }
    },
    "MaterialInterface": {
      "properties": {
        "LightingGuid": {
          "comment": "Unique ID for this material, used for caching during distributed lighting"
        },
        "ParentRefFence": {
          "comment": "A fence to track when the primitive is no longer used as a parent"
        },
        "LightmassSettings<ScriptOrder=true>": {
          "comment": "The Lightmass settings for this object."
        },
        "PreviewMesh": {
          "comment": "The mesh used by the material editor to preview the material."
        },
        "bAutoFlattenMobile": {
          "comment": "When enabled, the base texture will be generated automatically by statically 'flattening' the graph network into a texture."
        },
        "bMobileAllowFog": {
          "comment": "When enabled, primitives using this material may be fogged. Disable this to improve performance for primitives that don't need fog."
        },
        "MobileAmbientOcclusionSource": {
          "comment": "Enables baked ambient occlusion from mesh vertices and selects which vertex color channel to get the AO data from"
        },
        "MobileBaseTexture": {
          "comment": "Base (diffuse) texture, or a texture that was generated by flattening the graph network"
        },
        "MobileBaseTextureTexCoordsSource": {
          "comment": "Texture coordinates from mesh vertex to use when sampling base texture on mobile platforms"
        },
        "MobileNormalTexture": {
          "comment": "Normal map texture. If specified, this enables per pixel lighting when used in combination with other material features."
        },
        "bUseMobileBumpOffset": {
          "comment": "Enables a bump offset effect for this material. A mask texture must be supplied. The bump offset amount is stored in the mask texture's RED channel."
        },
        "MobileBumpOffsetHeightRatio<EditCondition=bUseMobileBumpOffset>": {
          "comment": "Bump height ratio"
        },
        "MobileBumpOffsetReferencePlane<EditCondition=bUseMobileBumpOffset>": {
          "comment": "Bump offset reference plane"
        },
        "bUseMobileUniformColorMultiply": {
          "comment": "Whether to use uniform color scaling (mesh particles) or not"
        },
        "bUseMobileVertexColorMultiply": {
          "comment": "Whether to use per vertex color scaling"
        },
        "DefaultUniformColor": {
          "comment": "Default color to modulate each vertex by"
        },
        "MobileEmissiveColor": {
          "comment": "Mobile emissive color. Only used when MobileEmissiveColorSource is set to 'Constant'"
        },
        "MobileEmissiveColorSource": {
          "comment": "Mobile emissive color source"
        },
        "MobileEmissiveMaskSource": {
          "comment": "Selects a source for emissive light masking"
        },
        "MobileEmissiveTexture": {
          "comment": "Emissive texture. If the emissive color source is set to 'Emissive Texture', setting this texture will enable emissive lighting"
        },
        "MobileEnvironmentAmount<ClampMin=0.0|UIMax=1.0>": {
          "comment": "Sets how much the environment map texture contributes to the final color"
        },
        "MobileEnvironmentBlendMode": {
          "comment": "When environment mapping is enabled, this sets how the environment color is blended with the base color."
        },
        "MobileEnvironmentColor": {
          "comment": "Environment map color scale"
        },
        "MobileEnvironmentFresnelAmount<ClampMin=0.0|UIMax=1.0>": {
          "comment": "Environment mapping fresnel amount. Set this to zero for best performance."
        },
        "MobileEnvironmentFresnelExponent<ClampMin=0.01|UIMax=8.0>": {
          "comment": "Environment mapping fresnel exponent. Set this to 1.0 for best performance."
        },
        "MobileEnvironmentMaskSource": {
          "comment": "Selects a source for environment map amount"
        },
        "MobileEnvironmentTexture": {
          "comment": "Spherical environment map texture. When specified, spherical environment mapping will be enabled for this material."
        },
        "MobileMaskTexture": {
          "comment": "General purpose mask texture used for bump offset amount, texture blending, etc."
        },
        "MobileMaskTextureTexCoordsSource": {
          "comment": "Texture coordinates from mesh vertex to use when sampling mask texture"
        },
        "MobileRimLightingColor": {
          "comment": "Rim light color"
        },
        "MobileRimLightingExponent<ClampMin=0.01|UIMax=8.0>": {
          "comment": "Sets the exponent used for rim lighting"
        },
        "MobileRimLightingMaskSource": {
          "comment": "Selects a source for rim light masking"
        },
        "MobileRimLightingStrength<ClampMin=0.0|UIMax=4.0>": {
          "comment": "When set to anything other than zero, enables rim lighting for this material and sets the amount of rim lighting to apply"
        },
        "bUseMobilePixelSpecular<EditCondition=bUseMobileSpecular>": {
          "comment": "Enables per-pixel specular for this material (requires normal map)"
        },
        "bUseMobileSpecular": {
          "comment": "Enables dynamic specular lighting from the single most prominent light source"
        },
        "MobileSpecularColor<EditCondition=bUseMobileSpecular>": {
          "comment": "Material specular color"
        },
        "MobileSpecularMask": {
          "comment": "Determines how specular values are masked. Constant: Mask is disabled. Luminance: Diffuse RGB luminance used as mask. Diffuse Red/Green/Blue: Use a specific channel of the diffuse texture as the specular mask. Mask Texture RGB: Uses the color from the mask texture"
        },
        "MobileSpecularPower<EditCondition=bUseMobileSpecular>": {
          "comment": "When specular is enabled, this sets the specular power. Lower values yield a wider highlight, higher values yield a sharper highlight"
        },
        "bLockColorBlending": {
          "comment": "Locks use of the detail texture and does not allow it to be forced off by system settings"
        },
        "MobileDetailTexture": {
          "comment": "Detail texture to use for blending the base texture"
        },
        "MobileDetailTextureTexCoordsSource": {
          "comment": "Texture coordinates from mesh vertex to use when sampling detail texture"
        },
        "MobileTextureBlendFactorSource": {
          "comment": "Where the blend factor comes from, for blending the base texture with the detail texture"
        },
        "bUseMobileTextureTransform": {
          "comment": "Enables texture transform features"
        },
        "FixedScaleX<EditCondition=bUseMobileTextureTransform>": {
          "comment": "Fixed horizontal texture scale (around the rotation center)"
        },
        "FixedScaleY<EditCondition=bUseMobileTextureTransform>": {
          "comment": "Fixed vertical texture scale (around the rotation center)"
        },
        "MobileTextureTransformTarget<EditCondition=bUseMobileTextureTransform>": {
          "comment": "Which texture UVs to transform"
        },
        "PannerSpeedX<EditCondition=bUseMobileTextureTransform>": {
          "comment": "Horizontal speed for texture panning"
        },
        "PannerSpeedY<EditCondition=bUseMobileTextureTransform>": {
          "comment": "Vertical speed for texture panning"
        },
        "RotateSpeed<EditCondition=bUseMobileTextureTransform>": {
          "comment": "Texture rotation speed in radians per second"
        },
        "SineScaleFrequencyMultipler<EditCondition=bUseMobileTextureTransform>": {
          "comment": "Multiplier for sine wave texture scaling frequency"
        },
        "SineScaleX<EditCondition=bUseMobileTextureTransform>": {
          "comment": "Horizontal texture scale applied to a sine wave"
        },
        "SineScaleY<EditCondition=bUseMobileTextureTransform>": {
          "comment": "Vertical texture scale applied to a sine wave"
        },
        "TransformCenterX<EditCondition=bUseMobileTextureTransform>": {
          "comment": "Horizontal center for texture rotation/scale"
        },
        "TransformCenterY<EditCondition=bUseMobileTextureTransform>": {
          "comment": "Vertical center for texture rotation/scale"
        },
        "bUseMobileWaveVertexMovement": {
          "comment": "Enables per-vertex movement on a wave (for use with trees and similar objects)"
        },
        "MobileMaxVertexMovementAmplitude<EditCondition=bUseMobileWaveVertexMovement>": {
          "comment": "Amplitude of adjustments for wave on vertex positions"
        },
        "MobileSwayFrequencyMultiplier<EditCondition=bUseMobileWaveVertexMovement>": {
          "comment": "Frequency of entire object sway"
        },
        "MobileSwayMaxAngle<EditCondition=bUseMobileWaveVertexMovement>": {
          "comment": "Frequency of entire object sway"
        },
        "MobileTangentVertexFrequencyMultiplier<EditCondition=bUseMobileWaveVertexMovement>": {
          "comment": "Frequency adjustment for wave on vertex positions"
        },
        "MobileVerticalFrequencyMultiplier<EditCondition=bUseMobileWaveVertexMovement>": {
          "comment": "Frequency adjustment for wave on vertex positions"
        }
      },
      "functions": {
        "GetPhysicalMaterial": {
          "comment": "Returns a pointer to the physical material used by this material instance."
        },
        "SetForceMipLevelsToBeResident": {
          "comment": "Forces the streaming system to disregard the normal logic for the specified duration and\n instead always load all mip-levels for all textures used by this material.",
          "params": {
            "ForceDuration": "Number of seconds to keep all mip-levels in memory, disregarding the normal priority logic.",
            "CinematicTextureGroups": "Bitfield indicating which texture groups that use extra high-resolution mips"
          }
        }
      },
      "structs": {
        "LightmassMaterialInterfaceSettings": {
          "comment": "Material interface settings for Lightmass",
          "properties": {
            "bCastShadowAsMasked": {
              "comment": "If TRUE, forces translucency to cast static shadows as if the material were masked."
            },
            "bOverrideCastShadowAsMasked": {
              "comment": "If TRUE, override the bCastShadowAsMasked setting of the parent material."
            },
            "bOverrideDiffuseBoost": {
              "comment": "If TRUE, override the diffuse boost setting of the parent material."
            },
            "bOverrideDistanceFieldPenumbraScale": {
              "comment": "If TRUE, override the distance field penumbra scale setting of the parent material."
            },
            "bOverrideEmissiveBoost": {
              "comment": "If TRUE, override the emissive boost setting of the parent material."
            },
            "bOverrideExportResolutionScale": {
              "comment": "If TRUE, override the export resolution scale setting of the parent material."
            },
            "bOverrideSpecularBoost": {
              "comment": "If TRUE, override the specular boost setting of the parent material."
            },
            "DiffuseBoost": {
              "comment": "Scales the diffuse contribution of this material to static lighting."
            },
            "DistanceFieldPenumbraScale": {
              "comment": "Scales the penumbra size of distance field shadows. This is useful to get softer precomputed shadows on certain material types like foliage."
            },
            "EmissiveBoost": {
              "comment": "Scales the emissive contribution of this material to static lighting."
            },
            "ExportResolutionScale": {
              "comment": "Scales the resolution that this material's attributes were exported at. \n This is useful for increasing material resolution when details are needed."
            },
            "SpecularBoost": {
              "comment": "Scales the specular contribution of this material to static lighting."
            }
          }
        }
      }
    },
    "MatineeActor": {
      "properties": {
        "AIGroupInitStage[MAX_AIGROUP_NUMBER]": {
          "comment": "This flag is used by multiple purpose. At the end of initializtion, it will be set. \n 0: not initialized\n 1: called InitGroup"
        },
        "AIGroupNames[MAX_AIGROUP_NUMBER]": {
          "comment": "to replicate AIGroup actors - for now up to 10 it can replicat"
        },
        "AllAIGroupsInitialized": {
          "comment": "This is just optimization flag to skip checking it again. If all is initialized, it will set this to be TRUE"
        },
        "bIsPlaying": {
          "comment": "properties that may change on InterpAction that we need to notify clients about, since the object's properties will not be replicated"
        },
        "bPaused": {
          "comment": "properties that may change on InterpAction that we need to notify clients about, since the object's properties will not be replicated"
        },
        "bReversePlayback": {
          "comment": "properties that may change on InterpAction that we need to notify clients about, since the object's properties will not be replicated"
        },
        "ClientSidePositionErrorTolerance": {
          "comment": "How much error is tolerated in the client-side position before the position that the server replicated is applied"
        },
        "InterpAction": {
          "comment": "the SeqAct_Interp associated with this actor (this is set in C++ by the action that spawns this actor)\n on the client, the MatineeActor will tick this SeqAct_Interp and notify the actors it should be affecting"
        }
      },
      "functions": {
        "AddAIGroupActor": {
          "comment": "Add AI group actors to this actor"
        },
        "CheckPriorityRefresh": {
          "comment": "check if we should perform a network positional update of this matinee\n to make sure it's in sync even if it hasn't had significant changes\n because it's really important (e.g. a player is standing on it or being controlled by it)"
        },
        "Update": {
          "comment": "called by InterpAction when significant changes occur. Updates replicated data."
        }
      }
    },
    "MeshComponent": {
      "properties": {
        "Materials": {
          "comment": "Per-Component material overrides. These must NOT be set directly or a race condition can occur between GC and the rendering thread."
        }
      },
      "functions": {
        "CreateAndSetMaterialInstanceConstant": {
          "comment": "Creates a material instance for the specified element index. The parent of the instance is set to the material being replaced.",
          "params": {
            "ElementIndex": "The index of the skin to replace the material for."
          }
        },
        "CreateAndSetMaterialInstanceTimeVarying": {
          "comment": "Creates a material instance for the specified element index. The parent of the instance is set to the material being replaced.",
          "params": {
            "ElementIndex": "The index of the skin to replace the material for."
          }
        },
        "GetMaterial": {
          "params": {
            "ElementIndex": "The element to access the material of."
          }
        },
        "PrestreamTextures": {
          "comment": "Tell the streaming system to start loading all textures with all mip-levels.",
          "params": {
            "Seconds": "Number of seconds to force all mip-levels to be resident",
            "bPrioritizeCharacterTextures": "Whether character textures should be prioritized for a while by the streaming system",
            "CinematicTextureGroups": "Bitfield indicating which texture groups that use extra high-resolution mips"
          }
        },
        "SetMaterial": {
          "comment": "Changes the material applied to an element of the mesh.",
          "params": {
            "ElementIndex": "The element to access the material of."
          }
        }
      }
    },
    "ModelComponent": {
      "properties": {
        "Model": {
          "comment": "These mirror the C++ side properties. I'm making a class here so"
        }
      }
    },
    "MorphNodeBase": {
      "properties": {
        "bDrawSlider": {
          "comment": "If true, draw a slider for this node in the AnimSetViewer."
        },
        "NodeName": {
          "comment": "User-defined name of morph node, used for identifying a particular by node for example."
        }
      }
    },
    "MorphNodeMultiPose": {
      "properties": {
        "Targets": {
          "comment": "Cached pointer to actual MorphTarget object."
        },
        "MorphNames": {
          "comment": "Name of morph target to use for this pose node. \n Actual MorphTarget is looked up by name in the MorphSets array in the SkeletalMeshComponent."
        },
        "Weights": {
          "comment": "default weight is 1.f. But it can be scaled for tweaking."
        }
      },
      "functions": {
        "AddMorphTarget": {
          "comment": "Add the MorphTarget to use for this MorphNodeMultiPose by name. \n Will find it in the owning SkeletalMeshComponent MorphSets array using FindMorphTarget."
        },
        "RemoveMorphTarget": {
          "comment": "Remove the MorphTarget from using for this MorphNodeMultiPose by name. \n Will find it in the owning SkeletalMeshComponent MorphSets array using FindMorphTarget."
        },
        "UpdateMorphTarget": {
          "comment": "Update weight of the morph target"
        }
      }
    },
    "MorphNodePose": {
      "properties": {
        "Target": {
          "comment": "Cached pointer to actual MorphTarget object."
        },
        "MorphName": {
          "comment": "Name of morph target to use for this pose node. \n Actual MorphTarget is looked up by name in the MorphSets array in the SkeletalMeshComponent."
        },
        "Weight": {
          "comment": "default weight is 1.f. But it can be scaled for tweaking."
        }
      },
      "functions": {
        "SetMorphTarget": {
          "comment": "Set the MorphTarget to use for this MorphNodePose by name. \n Will find it in the owning SkeletalMeshComponent MorphSets array using FindMorphTarget."
        }
      }
    },
    "MorphNodeWeight": {
      "properties": {
        "NodeWeight": {
          "comment": "Weight to apply to all child nodes of this one."
        }
      },
      "functions": {
        "SetNodeWeight": {
          "comment": "Change the current NodeWeight of this MorphNodeWeight."
        }
      }
    },
    "MorphNodeWeightBase": {
      "properties": {
        "NodeConns": {
          "comment": "Array of connectors to which you can connect other MorphNodes."
        }
      },
      "structs": {
        "MorphNodeConn": {
          "comment": "Draws this morph node in the AnimTreeEditor.\n \n@param Canvas The canvas to use.\n \n@param SelectedNodes Reference to array of all currently selected nodes, potentially including this node",
          "properties": {
            "ChildNodes": {
              "comment": "Array of nodes attached to this connector."
            },
            "ConnName": {
              "comment": "Name of this connector."
            },
            "DrawY": {
              "comment": "Used in editor to draw line to this connector."
            }
          }
        }
      }
    },
    "MorphNodeWeightByBoneAngle": {
      "properties": {
        "Angle": {
          "comment": "Draw on 3d viewport canvas when node is selected"
        },
        "AngleBoneAxis": {
          "comment": "Axis to use on Angle Bone, X, Y or Z"
        },
        "AngleBoneName": {
          "comment": "Angle bone name"
        },
        "bInvertAngleBoneAxis": {
          "comment": "Should the Angle bone axis be inverted?"
        },
        "BaseBoneAxis": {
          "comment": "Axis to use on Base Bone, X, Y or Z"
        },
        "BaseBoneName": {
          "comment": "Base Bone Name"
        },
        "bInvertBaseBoneAxis": {
          "comment": "Should the Angle bone axis be inverted?"
        },
        "WeightArray": {
          "comment": "Array of points translating angles into morph weights"
        }
      },
      "structs": {
        "BoneAngleMorph": {
          "comment": "Structure defining Angle to Morph weight correspondance"
        }
      }
    },
    "MorphNodeWeightByBoneRotation": {
      "properties": {
        "Angle": {
          "comment": "Draw on 3d viewport canvas when node is selected"
        },
        "bInvertBoneAxis": {
          "comment": "Should the bone axis be inverted?"
        },
        "BoneAxis": {
          "comment": "Bone Axis to use X, Y or Z"
        },
        "BoneName": {
          "comment": "Bone Name"
        },
        "WeightArray": {
          "comment": "Array of points translating angles into morph weights"
        }
      }
    },
    "MorphTarget": {
      "properties": {
        "MorphLODModels": {
          "comment": "morph mesh vertex data for each LOD"
        },
        "MaterialSlotId": {
          "comment": "Material Parameter control"
        }
      }
    },
    "MorphTargetSet": {
      "properties": {
        "BaseSkelMesh": {
          "comment": "SkeletalMesh that this MorphTargetSet works on."
        },
        "RawWedgePointIndices": {
          "comment": "morph mesh original wedge point indices for each LOD - used to remap"
        },
        "Targets": {
          "comment": "Array of pointers to MorphTarget objects, containing vertex deformation information."
        }
      },
      "functions": {
        "FindMorphTarget": {
          "comment": "Find a morph target by name in this MorphTargetSet."
        }
      }
    },
    "MotionBlurEffect": {
      "properties": {
        "CameraRotationThreshold": {
          "comment": "Threshhold for when to turn off motion blur when the camera rotates swiftly during a single frame (in degrees)."
        },
        "CameraTranslationThreshold": {
          "comment": "Threshhold for when to turn off motion blur when the camera translates swiftly during a single frame (in world units)."
        },
        "FullMotionBlur": {
          "comment": "Whether everything (static/dynamic objects) should motion blur or not. If disabled, only moving objects may blur."
        },
        "MaxVelocity": {
          "comment": "Maximum blur velocity amount. This is a clamp on the amount of blur."
        },
        "MotionBlurAmount": {
          "comment": "This is a scale that could be considered as the \"sensitivity\" of the blur."
        }
      }
    },
    "MultiFont": {
      "comment": "A font class that stores multiple font pages for different resolutions",
      "properties": {
        "ResolutionTestTable": {
          "comment": "Holds a list of resolutions that map to a given set of font pages"
        }
      },
      "functions": {
        "GetResolutionTestTableIndex": {
          "comment": "Calulate the index into the ResolutionTestTable which is closest to the specified screen resolution.",
          "params": {
            "HeightTest": "the height (in pixels) of the viewport being rendered to."
          }
        }
      }
    },
    "MusicTrackDataStructures": {
      "structs": {
        "MusicTrackStruct": {
          "properties": {
            "bAutoPlay": {
              "comment": "Controls whether or not the track is auto-played when it is attached to the scene."
            },
            "bPersistentAcrossLevels": {
              "comment": "Controls whether the sound is not stopped on a map change"
            },
            "FadeInTime": {
              "comment": "Time taken for sound to fade in when action is activated."
            },
            "FadeInVolumeLevel": {
              "comment": "Volume the sound to should fade in to"
            },
            "FadeOutTime": {
              "comment": "Time take for sound to fade out when Stop input is fired."
            },
            "FadeOutVolumeLevel": {
              "comment": "Volume the sound to should fade out to"
            },
            "MP3Filename": {
              "comment": "Alternate Mp3 file to play on devices (iPhone, not PC) that support it."
            },
            "TheSoundCue": {
              "comment": "The soundCue to play"
            }
          }
        }
      }
    },
    "Mutator": {
      "properties": {
        "bUserAdded": {
          "comment": "Meant to verify if this mutator was from Command Line parameters or added from other Actors"
        },
        "NextMutator": {
          "comment": "Next in list of mutators linked from GameInfo.BaseMutator"
        },
        "GroupNames": {
          "comment": "list of groups this mutator is in. Mutators that share any group cannot be activated simultaneously"
        }
      },
      "functions": {
        "AddMutator": {
          "comment": "Add Mutator M to the mutator list."
        },
        "AlwaysKeep": {
          "comment": "Force game to always keep this actor, even if other mutators want to get rid of it"
        },
        "CheckRelevance": {
          "comment": "Check whether Other (being spawned) should be allowed to exist"
        },
        "CheckReplacement": {
          "comment": "Returns true to keep this actor"
        },
        "Destroyed": {
          "comment": "Make sure this is removed from the game's mutator list"
        },
        "GetSeamlessTravelActorList": {
          "comment": "called on the server during seamless level transitions to get the list of Actors that should be moved into the new level\n PlayerControllers, Role < ROLE_Authority Actors, and any non-Actors that are inside an Actor that is in the list\n (i.e. Object.Outer == Actor in the list)\n are all automatically moved regardless of whether they're included here\n only dynamic (!bStatic and !bNoDelete) actors in the PersistentLevel may be moved (this includes all actors spawned during gameplay)\n this is called for both parts of the transition because actors might change while in the middle (e.g. players might join or leave the game)",
          "params": {
            "bToEntry": "true if we are going from old level -> entry, false if we are going from entry -> new level",
            "ActorList": "(out) list of actors to maintain"
          }
        },
        "InitMutator": {
          "comment": "This function can be used to parse the command line parameters when a server\n starts up"
        },
        "IsRelevant": {
          "comment": "Returns whether Other (being spawned) is relevant (should be allowed to exist)"
        },
        "MutatorIsAllowed": {
          "comment": "Returns whether mutator is allowed in this session."
        },
        "OverridePickupQuery": {
          "comment": "OverridePickupQuery()\n when pawn wants to pickup something, mutators are given a chance to modify it. If this function\n returns true, bAllowPickup will determine if the object can be picked up.",
          "params": {
            "Other": "the Pawn that wants the item",
            "ItemClass": "the Inventory class the Pawn can pick up",
            "Pickup": "the Actor containing that item (this may be a PickupFactory or it may be a DroppedPickup)",
            "bAllowPickup": "(out) whether or not the Pickup actor should give its item to Other (0 == false, anything else == true)"
          }
        },
        "PreBeginPlay": {
          "comment": "Make sure mutator is allowed in this session.\n Don't call Actor.PreBeginPlay() for Mutator."
        }
      }
    },
    "NavigationHandle": {
      "properties": {
        "AnchorPylon": {
          "comment": "Current pylon AI is anchored to"
        },
        "BestUnfinishedPathPoint": {
          "comment": "This points to the BestUnfinishedPathPoint. Which will usually be set by some EvaluateGoal or DetermineFinalGoal function/\n In some cases it is not possible to get a full path, but having the best unfinished path is good enough (e.g. ai on top\n of a crevice, or on a navmesh island disconnected from everyone else)"
        },
        "BreadCrumbDistanceInterval": {
          "comment": "bread crumb interval (how far we need to move before laying a new breadcrumb)"
        },
        "BreadCrumbMostRecentIdx": {
          "comment": "index that represents the most recent breadcrumb"
        },
        "Breadcrumbs[NumBreadCrumbs]": {
          "comment": "ring buffer of breadcrumb positions"
        },
        "bSkipRouteCacheUpdates": {
          "comment": "AI should not update route cache - flag to prevent cache from being changed when pathing is used to evaluate squad location"
        },
        "bUseORforEvaluateGoal": {
          "comment": "when this is TRUE the goal evaluator chain will be treated as an OR chain instead of an AND chain"
        },
        "CurrentEdge": {
          "comment": "List of polys to move through"
        },
        "FinalDestination": {
          "comment": "Final destination"
        },
        "PathConstraintList": {
          "comment": "List of search constraints for pathing"
        },
        "SubGoal_DestPoly": {
          "comment": "the poly we're currently trying to get inside"
        },
        "bDebug_Breadcrumbs": {
          "comment": "draw breadcrumb debug info?"
        },
        "bDebugConstraintsAndGoalEvals": {
          "comment": "when this bool is TRUE, statistics about which constraints are doing what will be printed following\n path searches"
        },
        "bUltraVerbosePathDebugging": {
          "comment": "when true TONS of information will be printed to the log, as well as a bunch of stuff drawn to the screen.\n debug lines will be drawn indicating the progress of the path traversal, and whenever a log message is printed related\n to an edge on the navmesh a number will be printed to the screen above it indexing into the log messages to tell you\n what that message is.\n RED lines indicate expansion was stopped at that step, other colors will change depending on the expansion generation\n (e.g. all edges traversed in the first step will be of the same color, second step a different color etc.."
        },
        "LastPathError": {
          "comment": "Relevant error code set by FindPath when a path search fails. \n Allows decision on how to resolve a failed search by providing more information on the failure cause .\n Only valid if FindPath returns FALSE. Safe to ignore otherwise.\n This value is not updated until the next search fails."
        }
      },
      "functions": {
        "CalculatePathDistance": {
          "comment": "this will calculate the optimal edge positions along the pathcache, and add up the distances\n to generate an accurate distance that will be travelled along the current path\n Note: includes distance to final destination",
          "params": {
            "FinalDest": "optional finaldest override (if not passed will use NavigationHandle.FinalDestination)"
          }
        },
        "ClearConstraints": {
          "comment": "Path constraint operations\n Allows the user to push a list of constraints which affect pathing heuristics, as well as determine when the path traversal is finished"
        },
        "ClearCurrentEdge": {
          "comment": "NULLs the currentedge reference"
        },
        "ComputeValidFinalDestination": {
          "comment": "ComputeValidFinalDestination\n will find a valid, pathable point near the passed desired destination"
        },
        "CreatePathConstraint": {
          "comment": "Path shaping creation functions...\n these functions by default will just new the class, but this offers a handy\n interface to override for to do things like pool the constraints"
        },
        "DoesPylonAHaveAPathToPylonB": {
          "comment": "returns whether or not pylon A has any path to Pylon B (useful for high level early outs)"
        },
        "FindPath": {
          "comment": "this will set up a path search, and ultimately call GeneratePath to do the A* path search\n Note: it's up to your constraints to determine what it is you're doing.. if you're trying to\n path to a particular point you probably want to add a NavmeshGoal_At goal evaluator\n and supply it with the position you're pathing toward so the goal evaluator can stop the path search\n once the destination is found. You also need a path constraint to provide a heuristic for the search,\n which typically is going to consist of at least a NavMeshPath_Toward which will weight based on\n euclidian distance to the goal.",
          "params": {
            "out_DestActor": "output variable which goal evaluators can use to supply the 'found' actor at path finish",
            "out_DestItem": "output variable which goal evaluators can use to supply extra data to path search clients"
          }
        },
        "GetAllCoverSlotsInRadius": {
          "comment": "Gather all cover slot info within radius of the given point",
          "params": {
            "FromLoc": "location at center of sphere to check",
            "Radius": "radius of sphere within which to gather cover",
            "out_CoverList": "out array filled with cover infos within radius"
          }
        },
        "GetAllPolyCentersWithinBounds": {
          "comment": "returns the center points of all polys within the specefied area",
          "params": {
            "Pos": "Center of bounds to check for polys",
            "Extent": "Extent of area to return",
            "out_PolyCtrs": "out var of poly centers within the specefied area"
          }
        },
        "GetBestUnfinishedPathPoint": {
          "comment": "This will return the best \"unfinished path\". We need this for things where we are using the navmesh to find locations which\n are not connected (pathable) to the originating NavHandle but are still valid world positions."
        },
        "GetCurrentEdgeDebugText": {
          "comment": "for debugging.. will return descriptive text about the current edge"
        },
        "GetFirstMoveLocation": {
          "comment": "this will a good point on the first edge in the pathcache (or the finaldest if there is no pathcache)"
        },
        "GetNextBreadCrumb": {
          "comment": "will return the most recent breadcrumb, and pop it off the list"
        },
        "GetNextMoveLocation": {
          "comment": "will return the actual point that we should move to right now to walk along our path\n this will usually be a point along our current edge, but sometimes will\n be something else in special situations (e.g. right on top of the edge)",
          "params": {
            "out_MoveDest": "output movement destination we have determined",
            "ArrivalDistance": "this tells getnextmovelocation how close to a point we have to be before MoveTo() returns\n necessary so we can compesnate for early arrivals in some situations"
          }
        },
        "GetValidatedAnchorPosition": {
          "comment": "will get a point nearby which is in a poly that has edges outbound that support this AI",
          "params": {
            "out_NewAnchorLoc": "-",
            "OverrideStartLoc": "optional param to override the starting location for this query (if none is given this AI's searchstart will be used)"
          }
        },
        "GetValidPositionsForBox": {
          "comment": "will return a list of valid spots on the mesh which fit the passed extent and are within radius to Pos",
          "params": {
            "Pos": "Center of bounds to check for polys",
            "Radius": "radius from Pos to find valid positions within",
            "Extent": "Extent of entity we're finding a spot for",
            "bMustBeReachableFromStartPos": "if TRUE, only positions which are directly reachable from the starting position will be returned",
            "ValidPositions": "out var of valid positions for the passed entity size",
            "MaxPositions": "the maximum positions needed (e.g. the search for valid positions will stop after this many have been found)",
            "MinRadius": "minimum distance from center position to potential spots (default 0)",
            "ValidBoxAroundStartPos": "when bMustBeReachableFromStartPos is TRUE, all hits that are within this AABB of the start pos will be considered valid"
          }
        },
        "IsAnchorInescapable": {
          "comment": "this function will determine if the poly this entity is currently in is inescapable by that entity"
        },
        "LimitPathCacheDistance": {
          "comment": "will clip off edges from the pathcache which are greater than the specified distance from the start of the path",
          "params": {
            "MaxDist": "the maximum distance for the path"
          }
        },
        "LineCheck": {
          "comment": "does a line check against the Walkable mesh",
          "params": {
            "Start": "start of the line segment to check",
            "End": "end position of the line segment to check",
            "Extent": "extent of box to be swept along line segment"
          }
        },
        "MoveToDesiredHeightAboveMesh": {
          "comment": "this will take the given position and attempt to move it the passed height above the poly that point is in (along a cardinal axis)",
          "params": {
            "Point": "point to adjust",
            "Height": "height above mesh you would like"
          }
        },
        "ObstacleLineCheck": {
          "comment": "does a line check against the obstacle mesh",
          "params": {
            "Start": "start of the line segment to check",
            "End": "end position of the line segment to check",
            "Extent": "extent of box to be swept along line segment",
            "out_HitLoc": "hit location of obstacle line check (if any)",
            "out_hitNorm": "hit normal of surface we hit during obstacle line check (if any)"
          }
        },
        "ObstaclePointCheck": {
          "comment": "Does a point check against the obstacle mesh",
          "params": {
            "Pt": "centroid of box to check aginast obstacle mesh",
            "Extent": "Extent of box to check against obstacl mesh"
          }
        },
        "PathCache_Empty": {
          "comment": "Path Cache Operations\n Allows operations on nodes in the route while modifying route (ie before emptying the cache)\n Should override in subclasses as needed"
        },
        "PathCache_GetGoalPoint": {
          "comment": "After FindPath has been called this will return the location in the world that the pathfind found based on the NavMeshGoals\n the FindPath used."
        },
        "PointCheck": {
          "comment": "Does a point check against the Walkable mesh",
          "params": {
            "Pt": "centroid of box to check against obstacle mesh",
            "Extent": "Extent of box to check against obstacle mesh"
          }
        },
        "PointReachable": {
          "comment": "returns TRUE if Point/Actor is directly reachable",
          "params": {
            "Point": "point we want to test to",
            "OverrideStartPoint": "(optional) - optional override for starting position of AI (default uses bot location)",
            "bAllowHitsInEndCollisionBox": "(optional) - optional.. (defaults to ON) if this is true and a hit is detected that falls within the collision cylinder of the entity, let the hit pass"
          }
        },
        "PopulatePathfindingParamCache": {
          "comment": "This will attempt to grab an interface_navigationhandle from outer, and have that interface populate\n our cached pathing params."
        },
        "SetFinalDestination": {
          "comment": "lets the navigation handle know what the ultimate goal of the current move is",
          "params": {
            "FinalDest": "the destination desired"
          }
        },
        "SuggestMovePreparation": {
          "comment": "this will notify our curretn edge we're about to traverse it, and allow that edge to perform custom actions for traversal",
          "params": {
            "MovePt": "the point we're about to move to",
            "C": "controller we're suggesting move prep for"
          }
        },
        "UpdateBreadCrumbs": {
          "comment": "checks if we've moved far enough, and if so updates the breadcrumb trail",
          "params": {
            "Location": "current location"
          }
        }
      },
      "structs": {
        "EdgePointer": {
          "comment": "dummy struct used to match alignment in pathcache array"
        },
        "NavMeshPathParams": {
          "properties": {
            "bAbleToSearch": {
              "comment": "is this entity valid to pathfind (does it have a pawn, etc..)"
            },
            "bCanMantle": {
              "comment": "can this entity use mantle edges?"
            },
            "bNeedsMantleValidityTest": {
              "comment": "do we need to perform extra checks when determining if an edge supports the entiy?"
            },
            "Interface": {
              "comment": "the navhandle interface for the pathing entity"
            },
            "MaxDropHeight": {
              "comment": "the maximum valid height for this entity to 'drop down' (e.g. max height to use on dropdown edges)"
            },
            "MaxHoverDistance": {
              "comment": "max hover distance -- the maximum distance this entity can hover above the surface of a polygon. (-1 means arbitrarily high)"
            },
            "MinWalkableZ": {
              "comment": "the minimum value for the Z component of walkable surfaces"
            },
            "SearchExtent": {
              "comment": "the size of the entity looking for a path"
            },
            "SearchStart": {
              "comment": "the starting location for the path search"
            }
          }
        }
      }
    },
    "NavigationPoint": {
      "properties": {
        "AnchoredPawn": {
          "comment": "Pawn that is currently anchor to this navigation point"
        },
        "BadSprite": {
          "comment": "Used to draw bad collision intersection in editor"
        },
        "bBuildLongPaths": {
          "comment": "if true, attempt to build long range (> MAXPATHDIST) paths to/from this node"
        },
        "bCanWalkOnToReach": {
          "comment": "whether walking on (being based on) this NavigationPoint counts as reaching it"
        },
        "bHasCrossLevelPaths": {
          "comment": "Does this nav point point to others in separate levels?"
        },
        "bShouldSaveForCheckpoint": {
          "comment": "whether we need to save this in checkpoints because it has been modified by Kismet"
        },
        "CostArray": {
          "comment": "constructors"
        },
        "EditorForcedPaths": {
          "comment": "List of navigation points to force paths to be built to"
        },
        "EditorProscribedPaths": {
          "comment": "List of navigation points to prevent paths being built to"
        },
        "GoodSprite": {
          "comment": "Normal editor sprite"
        },
        "LastAnchoredPawnTime": {
          "comment": "Last time a pawn was anchored to this navigation point - set when Pawn chooses a new anchor"
        },
        "NavOctreeObject": {
          "comment": "templated accessor to Owner, to avoid casting for common cases\n @note T must be UObject or a subclass, or this function will not compile"
        },
        "MaxPathSize": {
          "comment": "path size of the largest ReachSpec in this node's PathList"
        },
        "NavGuid": {
          "comment": "GUID used for linking paths across levels"
        },
        "NetworkID": {
          "comment": "Which navigation network does this navigation point connect to?"
        },
        "Volumes": {
          "comment": "List of volumes containing this navigation point relevant for gameplay"
        },
        "bBlockedForVehicles": {
          "comment": "indicates vehicles cannot use this node"
        },
        "bPreferredVehiclePath": {
          "comment": "vehicles with bUsePreferredVehiclePaths set (large vehicles, usually) will prioritize using these nodes"
        }
      },
      "functions": {
        "CanTeleport": {
          "comment": "returns whether this NavigationPoint is a teleporter that can teleport the given Actor"
        },
        "GetAllNavInRadius": {
          "comment": "Returns all navigation points near the ChkPoint specified by Radius."
        },
        "GetBoundingCylinder": {
          "comment": "Works through the component arrays marking entries as pending kill so references to them\n will be NULL'ed.",
          "params": {
            "bAllowComponentOverride": "Whether to allow component to override marking the setting"
          }
        },
        "GetNearestNavToActor": {
          "comment": "Returns the nearest valid navigation point to the given actor."
        },
        "GetNearestNavToPoint": {
          "comment": "Returns the nearest valid navigation point to the given point."
        },
        "IsOnDifferentNetwork": {
          "comment": "Returns if this navigation point is on a different network than the given"
        },
        "IsUsableAnchorFor": {
          "comment": "returns whether this NavigationPoint is valid to be considered as an Anchor (start or end) for pathfinding by the given Pawn",
          "params": {
            "P": "the Pawn doing pathfinding"
          }
        },
        "OnToggle": {
          "comment": "Toggle the blocked state of a navigation point."
        }
      },
      "structs": {
        "DebugNavCost": {
          "comment": "Mapping of Cost/Description for costs of this node"
        },
        "NavigationOctreeObject": {
          "comment": "structure for inserting things into the navigation octree",
          "properties": {
            "BoundingBox": {
              "comment": "the bounding box to use"
            },
            "BoxCenter": {
              "comment": "cached center of that box"
            },
            "OctreeNode": {
              "comment": "if this object is in the octree, pointer to the node it's in, otherwise NULL"
            },
            "Owner": {
              "comment": "UObject that owns the entry in the octree"
            },
            "OwnerType": {
              "comment": "bitfield representing common classes of Owner so we can avoid casts"
            }
          }
        }
      }
    },
    "NavMeshGoalFilter_MinPathDistance": {
      "functions": {
        "MustBeLongerPathThan": {
          "comment": "Called on each Goal_Filter that is in the list of a generic filter container to determine a goal's fitness for being 'the one'",
          "params": {
            "PossibleGoal": "the chosen (cheapest) successor from the open list",
            "PathParams": "the cached pathfinding params for the pathing entity"
          }
        }
      }
    },
    "NavMeshGoalFilter_NotNearOtherAI": {
      "properties": {
        "DistanceToCheck": {
          "comment": "This is how far we are going to check around our spawn location."
        }
      },
      "functions": {
        "NotNearOtherAI": {
          "comment": "Called on each Goal_Filter that is in the list of a generic filter container to determine a goal's fitness for being 'the one'",
          "params": {
            "PossibleGoal": "the chosen (cheapest) successor from the open list",
            "PathParams": "the cached pathfinding params for the pathing entity"
          }
        }
      }
    },
    "NavMeshGoalFilter_OutOfViewFrom": {
      "functions": {
        "MustBeHiddenFromThisPoint": {
          "comment": "Called on each Goal_Filter that is in the list of a generic filter container to determine a goal's fitness for being 'the one'",
          "params": {
            "PossibleGoal": "the chosen (cheapest) successor from the open list",
            "PathParams": "the cached pathfinding params for the pathing entity"
          }
        }
      }
    },
    "NavMeshGoalFilter_OutSideOfDotProductWedge": {
      "properties": {
        "Location": {
          "comment": "Location to compare from"
        }
      },
      "functions": {
        "OutsideOfDotProductWedge": {
          "comment": "Called on each Goal_Filter that is in the list of a generic filter container to determine a goal's fitness for being 'the one'",
          "params": {
            "PossibleGoal": "the chosen (cheapest) successor from the open list",
            "PathParams": "the cached pathfinding params for the pathing entity"
          }
        }
      }
    },
    "NavMeshGoalFilter_PolyEncompassesAI": {
      "comment": "this goal will throw out polygons which can't fully fit the entity searching\n this is useful for open-ended path searches (e.g. find any poly outside of a radius) because\n an edge may support the entity allowing the traversal to enter a polygon, but the entity might not necessarily fully \n fit inside the polygon, even though he could move through it",
      "properties": {
        "OverrideExtentToCheck": {
          "comment": "This is what we are going to check and make certain we have enough space to spawn this size of extent"
        }
      },
      "functions": {
        "MakeSureAIFits": {
          "comment": "Called on each Goal_Filter that is in the list of a generic filter container to determine a goal's fitness for being 'the one'",
          "params": {
            "PossibleGoal": "the chosen (cheapest) successor from the open list",
            "PathParams": "the cached pathfinding params for the pathing entity"
          }
        }
      }
    },
    "NavMeshGoal_At": {
      "properties": {
        "bKeepPartial": {
          "comment": "Should keep track of cheapest path even if don't reach goal"
        },
        "Goal": {
          "comment": "Location to reach"
        },
        "GoalDist": {
          "comment": "Within this acceptable distance"
        }
      }
    },
    "NavMeshGoal_ClosestActorInList": {
      "properties": {
        "CachedAnchorPoly": {
          "comment": "Cached ref to the anchor poly we're trying to path back to"
        },
        "GoalList": {
          "comment": "walks the previousPath chain back and saves out edges into the handle's pathcache for that handle to follow\n \n@param StartingPoly - the Polygon we are walking backwards toward\n \n@param GoalPoly - the polygon to begin walking backwards from\n \n@param Handle - the handle to save the path out to \n \n@param GoalEdge - the edge that lead us to the goal poly"
        },
        "PolyToGoalActorMap": {
          "comment": "cached map of which polys match to which actors"
        }
      }
    },
    "NavMeshGoal_Filter": {
      "comment": "-this is a helper base class which is for filters that are meant to be used in conjunction with NavMshGoal_GenericFilterContainer\n these goals should only answer this question \"is this a valid final goal or not?\" and do nothing else.",
      "properties": {
        "NumNodesProcessed": {
          "comment": "Debug var to keep track of how many nodes this goal evaluator has processed"
        },
        "NumNodesThrownOut": {
          "comment": "Debug var to keep track of how many nodes this goal evaluator has nixed"
        }
      },
      "functions": {
        "GetDumpString": {
          "comment": "Called on each filter in the GenericFilterContainer to verify that a particular node is valid to be added\n as a seed poly (default is to just call IsValidFinalGoal)",
          "params": {
            "PossibleGoal": "the chosen (cheapest) successor from the open list",
            "PathParams": "the cached pathfinding params for the pathing entity"
          }
        }
      }
    },
    "NavMeshGoal_GenericFilterContainer": {
      "comment": "this goal eval will not stop until its out of paths, and will simply return the node with the least cost",
      "properties": {
        "GoalFilters": {
          "comment": "sets up internal vars for path searching, and will early out if something fails\n \n@param Handle - handle we're initializing for\n \n@param PathParams - pathfinding parameter packet\n \n@return - whether or not we should early out form this search"
        },
        "MyNavigationHandle": {
          "comment": "Ref to our NavHandle so we can interrogate it for Debug flags."
        },
        "SuccessfulGoal": {
          "comment": "storage of the goal we found an determined was OK (for use when goal does not have a path, but we still want to know what the goal was)"
        }
      },
      "functions": {
        "GetGoalPoint": {
          "comment": "returns the center of the poly we found as a valid goal, or 0,0,0 if none found (uses SuccessfulGoal member var0"
        }
      }
    },
    "NavMeshGoal_Null": {
      "comment": "this goal eval will not stop until its out of paths, and will simply return the node with the least cost"
    },
    "NavMeshGoal_PolyEncompassesAI": {
      "comment": "this goal will throw out polygons which can't fully fit the entity searching\n this is useful for open-ended path searches (e.g. find any poly outside of a radius) because\n an edge may support the entity allowing the traversal to enter a polygon, but the entity might not necessarily fully \n fit inside the polygon, even though he could move through it",
      "properties": {
        "OverrideExtentToCheck": {
          "comment": "This is what we are going to check and make certain we have enough space to spawn this size of extent"
        }
      }
    },
    "NavMeshGoal_Random": {
      "comment": "this goal eval will not stop until its out of paths, and will return one of the nodes traversed at random",
      "properties": {
        "MinDist": {
          "comment": "minimum path distance before we start rating nodes; useful when you want to make sure the random decision covers a reasonable distance\n and isn't just moving back and forth in a small area"
        }
      }
    },
    "NavMeshGoal_WithinDistanceEnvelope": {
      "properties": {
        "MaxDistance": {
          "comment": "outer distance of envelope (distance from test actor)"
        },
        "MinDistance": {
          "comment": "inner distance of envelope (distance from test actor)"
        }
      }
    },
    "NavMeshObstacle": {
      "functions": {
        "GetObstacleBoudingShape": {
          "comment": "script accessible function that builds the bounding shape for the navmesh obstacle \n Note: needs to return a CW wound convex shape!",
          "params": {
            "shape": "array of verts for cutting shape"
          }
        }
      }
    },
    "NavMeshPathConstraint": {
      "properties": {
        "AddedDirectCost": {
          "comment": "total cost added by this constraint to the saved *real* cost of nodes"
        },
        "AddedHeuristicCost": {
          "comment": "total cost added by this constraint to the heuristic cost of nodes"
        },
        "NextConstraint": {
          "comment": "Next constraint in the list"
        },
        "NumNodesProcessed": {
          "comment": "number of nodes this constraint has processed"
        },
        "NumThrownOutNodes": {
          "comment": "number of nodes this constraint has returned FALSE for"
        }
      }
    },
    "NavMeshPathGoalEvaluator": {
      "properties": {
        "bAlwaysCallEvaluateGoal": {
          "comment": "this bool determines if this evaluator's 'EvaluageGoal' function gets called even after a determination has been made\n about the current goal. E.G. a previous evaluator returned FALSE indicating the search was not complete, but we still want\n EvaluateGoal called even when the outcome has already been decided. This is useful for \n evaluators that need to see all incoming candidates regardless of whether or not another evaluator is throwing htem out"
        },
        "MaxPathVisits": {
          "comment": "maximum number of NavigationPoints to test before giving up"
        },
        "NextEvaluator": {
          "comment": "Next goal evaluator"
        },
        "NumNodesProcessed": {
          "comment": "Debug var to keep track of how many nodes this goal evaluator has processed"
        },
        "NumNodesThrownOut": {
          "comment": "Debug var to keep track of how many nodes this goal evaluator has nixed"
        }
      },
      "structs": {
        "BiasedGoalActor": {
          "comment": "list of goals to search for",
          "properties": {
            "ExtraCost": {
              "comment": "an additional cost (in units) to add to the pathfinding distance to bias against this choice\n (e.g. if one choice is enough better than the others that it should be prioritized if it's only a little bit further away)"
            },
            "Goal": {
              "comment": "the goal to search for"
            }
          }
        }
      }
    },
    "NavMeshPath_AlongLine": {
      "properties": {
        "Direction": {
          "comment": "Direction to move in"
        }
      }
    },
    "NavMeshPath_EnforceTwoWayEdges": {
      "comment": "only allows edges which have a corresponding edge back (filters out one-way situations)"
    },
    "NavMeshPath_MinDistBetweenSpecsOfType": {
      "comment": "penalizes specs of a certain class if they are within a set distance of another mantle in the predecessor chain",
      "properties": {
        "EdgeType": {
          "comment": "the type of edge we want to enforce minimum distance between"
        },
        "InitLocation": {
          "comment": "can be used to indicate we last mantled at this location in previous path and we shouldn't take mantles within"
        },
        "MinDistBetweenEdgeTypes": {
          "comment": "min dist between edges of the specified type type"
        },
        "Penalty": {
          "comment": "penalty to apply when two specs are within mindist"
        }
      }
    },
    "NavMeshPath_Toward": {
      "properties": {
        "GoalActor": {
          "comment": "Goal trying to find path toward"
        },
        "GoalPoint": {
          "comment": "Goal trying to find path toward"
        }
      }
    },
    "NavMeshPath_WithinDistanceEnvelope": {
      "properties": {
        "bOnlyThrowOutNodesThatLeaveEnvelope": {
          "comment": "when bSoft is false, should we throw out nodes whose start and end are both outside the envelope?"
        },
        "bSoft": {
          "comment": "if this is on instead of throwing out nodes outside traversal distance they will be gradiently penalized the further out they are"
        },
        "MaxDistance": {
          "comment": "outer distance of envelope (distance from test actor)"
        },
        "MinDistance": {
          "comment": "inner distance of envelope (distance from test actor)"
        },
        "SoftStartPenalty": {
          "comment": "when a path exceeds specified traversal distance this penalty will be applied, and scaled up depending on how far outside the dist it is"
        }
      }
    },
    "NavMeshPath_WithinTraversalDist": {
      "properties": {
        "bSoft": {
          "comment": "if this is on instead of throwing out nodes outside traversal distance they will be gradiently penalized the further out they are"
        },
        "MaxTraversalDist": {
          "comment": "Maximum distance to traverse along a branch"
        },
        "SoftStartPenalty": {
          "comment": "when a path exceeds specified traversal distance this penantly will be applied, and scaled up depending on how far outside the dist it is"
        }
      }
    },
    "NxCylindricalForceField": {
      "properties": {
        "Kernel": {
          "comment": "custom force field kernel"
        },
        "EscapeVelocity": {
          "comment": "Velocity above which the radial force is ignored."
        },
        "ForceHeight": {
          "comment": "Height of force cylinder"
        },
        "ForceRadius": {
          "comment": "Radius of influence of the force at the bottom of the cylinder."
        },
        "ForceTopRadius": {
          "comment": "Radius of the force field at the top"
        },
        "HeightOffset": {
          "comment": "Offset from the actor base to the center of the force field"
        },
        "LiftFalloffHeight": {
          "comment": "Lift falloff height, 0-1, lift starts to fall off in a linear way above this height"
        },
        "LiftStrength": {
          "comment": "Strength of the force applied along the cylinder axis"
        },
        "RadialStrength": {
          "comment": "Strength of the force applied by this actor."
        },
        "RotationalStrength": {
          "comment": "Rotational strength of the force applied around the cylinder axis."
        },
        "UseSpecialRadialForce": {
          "comment": "Whether to use a special radial force"
        }
      }
    },
    "NxCylindricalForceFieldCapsule": {
      "properties": {
        "RenderComponent": {
          "comment": "Used to preview the radius of the force."
        }
      },
      "functions": {
        "DoInitRBPhys": {
          "comment": "This is used to InitRBPhys for a dynamically spawned ForceField.\n Used for starting RBPhsys on dyanmically spawned force fields. This will probably need to set some transient pointer to NULL"
        }
      }
    },
    "NxForceField": {
      "properties": {
        "SceneIndex": {
          "comment": "Physics scene index."
        },
        "bForceActive": {
          "comment": "Indicates whether the force is active at the moment."
        },
        "CollideWithChannels": {
          "comment": "Which types of object to apply this force field to"
        },
        "ExcludeChannel": {
          "comment": "Channel id, used to identify which force field exclude volumes apply to this force field"
        },
        "RBChannel": {
          "comment": "enum indicating what collision filtering channel this force field should be in"
        }
      },
      "functions": {
        "DoInitRBPhys": {
          "comment": "This is used to InitRBPhys for a dynamically spawned ForceField.\n Used for starting RBPhsys on dyanmically spawned force fields. This will probably need to set some transient pointer to NULL"
        },
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        }
      }
    },
    "NxForceFieldComponent": {
      "properties": {
        "ElapsedTime": {
          "comment": "Internal variable for storing the elapsed time of the force field"
        },
        "RenderComponent": {
          "comment": "Internal variable to hold the render component for attaching and detaching"
        },
        "SceneIndex": {
          "comment": "Physics scene index."
        },
        "bDestroyWhenInactive": {
          "comment": "Destroy the forcefield from the actor when it become inactive"
        },
        "bForceActive": {
          "comment": "Indicates whether the force is active at the moment."
        },
        "CollideWithChannels": {
          "comment": "Which types of object to apply this force field to"
        },
        "Duration": {
          "comment": "Time in seconds until force field expiration for FMT_CONSTANT type force mode. 0 = Infinite"
        },
        "ExcludeChannel": {
          "comment": "Channel id, used to identify which force field exclude volumes apply to this force field"
        }
      }
    },
    "NxForceFieldCylindricalComponent": {
      "properties": {
        "Kernel": {
          "comment": "custom force field kernel"
        },
        "EscapeVelocity": {
          "comment": "Velocity above which the radial force is ignored."
        },
        "ForceHeight": {
          "comment": "Height of force cylinder"
        },
        "ForceRadius": {
          "comment": "Radius of influence of the force at the bottom of the cylinder."
        },
        "ForceTopRadius": {
          "comment": "Radius of the force field at the top"
        },
        "HeightOffset": {
          "comment": "Offset from the actor base to the center of the force field"
        },
        "LiftFalloffHeight": {
          "comment": "Lift falloff height, 0-1, lift starts to fall off in a linear way above this height"
        },
        "LiftStrength": {
          "comment": "Strength of the force applied along the cylinder axis"
        },
        "RadialStrength": {
          "comment": "Strength of the force applied by this actor."
        },
        "RotationalStrength": {
          "comment": "Rotational strength of the force applied around the cylinder axis."
        },
        "UseSpecialRadialForce": {
          "comment": "Whether to use a special radial force"
        }
      }
    },
    "NxForceFieldGeneric": {
      "properties": {
        "LinearKernel": {
          "comment": "linear force field kernel"
        },
        "Constant": {
          "comment": "Constant force vector that is applied inside force volume"
        },
        "Coordinates": {
          "comment": "Type of Coordinates to define the force field"
        },
        "FalloffLinear": {
          "comment": "Linear falloff for vector in chosen coordinate system"
        },
        "FalloffQuadratic": {
          "comment": "Quadratic falloff for vector in chosen coordinate system"
        },
        "Noise": {
          "comment": "Vector that scales random noise added to the force"
        },
        "PositionMultiplierX": {
          "comment": "Rows of matrix that defines force depending on position"
        },
        "PositionTarget": {
          "comment": "Vector that defines force depending on position"
        },
        "TorusRadius": {
          "comment": "Radius of torus in case toroidal coordinate system is used"
        },
        "VelocityMultiplierX": {
          "comment": "Rows of matrix that defines force depending on velocity"
        },
        "VelocityTarget": {
          "comment": "Vector that defines force depending on velocity"
        }
      },
      "functions": {
        "DoInitRBPhys": {
          "comment": "This is used to InitRBPhys for a dynamically spawned ForceField.\n Used for starting RBPhsys on dyanmically spawned force fields. This will probably need to set some transient pointer to NULL"
        }
      }
    },
    "NxForceFieldGenericComponent": {
      "properties": {
        "Kernel": {
          "comment": "linear force field kernel"
        },
        "Constant": {
          "comment": "Constant force vector that is applied inside force volume"
        },
        "Coordinates": {
          "comment": "Type of Coordinates to define the force field"
        },
        "FalloffLinear": {
          "comment": "Linear falloff for vector in chosen coordinate system"
        },
        "FalloffQuadratic": {
          "comment": "Quadratic falloff for vector in chosen coordinate system"
        },
        "Noise": {
          "comment": "Vector that scales random noise added to the force"
        },
        "PositionMultiplierX": {
          "comment": "Rows of matrix that defines force depending on position"
        },
        "PositionTarget": {
          "comment": "Vector that defines force depending on position"
        },
        "TorusRadius": {
          "comment": "Radius of torus in case toroidal coordinate system is used"
        },
        "VelocityMultiplierX": {
          "comment": "Rows of matrix that defines force depending on velocity"
        },
        "VelocityTarget": {
          "comment": "Vector that defines force depending on velocity"
        }
      }
    },
    "NxForceFieldRadial": {
      "properties": {
        "Kernel": {
          "comment": "custom force field kernel"
        },
        "ForceFalloff": {
          "comment": "Way in which the force falls off as objects are further away from the location."
        },
        "ForceRadius": {
          "comment": "Radius of influence of the force."
        },
        "ForceStrength": {
          "comment": "Strength of the force applied by this actor. Positive forces are applied outwards."
        }
      },
      "functions": {
        "DoInitRBPhys": {
          "comment": "This is used to InitRBPhys for a dynamically spawned ForceField.\n Used for starting RBPhsys on dyanmically spawned force fields. This will probably need to set some transient pointer to NULL"
        }
      }
    },
    "NxForceFieldRadialComponent": {
      "properties": {
        "Kernel": {
          "comment": "custom force field kernel"
        },
        "ForceFalloff": {
          "comment": "Way in which the force falls off as objects are further away from the location."
        },
        "ForceRadius": {
          "comment": "Radius of influence of the force."
        },
        "ForceStrength": {
          "comment": "Strength of the force applied by this actor. Positive forces are applied outwards."
        }
      }
    },
    "NxForceFieldSpawnable": {
      "functions": {
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        }
      }
    },
    "NxForceFieldTornado": {
      "properties": {
        "Kernel": {
          "comment": "custom force field kernel"
        },
        "EscapeVelocity": {
          "comment": "Velocity above which the radial force is ignored."
        },
        "ForceHeight": {
          "comment": "Height of force cylinder"
        },
        "ForceRadius": {
          "comment": "Radius of influence of the force at the bottom of the cylinder."
        },
        "ForceTopRadius": {
          "comment": "Radius of the force field at the top"
        },
        "HeightOffset": {
          "comment": "Offset from the actor base to the center of the force field"
        },
        "LiftFalloffHeight": {
          "comment": "Lift falloff height, 0-1, lift starts to fall off in a linear way above this height"
        },
        "LiftStrength": {
          "comment": "Strength of the force applied along the cylinder axis"
        },
        "RadialStrength": {
          "comment": "Strength of the force applied by this actor."
        },
        "RotationalStrength": {
          "comment": "Rotational strength of the force applied around the cylinder axis."
        }
      },
      "functions": {
        "DoInitRBPhys": {
          "comment": "This is used to InitRBPhys for a dynamically spawned ForceField.\n Used for starting RBPhsys on dyanmically spawned force fields. This will probably need to set some transient pointer to NULL"
        }
      }
    },
    "NxForceFieldTornadoComponent": {
      "properties": {
        "Kernel": {
          "comment": "custom force field kernel"
        },
        "EscapeVelocity": {
          "comment": "Velocity above which the radial force is ignored."
        },
        "ForceHeight": {
          "comment": "Height of force cylinder"
        },
        "ForceRadius": {
          "comment": "Radius of influence of the force at the bottom of the cylinder."
        },
        "ForceTopRadius": {
          "comment": "Radius of the force field at the top"
        },
        "HeightOffset": {
          "comment": "Offset from the actor base to the center of the force field"
        },
        "LiftFalloffHeight": {
          "comment": "Lift falloff height, 0-1, lift starts to fall off in a linear way above this height"
        },
        "LiftStrength": {
          "comment": "Strength of the force applied along the cylinder axis"
        },
        "RadialStrength": {
          "comment": "Strength of the force applied by this actor."
        },
        "RotationalStrength": {
          "comment": "Rotational strength of the force applied around the cylinder axis."
        }
      }
    },
    "NxGenericForceField": {
      "properties": {
        "LinearKernel": {
          "comment": "linear force field kernel"
        },
        "Constant": {
          "comment": "Constant force vector that is applied inside force volume"
        },
        "Coordinates": {
          "comment": "Type of Coordinates to define the force field"
        },
        "FalloffLinear": {
          "comment": "Linear falloff for vector in chosen coordinate system"
        },
        "FalloffQuadratic": {
          "comment": "Quadratic falloff for vector in chosen coordinate system"
        },
        "Noise": {
          "comment": "Vector that scales random noise added to the force"
        },
        "PositionMultiplierX": {
          "comment": "Rows of matrix that defines force depending on position"
        },
        "PositionTarget": {
          "comment": "Vector that defines force depending on position"
        },
        "TorusRadius": {
          "comment": "Radius of torus in case toroidal coordinate system is used"
        },
        "VelocityMultiplierX": {
          "comment": "Rows of matrix that defines force depending on velocity"
        },
        "VelocityTarget": {
          "comment": "Vector that defines force depending on velocity"
        }
      }
    },
    "NxGenericForceFieldBox": {
      "properties": {
        "RenderComponent": {
          "comment": "Used to preview the radius of the force."
        },
        "BoxExtent": {
          "comment": "Radius of influence of the force."
        }
      },
      "functions": {
        "DoInitRBPhys": {
          "comment": "This is used to InitRBPhys for a dynamically spawned ForceField.\n Used for starting RBPhsys on dyanmically spawned force fields. This will probably need to set some transient pointer to NULL"
        }
      }
    },
    "NxGenericForceFieldBrush": {
      "properties": {
        "ForceField": {
          "comment": "Value to scale force on soft body"
        },
        "LinearKernel": {
          "comment": "linear force field kernel"
        },
        "CollideWithChannels": {
          "comment": "Which types of object to apply this force field to"
        },
        "Constant": {
          "comment": "Constant force vector that is applied inside force volume"
        },
        "ExcludeChannel": {
          "comment": "Channel id, used to identify which force field exclude volumes apply to this force field"
        },
        "FalloffLinear": {
          "comment": "Linear falloff for vector in chosen coordinate system"
        },
        "FalloffQuadratic": {
          "comment": "Quadratic falloff for vector in chosen coordinate system"
        },
        "Noise": {
          "comment": "Vector that scales random noise added to the force"
        },
        "PositionMultiplierX": {
          "comment": "Rows of matrix that defines force depending on position"
        },
        "PositionTarget": {
          "comment": "Vector that defines force depending on position"
        },
        "RBChannel": {
          "comment": "enum indicating what collision filtering channel this force field should be in"
        },
        "TorusRadius": {
          "comment": "Radius of torus in case toroidal coordinate system is used"
        },
        "VelocityMultiplierX": {
          "comment": "Rows of matrix that defines force depending on velocity"
        },
        "VelocityTarget": {
          "comment": "Vector that defines force depending on velocity"
        }
      }
    },
    "NxGenericForceFieldCapsule": {
      "properties": {
        "RenderComponent": {
          "comment": "Used to preview the radius of the force."
        },
        "CapsuleHeight": {
          "comment": "Radius of influence of the force."
        }
      }
    },
    "NxRadialCustomForceField": {
      "properties": {
        "Kernel": {
          "comment": "custom force field kernel"
        }
      }
    },
    "NxRadialForceField": {
      "properties": {
        "LinearKernel": {
          "comment": "linear force field kernel"
        },
        "RenderComponent": {
          "comment": "Used to preview the radius of the force."
        },
        "ForceFalloff": {
          "comment": "Way in which the force falls off as objects are further away from the location."
        },
        "ForceRadius": {
          "comment": "Radius of influence of the force."
        },
        "ForceStrength": {
          "comment": "Strength of the force applied by this actor. Positive forces are applied outwards."
        }
      }
    },
    "NxTornadoAngularForceField": {
      "properties": {
        "Kernel": {
          "comment": "custom force field kernel"
        },
        "EscapeVelocity": {
          "comment": "Velocity above which the radial force is ignored."
        },
        "ForceHeight": {
          "comment": "Height of force cylinder"
        },
        "ForceRadius": {
          "comment": "Radius of influence of the force at the bottom of the cylinder."
        },
        "ForceTopRadius": {
          "comment": "Radius of the force field at the top"
        },
        "HeightOffset": {
          "comment": "Offset from the actor base to the center of the force field"
        },
        "LiftFalloffHeight": {
          "comment": "Lift falloff height, 0-1, lift starts to fall off in a linear way above this height"
        },
        "LiftStrength": {
          "comment": "Strength of the force applied along the cylinder axis"
        },
        "RadialStrength": {
          "comment": "Strength of the force applied by this actor."
        },
        "RotationalStrength": {
          "comment": "Rotational strength of the force applied around the cylinder axis."
        }
      }
    },
    "NxTornadoAngularForceFieldCapsule": {
      "properties": {
        "RenderComponent": {
          "comment": "Used to preview the radius of the force."
        }
      }
    },
    "NxTornadoForceField": {
      "properties": {
        "Kernel": {
          "comment": "custom force field kernel"
        },
        "EscapeVelocity": {
          "comment": "Velocity above which the radial force is ignored."
        },
        "ForceHeight": {
          "comment": "Height of force cylinder"
        },
        "ForceRadius": {
          "comment": "Radius of influence of the force at the bottom of the cylinder."
        },
        "ForceTopRadius": {
          "comment": "Radius of the force field at the top"
        },
        "HeightOffset": {
          "comment": "Offset from the actor base to the center of the force field"
        },
        "LiftFalloffHeight": {
          "comment": "Lift falloff height, 0-1, lift starts to fall off in a linear way above this height"
        },
        "LiftStrength": {
          "comment": "Strength of the force applied along the cylinder axis"
        },
        "RadialStrength": {
          "comment": "Strength of the force applied by this actor."
        },
        "RotationalStrength": {
          "comment": "Rotational strength of the force applied around the cylinder axis."
        }
      }
    },
    "NxTornadoForceFieldCapsule": {
      "properties": {
        "RenderComponent": {
          "comment": "Used to preview the radius of the force."
        }
      }
    },
    "ObjectReferencer": {
      "comment": "Helper class to force object references for various reasons.",
      "properties": {
        "ReferencedObjects": {
          "comment": "Array of objects being referenced."
        }
      }
    },
    "OnlineAccountInterface": {
      "comment": "This interface provides account creation and enumeration functions",
      "functions": {
        "AddCreateOnlineAccountCompletedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that account creation completed",
          "params": {
            "AccountCreateDelegate": "the delegate to use for notifications"
          }
        },
        "ClearCreateOnlineAccountCompletedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "AccountCreateDelegate": "the delegate to use for notifications"
          }
        },
        "CreateLocalAccount": {
          "comment": "Creates a non-networked account on the local system. Password is only used\n when supplied. Otherwise the account is not secured.",
          "params": {
            "UserName": "the unique nickname of the account",
            "Password": "the password securing the account"
          }
        },
        "CreateOnlineAccount": {
          "comment": "Creates a network enabled account on the online service",
          "params": {
            "UserName": "the unique nickname of the account",
            "Password": "the password securing the account",
            "EmailAddress": "the address used to send password hints to",
            "ProductKey": "the unique id for this installed product"
          }
        },
        "DeleteLocalAccount": {
          "comment": "Deletes a local account if the password matches",
          "params": {
            "UserName": "the unique nickname of the account",
            "Password": "the password securing the account"
          }
        },
        "GetLocalAccountNames": {
          "comment": "Fetches a list of local accounts",
          "params": {
            "Accounts": "the array that is populated with the accounts"
          }
        },
        "RenameLocalAccount": {
          "comment": "Changes the name of a local account",
          "params": {
            "UserName": "the unique nickname of the account",
            "Password": "the password securing the account"
          }
        }
      }
    },
    "OnlineCommunityContentInterface": {
      "functions": {
        "AddDownloadContentCompleteDelegate": {
          "comment": "Adds the delegate to the list that will be notified when the task completes",
          "params": {
            "DownloadContentCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddGetContentPayloadCompleteDelegate": {
          "comment": "Adds the delegate to the list that will be notified when the task completes",
          "params": {
            "GetContentPayloadCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadContentListCompleteDelegate": {
          "comment": "Adds the delegate to the list that will be notified when the task completes",
          "params": {
            "ReadContentListCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadFriendsContentListCompleteDelegate": {
          "comment": "Adds the delegate to the list that will be notified when the task completes",
          "params": {
            "ReadFriendsContentListCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddUploadContentCompleteDelegate": {
          "comment": "Adds the delegate to the list that will be notified when the task completes",
          "params": {
            "UploadContentCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearDownloadContentCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "DownloadContentCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearGetContentPayloadCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "GetContentPayloadCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadContentListCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "ReadContentListCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadFriendsContentListCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "ReadFriendsContentListCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearUploadContentCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "UploadContentCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "DownloadContent": {
          "comment": "Downloads the contents of the specified file",
          "params": {
            "PlayerNum": "the controller number associated with the player",
            "FileToDownload": "the file information that tells the system what to download"
          }
        },
        "Exit": {
          "comment": "Shuts down the community content object"
        },
        "GetContentList": {
          "comment": "Copies the content file information for the specified player",
          "params": {
            "PlayerNum": "the controller number associated with the player",
            "ContentFiles": "out array that is populated with the file list"
          }
        },
        "GetContentPayload": {
          "comment": "Copies the contents of the payload into the specified array for the specified file owned\n by the specified player",
          "params": {
            "PlayerNum": "the controller number associated with the player",
            "FileDownloaded": "the information for the file that was downloaded"
          }
        },
        "GetFriendsContentList": {
          "comment": "Copies the content file information for the specified player",
          "params": {
            "PlayerNum": "the controller number associated with the player",
            "Friend": "the friend to copy the file list for",
            "ContentFiles": "out array that is populated with the file list"
          }
        },
        "Init": {
          "comment": "Initializes the community content object"
        },
        "RateContent": {
          "comment": "Supplies a player defined rating for the specified content",
          "params": {
            "PlayerNum": "the controller number associated with the player",
            "FileToRate": "the information for the file that is being rated",
            "NewRating": "the new rating the player has given for this content"
          }
        },
        "ReadContentList": {
          "comment": "Starts the async task that reads the list of content that this person can download. The resulting\n data includes the information for that file (meta data and rating/download information)",
          "params": {
            "PlayerNum": "the controller number associated with the player",
            "StartAt": "used to read from a list starting a known offset",
            "NumToRead": "the number of items to retrieve (-1 means all)"
          }
        },
        "ReadFriendsContentList": {
          "comment": "Starts the async task that reads the list of content that this person can download. The resulting\n data includes the information for that file (meta data and rating/download information)",
          "params": {
            "PlayerNum": "the controller number associated with the player",
            "Friends": "the set of friends to read the content files for",
            "StartAt": "used to read from a list starting a known offset",
            "NumToRead": "the number of items to retrieve (-1 means all)"
          }
        },
        "UploadContent": {
          "comment": "Uploads the contents of the blob to the content server(s)",
          "params": {
            "PlayerNum": "the controller number associated with the player",
            "Payload": "the data that is being uploaded",
            "Metadata": "metadata describing the content"
          }
        }
      }
    },
    "OnlineContentInterface": {
      "comment": "This interface provides accessors to the platform specific content\n system (ie downloadable content, etc)",
      "functions": {
        "AddContentChangeDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that (downloaded) content changed",
          "params": {
            "Content": "Delegate the delegate to use for notifications",
            "LocalUserNum": "whether to watch for changes on a specific slot or all slots"
          }
        },
        "AddQueryAvailableDownloadsComplete": {
          "comment": "Adds the delegate used to notify the gameplay code that the content download query has completed",
          "params": {
            "LocalUserNum": "the user to check the content download availability for",
            "ReadContentCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadContentComplete": {
          "comment": "Adds the delegate used to notify the gameplay code that the content read request has completed",
          "params": {
            "LocalUserNum": "The user to read the content list of",
            "ContentType": "the type of content being read",
            "ReadContentCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadSaveGameDataComplete": {
          "comment": "Adds the delegate used to notify the gameplay code that a save game read request has completed",
          "params": {
            "LocalUserNum": "The user that was reading a save game",
            "ReadSaveGameDataCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWriteSaveGameDataComplete": {
          "comment": "Adds the delegate used to notify the gameplay code that a save game write request has completed",
          "params": {
            "LocalUserNum": "The user that was writing a save game",
            "WriteSaveGameDataCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearContentChangeDelegate": {
          "comment": "Removes the delegate from the set of delegates that are notified",
          "params": {
            "Content": "Delegate the delegate to use for notifications",
            "LocalUserNum": "whether to watch for changes on a specific slot or all slots"
          }
        },
        "ClearContentList": {
          "comment": "Starts an async task that frees any downloaded content resources for that player",
          "params": {
            "LocalUserNum": "The user to clear the content list for",
            "ContentType": "the type of content being read"
          }
        },
        "ClearQueryAvailableDownloadsComplete": {
          "comment": "Clears the delegate used to notify the gameplay code that the content download query has completed",
          "params": {
            "LocalUserNum": "the user to check the content download availability for",
            "ReadContentCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadContentComplete": {
          "comment": "Clears the delegate used to notify the gameplay code that the content read request has completed",
          "params": {
            "LocalUserNum": "The user to read the content list of",
            "ContentType": "the type of content being read",
            "ReadContentCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadSaveGameDataComplete": {
          "comment": "Clears the delegate used to notify the gameplay code that a save game read request has completed",
          "params": {
            "LocalUserNum": "The user that was reading a save game",
            "ReadSaveGameDataCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearSaveGames": {
          "comment": "Clears any cached save games",
          "params": {
            "LocalUserNum": "the user that is deleting data"
          }
        },
        "ClearWriteSaveGameDataComplete": {
          "comment": "Clears the delegate used to notify the gameplay code that a save game write request has completed",
          "params": {
            "LocalUserNum": "The user that was writing a save game",
            "WriteSaveGameDataCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "DeleteSaveGame": {
          "comment": "Deletes a player's save game data",
          "params": {
            "LocalUserNum": "the user that is deleting data",
            "DeviceId": "the device to delete the same game from",
            "FriendlyName": "the friendly name of the save game that was returned by enumeration",
            "FileName": "the file name of the content package to delete"
          }
        },
        "GetAvailableDownloadCounts": {
          "comment": "Returns the number of new and total downloads available for the user",
          "params": {
            "LocalUserNum": "the user to check the content download availability for",
            "NewDownloads": "out value of the number of new downloads available",
            "TotalDownloads": "out value of the number of total downloads available"
          }
        },
        "GetContentList": {
          "comment": "Retrieve the list of content the given user has downloaded or otherwise retrieved\n to the local console.",
          "params": {
            "LocalUserNum": "The user to read the content list of",
            "ContentType": "the type of content being read",
            "ContentList": "The out array that receives the list of all content"
          }
        },
        "GetSaveGameData": {
          "comment": "Copies a player's save game data from the cached async read data",
          "params": {
            "LocalUserNum": "the user that is initiating the data read (also used in validating ownership of the data)",
            "DeviceId": "the device to read the same game from",
            "FriendlyName": "the friendly name of the save game that was returned by enumeration",
            "FileName": "the file to read from inside of the content package",
            "SaveFileName": "the file name of the save game inside the content package",
            "bIsValid": "out value indicating whether the save is corrupt or not",
            "SaveGameData": "the array that is filled with the save game data"
          }
        },
        "QueryAvailableDownloads": {
          "comment": "Asks the online system for the number of new and total content downloads",
          "params": {
            "LocalUserNum": "the user to check the content download availability for",
            "CategoryMask": "the bitmask to use to filter content by type"
          }
        },
        "ReadContentList": {
          "comment": "Starts an async task that retrieves the list of downloaded content for the player.",
          "params": {
            "LocalUserNum": "The user to read the content list of",
            "ContentType": "the type of content being read",
            "DeviceId": "optional value to restrict the enumeration to a particular device"
          }
        },
        "ReadSaveGameData": {
          "comment": "Reads a player's save game data from the specified content bundle",
          "params": {
            "LocalUserNum": "the user that is initiating the data read (also used in validating ownership of the data)",
            "DeviceId": "the device to read the same game from",
            "FriendlyName": "the friendly name of the save game that was returned by enumeration",
            "FileName": "the file to read from inside of the content package",
            "SaveFileName": "the file name of the save game inside the content package"
          }
        },
        "WriteSaveGameData": {
          "comment": "Writes a player's save game data to the specified content bundle and file",
          "params": {
            "LocalUserNum": "the user that is initiating the data write",
            "DeviceId": "the device to write the same game to",
            "FriendlyName": "the friendly name of the save game that was returned by enumeration",
            "FileName": "the file name of the content package",
            "SaveFileName": "the file name of the save game inside the content package",
            "SaveGameData": "the data to write to the save game file"
          }
        }
      }
    },
    "OnlineEventsInterface": {
      "comment": "This interface deals with capturing gameplay events for logging with an online service",
      "functions": {
        "UpdatePlaylistPopulation": {
          "comment": "Sends the network backend the playlist population for this host",
          "params": {
            "PlaylistId": "the playlist we are updating the population for",
            "NumPlayers": "the number of players on this host in this playlist"
          }
        },
        "UploadGameplayEventsData": {
          "comment": "Sends gameplay event data to MCP",
          "params": {
            "UniqueId": "the player that is sending the stats",
            "Payload": "the stats data to upload"
          }
        },
        "UploadPlayerData": {
          "comment": "Sends the profile data to the server for statistics aggregation",
          "params": {
            "UniqueId": "the unique id for the player",
            "PlayerNick": "the player's nick name",
            "ProfileSettings": "the profile object that is being sent",
            "PlayerStorage": "the player storage object that is being sent"
          }
        }
      }
    },
    "OnlineGameInterface": {
      "comment": "This interface deals with the online games. It creates, destroys, performs\n searches for online games. This interface is overloaded to provide custom\n matchmaking services",
      "functions": {
        "AcceptGameInvite": {
          "comment": "Tells the online subsystem to accept the game invite that is currently pending",
          "params": {
            "LocalUserNum": "the local user accepting the invite",
            "SessionName": "the name of the session this invite is to be known as"
          }
        },
        "AddArbitrationRegistrationCompleteDelegate": {
          "comment": "Sets the notification callback to use when arbitration registration has completed",
          "params": {
            "ArbitrationRegistrationCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddCancelFindOnlineGamesCompleteDelegate": {
          "comment": "Adds the delegate to the list to notify with",
          "params": {
            "CancelFindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddCreateOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game they\n created has completed the creation process",
          "params": {
            "CreateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddDestroyOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game they\n destroyed has completed the destruction process",
          "params": {
            "DestroyOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddEndOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game has\n transitioned to the ending state.",
          "params": {
            "EndOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFindOnlineGamesCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the search they\n kicked off has completed",
          "params": {
            "FindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddGameInviteAcceptedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code when a game invite has been accepted",
          "params": {
            "LocalUserNum": "the user to request notification for",
            "GameInviteAcceptedDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinMigratedOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the join request for a migrated session they\n kicked off has completed",
          "params": {
            "JoinMigratedOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the join request they\n kicked off has completed",
          "params": {
            "JoinOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddMigrateOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code when the session migration completes",
          "params": {
            "MigrateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddQosStatusChangedDelegate": {
          "comment": "Adds a delegate to the list of objects that want to be notified",
          "params": {
            "QosStatusChangedDelegate": "the delegate to use for notifications"
          }
        },
        "AddRecalculateSkillRatingCompleteDelegate": {
          "comment": "Adds a delegate to the list of objects that want to be notified",
          "params": {
            "RecalculateSkillRatingCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddRegisterPlayerCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the player\n registration request they submitted has completed",
          "params": {
            "RegisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddStartOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game has\n transitioned to the started state.",
          "params": {
            "StartOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddUnregisterPlayerCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the player\n unregistration request they submitted has completed",
          "params": {
            "UnregisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddUpdateOnlineGameCompleteDelegate": {
          "comment": "Adds a delegate to the list of objects that want to be notified",
          "params": {
            "UpdateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "BindPlatformSpecificSessionToSearch": {
          "comment": "Creates a search result out of the platform specific data and adds that to the specified search object",
          "params": {
            "SearchingPlayerNum": "the index of the player searching for a match",
            "SearchSettings": "the desired search to bind the session to",
            "PlatformSpecificInfo": "the platform specific information to convert to a server object"
          }
        },
        "CancelFindOnlineGames": {
          "comment": "Cancels the current search in progress if possible for that search type"
        },
        "ClearArbitrationRegistrationCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "ArbitrationRegistrationCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearCancelFindOnlineGamesCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "CancelFindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearCreateOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "CreateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearDestroyOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "DestroyOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearEndOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "EndOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFindOnlineGamesCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "FindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearGameInviteAcceptedDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "GameInviteAcceptedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinMigratedOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "JoinMigratedOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "JoinOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearMigrateOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "MigrateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearQosStatusChangedDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "QosStatusChangedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRecalculateSkillRatingCompleteDelegate": {
          "comment": "Removes a delegate from the list of objects that want to be notified",
          "params": {
            "RecalculateSkillRatingCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRegisterPlayerCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "RegisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearStartOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "StartOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearUnregisterPlayerCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "UnregisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearUpdateOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "UpdateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "CreateOnlineGame": {
          "comment": "Creates an online game based upon the settings object specified.\n NOTE: online game registration is an async process and does not complete\n until the OnCreateOnlineGameComplete delegate is called.",
          "params": {
            "HostingPlayerNum": "the index of the player hosting the match",
            "SessionName": "the name to use for this session so that multiple sessions can exist at the same time",
            "NewGameSettings": "the settings to use for the new game session"
          }
        },
        "DestroyOnlineGame": {
          "comment": "Destroys the current online game\n NOTE: online game de-registration is an async process and does not complete\n until the OnDestroyOnlineGameComplete delegate is called.",
          "params": {
            "SessionName": "the name of the session to delete"
          }
        },
        "EndOnlineGame": {
          "comment": "Marks an online game as having been ended",
          "params": {
            "SessionName": "the name of the session the to end"
          }
        },
        "FindOnlineGames": {
          "comment": "Searches for games matching the settings specified",
          "params": {
            "SearchingPlayerNum": "the index of the player searching for a match",
            "SearchSettings": "the desired settings that the returned sessions will have"
          }
        },
        "FreeSearchResults": {
          "comment": "Cleans up any platform specific allocated data contained in the search results",
          "params": {
            "Search": "the object to free search results for"
          }
        },
        "GetArbitratedPlayers": {
          "comment": "Returns the list of arbitrated players for the arbitrated session",
          "params": {
            "SessionName": "the name of the session to get the arbitration results for"
          }
        },
        "GetGameSearch": {
          "comment": "Returns the currently set game search object"
        },
        "GetGameSettings": {
          "comment": "Returns the game settings object for the session with a matching name",
          "params": {
            "SessionName": "the name of the session to return"
          }
        },
        "GetResolvedConnectString": {
          "comment": "Returns the platform specific connection information for joining the match.\n Call this function from the delegate of join completion",
          "params": {
            "SessionName": "the name of the session to fetch the connection information for",
            "ConnectInfo": "the out var containing the platform specific connection information"
          }
        },
        "JoinMigratedOnlineGame": {
          "comment": "Joins the migrated game specified",
          "params": {
            "PlayerNum": "the index of the player about to join a match",
            "SessionName": "the name of the migrated session to join",
            "DesiredGame": "the desired migrated game to join"
          }
        },
        "JoinOnlineGame": {
          "comment": "Joins the game specified",
          "params": {
            "PlayerNum": "the index of the player searching for a match",
            "SessionName": "the name of the session to join",
            "DesiredGame": "the desired game to join"
          }
        },
        "MigrateOnlineGame": {
          "comment": "Migrates an existing online game on the host.\n NOTE: online game migration is an async process and does not complete\n until the OnMigrateOnlineGameComplete delegate is called.",
          "params": {
            "HostingPlayerNum": "the index of the player now hosting the match",
            "SessionName": "the name of the existing session to migrate"
          }
        },
        "QueryNonAdvertisedData": {
          "comment": "Fetches the additional data a session exposes outside of the online service.\n NOTE: notifications will come from the OnFindOnlineGamesComplete delegate",
          "params": {
            "StartAt": "the search result index to start gathering the extra information for",
            "NumberToQuery": "the number of additional search results to get the data for"
          }
        },
        "ReadPlatformSpecificSessionInfo": {
          "comment": "Serializes the platform specific data into the provided buffer for the specified search result",
          "params": {
            "DesiredGame": "the game to copy the platform specific data for",
            "PlatformSpecificInfo": "the buffer to fill with the platform specific information"
          }
        },
        "ReadPlatformSpecificSessionInfoBySessionName": {
          "comment": "Serializes the platform specific data into the provided buffer for the specified settings object.\n NOTE: This can only be done for a session that is bound to the online system",
          "params": {
            "GameSettings": "the game to copy the platform specific data for",
            "PlatformSpecificInfo": "the buffer to fill with the platform specific information"
          }
        },
        "RecalculateSkillRating": {
          "comment": "Updates the current session's skill rating using the list of players' skills",
          "params": {
            "SessionName": "the name of the session to update the skill rating for",
            "Players": "the set of players to use in the skill calculation"
          }
        },
        "RegisterForArbitration": {
          "comment": "Tells the game to register with the underlying arbitration server if available",
          "params": {
            "SessionName": "the name of the session to register for arbitration with"
          }
        },
        "RegisterPlayer": {
          "comment": "Registers a player with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "UniquePlayerId": "the player to register with the online service",
            "bWasInvited": "whether the player was invited to the game or searched for it"
          }
        },
        "RegisterPlayers": {
          "comment": "Registers a group of players with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "Players": "the list of players to register with the online service"
          }
        },
        "StartOnlineGame": {
          "comment": "Marks an online game as in progress (as opposed to being in lobby or pending)",
          "params": {
            "SessionName": "the name of the session that is being started"
          }
        },
        "UnregisterPlayer": {
          "comment": "Unregisters a player with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is leaving",
            "PlayerId": "the player to unregister with the online service"
          }
        },
        "UnregisterPlayers": {
          "comment": "Unregisters a group of players with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "Players": "the list of players to unregister with the online service"
          }
        },
        "UpdateOnlineGame": {
          "comment": "Updates the localized settings/properties for the game in question",
          "params": {
            "SessionName": "the name of the session to update",
            "UpdatedGameSettings": "the object to update the game settings with",
            "bShouldRefreshOnlineData": "whether to submit the data to the backend or not"
          }
        }
      }
    },
    "OnlineGameSearch": {
      "comment": "Holds the base settings for an online game search",
      "properties": {
        "AdditionalSearchCriteria": {
          "comment": "String that is tacked onto the end of the search query (GameSpy only)"
        },
        "bIsLanQuery": {
          "comment": "Whether the query is intended for LAN matches or not"
        },
        "bIsSearchInProgress": {
          "comment": "Whether the search object in question is in progress or not. This is the union of the other flags"
        },
        "bUsesArbitration": {
          "comment": "Whether to use arbitration or not"
        },
        "FilterQuery": {
          "comment": "Holds the query to use when filtering servers and they require non-predefined queries"
        },
        "GameSettingsClass": {
          "comment": "The class to create for each returned result from the search"
        },
        "ManualSkillOverride": {
          "comment": "Instance of the above to manually specify the players involved in the skill search"
        },
        "MaxPingBytes": {
          "comment": "The max amount of data to use when pinging"
        },
        "MaxSearchResults": {
          "comment": "Max number of queries returned by the matchmaking service"
        },
        "NamedProperties": {
          "comment": "The list of named properties to search on"
        },
        "NumPingProbes": {
          "comment": "The number of probes used to determine ping"
        },
        "PingBucketSize": {
          "comment": "Used to sort games into buckets since a the difference in terms of feel for ping\n in the same bucket is often not a useful comparison and skill is better"
        },
        "Query": {
          "comment": "The query to use for finding matching servers"
        },
        "Results": {
          "comment": "The list of servers and their settings that match the search"
        }
      },
      "functions": {
        "SetSkillOverride": {
          "comment": "Sets the information needed to do a manual specification of the skill to use when searching",
          "params": {
            "LeaderboardId": "the skill leaderboard to read from",
            "Players": "the set of players to use when determining the skill"
          }
        },
        "SortSearchResults": {
          "comment": "Allows a search object to provide a customized sort routine to order the results in\n a way that best fits the game type"
        }
      },
      "structs": {
        "NamedObjectProperty": {
          "comment": "Used to search for named properties on game setting objects",
          "properties": {
            "ObjectPropertyName": {
              "comment": "The name of the property to search with"
            },
            "ObjectPropertyValue": {
              "comment": "The string value to compare against"
            }
          }
        },
        "OnlineGameSearchORClause": {
          "comment": "Matches parameters using a series of OR comparisons",
          "properties": {
            "OrParams": {
              "comment": "The list of parameters to compare and use as an OR clause"
            }
          }
        },
        "OnlineGameSearchParameter": {
          "comment": "Struct used to describe a search criteria",
          "properties": {
            "ComparisonType": {
              "comment": "The type of comparison to perform"
            },
            "EntryId": {
              "comment": "The Id of the property or localized string"
            },
            "EntryType": {
              "comment": "Whether this parameter to compare against comes from a property or a localized setting"
            },
            "ObjectPropertyName": {
              "comment": "The name of the property to search with"
            }
          }
        },
        "OnlineGameSearchQuery": {
          "comment": "Struct used to describe a query",
          "properties": {
            "OrClauses": {
              "comment": "A set of OR clauses that are ANDed together to filter potential servers"
            },
            "SortClauses": {
              "comment": "A list of sort operations used to order the servers that match the filtering"
            }
          }
        },
        "OnlineGameSearchResult": {
          "comment": "Struct used to return matching servers",
          "properties": {
            "GameSettings": {
              "comment": "The settings used by this particular server"
            },
            "PlatformData": {
              "comment": "Platform/online provider specific data\n NOTE: It is imperative that the subsystem be called to clean this data\n up or the PlatformData will leak memory!"
            }
          }
        },
        "OnlineGameSearchSortClause": {
          "comment": "Struct used to describe the sorting of items",
          "properties": {
            "EntryId": {
              "comment": "The Id of the property or localized string"
            },
            "EntryType": {
              "comment": "Whether this parameter to compare against comes from a property or a localized setting"
            },
            "ObjectPropertyName": {
              "comment": "The name of the property to search with"
            },
            "SortType": {
              "comment": "The type of comparison to perform"
            }
          }
        },
        "OverrideSkill": {
          "comment": "Used to manually specify the skill to use when matchmaking",
          "properties": {
            "LeaderboardId": {
              "comment": "The skill leaderboard to read the player skill from"
            },
            "Mus": {
              "comment": "The set of skill values to use"
            },
            "Players": {
              "comment": "The set of players to read the skill for"
            }
          }
        }
      }
    },
    "OnlineGameSettings": {
      "comment": "Holds the base configuration settings for an online game",
      "properties": {
        "bAllowInvites": {
          "comment": "Whether the match allows invitations for this session or not"
        },
        "bAllowJoinInProgress": {
          "comment": "Whether joining in progress is allowed or not"
        },
        "bAllowJoinViaPresence": {
          "comment": "Whether joining via player presence is allowed or not"
        },
        "bAllowJoinViaPresenceFriendsOnly": {
          "comment": "Whether joining via player presence is allowed for friends only or not"
        },
        "bAntiCheatProtected": {
          "comment": "Whether the server employs anti-cheat (punkbuster, vac, etc)"
        },
        "bHasSkillUpdateInProgress": {
          "comment": "Whether there is a skill update in progress or not (don't do multiple at once)"
        },
        "bIsDedicated": {
          "comment": "Whether this server is a dedicated server or not"
        },
        "bIsLanMatch": {
          "comment": "This game will be lan only and not be visible to external players"
        },
        "bShouldAdvertise": {
          "comment": "Whether this match is publicly advertised on the online service"
        },
        "bShouldShrinkArbitratedSessions": {
          "comment": "Whether to shrink the session slots when a player leaves the match or not"
        },
        "BuildUniqueId": {
          "comment": "Used to keep different builds from seeing each other during searches"
        },
        "bUsesArbitration": {
          "comment": "Whether the session should use arbitration or not"
        },
        "bUsesPresence": {
          "comment": "Whether to display user presence information or not"
        },
        "bUsesStats": {
          "comment": "Whether the match should gather stats or not"
        },
        "bWasFromInvite": {
          "comment": "Whether the game is an invitation or searched for game"
        },
        "GameState": {
          "comment": "The current state of the online game"
        },
        "MatchQuality": {
          "comment": "Represents how good a match this is in a range from 0 to 1"
        },
        "NumOpenPrivateConnections": {
          "comment": "The number of private connections that are available (read only)"
        },
        "NumOpenPublicConnections": {
          "comment": "The number of publicly available connections that are available (read only)"
        },
        "NumPrivateConnections": {
          "comment": "The number of connections that are private (invite/password) only"
        },
        "NumPublicConnections": {
          "comment": "The number of publicly available connections advertised"
        },
        "OwningPlayerId": {
          "comment": "The unique net id of the player that owns this game"
        },
        "OwningPlayerName": {
          "comment": "The owner of the game"
        },
        "PingInMs": {
          "comment": "The ping of the server in milliseconds (-1 means the server was unreachable)"
        },
        "ServerNonce": {
          "comment": "The server's nonce for this session"
        }
      }
    },
    "OnlineMatchmakingStats": {
      "comment": "Holds the matchmaking stats when searching for sessions. \n These can be converted to XML and uploaded to MCP."
    },
    "OnlineNewsInterface": {
      "comment": "This interface provides functions for reading game specific news and announcements",
      "functions": {
        "AddReadNewsCompletedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that news reading has completed",
          "params": {
            "ReadNewsDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadNewsCompletedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "ReadNewsDelegate": "the delegate to use for notifications"
          }
        },
        "GetNews": {
          "comment": "Returns the game specific news from the cache",
          "params": {
            "LocalUserNum": "the local user the news is being read for",
            "NewsType": "the type of news to read"
          }
        },
        "ReadNews": {
          "comment": "Reads the game specific news from the online subsystem",
          "params": {
            "LocalUserNum": "the local user the news is being read for",
            "NewsType": "the type of news to read"
          }
        }
      }
    },
    "OnlinePartyChatInterface": {
      "comment": "This interface provides extended player functionality not supported by\n all platforms. The OnlineSubsystem will return NULL when requesting this\n interface on a platform where it is not supporeted.",
      "functions": {
        "AddPartyMemberListChangedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that async task has completed",
          "params": {
            "LocalUserNum": "the user to listening for party chat notifications",
            "PartyMemberListChangedDelegate": "the delegate to use for notifications"
          }
        },
        "AddPartyMembersInfoChangedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that async task has completed",
          "params": {
            "LocalUserNum": "the user to listening for party chat notifications",
            "PartyMembersInfoChangedDelegate": "the delegate to use for notifications"
          }
        },
        "AddSendPartyGameInvitesCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that async task has completed",
          "params": {
            "LocalUserNum": "the user to sending the invites",
            "SendPartyGameInvitesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearPartyMemberListChangedDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that async task has completed",
          "params": {
            "LocalUserNum": "the user to listening for party chat notifications",
            "PartyMemberListChangedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearPartyMembersInfoChangedDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that async task has completed",
          "params": {
            "LocalUserNum": "the user to listening for party chat notifications",
            "PartyMembersInfoChangedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearSendPartyGameInvitesCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that async task has completed",
          "params": {
            "LocalUserNum": "the user to sending the invites",
            "SendPartyGameInvitesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "GetPartyBandwidth": {
          "comment": "Determines the amount of data that has been sent in the last second"
        },
        "GetPartyMemberInformation": {
          "comment": "Gets the individual party member's information from the platform, including the application specific data",
          "params": {
            "MemberId": "the id of the party member to lookup",
            "PartyMember": "out value where the data is copied to"
          }
        },
        "GetPartyMembersInformation": {
          "comment": "Gets the party member information from the platform, including the application specific data",
          "params": {
            "PartyMembers": "the array to be filled out of party member information"
          }
        },
        "IsInPartyChat": {
          "comment": "Checks for the specified player being in a party chat",
          "params": {
            "LocalUserNum": "the user that you are setting the data for"
          }
        },
        "SendPartyGameInvites": {
          "comment": "Sends an invite to everyone in the existing party session",
          "params": {
            "LocalUserNum": "the user to sending the invites"
          }
        },
        "SetPartyMemberCustomData": {
          "comment": "Sets a party member's application specific data",
          "params": {
            "LocalUserNum": "the user that you are setting the data for",
            "Data1": "the first 4 bytes of custom data",
            "Data2": "the second 4 bytes of custom data",
            "Data3": "the third 4 bytes of custom data",
            "Data4": "the fourth 4 bytes of custom data"
          }
        },
        "ShowCommunitySessionsUI": {
          "comment": "Opens the community sessions UI for the user",
          "params": {
            "LocalUserNum": "the user requesting the UI"
          }
        },
        "ShowPartyUI": {
          "comment": "Opens the party UI for the user",
          "params": {
            "LocalUserNum": "the user requesting the UI"
          }
        },
        "ShowVoiceChannelUI": {
          "comment": "Opens the voice channel UI for the user",
          "params": {
            "LocalUserNum": "the user requesting the UI"
          }
        }
      }
    },
    "OnlinePlayerInterface": {
      "comment": "This interface provides accessors to the platform specific player methods.\n NOTE: All players are referenced by their controller number, which is\n zero on the PC.",
      "functions": {
        "AcceptFriendInvite": {
          "comment": "Used to accept a friend invite sent to this player",
          "params": {
            "LocalUserNum": "the user the invite is for",
            "RequestingPlayer": "the player the invite is from",
            "true": "if successful, false otherwise"
          }
        },
        "AddAddFriendByNameCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "FriendDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriend": {
          "comment": "Sends a friend invite to the specified player",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "NewFriend": "the player to send the friend request to",
            "Message": "the message to display to the recipient"
          }
        },
        "AddFriendByName": {
          "comment": "Sends a friend invite to the specified player nick",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "FriendName": "the name of the player to send the invite to",
            "Message": "the message to display to the recipient"
          }
        },
        "AddFriendInviteReceivedDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "InviteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriendMessageReceivedDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "MessageDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriendsChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a friends list changed",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinFriendGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify when the join friend is complete",
          "params": {
            "JoinFriendGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddKeyboardInputDoneDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has completed\n their keyboard input",
          "params": {
            "InputDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginCancelledDelegate": {
          "comment": "Adds a delegate to the list of delegates that are fired when a login is cancelled",
          "params": {
            "CancelledDelegate": "the delegate to add to the list"
          }
        },
        "AddLoginChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login changed",
          "params": {
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginFailedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login failed",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginStatusChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login status has changed",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "the player to watch login status changes for"
          }
        },
        "AddLogoutCompletedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a logout completed",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LogoutDelegate": "the delegate to use for notifications"
          }
        },
        "AddMutingChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a muting list changed",
          "params": {
            "MutingDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadAchievementsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to read the achievements list for",
            "ReadAchievementsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadFriendsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the friends read request has completed",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "ReadFriendsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadPlayerStorageCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadPlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadPlayerStorageForNetIdCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "NetId": "the net id for the user to watch for read complete notifications",
            "ReadPlayerStorageForNetIdCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadProfileSettingsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReceivedGameInviteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a game invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "ReceivedGameInviteDelegate": "the delegate to use for notifications"
          }
        },
        "AddUnlockAchievementCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the achievement unlocking has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "UnlockAchievementCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWritePlayerStorageCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WritePlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWriteProfileSettingsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WriteProfileSettingsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AreAnyFriends": {
          "comment": "Checks that whether a group of player ids are among the specified player's\n friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Query": "an array of players to check for being included on the friends list"
          }
        },
        "CanCommunicate": {
          "comment": "Determines whether the player is allowed to use voice or text chat online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanDownloadUserContent": {
          "comment": "Determines whether the player is allowed to download user created content",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanPlayOnline": {
          "comment": "Determines whether the player is allowed to play online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanPurchaseContent": {
          "comment": "Determines whether the player is allowed to buy content online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanShowPresenceInformation": {
          "comment": "Determines whether the player is allowed to have their online presence\n information shown to remote clients",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanViewPlayerProfiles": {
          "comment": "Determines whether the player is allowed to view other people's player profile",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ClearAddFriendByNameCompleteDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "FriendDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendInviteReceivedDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "InviteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendMessageReceivedDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "MessageDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendsChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a friends list changed",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinFriendGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "JoinFriendGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearKeyboardInputDoneDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the user has completed\n their keyboard input",
          "params": {
            "InputDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLoginCancelledDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "CancelledDelegate": "the delegate to remove fromt he list"
          }
        },
        "ClearLoginChangeDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLoginFailedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLoginStatusChangeDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "the player to watch login status changes for"
          }
        },
        "ClearLogoutCompletedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LogoutDelegate": "the delegate to use for notifications"
          }
        },
        "ClearMutingChangeDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that a muting list changed",
          "params": {
            "MutingDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadAchievementsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to read the achievements list for",
            "ReadAchievementsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadFriendsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the friends read request has completed",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "ReadFriendsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadPlayerStorageCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadPlayerStorageCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadPlayerStorageForNetIdCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "NetId": "the net id for the user to watch for read complete notifications",
            "ReadPlayerStorageForNetIdCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadProfileSettingsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReceivedGameInviteDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "ReceivedGameInviteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearUnlockAchievementCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the achievement unlocking has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "UnlockAchievementCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearWritePlayerStorageCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WritePlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearWriteProfileSettingsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WriteProfileSettingsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "DeleteMessage": {
          "comment": "Deletes a message from the list of messages",
          "params": {
            "LocalUserNum": "the user that is deleting the message",
            "MessageIndex": "the index of the message to delete"
          }
        },
        "DenyFriendInvite": {
          "comment": "Used to deny a friend request sent to this player",
          "params": {
            "LocalUserNum": "the user the invite is for",
            "RequestingPlayer": "the player the invite is from",
            "true": "if successful, false otherwise"
          }
        },
        "GetAchievements": {
          "comment": "Copies the list of achievements for the specified player and title id",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Achievements": "the out array that receives the copied data",
            "TitleId": "the title id of the game that these were read for"
          }
        },
        "GetFriendMessages": {
          "comment": "Returns the list of messages for the specified player",
          "params": {
            "LocalUserNum": "the local player wanting to join",
            "FriendMessages": "the set of messages cached locally for the player"
          }
        },
        "GetFriendsList": {
          "comment": "Copies the list of friends for the player previously retrieved from the online\n service. The list can be retrieved in whole or in part.",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Friends": "the out array that receives the copied data",
            "Count": "the number of friends to read or zero for all",
            "StartingAt": "the index of the friends list to start at (for pulling partial lists)"
          }
        },
        "GetKeyboardInputResults": {
          "comment": "Fetches the results of the input",
          "params": {
            "bWasCanceled": "whether the user cancelled the input or not"
          }
        },
        "GetLoginStatus": {
          "comment": "Fetches the login status for a given player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "GetPlayerNickname": {
          "comment": "Reads the player's nick name from the online service",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "GetPlayerStorage": {
          "comment": "Returns the online player storage for a given local user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for"
          }
        },
        "GetProfileSettings": {
          "comment": "Returns the online profile settings for a given user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for"
          }
        },
        "GetUniquePlayerId": {
          "comment": "Gets the platform specific unique id for the specified player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the byte array that will receive the id"
          }
        },
        "IsFriend": {
          "comment": "Checks that a unique player id is part of the specified user's friends list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being checked"
          }
        },
        "IsGuestLogin": {
          "comment": "Determines whether the specified user is a guest login or not",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "IsLocalLogin": {
          "comment": "Determines whether the specified user is a local (non-online) login or not",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "IsMuted": {
          "comment": "Checks that a unique player id is on the specified user's mute list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being checked"
          }
        },
        "JoinFriendGame": {
          "comment": "Allows the local player to follow a friend into a game",
          "params": {
            "LocalUserNum": "the local player wanting to join",
            "Friend": "the player that is being followed"
          }
        },
        "Login": {
          "comment": "Logs the player into the online service. If this fails, it generates a\n OnLoginFailed notification",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginName": "the unique identifier for the player",
            "Password": "the password for this account",
            "bWantsLocalOnly": "whether the player wants to sign in locally only or not"
          }
        },
        "Logout": {
          "comment": "Signs the player out of the online service",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ReadAchievements": {
          "comment": "Starts an async read for the achievement list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "TitleId": "the title id of the game the achievements are to be read for",
            "bShouldReadText": "whether to fetch the text strings or not",
            "bShouldReadImages": "whether to fetch the image data or not"
          }
        },
        "ReadFriendsList": {
          "comment": "Starts an async task that retrieves the list of friends for the player from the\n online service. The list can be retrieved in whole or in part.",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Count": "the number of friends to read or zero for all",
            "StartingAt": "the index of the friends list to start at (for pulling partial lists)"
          }
        },
        "ReadPlayerStorage": {
          "comment": "Reads the online player storage data for a given local user\n If a valid storage device ID is specified then data is also read from that device and the newer version is kept.",
          "params": {
            "LocalUserNum": "the user that we are reading the data for",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read",
            "DeviceId": "optional ID for connected device to read from. -1 for no device"
          }
        },
        "ReadPlayerStorageForNetId": {
          "comment": "Reads the online player storage data for a given net user",
          "params": {
            "LocalUserNum": "the local user that is initiating the read",
            "NetId": "the net user that we are reading the data for",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read"
          }
        },
        "ReadProfileSettings": {
          "comment": "Reads the online profile settings for a given user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for",
            "ProfileSettings": "the object to copy the results to and contains the list of items to read"
          }
        },
        "RemoveFriend": {
          "comment": "Removes a friend from the player's friend list",
          "params": {
            "LocalUserNum": "the user that is removing the friend",
            "FormerFriend": "the player to remove from the friend list"
          }
        },
        "SendGameInviteToFriend": {
          "comment": "Sends an invitation to play in the player's current session",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "Friend": "the player to send the invite to",
            "Text": "the text of the message for the invite"
          }
        },
        "SendGameInviteToFriends": {
          "comment": "Sends invitations to play in the player's current session",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "Friends": "the player to send the invite to",
            "Text": "the text of the message for the invite"
          }
        },
        "SendMessageToFriend": {
          "comment": "Sends a message to a friend",
          "params": {
            "LocalUserNum": "the user that is sending the message",
            "Friend": "the player to send the message to",
            "Message": "the message to display to the recipient"
          }
        },
        "SetOnlineStatus": {
          "comment": "Sets the online status information to use for the specified player. Used to\n tell other players what the player is doing (playing, menus, away, etc.)",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "StatusId": "the status id to use (maps to strings where possible)",
            "LocalizedStringSettings": "the list of localized string settings to set",
            "Properties": "the list of properties to set"
          }
        },
        "ShowFriendsUI": {
          "comment": "Displays the UI that shows a user's list of friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowKeyboardUI": {
          "comment": "Displays the UI that shows the keyboard for inputing text",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "TitleText": "the title to display to the user",
            "DescriptionText": "the text telling the user what to input",
            "bIsPassword": "whether the item being entered is a password or not",
            "bShouldValidate": "whether to apply the string validation API after input or not",
            "DefaultText": "the default string to display",
            "MaxResultLength": "the maximum length string expected to be filled in"
          }
        },
        "ShowLoginUI": {
          "comment": "Displays the UI that prompts the user for their login credentials. Each\n platform handles the authentication of the user's data.",
          "params": {
            "bShowOnlineOnly": "whether to only display online enabled profiles or not"
          }
        },
        "UnlockAchievement": {
          "comment": "Unlocks the specified achievement for the specified user",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "AchievementId": "the id of the achievement to unlock"
          }
        },
        "WritePlayerStorage": {
          "comment": "Writes the online player storage data for a given local user to the online data store\n If a valid storage device ID is specified then data is also written to that device.",
          "params": {
            "LocalUserNum": "the user that we are writing the data for",
            "PlayerStorage": "the object that contains the list of items to write",
            "DeviceId": "optional ID for connected device to write to. -1 for no device"
          }
        },
        "WriteProfileSettings": {
          "comment": "Writes the online profile settings for a given user to the online data store",
          "params": {
            "LocalUserNum": "the user that we are writing the data for",
            "ProfileSettings": "the list of settings to write out"
          }
        }
      }
    },
    "OnlinePlayerInterfaceEx": {
      "comment": "This interface provides extended player functionality not supported by\n all platforms. The OnlineSubsystem will return NULL when requesting this\n interface on a platform where it is not supporeted.",
      "functions": {
        "AddDeviceSelectionDoneDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has completed\n their device selection",
          "params": {
            "DeviceDelegate": "the delegate to use for notifications"
          }
        },
        "AddProfileDataChangedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that someone has changed their profile data externally",
          "params": {
            "LocalUserNum": "the user the delegate is interested in",
            "ProfileDataChangedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearDeviceSelectionDoneDelegate": {
          "comment": "Removes the specified delegate from the list of callbacks",
          "params": {
            "DeviceDelegate": "the delegate to use for notifications"
          }
        },
        "ClearProfileDataChangedDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that someone has changed their profile data externally",
          "params": {
            "LocalUserNum": "the user the delegate is interested in",
            "ProfileDataChangedDelegate": "the delegate to use for notifications"
          }
        },
        "GetDeviceSelectionResults": {
          "comment": "Fetches the results of the device selection",
          "params": {
            "LocalUserNum": "the player to check the results for",
            "DeviceName": "out param that gets a copy of the string"
          }
        },
        "IsDeviceValid": {
          "comment": "Checks the device id to determine if it is still valid (could be removed) and/or\n if there is enough space on the specified device",
          "params": {
            "DeviceId": "the device to check",
            "SizeNeeded": "the amount of space requested"
          }
        },
        "ShowAchievementsUI": {
          "comment": "Displays the achievements UI for a player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowContentMarketplaceUI": {
          "comment": "Displays the marketplace UI for content",
          "params": {
            "LocalUserNum": "the local user viewing available content",
            "CategoryMask": "the bitmask to use to filter content by type",
            "OfferId": "a specific offer that you want shown"
          }
        },
        "ShowCustomPlayersUI": {
          "comment": "Shows a custom players UI for the specified list of players",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Players": "the list of players to show in the custom UI",
            "Title": "the title to use for the UI",
            "Description": "the text to show at the top of the UI"
          }
        },
        "ShowDeviceSelectionUI": {
          "comment": "Displays the UI that allows the user to choose which device to save content to",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "SizeNeeded": "the size of the data to be saved in bytes",
            "bManageStorage": "whether to allow the user to manage their storage or not"
          }
        },
        "ShowFeedbackUI": {
          "comment": "Displays the UI that allows a player to give feedback on another player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player having feedback given for"
          }
        },
        "ShowFriendsInviteUI": {
          "comment": "Displays the UI that shows a user's list of friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being invited"
          }
        },
        "ShowGamerCardUI": {
          "comment": "Displays the gamer card UI for the specified player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player to show the gamer card of"
          }
        },
        "ShowInviteUI": {
          "comment": "Displays the invite ui",
          "params": {
            "LocalUserNum": "the local user sending the invite",
            "InviteText": "the string to prefill the UI with"
          }
        },
        "ShowMembershipMarketplaceUI": {
          "comment": "Displays the marketplace UI for memberships",
          "params": {
            "LocalUserNum": "the local user viewing available memberships"
          }
        },
        "ShowMessagesUI": {
          "comment": "Displays the messages UI for a player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowPlayersUI": {
          "comment": "Displays the UI that shows the player list",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "UnlockAvatarAward": {
          "comment": "Unlocks an avatar award for the local user",
          "params": {
            "LocalUserNum": "the user to unlock the avatar item for",
            "AvatarItemId": "the id of the avatar item to unlock"
          }
        },
        "UnlockGamerPicture": {
          "comment": "Unlocks a gamer picture for the local user",
          "params": {
            "LocalUserNum": "the user to unlock the picture for",
            "PictureId": "the id of the picture to unlock"
          }
        }
      }
    },
    "OnlinePlayerStorage": {
      "comment": "This class holds the data used in reading/writing online player data.\n The online player data is stored by an external service.",
      "properties": {
        "AsyncState": {
          "comment": "Indicates the state of the profile (whether an async action is happening and what type)"
        },
        "DeviceId": {
          "comment": "The device id this data is stored to if applicable"
        },
        "ProfileMappings": {
          "comment": "Holds the set of mappings from native format to human readable format"
        },
        "ProfileSettings": {
          "comment": "Current set of player data that is either returned from a read or to be written out"
        },
        "SaveCountSettingId": {
          "comment": "id for profile setting that contains the save count"
        },
        "VersionNumber": {
          "comment": "Used to determine if the read online player data is the proper version or not"
        },
        "VersionSettingsId": {
          "comment": "id for profile setting that contains the version #"
        }
      },
      "functions": {
        "AddSettingFloat": {
          "comment": "Adds an id to the array, assuming that it doesn't already exist",
          "params": {
            "SettingId": "the id to add to the array"
          }
        },
        "AddSettingInt": {
          "comment": "Adds an id to the array, assuming that it doesn't already exist",
          "params": {
            "SettingId": "the id to add to the array"
          }
        },
        "AppendVersionToSettings": {
          "comment": "Adds the version number to the read data if not present"
        },
        "FindDefaultProfileMappingIndexByName": {
          "comment": "Finds the default index of SettingsPropertyPropertyMetaData struct, given its settings name.",
          "params": {
            "ProfileSettingId": "the id of the struct to search for"
          }
        },
        "FindProfileMappingIndex": {
          "comment": "Finds the index of SettingsPropertyPropertyMetaData struct, given its settings id.",
          "params": {
            "ProfileSettingId": "the id of the struct to search for"
          }
        },
        "FindProfileMappingIndexByName": {
          "comment": "Finds the index of SettingsPropertyPropertyMetaData struct, given its settings name.",
          "params": {
            "ProfileSettingId": "the id of the struct to search for"
          }
        },
        "FindProfileSettingIndex": {
          "comment": "Finds the index of an OnlineProfileSetting struct given its settings id.",
          "params": {
            "ProfileSettingId": "the id of the struct to search for"
          }
        },
        "GetProfileSettingColumnHeader": {
          "comment": "Finds the localized column header text for the profile setting",
          "params": {
            "ProfileSettingId": "the id to look up in the mappings table"
          }
        },
        "GetProfileSettingId": {
          "comment": "Searches the profile setting array for the matching string setting name and returns the id",
          "params": {
            "ProfileSettingName": "the name of the profile setting being searched for",
            "ProfileSettingId": "the id of the context that matches the name"
          }
        },
        "GetProfileSettingMappingIds": {
          "comment": "Get the list of Ids this profile setting maps to",
          "params": {
            "ProfileId": "the ID to get the mapping type for",
            "Ids": "the list of IDs that are in this mapping"
          }
        },
        "GetProfileSettingMappingType": {
          "comment": "Determines the mapping type for the specified property",
          "params": {
            "ProfileId": "the ID to get the mapping type for",
            "OutType": "the out var the value is placed in"
          }
        },
        "GetProfileSettingName": {
          "comment": "Finds the human readable name for the profile setting",
          "params": {
            "ProfileSettingId": "the id to look up in the mappings table"
          }
        },
        "GetProfileSettingRange": {
          "comment": "Determines the min and max values of a property that is clamped to a range",
          "params": {
            "ProfileId": "the ID to get the mapping type for",
            "OutMinValue": "the out var the min value is placed in",
            "OutMaxValue": "the out var the max value is placed in",
            "RangeIncrement": "the amount the range can be adjusted by the UI in any single update",
            "bFormatAsInt": "whether the range's value should be treated as an int."
          }
        },
        "GetProfileSettingValue": {
          "comment": "Finds the human readable name for a profile setting's value. Searches the\n profile settings mappings for the specifc profile setting and then searches\n the set of values for the specific value index and returns that value's\n human readable name",
          "params": {
            "ProfileSettingId": "the id to look up in the mappings table",
            "Value": "the out param that gets the value copied to it",
            "ValueMapID": "optional parameter that allows you to select a specific index in the ValueMappings instead\n of automatically using the currently set index (if -1 is passed in, which is the default, it means to just\n use the set index"
          }
        },
        "GetProfileSettingValueByName": {
          "comment": "Finds the human readable name for a profile setting's value. Searches the\n profile settings mappings for the specifc profile setting and then searches\n the set of values for the specific value index and returns that value's\n human readable name",
          "params": {
            "ProfileSettingName": "the name of the profile setting to find the string value of",
            "Value": "the out param that gets the value copied to it"
          }
        },
        "GetProfileSettingValueFloat": {
          "comment": "Searches for the profile setting by id and gets the value index",
          "params": {
            "ProfileSettingId": "the id of the profile setting to return",
            "Value": "the out value of the setting"
          }
        },
        "GetProfileSettingValueFromListIndex": {
          "comment": "Maps a list index into a value mappings array to the actual value that should be stored in the profile",
          "params": {
            "ProfileSettingId": "The ID of the profile setting to use for index to value conversion",
            "ListIndex": "The index into the value options array to convert",
            "Value": "The out param that will contain the value to save in the profile"
          }
        },
        "GetProfileSettingValueId": {
          "comment": "Searches for the profile setting by id and gets the value index",
          "params": {
            "ProfileSettingId": "the id of the profile setting to return",
            "ValueId": "the out value of the id",
            "ListIndex": "the out value of the index where that value lies in the ValueMappings list"
          }
        },
        "GetProfileSettingValueInt": {
          "comment": "Searches for the profile setting by id and gets the value index",
          "params": {
            "ProfileSettingId": "the id of the profile setting to return",
            "Value": "the out value of the setting"
          }
        },
        "GetProfileSettingValueName": {
          "comment": "Finds the human readable name for a profile setting's value. Searches the\n profile settings mappings for the specifc profile setting and then searches\n the set of values for the specific value index and returns that value's\n human readable name",
          "params": {
            "ProfileSettingId": "the id to look up in the mappings table"
          }
        },
        "GetProfileSettingValues": {
          "comment": "Searches the profile settings mappings for the specifc profile setting and\n then adds all of the possible values to the out parameter",
          "params": {
            "ProfileSettingId": "the id to look up in the mappings table",
            "Values": "the out param that gets the list of values copied to it"
          }
        },
        "GetRangedProfileSettingValue": {
          "comment": "Gets the value of a ranged property",
          "params": {
            "ProfileId": "the ID to get the value of",
            "OutValue": "the out var that receives the value"
          }
        },
        "GetVersionNumber": {
          "comment": "Returns the version number that was found in the profile read results"
        },
        "IsProfileSettingIdMapped": {
          "comment": "Determines if the setting is id mapped or not",
          "params": {
            "ProfileSettingId": "the id to look up in the mappings table"
          }
        },
        "SetDefaultVersionNumber": {
          "comment": "Sets the version number to the class default"
        },
        "SetProfileSettingValue": {
          "comment": "Searches for the profile setting by name and sets the value index to the\n value contained in the profile setting meta data",
          "params": {
            "ProfileSettingName": "the name of the profile setting to set the string value of",
            "NewValue": "the string value to use"
          }
        },
        "SetProfileSettingValueByName": {
          "comment": "Searches for the profile setting by name and sets the value index to the\n value contained in the profile setting meta data",
          "params": {
            "ProfileSettingName": "the name of the profile setting to find",
            "NewValue": "the string value to use"
          }
        },
        "SetProfileSettingValueFloat": {
          "comment": "Searches for the profile setting by id and sets the value",
          "params": {
            "ProfileSettingId": "the id of the profile setting to return",
            "Value": "the new value"
          }
        },
        "SetProfileSettingValueId": {
          "comment": "Searches for the profile setting by id and sets the value",
          "params": {
            "ProfileSettingId": "the id of the profile setting to return",
            "Value": "the new value"
          }
        },
        "SetProfileSettingValueInt": {
          "comment": "Searches for the profile setting by id and sets the value",
          "params": {
            "ProfileSettingId": "the id of the profile setting to return",
            "Value": "the new value"
          }
        },
        "SetRangedProfileSettingValue": {
          "comment": "Sets the value of a ranged property, clamping to the min/max values",
          "params": {
            "ProfileId": "the ID of the property to set",
            "NewValue": "the new value to apply to the"
          }
        },
        "SetToDefaults": {
          "comment": "Clear out the settings. Subclasses can override to set their own defaults."
        }
      },
      "structs": {
        "OnlineProfileSetting": {
          "comment": "Structure used to hold the information for a given profile setting",
          "properties": {
            "Owner": {
              "comment": "Which party owns the data (online service vs game)"
            },
            "ProfileSetting": {
              "comment": "The profile setting comprised of unique id and union of held types"
            }
          }
        }
      }
    },
    "OnlinePlaylistGameTypeProvider": {
      "comment": "Per object config provider that exposes dynamic playlists to the UI system",
      "properties": {
        "Description": {
          "comment": "Localized description for the gamemode"
        },
        "DisplayName": {
          "comment": "Localized name for the gamemode"
        },
        "GameTypeId": {
          "comment": "Unique identifier for this game type"
        },
        "PlaylistGameTypeName": {
          "comment": "Unique name identifier for this PlayerlistGameType"
        }
      }
    },
    "OnlineProfileSettings": {
      "comment": "This class holds the data used in reading/writing online profile settings.\n Online profile settings are stored by an external service.",
      "properties": {
        "DefaultSettings": {
          "comment": "These are the settings to use when no setting has been specified yet for\n a given id. These values should be used by subclasses to fill in per game\n default settings"
        },
        "OwnerMappings": {
          "comment": "Mappings for owner information"
        },
        "ProfileSettingIds": {
          "comment": "Holds the list of profile settings to read from the service.\n NOTE: Only used for a read request and populated by the subclass"
        }
      },
      "functions": {
        "AppendVersionToReadIds": {
          "comment": "Adds the version id to the read ids if it is not present"
        },
        "GetProfileSettingDefaultFloat": {
          "comment": "Searches for the profile setting by id and gets the default value float",
          "params": {
            "ProfileSettingId": "the id of the profile setting to return the default of",
            "Value": "the out value of the default setting"
          }
        },
        "GetProfileSettingDefaultId": {
          "comment": "Searches for the profile setting by id and gets the default value index",
          "params": {
            "ProfileSettingId": "the id of the profile setting to return",
            "DefaultId": "the out value of the default id",
            "ListIndex": "the out value of the index where that value lies in the ValueMappings list"
          }
        },
        "GetProfileSettingDefaultInt": {
          "comment": "Searches for the profile setting by id and gets the default value int",
          "params": {
            "ProfileSettingId": "the id of the profile setting to return the default of",
            "Value": "the out value of the default setting"
          }
        },
        "ModifyAvailableProfileSettings": {
          "comment": "Hooks to allow child classes to dynamically adjust available profile settings or mappings based on e.g. ini values."
        },
        "SetToDefaults": {
          "comment": "Sets all of the profile settings to their default values"
        }
      }
    },
    "OnlineRecentPlayersList": {
      "comment": "This class holds a list of players met online that the players on this PC/console\n encountered. It does not persist the list. Both parties and individuals are tracked\n with the individuals containing all party members. Note that it only holds the\n unique ids of the players.",
      "properties": {
        "CurrentPlayers": {
          "comment": "Holds the list of current players (the set of players currently in a session"
        },
        "LastParty": {
          "comment": "Holds the information about the last party that a player on this pc/console was in"
        },
        "MaxRecentParties": {
          "comment": "The size of the recent party list to allow before losing the oldest entries"
        },
        "MaxRecentPlayers": {
          "comment": "The size of the recent player list to allow before losing the oldest entries"
        },
        "RecentParties": {
          "comment": "The list of recent parties that the players on this PC/console has encountered"
        },
        "RecentPartiesAddIndex": {
          "comment": "The position in the array that new parties should be added at"
        },
        "RecentPlayers": {
          "comment": "The set of players that players on this PC/console have recently encountered"
        },
        "RecentPlayersAddIndex": {
          "comment": "The position in the array that new players should be added at"
        }
      },
      "functions": {
        "AddPartyToRecentParties": {
          "comment": "Adds a player to the recent players list",
          "params": {
            "PartyLeader": "the player being added",
            "PartyMembers": "the members of the party"
          }
        },
        "AddPlayerToRecentPlayers": {
          "comment": "Adds a player to the recent players list",
          "params": {
            "NewPlayer": "the player being added"
          }
        },
        "ClearRecentParties": {
          "comment": "Clears the recent parties list and resets the add index"
        },
        "ClearRecentPlayers": {
          "comment": "Clears the recent players list and resets the add index"
        },
        "DumpPlayersList": {
          "comment": "Log list of players for debugging"
        },
        "GetPlayersFromCurrentPlayers": {
          "comment": "Builds a single list of players from the current players list",
          "params": {
            "Players": "the array getting the data copied into it"
          }
        },
        "GetPlayersFromRecentParties": {
          "comment": "Builds a single list of players from the recent parties list",
          "params": {
            "Players": "the array getting the data copied into it"
          }
        },
        "GetSkillForCurrentPlayer": {
          "comment": "Finds the player indicated and returns their skill rating",
          "params": {
            "Player": "the player to search for"
          }
        },
        "GetTeamForCurrentPlayer": {
          "comment": "Finds the player indicated and returns their team that was assigned",
          "params": {
            "Player": "the player to search for"
          }
        },
        "SetCurrentPlayersList": {
          "comment": "Sets the current player list to the data specified",
          "params": {
            "Players": "the list of players to copy"
          }
        },
        "SetLastParty": {
          "comment": "Adds a player to the recent players list",
          "params": {
            "PartyLeader": "the player being added",
            "PartyMembers": "the members of the party"
          }
        },
        "ShowCurrentPlayersList": {
          "comment": "Builds a single player list out of the players in the current players list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Title": "the title to use for the UI",
            "Description": "the text to show at the top of the UI"
          }
        },
        "ShowLastPartyPlayerList": {
          "comment": "Shows the last party that you were in as a player list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Title": "the title to use for the UI",
            "Description": "the text to show at the top of the UI"
          }
        },
        "ShowRecentPartiesPlayerList": {
          "comment": "Builds a single player list out of the various parties encountered and shows",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Title": "the title to use for the UI",
            "Description": "the text to show at the top of the UI"
          }
        },
        "ShowRecentPlayerList": {
          "comment": "Helper function for showing the recent players list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Title": "the title to use for the UI",
            "Description": "the text to show at the top of the UI"
          }
        }
      },
      "structs": {
        "CurrentPlayerMet": {
          "comment": "The set of people that the player/PC/console are currently playing with/against",
          "properties": {
            "NetId": {
              "comment": "The unique net id for the player"
            },
            "Skill": {
              "comment": "The skill rating of the player"
            },
            "TeamNum": {
              "comment": "The team the player is on"
            }
          }
        },
        "RecentParty": {
          "comment": "Holds a set of players that made up a party",
          "properties": {
            "PartyLeader": {
              "comment": "The player that was the party leader"
            },
            "PartyMembers": {
              "comment": "The list of players that comprise the party (should include the leader)"
            }
          }
        }
      }
    },
    "OnlineStats": {
      "comment": "Base class for stats read and write objects. Contains common structures\n and methods used by both read and write objects.",
      "properties": {
        "ViewIdMappings": {
          "comment": "Provides metadata view ids so that we can present their human readable form"
        }
      },
      "functions": {
        "GetViewId": {
          "comment": "Searches the view id mappings to find the view id that matches the name",
          "params": {
            "ViewName": "the name of the view being searched for",
            "ViewId": "the id of the view that matches the name"
          }
        },
        "GetViewName": {
          "comment": "Finds the human readable name for the view",
          "params": {
            "ViewId": "the id to look up in the mappings table"
          }
        }
      }
    },
    "OnlineStatsInterface": {
      "comment": "This interface deals with reading & writing stats to the online subsytem.",
      "functions": {
        "AddFlushOnlineStatsCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the stats flush has completed",
          "params": {
            "FlushOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadOnlineStatsCompleteDelegate": {
          "comment": "Adds the delegate to a list used to notify the gameplay code that the stats read has completed",
          "params": {
            "ReadOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddRegisterHostStatGuidCompleteDelegate": {
          "comment": "Adds the delegate for notifying when the host guid registration is done",
          "params": {
            "RegisterHostStatGuidCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "CalcAggregateSkill": {
          "comment": "Calculates the aggregate skill from an array of skills.",
          "params": {
            "Mus": "array that holds the mu values",
            "Sigmas": "array that holds the sigma values",
            "OutAggregateMu": "aggregate Mu",
            "OutAggregateSigma": "aggregate Sigma"
          }
        },
        "ClearFlushOnlineStatsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the stats flush has completed",
          "params": {
            "FlushOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadOnlineStatsCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ReadOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRegisterHostStatGuidCompleteDelegateDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code",
          "params": {
            "RegisterHostStatGuidCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "FlushOnlineStats": {
          "comment": "Commits any changes in the online stats cache to the permanent storage",
          "params": {
            "SessionName": "the name of the session having stats flushed for"
          }
        },
        "FreeStats": {
          "comment": "Cleans up any platform specific allocated data contained in the stats data",
          "params": {
            "StatsRead": "the object to handle per platform clean up on"
          }
        },
        "GetClientStatGuid": {
          "comment": "Reads the client's stat guid that was generated by registering the host's guid\n Used for synching up stats. Only valid on the client. Only callable after the\n host registration has completed"
        },
        "GetHostStatGuid": {
          "comment": "Reads the host's stat guid for synching up stats. Only valid on the host."
        },
        "ReadOnlineStats": {
          "comment": "Reads a set of stats for the specified list of players",
          "params": {
            "Players": "the array of unique ids to read stats for",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object"
          }
        },
        "ReadOnlineStatsByRank": {
          "comment": "Reads stats by ranking. This grabs the rows starting at StartIndex through\n NumToRead and places them in the StatsRead object.",
          "params": {
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object",
            "StartIndex": "the starting rank to begin reads at (1 for top)",
            "NumToRead": "the number of rows to read (clamped at 100 underneath)"
          }
        },
        "ReadOnlineStatsByRankAroundPlayer": {
          "comment": "Reads stats by ranking centered around a player. This grabs a set of rows\n above and below the player's current rank",
          "params": {
            "LocalUserNum": "the local player having their stats being centered upon",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object",
            "NumRows": "the number of rows to read above and below the player's rank"
          }
        },
        "ReadOnlineStatsForFriends": {
          "comment": "Reads a player's stats and all of that player's friends stats for the\n specified set of stat views. This allows you to easily compare a player's\n stats to their friends.",
          "params": {
            "LocalUserNum": "the local player having their stats and friend's stats read for",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object"
          }
        },
        "RegisterHostStatGuid": {
          "comment": "Registers the host's stat guid with the client for verification they are part of\n the stat. Note this is an async task for any backend communication that needs to\n happen before the registration is deemed complete",
          "params": {
            "HostStatGuid": "the host's stat guid"
          }
        },
        "RegisterStatGuid": {
          "comment": "Registers the client's stat guid on the host to validate that the client was in the stat.\n Used for synching up stats. Only valid on the host.",
          "params": {
            "PlayerId": "the client's unique net id",
            "ClientStatGuid": "the client's stat guid"
          }
        },
        "WriteOnlinePlayerScores": {
          "comment": "Writes the score data for the match",
          "params": {
            "SessionName": "the name of the session the player stats are being recorded for",
            "LeaderboardId": "the leaderboard to write the score information to",
            "PlayerScores": "the list of players, teams, and scores they earned"
          }
        },
        "WriteOnlineStats": {
          "comment": "Writes out the stats contained within the stats write object to the online\n subsystem's cache of stats data. Note the new data replaces the old. It does\n not write the data to the permanent storage until a FlushOnlineStats() call\n or a session ends. Stats cannot be written without a session or the write\n request is ignored. No more than 5 stats views can be written to at a time\n or the write request is ignored.",
          "params": {
            "SessionName": "the name of the session the stats are being written to",
            "Player": "the player to write stats for",
            "StatsWrite": "the object containing the information to write"
          }
        }
      }
    },
    "OnlineStatsRead": {
      "comment": "Stats class that holds the read request definitions and the resulting data",
      "properties": {
        "ColumnIds": {
          "comment": "The columns to read in the view we are interested in"
        },
        "ColumnMappings": {
          "comment": "Provides metadata for column ids so that we can present their human readable form"
        },
        "Rows": {
          "comment": "The rows of data returned by the online service"
        },
        "SortColumnId": {
          "comment": "The column id to use for sorting rank"
        },
        "TitleId": {
          "comment": "An optional title id to specify when reading stats (zero uses the default for the exe)"
        },
        "TotalRowsInView": {
          "comment": "The total number of rows in the view"
        },
        "ViewId": {
          "comment": "The unique id of the view that these stats are from"
        },
        "ViewName": {
          "comment": "The name of the view in human readable terms"
        }
      },
      "functions": {
        "AddPlayer": {
          "comment": "Adds a player to the results if not present",
          "params": {
            "PlayerName": "the name to place in the data",
            "PlayerId": "the player to search for"
          }
        },
        "GetFloatStatValueForPlayer": {
          "comment": "Searches the stat rows for the player and then finds the stat value from the specified column within that row",
          "params": {
            "PlayerId": "the player to search for",
            "StatColumnNo": "the column number to look up",
            "StatValue": "the out value that is assigned the stat"
          }
        },
        "GetIntStatValueForPlayer": {
          "comment": "Searches the stat rows for the player and then finds the stat value from the specified column within that row",
          "params": {
            "PlayerId": "the player to search for",
            "StatColumnNo": "the column number to look up",
            "StatValue": "the out value that is assigned the stat"
          }
        },
        "GetRankForPlayer": {
          "comment": "Searches the rows for the player and returns their rank on the leaderboard",
          "params": {
            "PlayerId": "the player to search for"
          }
        },
        "GetStatValueForPlayerAsString": {
          "comment": "Searches the stat rows for the player and then finds the stat value from the specified column within that row",
          "params": {
            "PlayerId": "the player to search for",
            "StatColumnNo": "the column number to look up",
            "StatValue": "the out value that is assigned the stat in string form"
          }
        },
        "IsStatZero": {
          "comment": "Searches the stat rows for the player and then returns whether or not the stat is 0. Only works on float, double, int, int64, and empty stat types. Others return FALSE.",
          "params": {
            "PlayerId": "the player to search for",
            "StatColumnNo": "the column number to look up"
          }
        },
        "OnReadComplete": {
          "comment": "This event is called post read complete so that the stats object has a chance\n synthesize new stats from returned data, e.g. ratios, averages, etc."
        },
        "SetFloatStatValueForPlayer": {
          "comment": "Searches the stat rows for the player and then sets the stat value from the specified column within that row",
          "params": {
            "PlayerId": "the player to search for",
            "StatColumnNo": "the column number to look up",
            "StatValue": "the value to set that column to"
          }
        },
        "SetIntStatValueForPlayer": {
          "comment": "Searches the stat rows for the player and then sets the stat value from the specified column within that row",
          "params": {
            "PlayerId": "the player to search for",
            "StatColumnNo": "the column number to look up",
            "StatValue": "the value to set that column to"
          }
        }
      },
      "structs": {
        "ColumnMetaData": {
          "comment": "Provides human readable values for column ids",
          "properties": {
            "ColumnName": {
              "comment": "The name displayed in column headings in the UI"
            },
            "Id": {
              "comment": "Id for the given string"
            },
            "Name": {
              "comment": "Human readable form of the Id"
            }
          }
        },
        "OnlineStatsColumn": {
          "comment": "A single instance of a stat in a row",
          "properties": {
            "ColumnNo": {
              "comment": "The ordinal value of the column"
            },
            "StatValue": {
              "comment": "The value of the stat for this column"
            }
          }
        },
        "OnlineStatsRow": {
          "comment": "Holds a single player's set of data for this stats view",
          "properties": {
            "Columns": {
              "comment": "The set of columns (stat instances) for this row"
            },
            "NickName": {
              "comment": "Player's online nickname"
            },
            "PlayerId": {
              "comment": "The unique player id of the player these stats are for"
            },
            "Rank": {
              "comment": "The rank of the player in this stats view"
            }
          }
        }
      }
    },
    "OnlineStatsWrite": {
      "comment": "Stats class that accumulates the stats data before submitting it to the\n online subsytem for storage.",
      "properties": {
        "ArbitratedViewIds": {
          "comment": "This array contains the list of views to write the properties to for arbitrated matches"
        },
        "Properties": {
          "comment": "The array of properties to publish to the stats view"
        },
        "RatingId": {
          "comment": "This is the property id that is used to rate on"
        },
        "StatMappings": {
          "comment": "Maps the stat's column num to the human readable stat name"
        },
        "ViewIds": {
          "comment": "This array contains the list of views to write the properties to"
        }
      },
      "functions": {
        "DecrementFloatStat": {
          "comment": "Decrements a stat of type SDT_Float by the value specified. Does nothing\n if the stat is not of the right type.",
          "params": {
            "StatId": "the stat to decrement",
            "DecBy": "the value to decrement by"
          }
        },
        "DecrementIntStat": {
          "comment": "Decrements a stat of type SDT_Int by the value specified. Does nothing\n if the stat is not of the right type.",
          "params": {
            "StatId": "the stat to decrement",
            "DecBy": "the value to decrement by"
          }
        },
        "GetStatId": {
          "comment": "Searches the stat mappings to find the stat id that matches the name",
          "params": {
            "StatName": "the name of the stat being searched for",
            "StatId": "the out value that gets the id"
          }
        },
        "GetStatName": {
          "comment": "Searches the stat mappings to find human readable name for the stat id",
          "params": {
            "StatId": "the id of the stats to find the name for"
          }
        },
        "IncrementFloatStat": {
          "comment": "Increments a stat of type SDT_Float by the value specified. Does nothing\n if the stat is not of the right type.",
          "params": {
            "StatId": "the stat to increment",
            "IncBy": "the value to increment by"
          }
        },
        "IncrementIntStat": {
          "comment": "Increments a stat of type SDT_Int by the value specified. Does nothing\n if the stat is not of the right type.",
          "params": {
            "StatId": "the stat to increment",
            "IncBy": "the value to increment by"
          }
        },
        "SetFloatStat": {
          "comment": "Sets a stat of type SDT_Float to the value specified. Does nothing\n if the stat is not of the right type.",
          "params": {
            "StatId": "the stat to change the value of",
            "Value": "the new value to assign to the stat"
          }
        },
        "SetIntStat": {
          "comment": "Sets a stat of type SDT_Int to the value specified. Does nothing\n if the stat is not of the right type.",
          "params": {
            "StatId": "the stat to change the value of",
            "Value": "the new value to assign to the stat"
          }
        }
      }
    },
    "OnlineSubsystem": {
      "comment": "This class holds a set of online interfaces that game code uses to talk\n with the platform layer's services. The set of services are implemented\n as interface pointers so that we can mix & match services at run time.\n This also allows licensees the ability to use part of our base services\n and provide custom implmentations of others.",
      "properties": {
        "AccountInterface": {
          "comment": "The interface to use for creating and/or enumerating account information"
        },
        "AsyncMinCompletionTime": {
          "comment": "Used to introduce latency when communicating with the online layer for testing purposes"
        },
        "BuildIdOverride": {
          "comment": "Used to specify a build override value"
        },
        "bUseBuildIdOverride": {
          "comment": "Whether to use the override or not"
        },
        "ContentInterface": {
          "comment": "The interface to use for online content"
        },
        "GameInterface": {
          "comment": "The interface to use for creating, searching for, or destroying online games"
        },
        "IniLocPatcherClassName": {
          "comment": "The class to create our patcher instance from"
        },
        "NamedInterfaceDefs": {
          "comment": "The list of named interfaces to automatically create and store"
        },
        "NamedInterfaces": {
          "comment": "Holds the set of registered named interfaces"
        },
        "NewsInterface": {
          "comment": "The interface to use for reading game specific news announcements"
        },
        "PartyChatInterface": {
          "comment": "The interface to use for accessing online party chat methods"
        },
        "Patcher": {
          "comment": "The object responsible for patching downloaded INI/loc files"
        },
        "PlayerInterface": {
          "comment": "The interface for accessing online player methods"
        },
        "PlayerInterfaceEx": {
          "comment": "The interface for accessing online player extension methods"
        },
        "Sessions": {
          "comment": "The list of sessions currently managed by the online subsystem"
        },
        "StatsInterface": {
          "comment": "The interface to use for stats read/write operations"
        },
        "SystemInterface": {
          "comment": "The interface for accessing system wide network functions"
        },
        "TitleFileInterface": {
          "comment": "The interface to use for downloading files from the network platform"
        },
        "VoiceInterface": {
          "comment": "The interface to use for voice communication"
        }
      },
      "functions": {
        "DumpGameSettings": {
          "comment": "Logs the game settings object",
          "params": {
            "GameSettings": "settings to dump"
          }
        },
        "DumpNetIds": {
          "comment": "Log list of players' netids for debugging"
        },
        "DumpSessionState": {
          "comment": "Logs the session state for all sessions present"
        },
        "DumpVoiceRegistration": {
          "comment": "Logs the list of players that are registered for voice"
        },
        "Exit": {
          "comment": "Called from the engine shutdown code to allow the subsystem to release any\n resources that may have been allocated"
        },
        "GetBuildUniqueId": {
          "comment": "Generates a unique number based off of the current script compilation"
        },
        "GetNamedInterface": {
          "comment": "Returns the interface object associated with the specified name",
          "params": {
            "InterfaceName": "the name of the interface to retrieve"
          }
        },
        "GetNumSupportedLogins": {
          "comment": "Returns the number of players that can be signed in on this platform"
        },
        "Init": {
          "comment": "Called from engine start up code to allow the subsystem to initialize"
        },
        "PostInit": {
          "comment": "Used to trigger any automated tasks that need to happen just after startup"
        },
        "SetAccountInterface": {
          "comment": "Called from native code to assign the account interface",
          "params": {
            "NewInterface": "the object to assign as providing the account interface"
          }
        },
        "SetContentInterface": {
          "comment": "Called from native code to assign the content interface",
          "params": {
            "NewInterface": "the object to assign as providing the content interface"
          }
        },
        "SetDebugSpewLevel": {
          "comment": "Sets the debug output level for the platform specific API (if applicable)",
          "params": {
            "DebugSpewLevel": "the level to set"
          }
        },
        "SetGameInterface": {
          "comment": "Called from native code to assign the game interface",
          "params": {
            "NewInterface": "the object to assign as providing the game interface"
          }
        },
        "SetNamedInterface": {
          "comment": "Adds the interface object to the named interface list with the specified name",
          "params": {
            "InterfaceName": "the name of the interface to add it as",
            "NewInterface": "the object/interface that is being cached"
          }
        },
        "SetNewsInterface": {
          "comment": "Called from native code to assign the news interface",
          "params": {
            "NewInterface": "the object to assign as providing the news interface"
          }
        },
        "SetPartyChatInterface": {
          "comment": "Called from native code to assign the party chat interface",
          "params": {
            "NewInterface": "the object to assign as providing the party chat interface"
          }
        },
        "SetPlayerInterface": {
          "comment": "Called from native code to assign the player interface",
          "params": {
            "NewInterface": "the object to assign as providing the player interface"
          }
        },
        "SetPlayerInterfaceEx": {
          "comment": "Called from native code to assign the extended player interface",
          "params": {
            "NewInterface": "the object to assign as providing the player interface"
          }
        },
        "SetStatsInterface": {
          "comment": "Called from native code to assign the stats interface",
          "params": {
            "NewInterface": "the object to assign as providing the stats interface"
          }
        },
        "SetSystemInterface": {
          "comment": "Called from native code to assign the system interface",
          "params": {
            "NewInterface": "the object to assign as providing the system interface"
          }
        },
        "SetTitleFileInterface": {
          "comment": "Called from native code to assign the title file interface",
          "params": {
            "NewInterface": "the object to assign as providing the file downloading interface"
          }
        },
        "SetVoiceInterface": {
          "comment": "Called from native code to assign the voice interface",
          "params": {
            "NewInterface": "the object to assign as providing the voice interface"
          }
        },
        "StringToUniqueNetId": {
          "comment": "Converts a string representing a UniqueNetId into a UniqueNetId struct.",
          "params": {
            "UniqueNetIdString": "the string containing the text representation of the unique id.",
            "out_UniqueId": "will receive the UniqueNetId generated from the string."
          }
        },
        "UniqueNetIdToString": {
          "comment": "Generates a string representation of a UniqueNetId struct.",
          "params": {
            "IdToConvert": "the unique net id that should be converted to a string."
          }
        }
      },
      "structs": {
        "AchievementDetails": {
          "comment": "Holds the information contained in Live's achievements for this title",
          "properties": {
            "AchievementName": {
              "comment": "The name of the achievement"
            },
            "bIsSecret": {
              "comment": "Whether the achievement is secret (hidden if not achieved) or not"
            },
            "bWasAchievedOffline": {
              "comment": "Whether the achievement awarded offline or not"
            },
            "bWasAchievedOnline": {
              "comment": "Whether the achievement awarded online or not"
            },
            "DayEarned": {
              "comment": "The day of the month of when it was earned"
            },
            "DayOfWeekEarned": {
              "comment": "The day of week since we have a byte available for padding"
            },
            "Description": {
              "comment": "The description of the achievement"
            },
            "GamerPoints": {
              "comment": "How much this achievement is worth"
            },
            "HowTo": {
              "comment": "The description of how to meet the requirements of the achievement"
            },
            "Id": {
              "comment": "The ID of the achievement"
            },
            "Image": {
              "comment": "The image associated with the achievement"
            },
            "MonthEarned": {
              "comment": "The month of when it was earned"
            },
            "YearEarned": {
              "comment": "The year of when it was earned (byte is fine since the none of the consoles will last that long :) )"
            }
          }
        },
        "CommunityContentFile": {
          "comment": "Community file info",
          "properties": {
            "AverageRating": {
              "comment": "The average rating for this file from the community"
            },
            "ContentId": {
              "comment": "Unique identifier for this content file"
            },
            "ContentType": {
              "comment": "Game specific content type field"
            },
            "DownloadCount": {
              "comment": "The number of times this file has been downloaded"
            },
            "FileId": {
              "comment": "Additional identifier for providers that need it"
            },
            "FileSize": {
              "comment": "Size in bytes of the payload in the file"
            },
            "LastRatingGiven": {
              "comment": "The last rating the user gave this content"
            },
            "LocalFilePath": {
              "comment": "The path to the file if stored locally"
            },
            "Owner": {
              "comment": "The original owner of the file"
            },
            "RatingCount": {
              "comment": "The number of times this file has been rated"
            }
          }
        },
        "CommunityContentMetadata": {
          "comment": "Community file metadata",
          "properties": {
            "ContentType": {
              "comment": "Unique identifier for this content type"
            },
            "MetadataItems": {
              "comment": "Metadata to associate with the file"
            }
          }
        },
        "FriendsQuery": {
          "comment": "Used to bulk query the friends list",
          "properties": {
            "bIsFriend": {
              "comment": "Out param indicating whether the player is a friend or not"
            },
            "UniqueId": {
              "comment": "The unique player id to check friends status for"
            }
          }
        },
        "LocalTalker": {
          "comment": "Information about a local talker",
          "properties": {
            "bHasNetworkedVoice": {
              "comment": "Whether the talker should send network data"
            },
            "bHasVoice": {
              "comment": "Whether this talker is currently registered"
            },
            "bIsRecognizingSpeech": {
              "comment": "Whether the player is trying to speak voice commands"
            },
            "bIsRegistered": {
              "comment": "Whether this player was already registered with the voice interface or not"
            },
            "bIsTalking": {
              "comment": "Whether the remote talker is speaking this frame"
            },
            "bWasTalking": {
              "comment": "Whether the local talker was speaking last frame"
            }
          }
        },
        "NamedInterface": {
          "comment": "Holds a named object interface for dynamically bound interfaces",
          "properties": {
            "InterfaceName": {
              "comment": "The name to bind this object to"
            },
            "InterfaceObject": {
              "comment": "The object to store at this location"
            }
          }
        },
        "NamedInterfaceDef": {
          "comment": "Holds a name to class name mapping for adding the named interfaces automatically",
          "properties": {
            "InterfaceClassName": {
              "comment": "The class to load and create for the named interface"
            },
            "InterfaceName": {
              "comment": "The name to bind this object to"
            }
          }
        },
        "NamedSession": {
          "comment": "Holds the per session information for named sessions",
          "properties": {
            "ArbitrationRegistrants": {
              "comment": "The set of registered players for arbitration"
            },
            "GameSettings": {
              "comment": "The game settings associated with this session"
            },
            "Registrants": {
              "comment": "List of players registered in the session"
            },
            "SessionInfo": {
              "comment": "The platform specific session information"
            },
            "SessionName": {
              "comment": "The name of the session"
            }
          }
        },
        "OnlineArbitrationRegistrant": {
          "comment": "Struct holding the information about a single arbitration registrant",
          "properties": {
            "MachineId": {
              "comment": "Unique id of the machine involved in the arbitrated session"
            },
            "Trustworthiness": {
              "comment": "Trust level of the machine/player for the arbitrated session"
            }
          }
        },
        "OnlineContent": {
          "comment": "Holds information about a single piece of downloaded content",
          "properties": {
            "ContentFiles": {
              "comment": "List of all non-package files in the content"
            },
            "ContentPackages": {
              "comment": "List of packages in the content"
            },
            "ContentPath": {
              "comment": "File system usable reference to the content"
            },
            "ContentType": {
              "comment": "The type of content this represents"
            },
            "DeviceId": {
              "comment": "The device ID the DLC is on"
            },
            "Filename": {
              "comment": "Non-displayable file name of the content"
            },
            "FriendlyName": {
              "comment": "Displayable name of the content"
            },
            "UserIndex": {
              "comment": "Optional user index that content is downloaded for (-1 means it's not associated with any user)"
            }
          }
        },
        "OnlineFriend": {
          "comment": "Holds information about a player in a friends list",
          "properties": {
            "bHasInvitedYou": {
              "comment": "Whether the friends has sent an invite to you or not"
            },
            "bHasVoiceSupport": {
              "comment": "Whether the friend can chat via voice or not"
            },
            "bHaveInvited": {
              "comment": "Whether the friends has an invitation outstanding from you or not"
            },
            "bIsJoinable": {
              "comment": "Whether the game the friend is in is joinable or not"
            },
            "bIsOnline": {
              "comment": "Whether the friend is online or not"
            },
            "bIsPlaying": {
              "comment": "Whether the friend is playing a game or not"
            },
            "bIsPlayingThisGame": {
              "comment": "Whether the friend is playing the same game or not"
            },
            "FriendState": {
              "comment": "The current state for this friend"
            },
            "NickName": {
              "comment": "Player's nick as published to the online service"
            },
            "PresenceInfo": {
              "comment": "String holding information about the player's game state (cap-ed flag, etc.)"
            },
            "SessionId": {
              "comment": "The session id that the player is in"
            },
            "UniqueId": {
              "comment": "Unique identifier of the friend"
            }
          }
        },
        "OnlineFriendMessage": {
          "comment": "Holds the data used in a friend message",
          "properties": {
            "bIsFriendInvite": {
              "comment": "Whether this is a friend invite or just a generic message"
            },
            "bIsGameInvite": {
              "comment": "Whether this message is a game invite or not"
            },
            "bWasAccepted": {
              "comment": "Whether the invite has been accepted or not"
            },
            "bWasDenied": {
              "comment": "Whether the invite has been denied or not"
            },
            "Message": {
              "comment": "The corresponding message that was sent"
            },
            "SendingPlayerId": {
              "comment": "The player that is sending the message"
            },
            "SendingPlayerNick": {
              "comment": "The nick name of the player that sent the message"
            }
          }
        },
        "OnlinePartyMember": {
          "comment": "Holds information about a player in a friends list",
          "properties": {
            "bIsInGameSession": {
              "comment": "Whether the player is in a game session"
            },
            "bIsInPartyVoice": {
              "comment": "Whether the player is in party voice or game voice"
            },
            "bIsLocal": {
              "comment": "Whether the player is local to this machine or remote"
            },
            "bIsPlayingThisGame": {
              "comment": "Whether the party member is playing the same game or not"
            },
            "bIsTalking": {
              "comment": "Whether the player is talking or not"
            },
            "Data1": {
              "comment": "The first 4 bytes of custom application data"
            },
            "Data2": {
              "comment": "The second 4 bytes of custom application data"
            },
            "Data3": {
              "comment": "The third 4 bytes of custom application data"
            },
            "Data4": {
              "comment": "The fourth 4 bytes of custom application data"
            },
            "LocalUserNum": {
              "comment": "The local controller id if local"
            },
            "NatType": {
              "comment": "The NAT type for this player"
            },
            "Nickname": {
              "comment": "The player's nickname"
            },
            "SessionId": {
              "comment": "The session id that the player is in"
            },
            "TitleId": {
              "comment": "The title id of the title the player is in"
            },
            "UniqueId": {
              "comment": "Unique identifier of the friend"
            }
          }
        },
        "OnlinePlayerScore": {
          "comment": "Struct holding information used when writing scoring information that is used\n to determine a player's skill rating",
          "properties": {
            "PlayerId": {
              "comment": "The player that this score is for"
            },
            "Score": {
              "comment": "The score for this player"
            },
            "TeamId": {
              "comment": "The team that the player is on"
            }
          }
        },
        "OnlineRegistrant": {
          "comment": "A player in a session",
          "properties": {
            "PlayerNetId": {
              "comment": "Unique id of the player involved in the arbitrated session"
            }
          }
        },
        "RemoteTalker": {
          "comment": "Information about a remote talker",
          "properties": {
            "bIsRegistered": {
              "comment": "Whether this player was already registered with the voice interface or not"
            },
            "bIsTalking": {
              "comment": "Whether the remote talker is speaking this frame"
            },
            "bWasTalking": {
              "comment": "Whether the remote talker was speaking last frame"
            },
            "LastNotificationTime": {
              "comment": "Used to trigger talking delegates only after a certain period of time has passed"
            },
            "TalkerId": {
              "comment": "The unique id for this talker"
            }
          }
        },
        "SpeechRecognizedWord": {
          "comment": "Holds a word/phrase that was recognized by the speech analyzer\n @note See VoiceInterface.h to change the native layout of this struct",
          "properties": {
            "Confidence": {
              "comment": "How confident the analyzer was in the recognition"
            },
            "WordId": {
              "comment": "The id of the word in the vocabulary"
            },
            "WordText": {
              "comment": "the actual word"
            }
          }
        },
        "TitleFile": {
          "comment": "Holds the data used in downloading a file asynchronously from the online service",
          "properties": {
            "AsyncState": {
              "comment": "The async state the file download is in"
            },
            "Data": {
              "comment": "The buffer of data for the file"
            },
            "Filename": {
              "comment": "The name of the file as requested"
            }
          }
        },
        "UniqueNetId": {
          "comment": "Struct that holds a transient, unique identifier for a player",
          "properties": {
            "Uid": {
              "comment": "The id used by the network to uniquely identify a player"
            }
          }
        }
      }
    },
    "OnlineSuppliedUIInterface": {
      "comment": "This interface provides accessors to platform-supplied UIs",
      "functions": {
        "AddShowOnlineStatsUICompleteDelegate": {
          "comment": "Adds the delegate to the list to be notified when stats UI is closed",
          "params": {
            "ShowOnlineStatsUICompleteDelegate": "the delegate to add"
          }
        },
        "ClearShowOnlineStatsUICompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ShowOnlineStatsUICompleteDelegate": "the delegate to remove"
          }
        },
        "ShowMatchmakingUI": {
          "comment": "Shows the platform supplied matchmaking UI. This will eventually either the JoinOnlineGameComplete \n or CreateOnlineGameComplete delegates, depending on if it's server or client",
          "params": {
            "SearchingPlayerNum": "the index of the player searching for a match",
            "SearchSettings": "settings used to search for",
            "GameSettings": "the game settings to use if this player becomes the server"
          }
        },
        "ShowOnlineStatsUI": {
          "comment": "Shows the platform supplied leaderboard UI",
          "params": {
            "Players": "the array of unique ids to show stats for",
            "StatsRead": "holds the definitions of the tables to show the data for\n (note that no results will be filled out)"
          }
        }
      }
    },
    "OnlineSystemInterface": {
      "comment": "This interface provides accessors to the platform specific system methods,\n features that do not pertain to a single user but to the game as a whole.",
      "functions": {
        "AddConnectionStatusChangeDelegate": {
          "comment": "Adds the delegate to the list to be notified when the connection status changes",
          "params": {
            "ConnectionStatusDelegate": "the delegate to add"
          }
        },
        "AddControllerChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the controller state changed",
          "params": {
            "ControllerChangeDelegate": "the delegate to use for notifications"
          }
        },
        "AddExternalUIChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that external UI state\n changed (opened/closed)",
          "params": {
            "ExternalUIDelegate": "the delegate to use for notifications"
          }
        },
        "AddLinkStatusChangeDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that link status changed",
          "params": {
            "LinkStatusDelegate": "the delegate to use for notifications"
          }
        },
        "AddStorageDeviceChangeDelegate": {
          "comment": "Adds the delegate to the list to be notified when a storage device changes",
          "params": {
            "StorageDeviceChangeDelegate": "the delegate to add"
          }
        },
        "ClearConnectionStatusChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ConnectionStatusDelegate": "the delegate to remove"
          }
        },
        "ClearControllerChangeDelegate": {
          "comment": "Removes the delegate used to notify the gameplay code that the controller state changed",
          "params": {
            "ControllerChangeDelegate": "the delegate to remove"
          }
        },
        "ClearExternalUIChangeDelegate": {
          "comment": "Removes the delegate from the notification list",
          "params": {
            "ExternalUIDelegate": "the delegate to remove"
          }
        },
        "ClearLinkStatusChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "LinkStatusDelegate": "the delegate to remove"
          }
        },
        "ClearStorageDeviceChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "StorageDeviceChangeDelegate": "the delegate to remove"
          }
        },
        "GetLocale": {
          "comment": "Determine the locale (country code) for the player"
        },
        "GetNATType": {
          "comment": "Determines the NAT type the player is using"
        },
        "GetNetworkNotificationPosition": {
          "comment": "Determines the current notification position setting"
        },
        "HasLinkConnection": {
          "comment": "Determines if the ethernet link is connected or not"
        },
        "IsControllerConnected": {
          "comment": "Determines if the specified controller is connected or not",
          "params": {
            "ControllerId": "the controller to query"
          }
        },
        "SetNetworkNotificationPosition": {
          "comment": "Sets a new position for the network notification icons/images",
          "params": {
            "NewPos": "the new location to use"
          }
        }
      }
    },
    "OnlineTitleFileInterface": {
      "comment": "This interface provides accessors to the platform specific tile file downloading",
      "functions": {
        "AddReadTitleFileCompleteDelegate": {
          "comment": "Adds the delegate to the list to be notified when a requested file has been read",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to add"
          }
        },
        "ClearDownloadedFile": {
          "comment": "Empties the cached data for this file if it is not being downloaded currently",
          "params": {
            "FileName": "the name of the file to remove from the cache"
          }
        },
        "ClearDownloadedFiles": {
          "comment": "Empties the set of downloaded files if possible (no async tasks outstanding)"
        },
        "ClearReadTitleFileCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to remove"
          }
        },
        "GetTitleFileContents": {
          "comment": "Copies the file data into the specified buffer for the specified file",
          "params": {
            "FileName": "the name of the file to read",
            "FileContents": "the out buffer to copy the data into"
          }
        },
        "GetTitleFileState": {
          "comment": "Determines the async state of the tile file read operation",
          "params": {
            "FileName": "the name of the file to check on"
          }
        },
        "ReadTitleFile": {
          "comment": "Starts an asynchronous read of the specified file from the network platform's\n title specific file store",
          "params": {
            "FileToRead": "the name of the file to read"
          }
        }
      }
    },
    "OnlineVoiceInterface": {
      "comment": "This interface deals with voice over IP. It is responsible for registering,\n unregistering, and filtering talkers. It also handles special voice effects.\n This interface also provides hooks for accessing the raw data to perform\n operations on it, such as speech recognition, lip sync, etc.",
      "functions": {
        "AddPlayerTalkingDelegate": {
          "comment": "Adds a talker delegate to the list of notifications",
          "params": {
            "TalkerDelegate": "the delegate to call when a player is talking"
          }
        },
        "AddRecognitionCompleteDelegate": {
          "comment": "Adds the speech recognition notification callback to list of callbacks for the specified user",
          "params": {
            "LocalUserNum": "the local user to receive notifications for",
            "RecognitionDelegate": "the delegate to call when recognition is complete"
          }
        },
        "ClearPlayerTalkingDelegate": {
          "comment": "Removes a talker delegate to the list of notifications",
          "params": {
            "TalkerDelegate": "the delegate to remove from the notification list"
          }
        },
        "ClearRecognitionCompleteDelegate": {
          "comment": "Clears the speech recognition notification callback to use for the specified user",
          "params": {
            "LocalUserNum": "the local user to receive notifications for",
            "RecognitionDelegate": "the delegate to call when recognition is complete"
          }
        },
        "GetRecognitionResults": {
          "comment": "Gets the results of the voice recognition\n Will not return results that were below the SpeechRecognition's ConfidenceThreshold,\n so you may get an empty array back",
          "params": {
            "LocalUserNum": "the local user to read the results of",
            "Words": "the set of words that were recognized by the voice analyzer"
          }
        },
        "IsHeadsetPresent": {
          "comment": "Determines if the specified player has a headset connected",
          "params": {
            "LocalUserNum": "the local player index being queried"
          }
        },
        "IsLocalPlayerTalking": {
          "comment": "Determines if the specified player is actively talking into the mic",
          "params": {
            "LocalUserNum": "the local player index being queried"
          }
        },
        "IsRemotePlayerTalking": {
          "comment": "Determines if the specified remote player is actively talking into the mic\n NOTE: Network latencies will make this not 100% accurate",
          "params": {
            "PlayerId": "the unique id of the remote player being queried"
          }
        },
        "MuteAll": {
          "comment": "Mutes all voice or all but friends",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "bAllowFriends": "whether to mute everyone or allow friends"
          }
        },
        "MuteRemoteTalker": {
          "comment": "Mutes a remote talker for the specified local player. NOTE: This only mutes them in the\n game unless the bIsSystemWide flag is true, which attempts to mute them globally",
          "params": {
            "LocalUserNum": "the user that is muting the remote talker",
            "PlayerId": "the remote talker that is being muted",
            "bIsSystemWide": "whether to try to mute them globally or not"
          }
        },
        "RegisterLocalTalker": {
          "comment": "Registers the user as a talker",
          "params": {
            "LocalUserNum": "the local player index that is a talker"
          }
        },
        "RegisterRemoteTalker": {
          "comment": "Registers a remote player as a talker",
          "params": {
            "PlayerId": "the unique id of the remote player that is a talker"
          }
        },
        "SelectVocabulary": {
          "comment": "Changes the vocabulary id that is currently being used",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "VocabularyId": "the new id to use"
          }
        },
        "SetRemoteTalkerPriority": {
          "comment": "Sets the relative priority for a remote talker. 0 is highest",
          "params": {
            "LocalUserNum": "the user that controls the relative priority",
            "PlayerId": "the remote talker that is having their priority changed for",
            "Priority": "the relative priority to use (0 highest, < 0 is muted)"
          }
        },
        "SetSpeechRecognitionObject": {
          "comment": "Changes the object that is in use to the one specified",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "SpeechRecogObj": "the new object use",
            "true": "if successful, false otherwise"
          }
        },
        "StartNetworkedVoice": {
          "comment": "Tells the voice layer that networked processing of the voice data is allowed\n for the specified player. This allows for push-to-talk style voice communication",
          "params": {
            "LocalUserNum": "the local user to allow network transimission for"
          }
        },
        "StartSpeechRecognition": {
          "comment": "Tells the voice system to start tracking voice data for speech recognition",
          "params": {
            "LocalUserNum": "the local user to recognize voice data for"
          }
        },
        "StopNetworkedVoice": {
          "comment": "Tells the voice layer to stop processing networked voice support for the\n specified player. This allows for push-to-talk style voice communication",
          "params": {
            "LocalUserNum": "the local user to disallow network transimission for"
          }
        },
        "StopSpeechRecognition": {
          "comment": "Tells the voice system to stop tracking voice data for speech recognition",
          "params": {
            "LocalUserNum": "the local user to recognize voice data for"
          }
        },
        "UnmuteAll": {
          "comment": "Allows all speakers to send voice",
          "params": {
            "LocalUserNum": "the local user that is making the change"
          }
        },
        "UnmuteRemoteTalker": {
          "comment": "Allows a remote talker to talk to the specified local player. NOTE: This only unmutes them in the\n game unless the bIsSystemWide flag is true, which attempts to unmute them globally",
          "params": {
            "LocalUserNum": "the user that is allowing the remote talker to talk",
            "PlayerId": "the remote talker that is being restored to talking",
            "bIsSystemWide": "whether to try to unmute them globally or not"
          }
        },
        "UnregisterLocalTalker": {
          "comment": "Unregisters the user as a talker",
          "params": {
            "LocalUserNum": "the local player index to be removed"
          }
        },
        "UnregisterRemoteTalker": {
          "comment": "Unregisters a remote player as a talker",
          "params": {
            "PlayerId": "the unique id of the remote player to be removed"
          }
        }
      }
    },
    "ParticleEmitter": {
      "properties": {
        "bCookedOut": {
          "comment": "If TRUE, then this emitter was 'cooked out' by the cooker. \n This means it was completely disabled, but to preserve any\n indexing schemes, it is left in place."
        },
        "bIsSoloing": {
          "comment": "If TRUE, then show only this emitter in the editor"
        },
        "bCollapsed": {
          "comment": "This value indicates the emitter should be drawn 'collapsed' in Cascade"
        },
        "EmitterEditorColor": {
          "comment": "The color of the emitter in the curve editor and debug rendering modes."
        },
        "EmitterRenderMode": {
          "comment": "How to render the emitter particles. Can be one of the following:\n ERM_Normal - As the intended sprite/mesh\n ERM_Point - As a 2x2 pixel block with no scaling and the color set in EmitterEditorColor\n ERM_Cross - As a cross of lines, scaled to the size of the particle in EmitterEditorColor\n ERM_None - Do not render"
        },
        "EmitterName": {
          "comment": "The name of the emitter."
        },
        "InitialAllocationCount": {
          "comment": "Initial allocation count - overrides calculated peak count if > 0"
        },
        "MediumDetailSpawnRateScale": {
          "comment": "Scales the spawn rate of this emitter when the engine is running in medium or low detail mode.\n This can be used to optimize particle draw cost in splitscreen.\n A value of 0 effectively disables this emitter outside of high detail mode,\n And this does not affect spawn per unit, unless the value is 0."
        }
      },
      "functions": {
        "GetMaxLifespan": {
          "comment": "Get the longest possible lifespan for this emitter.",
          "params": {
            "InComponentDelay": "The delay from the component using the emitter"
          }
        }
      },
      "structs": {
        "ParticleBurst": {
          "properties": {
            "Count": {
              "comment": "The number of particles to burst"
            },
            "CountLow": {
              "comment": "If >= 0, use as a range [CountLow..Count]"
            },
            "Time": {
              "comment": "The time at which to burst them (0..1: emitter lifetime)"
            }
          }
        }
      }
    },
    "ParticleEventManager": {
      "functions": {
        "HandleParticleModuleEventSendToGame": {
          "comment": "Needs to be overridden by game classes"
        }
      }
    },
    "ParticleLightEnvironmentComponent": {
      "properties": {
        "bAllowDLESharing": {
          "comment": "Whether this DLE can be shared by particle components of the same actor."
        },
        "NumPooledReuses": {
          "comment": "Number of different particle components this particle light environment has been used by."
        },
        "ReferenceCount": {
          "comment": "Reference count used to know when this light environment can be detached and cleaned up since it may be shared by multiple particle system components."
        },
        "SharedInstigator": {
          "comment": "Lit particle components created from the emitter pool will only share particle DLE's if they have matching SharedInstigator's."
        },
        "SharedParticleSystem": {
          "comment": "Lit particle components created from the emitter pool will only share particle DLE's if they have matching SharedParticleSystem's."
        }
      }
    },
    "ParticleLODLevel": {
      "properties": {
        "bEnabled": {
          "comment": "True if the LOD level is enabled, meaning it should be updated and rendered."
        },
        "EventGenerator": {
          "comment": "The optional EventGenerator module."
        },
        "EventReceiverModules": {
          "comment": "Event receiver modules only!"
        },
        "Level": {
          "comment": "The index value of the LOD level"
        },
        "Modules": {
          "comment": "An array of particle modules that contain the adjusted data for the LOD level"
        },
        "OrbitModules": {
          "comment": "OrbitModules \n These are used to do offsets of the sprite from the particle location."
        },
        "RequiredModule": {
          "comment": "The required module for this LOD level"
        },
        "SpawningModules": {
          "comment": "SpawningModules - These are called to determine how many particles to spawn."
        },
        "SpawnModule": {
          "comment": "The SpawnRate/Burst module - required by all emitters."
        },
        "SpawnModules": {
          "comment": "SpawnModules - These are called when particles are spawned."
        },
        "UpdateModules": {
          "comment": "UpdateModules - These are called when particles are updated."
        }
      }
    },
    "ParticleModule": {
      "properties": {
        "bCurvesAsColor": {
          "comment": "If TRUE, the module displays vector curves as colors"
        },
        "bEditable": {
          "comment": "If TRUE, the module has had editing enabled on it"
        },
        "bEnabled": {
          "comment": "If TRUE, the module is enabled"
        },
        "bFinalUpdateModule": {
          "comment": "If TRUE, the module performs operations on particles during final update"
        },
        "bRequiresLoopingNotification": {
          "comment": "If TRUE, the module should be told when looping"
        },
        "bSpawnModule": {
          "comment": "If TRUE, the module performs operations on particles during Spawning"
        },
        "bSupported3DDrawMode": {
          "comment": "If TRUE, the module supports rendering a 3D visualization helper"
        },
        "bSupportsRandomSeed": {
          "comment": "If TRUE, the module supports RandomSeed setting"
        },
        "bUpdateModule": {
          "comment": "If TRUE, the module performs operations on particles during Updating"
        },
        "LODDuplicate": {
          "comment": "If TRUE, this flag indicates that auto-generation for LOD will result in\n an exact duplicate of the module, regardless of the percentage.\n If FALSE, it will result in a module with different settings."
        },
        "LODValidity": {
          "comment": "The LOD levels this module is present in.\n Bit-flags are used to indicate validity for a given LOD level.\n For example, if\n ((1 << Level) & LODValidity) != 0\n then the module is used in that LOD."
        },
        "b3DDrawMode": {
          "comment": "If TRUE, the module should render its 3D visualization helper"
        },
        "ModuleEditorColor": {
          "comment": "The color to draw the modules curves in the curve editor. \n If bCurvesAsColor is TRUE, it overrides this value."
        }
      },
      "structs": {
        "ParticleRandomSeedInfo": {
          "comment": "Sequential - select a particle in order",
          "properties": {
            "bGetSeedFromInstance": {
              "comment": "If TRUE, the module will attempt to get the seed from the owner\n instance. If that fails, it will fall back to getting it from\n the RandomSeeds array."
            },
            "bInstanceSeedIsIndex": {
              "comment": "If TRUE, the seed value retrieved from teh instance will be an\n index into the array of seeds."
            },
            "bResetSeedOnEmitterLooping": {
              "comment": "If TRUE, then reset the seed upon the emitter looping.\n For looping environmental effects this should likely be set to FALSE to avoid\n a repeating pattern."
            },
            "ParameterName": {
              "comment": "The name to expose to the placed instances for setting this seed"
            },
            "RandomSeeds": {
              "comment": "The random seed values to utilize for the module. \n More than 1 means the instance will randomly select one."
            }
          }
        }
      }
    },
    "ParticleModuleAcceleration": {
      "properties": {
        "Acceleration": {
          "comment": "The initial acceleration of the particle.\n Value is obtained using the EmitterTime at particle spawn.\n Each frame, the current and base velocity of the particle \n is then updated using the formula \n velocity += acceleration * DeltaTime\n where DeltaTime is the time passed since the last frame."
        },
        "bApplyOwnerScale": {
          "comment": "If true, then apply the particle system components scale \n to the acceleration value."
        }
      }
    },
    "ParticleModuleAccelerationBase": {
      "properties": {
        "bAlwaysInWorldSpace": {
          "comment": "If true, then treat the acceleration as world-space"
        }
      }
    },
    "ParticleModuleAccelerationOverLifetime": {
      "properties": {
        "AccelOverLife": {
          "comment": "The acceleration of the particle over its lifetime.\n Value is obtained using the RelativeTime of the partice.\n The current and base velocity values of the particle \n are then updated using the formula \n velocity += acceleration* DeltaTime\n where DeltaTime is the time passed since the last frame."
        }
      }
    },
    "ParticleModuleAttractorLine": {
      "properties": {
        "EndPoint0": {
          "comment": "The first endpoint of the line."
        },
        "EndPoint1": {
          "comment": "The second endpoint of the line."
        },
        "Range": {
          "comment": "The range of the line attractor."
        },
        "Strength": {
          "comment": "The strength of the line attractor."
        }
      }
    },
    "ParticleModuleAttractorParticle": {
      "properties": {
        "bAffectBaseVelocity": {
          "comment": "If TRUE, the velocity adjustment will be applied to the base velocity."
        },
        "bInheritSourceVel": {
          "comment": "Whether the particle should inherit the source veloctiy if it expires."
        },
        "bRenewSource": {
          "comment": "Whether the particle should grab a new particle if it's source expires."
        },
        "bStrengthByDistance": {
          "comment": "The strength curve is a function of distance or of time."
        },
        "EmitterName": {
          "comment": "The source emitter for attractors"
        },
        "Range": {
          "comment": "The radial range of the attraction around the source particle.\n Particle-life relative."
        },
        "Strength": {
          "comment": "The strength of the attraction (negative values repel).\n Particle-life relative if StrengthByDistance is false."
        },
        "SelectionMethod": {
          "comment": "The method to use when selecting an attractor target particle from the emitter.\n One of the following:\n Random - Randomly select a particle from the source emitter. \n Sequential - Select a particle using a sequential order."
        }
      }
    },
    "ParticleModuleAttractorPoint": {
      "properties": {
        "bAffectBaseVelocity": {
          "comment": "If TRUE, the velocity adjustment will be applied to the base velocity."
        },
        "bOverrideVelocity": {
          "comment": "If TRUE, set the velocity."
        },
        "bUseWorldSpacePosition": {
          "comment": "If TRUE, treat the position as world space. So don't transform the the point to localspace."
        },
        "Position": {
          "comment": "The position of the point attractor from the source of the emitter."
        },
        "Range": {
          "comment": "The radial range of the attractor."
        },
        "Strength": {
          "comment": "The strength of the point attractor."
        },
        "StrengthByDistance": {
          "comment": "The strength curve is a function of distance or of time."
        }
      }
    },
    "ParticleModuleBeamModifier": {
      "properties": {
        "ModifierType": {
          "comment": "Whether this module modifies the Source or the Target."
        },
        "Position": {
          "comment": "The value to use when modifying the position."
        },
        "PositionOptions": {
          "comment": "The options associated with the position."
        },
        "Strength": {
          "comment": "The value to use when modifying the Strength."
        },
        "StrengthOptions": {
          "comment": "The options associated with the Strength."
        },
        "bAbsoluteTangent": {
          "comment": "If TRUE, don't transform the tangent modifier into the tangent basis."
        },
        "Tangent": {
          "comment": "The value to use when modifying the Tangent."
        },
        "TangentOptions": {
          "comment": "The options associated with the Tangent."
        }
      },
      "structs": {
        "BeamModifierOptions": {
          "properties": {
            "bLock": {
              "comment": "If TRUE, lock the modifier to the life of the particle."
            },
            "bModify": {
              "comment": "If TRUE, modify the value associated with this grouping."
            },
            "bScale": {
              "comment": "If TRUE, scale the associated value by the given value."
            }
          }
        }
      }
    },
    "ParticleModuleBeamNoise": {
      "properties": {
        "bNoiseLock": {
          "comment": "INTERNAL - Whether the noise points should be locked."
        },
        "bApplyNoiseScale": {
          "comment": "If TRUE, apply the noise scale to the beam."
        },
        "bLowFreq_Enabled": {
          "comment": "Is low frequency noise enabled."
        },
        "bNRScaleEmitterTime": {
          "comment": "If TRUE, the NoiseRangeScale will be grabbed based on the emitter time.\n If FALSE, the NoiseRangeScale will be grabbed based on the particle time."
        },
        "bOscillate": {
          "comment": "Whether the noise points should be oscillate."
        },
        "bSmooth": {
          "comment": "Whether the noise movement should be smooth or 'jerky'."
        },
        "bTargetNoise": {
          "comment": "Whether to apply noise to the target point (or end of line in distance mode...)\n If TRUE, the beam could potentially 'leave' the target..."
        },
        "bUseNoiseTangents": {
          "comment": "If TRUE, calculate tangents at each noise point."
        },
        "Frequency": {
          "comment": "The frequency of noise points."
        },
        "FrequencyDistance": {
          "comment": "The distance at which to deposit noise points.\n If 0.0, then use the static frequency value.\n If not, distribute noise points at the given distance, up to the static Frequency value.\n At that point, evenly distribute them along the beam."
        },
        "Frequency_LowRange": {
          "comment": "If not 0, then the frequency will select a random value in the range\n [Frequency_LowRange..Frequency]"
        },
        "NoiseLockRadius": {
          "comment": "Default target-point information to use if the beam method is endpoint."
        },
        "NoiseLockTime": {
          "comment": "How long the noise points should be locked - 0.0 indicates forever."
        },
        "NoiseRange": {
          "comment": "The noise point ranges."
        },
        "NoiseRangeScale": {
          "comment": "A scale factor that will be applied to the noise range."
        },
        "NoiseScale": {
          "comment": "The scale factor to apply to noise range.\n The lookup value is determined by dividing the number of noise points present by the \n maximum number of noise points (Frequency)."
        },
        "NoiseSpeed": {
          "comment": "The speed with which to move each noise point."
        },
        "NoiseTangentStrength": {
          "comment": "The strength of noise tangents, if enabled."
        },
        "NoiseTension": {
          "comment": "The tension to apply to the tessellated noise line."
        },
        "NoiseTessellation": {
          "comment": "The amount of tessellation between noise points."
        }
      }
    },
    "ParticleModuleBeamSource": {
      "properties": {
        "bLockSource": {
          "comment": "Whether to lock the source to the life of the particle."
        },
        "bLockSourceStength": {
          "comment": "Whether to lock the source to the life of the particle."
        },
        "bLockSourceTangent": {
          "comment": "Whether to lock the source to the life of the particle."
        },
        "bSourceAbsolute": {
          "comment": "Whether to treat the as an absolute position in world space."
        },
        "Source": {
          "comment": "Default source-point to use."
        },
        "SourceMethod": {
          "comment": "The method flag."
        },
        "SourceName": {
          "comment": "The strength of the tangent from the source point for each beam."
        },
        "SourceStrength": {
          "comment": "The strength of the tangent from the source point for each beam."
        },
        "SourceTangent": {
          "comment": "The tangent for the source point for each beam."
        },
        "SourceTangentMethod": {
          "comment": "The method to use for the source tangent."
        }
      }
    },
    "ParticleModuleBeamTarget": {
      "properties": {
        "bLockTarget": {
          "comment": "Whether to lock the Target to the life of the particle."
        },
        "bLockTargetStength": {
          "comment": "Whether to lock the Target to the life of the particle."
        },
        "bLockTargetTangent": {
          "comment": "Whether to lock the Target to the life of the particle."
        },
        "bTargetAbsolute": {
          "comment": "Whether to treat the as an absolute position in world space."
        },
        "LockRadius": {
          "comment": "Default target-point information to use if the beam method is endpoint."
        },
        "Target": {
          "comment": "Default target-point information to use if the beam method is endpoint."
        },
        "TargetMethod": {
          "comment": "The method flag."
        },
        "TargetName": {
          "comment": "The target point sources of each beam, when using the end point method."
        },
        "TargetStrength": {
          "comment": "The strength of the tangent from the Target point for each beam."
        },
        "TargetTangent": {
          "comment": "The tangent for the Target point for each beam."
        },
        "TargetTangentMethod": {
          "comment": "The method to use for the Target tangent."
        }
      }
    },
    "ParticleModuleCameraOffset": {
      "properties": {
        "bSpawnTimeOnly": {
          "comment": "If TRUE, the offset will only be processed at spawn time"
        },
        "CameraOffset": {
          "comment": "The camera-relative offset to apply to sprite location"
        },
        "UpdateMethod": {
          "comment": "How to update the offset for this module.\n DirectSet - Set the value directly (overwrite any previous setting)\n Additive - Add the offset of this module to the existing offset\n Scalar - Scale the existing offset by the value of this module"
        }
      }
    },
    "ParticleModuleCollision": {
      "properties": {
        "bApplyPhysics": {
          "comment": "If TRUE, physic will be applied between a particle and the \n object it collides with. \n This is one-way - particle --> object. The particle does \n not have physics applied to it - it just generates an \n impulse applied to the object it collides with."
        },
        "bOnlyVerticalNormalsDecrementCount": {
          "comment": "If TRUE, then collisions that do not have a vertical hit \n normal will still react, but UsedMaxCollisions count will \n not be decremented. (ie., They don't 'count' as collisions)\n Useful for having particles come to rest on floors."
        },
        "bPawnsDoNotDecrementCount": {
          "comment": "If TRUE, then collisions with Pawns will still react, but \n the UsedMaxCollisions count will not be decremented. \n (ie., They don't 'count' as collisions)"
        },
        "CollisionCompletionOption": {
          "comment": "What to do once a particles MaxCollisions is reached.\n One of the following:\n EPCC_Kill\n Kill the particle when MaxCollisions is reached\n EPCC_Freeze\n Freeze in place, NO MORE UPDATES\n EPCC_HaltCollisions,\n Stop collision checks, keep updating everything\n EPCC_FreezeTranslation,\n Stop translations, keep updating everything else\n EPCC_FreezeRotation,\n Stop rotations, keep updating everything else\n EPCC_FreezeMovement\n Stop all movement, keep updating"
        },
        "DampingFactor": {
          "comment": "How much to `slow' the velocity of the particle after a collision.\n Value is obtained using the EmitterTime at particle spawn."
        },
        "DampingFactorRotation": {
          "comment": "How much to `slow' the rotation of the particle after a collision.\n Value is obtained using the EmitterTime at particle spawn."
        },
        "DelayAmount": {
          "comment": "How long to delay before checking a particle for collisions.\n Value is retrieved using the EmitterTime.\n During update, the particle flag IgnoreCollisions will be \n set until the particle RelativeTime has surpassed the \n DelayAmount."
        },
        "DirScalar": {
          "comment": "The directional scalar value - used to scale the bounds to \n 'assist' in avoiding inter-penetration or large gaps."
        },
        "MaxCollisions": {
          "comment": "The maximum number of collisions a particle can have. \n Value is obtained using the EmitterTime at particle spawn."
        },
        "ParticleMass": {
          "comment": "The mass of the particle - for use when bApplyPhysics is TRUE. \n Value is obtained using the EmitterTime at particle spawn."
        },
        "VerticalFudgeFactor": {
          "comment": "The fudge factor to use to determine vertical.\n True vertical will have a Hit.Normal.Z == 1.0\n This will allow for Z components in the range of\n [1.0-VerticalFudgeFactor..1.0]\n to count as vertical collisions."
        },
        "bDropDetail": {
          "comment": "If TRUE, when the WorldInfo.bDropDetail flag is set, the module will be ignored."
        }
      }
    },
    "ParticleModuleCollisionActor": {
      "properties": {
        "ActorsToCollideWith": {
          "comment": "List of actor parameter names (set on the placed instance) that this particle emitter should collide against"
        },
        "bCheckPawnCollisions": {
          "comment": "If TRUE, then collide with any pawns as well"
        }
      }
    },
    "ParticleModuleColor": {
      "properties": {
        "bClampAlpha": {
          "comment": "If TRUE, the alpha value will be clamped to the [0..1] range."
        },
        "StartAlpha": {
          "comment": "Initial alpha for a particle as a function of Emitter time."
        },
        "StartColor": {
          "comment": "Initial color for a particle as a function of Emitter time."
        }
      }
    },
    "ParticleModuleColorByParameter": {
      "properties": {
        "ColorParam": {
          "comment": "The name of the parameter to retrieve the color from."
        },
        "DefaultColor": {
          "comment": "The default color to use in the even that the parameter is not set on the emitter."
        }
      }
    },
    "ParticleModuleColorOverLife": {
      "properties": {
        "AlphaOverLife": {
          "comment": "The alpha to apply to the particle, as a function of the particle RelativeTime."
        },
        "bClampAlpha": {
          "comment": "If TRUE, the alpha value will be clamped to the [0..1] range."
        },
        "ColorOverLife": {
          "comment": "The color to apply to the particle, as a function of the particle RelativeTime."
        }
      }
    },
    "ParticleModuleColorScaleOverDensity": {
      "properties": {
        "AlphaScaleOverDensity": {
          "comment": "The alpha to apply to the particle, as a function of the particle Density."
        },
        "ColorScaleOverDensity": {
          "comment": "The color to apply to the particle, as a function of the particle Density."
        }
      }
    },
    "ParticleModuleColorScaleOverLife": {
      "properties": {
        "AlphaScaleOverLife": {
          "comment": "The scale factor for the alpha."
        },
        "bEmitterTime": {
          "comment": "Whether it is EmitterTime or ParticleTime related."
        },
        "ColorScaleOverLife": {
          "comment": "The scale factor for the color."
        }
      }
    },
    "ParticleModuleColor_Seeded": {
      "properties": {
        "RandomSeedInfo": {
          "comment": "The random seed(s) to use for looking up values in StartLocation"
        }
      }
    },
    "ParticleModuleEventGenerator": {
      "structs": {
        "ParticleEvent_GenerateInfo": {
          "properties": {
            "CustomName": {
              "comment": "Should the event tag with a custom name? Leave blank for the default."
            },
            "FirstTimeOnly": {
              "comment": "Only fire the first time (collision only)."
            },
            "Frequency": {
              "comment": "How often to trigger the event (<= 1 means EVERY time)."
            },
            "LastTimeOnly": {
              "comment": "Only fire the last time (collision only)."
            },
            "LowFreq": {
              "comment": "Frequency range? (-1 indicates no - else [LowFreq..Frequency]."
            },
            "ParticleFrequency": {
              "comment": "How often to trigger the event per particle (<= 1 means EVERY time) (collision only)."
            },
            "ParticleModuleEventsToSendToGame": {
              "comment": "The events we want to fire off when this event has been generated"
            },
            "Type": {
              "comment": "The type of event."
            },
            "UseReflectedImpactVector": {
              "comment": "Use the impact vector not the hit normal (collision only)."
            }
          }
        }
      }
    },
    "ParticleModuleEventReceiverBase": {
      "properties": {
        "EventGeneratorType": {
          "comment": "The type of event that will generate the kill."
        },
        "EventName": {
          "comment": "The name of the emitter of interest for generating the event."
        }
      }
    },
    "ParticleModuleEventReceiverKillParticles": {
      "properties": {
        "bStopSpawning": {
          "comment": "If TRUE, stop this emitter from spawning as well."
        }
      }
    },
    "ParticleModuleEventReceiverSpawn": {
      "properties": {
        "bUsePSysLocation": {
          "comment": "If TRUE, use the location of the particle system component for spawning.\n if FALSE (default), use the location of the particle event."
        },
        "bUseParticleTime": {
          "comment": "For Death-based event receiving, if this is TRUE, it indicates that the \n ParticleTime of the event should be used to look-up the SpawnCount.\n Otherwise (and in all other events received), use the emitter time of \n the event."
        },
        "SpawnCount": {
          "comment": "The number of particles to spawn."
        },
        "bInheritVelocity": {
          "comment": "If TRUE, use the velocity of the dying particle as the start velocity of \n the spawned particle."
        },
        "InheritVelocityScale": {
          "comment": "If bInheritVelocity is TRUE, scale the velocity with this."
        }
      }
    },
    "ParticleModuleEventSendToGame": {
      "functions": {
        "DoEvent": {
          "comment": "This is our function to allow subclasses to \"do the event action\""
        }
      }
    },
    "ParticleModuleKillBox": {
      "properties": {
        "bAbsolute": {
          "comment": "If TRUE, the box coordinates are in world space./"
        },
        "bKillInside": {
          "comment": "If TRUE, particles INSIDE the box will be killed. \n If FALSE (the default), particles OUTSIDE the box will be killed."
        },
        "LowerLeftCorner": {
          "comment": "The lower left corner of the box."
        },
        "UpperRightCorner": {
          "comment": "The upper right corner of the box."
        }
      }
    },
    "ParticleModuleKillHeight": {
      "properties": {
        "bAbsolute": {
          "comment": "If TRUE, the height should be treated as a world-space position."
        },
        "bApplyPSysScale": {
          "comment": "If TRUE, take the particle systems scale into account"
        },
        "bFloor": {
          "comment": "If TRUE, the plane should be considered a floor - ie kill anything BELOW it.\n If FALSE, if is a ceiling - ie kill anything ABOVE it."
        },
        "Height": {
          "comment": "The height at which to kill the particle."
        }
      }
    },
    "ParticleModuleLifetime": {
      "properties": {
        "Lifetime": {
          "comment": "The lifetime of the particle, in seconds. Retrieved using the EmitterTime at the spawn of the particle."
        }
      }
    },
    "ParticleModuleLifetime_Seeded": {
      "properties": {
        "RandomSeedInfo": {
          "comment": "The random seed(s) to use for looking up values in StartLocation"
        }
      }
    },
    "ParticleModuleLocation": {
      "properties": {
        "StartLocation": {
          "comment": "The location the particle should be emitted, relative to the emitter.\n Retrieved using the EmitterTime at the spawn of the particle."
        }
      }
    },
    "ParticleModuleLocationBoneSocket": {
      "properties": {
        "bOrientMeshEmitters": {
          "comment": "If TRUE, rotate mesh emitter meshes to orient w/ the socket"
        },
        "bUpdatePositionEachFrame": {
          "comment": "If TRUE, update the particle locations each frame with that of the bone/socket"
        },
        "EditorSkelMesh": {
          "comment": "The name of the skeletal mesh to use in the editor"
        },
        "SelectionMethod": {
          "comment": "The method by which to select the bone/socket to spawn at.\n SEL_Sequential - loop through the bone/socket array in order\n SEL_Random - randomly select a bone/socket from the array\n SEL_RandomExhaustive - randomly select a bone/socket, but never the same one twice until all have been used, then reset"
        },
        "SkelMeshActorParamName": {
          "comment": "The parameter name of the skeletal mesh actor that supplies the SkelMeshComponent for in-game."
        },
        "SourceLocations": {
          "comment": "The name(s) of the bone/socket(s) to position at"
        },
        "SourceType": {
          "comment": "Whether the module uses Bones or Sockets for locations.\n BONESOCKETSOURCE_Bones - Use Bones as the source locations.\n BONESOCKETSOURCE_Sockets - Use Sockets as the source locations."
        },
        "UniversalOffset": {
          "comment": "An offset to apply to each bone/socket"
        }
      },
      "structs": {
        "LocationBoneSocketInfo": {
          "properties": {
            "BoneSocketName": {
              "comment": "The name of the bone/socket on the skeletal mesh"
            },
            "Offset": {
              "comment": "The offset from the bone/socket to use"
            }
          }
        }
      }
    },
    "ParticleModuleLocationDirect": {
      "properties": {
        "Direction": {
          "comment": "Currently unused."
        },
        "Location": {
          "comment": "The location of the particle at a give time. Retrieved using the particle RelativeTime. \n IMPORTANT: the particle location is set to this value, thereby over-writing any previous module impacts."
        },
        "LocationOffset": {
          "comment": "An offset to apply to the position retrieved from the Location calculation. \n The offset is retrieved using the EmitterTime. \n The offset will remain constant over the life of the particle."
        },
        "ScaleFactor": {
          "comment": "Scales the velocity of the object at a given point in the time-line."
        }
      }
    },
    "ParticleModuleLocationEmitter": {
      "properties": {
        "bInheritSourceRotation": {
          "comment": "If TRUE, the spawned particle should inherit the rotation of the source particle."
        },
        "EmitterName": {
          "comment": "The name of the emitter to use that the source location for particle."
        },
        "InheritSourceRotationScale": {
          "comment": "Amount to scale the source rotation by when inheriting it."
        },
        "InheritSourceVelocity": {
          "comment": "If TRUE, the spawned particle should inherit the velocity of the source particle."
        },
        "InheritSourceVelocityScale": {
          "comment": "Amount to scale the source velocity by when inheriting it."
        },
        "SelectionMethod": {
          "comment": "The method to use when selecting a spawn target particle from the emitter.\n Can be one of the following:\n ELESM_Random Randomly select a particle from the source emitter.\n ELESM_Sequential Step through each particle from the source emitter in order."
        }
      }
    },
    "ParticleModuleLocationEmitterDirect": {
      "properties": {
        "EmitterName": {
          "comment": "The name of the emitter to use as a source for the location of the particles."
        }
      }
    },
    "ParticleModuleLocationPrimitiveBase": {
      "properties": {
        "Negative_X": {
          "comment": "If TRUE, the negative X axis is valid for spawning."
        },
        "Negative_Y": {
          "comment": "If TRUE, the negative Y axis is valid for spawning."
        },
        "Negative_Z": {
          "comment": "If TRUE, the negative Zaxis is valid for spawning."
        },
        "Positive_X": {
          "comment": "If TRUE, the positive X axis is valid for spawning."
        },
        "Positive_Y": {
          "comment": "If TRUE, the positive Y axis is valid for spawning."
        },
        "Positive_Z": {
          "comment": "If TRUE, the positive Z axis is valid for spawning."
        },
        "StartLocation": {
          "comment": "The location of the bounding primitive relative to the position of the emitter."
        },
        "SurfaceOnly": {
          "comment": "If TRUE, particles will only spawn on the surface of the primitive."
        },
        "Velocity": {
          "comment": "If TRUE, the particle should get its velocity from the position within the primitive."
        },
        "VelocityScale": {
          "comment": "The scale applied to the velocity. (Only used if 'Velocity' is checked)."
        }
      }
    },
    "ParticleModuleLocationPrimitiveCylinder": {
      "properties": {
        "HeightAxis": {
          "comment": "Determines particle particle system axis that should represent the height of the cylinder.\n Can be one of the following:\n PMLPC_HEIGHTAXIS_X Orient the height along the particle system X-axis.\n PMLPC_HEIGHTAXIS_Y Orient the height along the particle system Y-axis.\n PMLPC_HEIGHTAXIS_Z Orient the height along the particle system Z-axis."
        },
        "RadialVelocity": {
          "comment": "If TRUE, get the particle velocity form the radial distance inside the primitive."
        },
        "StartHeight": {
          "comment": "The height of the cylinder, centered about the location."
        },
        "StartRadius": {
          "comment": "The radius of the cylinder."
        }
      }
    },
    "ParticleModuleLocationPrimitiveCylinder_Seeded": {
      "properties": {
        "RandomSeedInfo": {
          "comment": "The random seed(s) to use for looking up values in StartLocation"
        }
      }
    },
    "ParticleModuleLocationPrimitiveSphere": {
      "properties": {
        "StartRadius": {
          "comment": "The radius of the sphere. Retrieved using EmitterTime."
        }
      }
    },
    "ParticleModuleLocationPrimitiveSphere_Seeded": {
      "properties": {
        "RandomSeedInfo": {
          "comment": "The random seed(s) to use for looking up values in StartLocation"
        }
      }
    },
    "ParticleModuleLocationSkelVertSurface": {
      "properties": {
        "NormalCheckTolerance": {
          "comment": "Normal tolerance. Value between 1.0 and -1.0 with 1.0 being exact match, 0.0 being everything up to"
        },
        "bEnforceNormalCheck": {
          "comment": "When TRUE use the RestrictToNormal and NormalTolerance values to check surface normals"
        },
        "bOrientMeshEmitters": {
          "comment": "If TRUE, rotate mesh emitter meshes to orient w/ the vert/surface"
        },
        "bUpdatePositionEachFrame": {
          "comment": "If TRUE, update the particle locations each frame with that of the vert/surface"
        },
        "EditorSkelMesh": {
          "comment": "The name of the skeletal mesh to use in the editor"
        },
        "NormalCheckToleranceDegrees": {
          "comment": "Normal tolerance. 0 degrees means it must be an exact match, 180 degrees means it can be any angle."
        },
        "NormalToCompare": {
          "comment": "Use this normal to restrict spawning locations"
        },
        "SkelMeshActorParamName": {
          "comment": "The parameter name of the skeletal mesh actor that supplies the SkelMeshComponent for in-game."
        },
        "SourceType": {
          "comment": "Whether the module uses Verts or Surfaces for locations.\n VERTSURFACESOURCE_Vert - Use Verts as the source locations.\n VERTSURFACESOURCE_Surface - Use Surfaces as the source locations."
        },
        "UniversalOffset": {
          "comment": "An offset to apply to each vert/surface"
        },
        "ValidAssociatedBones": {
          "comment": "This module will only spawn from verts or surfaces associated with the bones in this list"
        },
        "ValidMaterialIndices": {
          "comment": "Array of material indices that are valid materials to spawn from.\n If empty, any material will be considered valid"
        }
      }
    },
    "ParticleModuleLocation_Seeded": {
      "properties": {
        "RandomSeedInfo": {
          "comment": "The random seed(s) to use for looking up values in StartLocation"
        }
      }
    },
    "ParticleModuleMaterialByParameter": {
      "properties": {
        "DefaultMaterials": {
          "comment": "The default materials to use when the MaterialParameter is not found."
        },
        "MaterialParameters": {
          "comment": "For Sprite and SubUV emitters only the first entry in these arrays will be valid. \n For Mesh emitters the code will try to match the order of the materials to the ones in the mesh material arrays.\n \n @see UParticleModuleMaterialByParameter::Update"
        }
      }
    },
    "ParticleModuleMeshMaterial": {
      "properties": {
        "MeshMaterials": {
          "comment": "The array of materials to apply to the mesh particles."
        }
      }
    },
    "ParticleModuleMeshRotation": {
      "properties": {
        "bInheritParent": {
          "comment": "If TRUE, apply the parents rotation as well."
        },
        "StartRotation": {
          "comment": "Initial rotation in ROTATIONS PER SECOND (1 = 360 degrees).\n The value is retrieved using the EmitterTime."
        }
      }
    },
    "ParticleModuleMeshRotationRate": {
      "properties": {
        "StartRotationRate": {
          "comment": "Initial rotation rate, in rotations per second.\n The value is retrieved using the EmitterTime."
        }
      }
    },
    "ParticleModuleMeshRotationRateMultiplyLife": {
      "properties": {
        "LifeMultiplier": {
          "comment": "The scale factor that should be applied to the rotation rate.\n The value is retrieved using the RelativeTime of the particle."
        }
      }
    },
    "ParticleModuleMeshRotationRateOverLife": {
      "properties": {
        "bScaleRotRate": {
          "comment": "If TRUE, scale the current rotation rate by the value retrieved.\n Otherwise, set the rotation rate to the value retrieved."
        },
        "RotRate": {
          "comment": "The rotation rate desired.\n The value is retrieved using the RelativeTime of the particle."
        }
      }
    },
    "ParticleModuleMeshRotationRate_Seeded": {
      "properties": {
        "RandomSeedInfo": {
          "comment": "The random seed(s) to use for looking up values in StartLocation"
        }
      }
    },
    "ParticleModuleMeshRotation_Seeded": {
      "properties": {
        "RandomSeedInfo": {
          "comment": "The random seed(s) to use for looking up values in StartLocation"
        }
      }
    },
    "ParticleModuleOrbit": {
      "properties": {
        "ChainMode": {
          "comment": "Orbit modules will chain together in the order they appear in the module stack.\n The combination of a module with the one prior to it is defined by using one\n of the following enumerations:\n EOChainMode_Add Add the values to the previous results\n EOChainMode_Scale Multiply the values by the previous results\n EOChainMode_Link 'Break' the chain and apply the values from the previous results"
        },
        "OffsetAmount": {
          "comment": "The amount to offset the sprite from the particle position."
        },
        "OffsetOptions": {
          "comment": "The options associated with the OffsetAmount look-up."
        },
        "RotationAmount": {
          "comment": "The amount (in 'turns') to rotate the offset about the particle position.\n 0.0 = no rotation\n 0.5 = 180 degree rotation\n 1.0 = 360 degree rotation"
        },
        "RotationOptions": {
          "comment": "The options associated with the RotationAmount look-up."
        },
        "RotationRateAmount": {
          "comment": "The rate (in 'turns') at which to rotate the offset about the particle positon.\n 0.0 = no rotation\n 0.5 = 180 degree rotation\n 1.0 = 360 degree rotation"
        },
        "RotationRateOptions": {
          "comment": "The options associated with the RotationRateAmount look-up."
        }
      },
      "structs": {
        "OrbitOptions": {
          "comment": "Container struct for holding options on the data updating for the module.",
          "properties": {
            "bProcessDuringSpawn": {
              "comment": "Whether to process the data during spawning."
            },
            "bProcessDuringUpdate": {
              "comment": "Whether to process the data during updating."
            },
            "bUseEmitterTime": {
              "comment": "Whether to use emitter time during data retrieval."
            }
          }
        }
      }
    },
    "ParticleModuleOrbitBase": {
      "properties": {
        "bUseEmitterTime": {
          "comment": "If TRUE, distribution values will be retrieved using the EmitterTime.\n If FALSE (default), they will be retrieved using the Particle.RelativeTime."
        }
      }
    },
    "ParticleModuleOrientationAxisLock": {
      "properties": {
        "LockAxisFlags": {
          "comment": "The lock axis flag setting.\n Can be one of the following:\n EPAL_NONE No locking to an axis.\n EPAL_X Lock the sprite facing towards +X.\n EPAL_Y Lock the sprite facing towards +Y.\n EPAL_Z Lock the sprite facing towards +Z.\n EPAL_NEGATIVE_X Lock the sprite facing towards -X.\n EPAL_NEGATIVE_Y Lock the sprite facing towards -Y.\n EPAL_NEGATIVE_Z Lock the sprite facing towards -Z.\n EPAL_ROTATE_X Lock the sprite rotation on the X-axis.\n EPAL_ROTATE_Y Lock the sprite rotation on the Y-axis.\n EPAL_ROTATE_Z Lock the sprite rotation on the Z-axis."
        }
      }
    },
    "ParticleModuleParameterDynamic": {
      "properties": {
        "DynamicParams": {
          "comment": "The dynamic parameters this module uses."
        }
      },
      "structs": {
        "EmitterDynamicParameter": {
          "comment": "Helper structure for displaying the parameter.",
          "properties": {
            "bScaleVelocityByParamValue": {
              "comment": "If TRUE, scale the velocity value selected in ValueMethod by the evaluated ParamValue."
            },
            "bSpawnTimeOnly": {
              "comment": "If TRUE, only set the value at spawn time of the particle, otherwise update each frame."
            },
            "bUseEmitterTime": {
              "comment": "If TRUE, use the EmitterTime to retrieve the value, otherwise use Particle RelativeTime."
            },
            "ParamName": {
              "comment": "The parameter name - from the material DynamicParameter expression. READ-ONLY"
            },
            "ParamValue": {
              "comment": "The distriubtion for the parameter value."
            },
            "ValueMethod": {
              "comment": "Where to get the parameter value from."
            }
          }
        }
      }
    },
    "ParticleModuleParameterDynamic_Seeded": {
      "properties": {
        "RandomSeedInfo": {
          "comment": "The random seed(s) to use for looking up values in StartLocation"
        }
      }
    },
    "ParticleModuleRequired": {
      "properties": {
        "bDirectUV": {
          "comment": "SUB-UV RELATIVE INTERNAL MEMBERS"
        },
        "bRequiresSorting": {
          "comment": "Whether this emitter requires sorting as specified by artist."
        },
        "BurstList": {
          "comment": "The array of burst entries."
        },
        "DownsampleThresholdScreenFraction": {
          "comment": "Fraction of the screen that the particle system's bounds must be larger than for the emitter to be rendered downsampled.\n The default is 0, which means downsampling is not allowed. \n A value of .5 means that the particle system's bounds must take up half of the screen or more before the emitter will be rendered at a lower resolution.\n Downsampled translucency renders significantly faster than full resolution, except that there is a fairly large constant overhead for every emitter that is downsampled.\n For this reason, it's best to only use downsampling on emitters that are known to have a fillrate cost larger than the constant overhead. \n A value of .5 is usually a good tradeoff when downsampling is desired.\n The quality of downsampled translucency is also affected, high frequency details will be lost and opaque edges in front of the translucency will appear more aliased.\n Note: This functionality uses the bounding radius so it's important that the particle system's bounds are accurate, use bUseFixedRelativeBoundingBox if necessary."
        },
        "ParticleBurstMethod": {
          "comment": "The method to utilize when burst-emitting particles"
        },
        "RandomImageTime": {
          "comment": "The amount of time (particle-relative, 0.0 to 1.0) to 'lock' on a random sub image\n 0.0 = change every frame\n 1.0 = select a random image at spawn and hold for the life of the particle"
        },
        "SpawnRate": {
          "comment": "The rate at which to spawn particles"
        },
        "bDelayFirstLoopOnly": {
          "comment": "If TRUE, the emitter will be delayed only on the first loop."
        },
        "bEmitterDelayUseRange": {
          "comment": "If TRUE, select the emitter delay from the range \n [EmitterDelayLow..EmitterDelay]"
        },
        "EmitterDelay": {
          "comment": "Indicates the time (in seconds) that this emitter should be delayed in the particle system."
        },
        "EmitterDelayLow": {
          "comment": "The low end of the emitter delay if using a range."
        },
        "bDurationRecalcEachLoop": {
          "comment": "If TRUE, recalculate the emitter duration on each loop."
        },
        "bEmitterDurationUseRange": {
          "comment": "If TRUE, select the emitter duration from the range \n [EmitterDurationLow..EmitterDuration]"
        },
        "EmitterDuration": {
          "comment": "How long, in seconds, the emitter will run before looping.\n If set to 0, the emitter will never loop."
        },
        "EmitterDurationLow": {
          "comment": "The low end of the emitter duration if using a range."
        },
        "EmitterLoops": {
          "comment": "The number of times to loop the emitter.\n 0 indicates loop continuously"
        },
        "bKillOnCompleted": {
          "comment": "If TRUE, kill the emitter when it completes"
        },
        "bKillOnDeactivate": {
          "comment": "If TRUE, kill the emitter when the particle system is deactivated"
        },
        "bUseLegacyEmitterTime": {
          "comment": "If TRUE, the EmitterTime for the emitter will be calculated by\n modulating the SecondsSinceCreation by the EmitterDuration. As\n this can lead to issues w/ looping and variable duration, a new\n approach has been implemented. \n If FALSE, this new approach is utilized, and the EmitterTime is\n simply incremented by DeltaTime each tick. When the emitter \n loops, it adjusts the EmitterTime by the current EmitterDuration\n resulting in proper looping/delay behavior."
        },
        "bUseLocalSpace": {
          "comment": "If TRUE, update the emitter in local space"
        },
        "Material": {
          "comment": "The material to utilize for the emitter at this LOD level."
        },
        "ScreenAlignment": {
          "comment": "The screen alignment to utilize for the emitter at this LOD level.\n One of the following:\n PSA_Square - Uniform scale (via SizeX) facing the camera\n PSA_Rectangle - Non-uniform scale (via SizeX and SizeY) facing the camera\n PSA_Velocity - Orient the particle towards both the camera and the direction \n the particle is moving. Non-uniform scaling is allowed.\n PSA_TypeSpecific - Use the alignment method indicated int he type data module."
        },
        "SortMode": {
          "comment": "The sorting mode to use for this emitter.\n PSORTMODE_None - No sorting required.\n PSORTMODE_ViewProjDepth - Sort by view projected depth of the particle.\n PSORTMODE_DistanceToView - Sort by distance of particle to view in world space.\n PSORTMODE_Age_OldestFirst - Sort by age, oldest drawn first.\n PSORTMODE_Age_NewestFirst - Sort by age, newest drawn first."
        },
        "EmitterNormalsMode": {
          "comment": "Normal generation mode for this emitter LOD."
        },
        "NormalsCylinderDirection": {
          "comment": "When EmitterNormalsMode is ENM_Cylindrical, \n particle normals are created to face away from the cylinder going through NormalsSphereCenter in the direction NormalsCylinderDirection. \n NormalsCylinderDirection is in local space."
        },
        "NormalsSphereCenter": {
          "comment": "When EmitterNormalsMode is ENM_Spherical, particle normals are created to face away from NormalsSphereCenter. \n NormalsSphereCenter is in local space."
        },
        "bUseMaxDrawCount": {
          "comment": "If TRUE, use the MaxDrawCount to limit the number of particles rendered.\n NOTE: This does not limit the number spawned/updated, only what is drawn."
        },
        "MaxDrawCount": {
          "comment": "The maximum number of particles to DRAW for this emitter.\n If set to 0, it will use whatever number are present."
        },
        "bScaleUV": {
          "comment": "Whether to scale the UV or not - ie, the model wasn't setup with sub uvs"
        },
        "InterpolationMethod": {
          "comment": "The interpolation method to used for the SubUV image selection.\n One of the following:\n PSUVIM_None - Do not apply SubUV modules to this emitter. \n PSUVIM_Linear - Smoothly transition between sub-images in the given order, \n with no blending between the current and the next\n PSUVIM_Linear_Blend - Smoothly transition between sub-images in the given order, \n blending between the current and the next \n PSUVIM_Random - Pick the next image at random, with no blending between \n the current and the next \n PSUVIM_Random_Blend - Pick the next image at random, blending between the current \n and the next"
        },
        "RandomImageChanges": {
          "comment": "The number of times to change a random image over the life of the particle."
        },
        "SubImages_Horizontal": {
          "comment": "The number of sub-images horizontally in the texture"
        },
        "SubImages_Vertical": {
          "comment": "The number of sub-images vertically in the texture"
        }
      }
    },
    "ParticleModuleRotation": {
      "properties": {
        "StartRotation": {
          "comment": "Initial rotation of the particle (1 = 360 degrees).\n The value is retrieved using the EmitterTime."
        }
      }
    },
    "ParticleModuleRotationOverLifetime": {
      "properties": {
        "RotationOverLife": {
          "comment": "The rotation of the particle (1.0 = 360 degrees).\n The value is retrieved using the RelativeTime of the particle."
        },
        "Scale": {
          "comment": "If TRUE, the particle rotation is multiplied by the value retrieved from RotationOverLife.\n If FALSE, the particle rotation is incremented by the value retrieved from RotationOverLife."
        }
      }
    },
    "ParticleModuleRotationRate": {
      "properties": {
        "StartRotationRate": {
          "comment": "Initial rotation rate, in rotations per second.\n The value is retrieved using the EmitterTime."
        }
      }
    },
    "ParticleModuleRotationRateMultiplyLife": {
      "properties": {
        "LifeMultiplier": {
          "comment": "The scale factor that should be applied to the rotation rate.\n The value is retrieved using the RelativeTime of the particle."
        }
      }
    },
    "ParticleModuleRotationRate_Seeded": {
      "properties": {
        "RandomSeedInfo": {
          "comment": "The random seed(s) to use for looking up values in StartLocation"
        }
      }
    },
    "ParticleModuleRotation_Seeded": {
      "properties": {
        "RandomSeedInfo": {
          "comment": "The random seed(s) to use for looking up values in StartLocation"
        }
      }
    },
    "ParticleModuleSize": {
      "properties": {
        "StartSize": {
          "comment": "The initial size that should be used for a particle.\n The value is retrieved using the EmitterTime during the spawn of a particle.\n It is added to the Size and BaseSize fields of the spawning particle."
        }
      }
    },
    "ParticleModuleSizeMultiplyLife": {
      "properties": {
        "LifeMultiplier": {
          "comment": "The scale factor for the size that should be used for a particle.\n The value is retrieved using the RelativeTime of the particle during its update."
        },
        "MultiplyX": {
          "comment": "If true, the X-component of the scale factor will be applied to the particle size X-component.\n If false, the X-component is left unaltered."
        },
        "MultiplyY": {
          "comment": "If true, the Y-component of the scale factor will be applied to the particle size Y-component.\n If false, the Y-component is left unaltered."
        },
        "MultiplyZ": {
          "comment": "If true, the Z-component of the scale factor will be applied to the particle size Z-component.\n If false, the Z-component is left unaltered."
        }
      }
    },
    "ParticleModuleSizeMultiplyVelocity": {
      "properties": {
        "MultiplyX": {
          "comment": "If true, the X-component of the scale factor will be applied to the particle size X-component.\n If false, the X-component is left unaltered."
        },
        "MultiplyY": {
          "comment": "If true, the Y-component of the scale factor will be applied to the particle size Y-component.\n If false, the Y-component is left unaltered."
        },
        "MultiplyZ": {
          "comment": "If true, the Z-component of the scale factor will be applied to the particle size Z-component.\n If false, the Z-component is left unaltered."
        },
        "VelocityMultiplier": {
          "comment": "The amount the velocity should be scaled prior to scaling the size of the particle. \n The value is retrieved using the RelativeTime of the particle during its update."
        }
      }
    },
    "ParticleModuleSizeScale": {
      "properties": {
        "EnableX": {
          "comment": "Ignored"
        },
        "EnableY": {
          "comment": "Ignored"
        },
        "EnableZ": {
          "comment": "Ignored"
        },
        "SizeScale": {
          "comment": "The amount the BaseSize should be scaled before being used as the size of the particle. \n The value is retrieved using the RelativeTime of the particle during its update.\n NOTE: this module overrides any size adjustments made prior to this module in that frame."
        }
      }
    },
    "ParticleModuleSizeScaleByTime": {
      "properties": {
        "bEnableX": {
          "comment": "If TRUE, scale the X-component of the size."
        },
        "bEnableY": {
          "comment": "If TRUE, scale the Y-component of the size."
        },
        "bEnableZ": {
          "comment": "If TRUE, scale the Z-component of the size."
        },
        "SizeScaleByTime": {
          "comment": "The amount the size should be scaled before being used as the size of the particle. \n The value is retrieved using the ABSOLUTE lifetime of the particle during its update."
        }
      }
    },
    "ParticleModuleSize_Seeded": {
      "properties": {
        "RandomSeedInfo": {
          "comment": "The random seed(s) to use for looking up values in StartLocation"
        }
      }
    },
    "ParticleModuleSourceMovement": {
      "properties": {
        "SourceMovementScale": {
          "comment": "The scale factor to apply to the source movement before adding to the particle location.\n The value is looked up using the particles RELATIVE time [0..1]."
        }
      }
    },
    "ParticleModuleSpawn": {
      "properties": {
        "BurstList": {
          "comment": "The array of burst entries."
        },
        "ParticleBurstMethod": {
          "comment": "The method to utilize when burst-emitting particles."
        },
        "Rate": {
          "comment": "The rate at which to spawn particles."
        },
        "RateScale": {
          "comment": "The scalar to apply to the rate."
        }
      }
    },
    "ParticleModuleSpawnBase": {
      "properties": {
        "bProcessBurstList": {
          "comment": "If TRUE, the BurstList of the SpawnModule of the emitter will be processed.\n If mutliple Spawn modules are 'stacked' in an emitter, if ANY of them \n have this set to FALSE, it will not process the SpawnModule BurstList."
        },
        "bProcessSpawnRate": {
          "comment": "If TRUE, the SpawnRate of the SpawnModule of the emitter will be processed.\n If mutliple Spawn modules are 'stacked' in an emitter, if ANY of them \n have this set to FALSE, it will not process the SpawnModule SpawnRate."
        }
      }
    },
    "ParticleModuleSpawnPerUnit": {
      "properties": {
        "bIgnoreMovementAlongX": {
          "comment": "If TRUE, ignore the X-component of the movement"
        },
        "bIgnoreMovementAlongY": {
          "comment": "If TRUE, ignore the Y-component of the movement"
        },
        "bIgnoreMovementAlongZ": {
          "comment": "If TRUE, ignore the Z-component of the movement"
        },
        "bIgnoreSpawnRateWhenMoving": {
          "comment": "If TRUE, process the default spawn rate when not moving...\n When not moving, skip the default spawn rate.\n If FALSE, return the bProcessSpawnRate setting."
        },
        "MovementTolerance": {
          "comment": "The tolerance for moving vs. not moving w.r.t. the bIgnoreSpawnRateWhenMoving flag.\n Ie, if (DistanceMoved < (UnitScalar x MovementTolerance)) then consider it not moving."
        },
        "SpawnPerUnit": {
          "comment": "The amount to spawn per meter distribution.\n The value is retrieved using the EmitterTime."
        },
        "UnitScalar": {
          "comment": "The scalar to apply to the distance traveled.\n The value from SpawnPerUnit is divided by this value to give the actual\n number of particles per unit."
        }
      }
    },
    "ParticleModuleSubUV": {
      "properties": {
        "bUseRealTime": {
          "comment": "If TRUE, use *real* time when updating the image index.\n The movie will update regardless of the slomo settings of the game."
        },
        "SubImageIndex": {
          "comment": "The index of the sub-image that should be used for the particle.\n The value is retrieved using the RelativeTime of the particles."
        }
      }
    },
    "ParticleModuleSubUVDirect": {
      "properties": {
        "SubUVPosition": {
          "comment": "The upper-left corner of the texture coordinates desired.\n Value is retrieved using RelativeTime of the particle."
        },
        "SubUVSize": {
          "comment": "The size of the texture sample desired.\n Value is retrieved using RelativeTime of the particle."
        }
      }
    },
    "ParticleModuleSubUVMovie": {
      "properties": {
        "bUseEmitterTime": {
          "comment": "If TRUE, use the emitter time to look up the frame rate.\n If FALSE (default), use the particle relative time."
        },
        "FrameRate": {
          "comment": "The frame rate the SubUV images should be 'flipped' thru at."
        },
        "StartingFrame": {
          "comment": "The starting image index for the SubUV (1 = the first frame).\n Assumes order of Left->Right, Top->Bottom\n If greater than the last frame, it will clamp to the last one.\n If 0, then randomly selects a starting frame."
        }
      }
    },
    "ParticleModuleSubUVSelect": {
      "properties": {
        "SubImageSelect": {
          "comment": "The horizontal (X) and vertical (Y) index of the sub-image desired.\n Value is retrieved using the RelativeTime of the particle."
        }
      }
    },
    "ParticleModuleTrailSource": {
      "properties": {
        "bInheritRotation": {
          "comment": "Interhit particle rotation - only valid for SourceMethod of PET2SRCM_Particle."
        },
        "bLockSourceStength": {
          "comment": "Whether to lock the source to the life of the particle."
        },
        "SelectionMethod": {
          "comment": "Particle selection method, when using the SourceMethod of Particle."
        },
        "SourceMethod": {
          "comment": "The source method for the trail."
        },
        "SourceName": {
          "comment": "The name of the source - either the emitter or Actor."
        },
        "SourceOffsetCount": {
          "comment": "SourceOffsetCount\n The number of source offsets that can be expected to be found on the instance.\n These must be named\n TrailSourceOffset#"
        },
        "SourceOffsetDefaults": {
          "comment": "Default offsets from the source(s). \n If there are < SourceOffsetCount slots, the grabbing of values will simply wrap."
        },
        "SourceStrength": {
          "comment": "The strength of the tangent from the source point for each Trail."
        }
      }
    },
    "ParticleModuleTrailSpawn": {
      "properties": {
        "MinSpawnVelocity": {
          "comment": "The minimum velocity the source must be travelling at in order to spawn particles."
        },
        "SpawnDistanceMap": {
          "comment": "This parameter will map a given distance range [MinInput..MaxInput]\n to the given spawn values [MinOutput..MaxOutput]\n Anything below the MinOutput will result in no particles being spawned\n NOTE: The distance travelled is accumulated. If it takes 10 frames to travel the min.\n distance, then MinOutput particles will be spawned every 10 frames...\n IMPORTANT! This type must be a floatparticleparam type, but nothing is forcing it now!"
        }
      }
    },
    "ParticleModuleTrailTaper": {
      "properties": {
        "TaperFactor": {
          "comment": "Tapering factor, 0 = source of beam, 1 = target"
        },
        "TaperMethod": {
          "comment": "Tapering mode"
        }
      }
    },
    "ParticleModuleTypeDataAnimTrail": {
      "properties": {
        "ControlEdgeName": {
          "comment": "The name of the socket that supplied the control edge for this emitter."
        },
        "bRenderGeometry": {
          "comment": "If TRUE, render the trail geometry (this should typically be on)"
        },
        "bRenderSpawnPoints": {
          "comment": "If TRUE, render stars at each spawned particle point along the trail"
        },
        "bRenderTangents": {
          "comment": "If TRUE, render a line showing the tangent at each spawned particle point along the trail"
        },
        "bRenderTessellation": {
          "comment": "If TRUE, render the tessellated path between spawned particles"
        },
        "DistanceTessellationStepSize": {
          "comment": "The distance step size for tessellation.\n # Tessellation Points = Trunc((Distance Between Spawned Particles) / DistanceTessellationStepSize))"
        },
        "TangentTessellationScalar": {
          "comment": "The tangent scalar for tessellation.\n Angles between tangent A and B are mapped to [0.0f .. 1.0f]\n This is then multiplied by TangentTessellationScalar to give the number of points to tessellate"
        },
        "TilingDistance": {
          "comment": "The (estimated) covered distance to tile the 2nd UV set at.\n If 0.0, a second UV set will not be passed in."
        },
        "bClipSourceSegement": {
          "comment": "If true, do not join the trail to the source position"
        },
        "bDeadTrailsOnDeactivate": {
          "comment": "If true, when the system is deactivated, mark trails as dead.\n This means they will still render, but will not have more particles\n added to them, even if the system re-activates..."
        },
        "bEnablePreviousTangentRecalculation": {
          "comment": "If true, recalculate the previous tangent when a new particle is spawned"
        },
        "bTangentRecalculationEveryFrame": {
          "comment": "If true, recalculate tangents every frame to allow velocity/acceleration to be applied"
        },
        "SheetsPerTrail": {
          "comment": "The number of sheets to render for the trail."
        }
      }
    },
    "ParticleModuleTypeDataBeam2": {
      "properties": {
        "bAlwaysOn": {
          "comment": "If true, there will ALWAYS be a beam..."
        },
        "BeamMethod": {
          "comment": "The method with which to form the beam(s). Must be one of the following:\n PEB2M_Distance - Use the distance property to emit a beam along the X-axis of the emitter.\n PEB2M_Target - Emit a beam from the source to the supplied target.\n PEB2M_Branch - Currently unimplemented."
        },
        "InterpolationPoints": {
          "comment": "Indicates whether the beam should be interpolated.\n <= 0 --> no\n > 0 --> yes (and is equal to the number of interpolation steps that should be taken."
        },
        "MaxBeamCount": {
          "comment": "The number of live beams"
        },
        "Sheets": {
          "comment": "The number of sheets to render"
        },
        "Speed": {
          "comment": "The speed at which the beam should move from source to target when firing up.\n '0' indicates instantaneous"
        },
        "TextureTile": {
          "comment": "The number of times to tile the texture along each beam"
        },
        "TextureTileDistance": {
          "comment": "The distance per texture tile"
        },
        "UpVectorStepSize": {
          "comment": "The approach to use for determining the Up vector(s) for the beam.\n 0 indicates that the Up vector should be calculated at EVERY point in the beam.\n 1 indicates a single Up vector should be determined at the start of the beam and used at every point.\n N indicates an Up vector should be calculated every N points of the beam and interpolated between them.\n [NOTE: This mode is currently unsupported.]"
        },
        "BranchParentName": {
          "comment": "The name of the emitter to branch from (if mode is PEB2M_Branch)\n MUST BE IN THE SAME PARTICLE SYSTEM!"
        },
        "Distance": {
          "comment": "The distance along the X-axis to stretch the beam\n Distance is only used if BeamMethod is PEB2M_Distance"
        },
        "TaperFactor": {
          "comment": "Tapering factor, 0 = source of beam, 1 = target"
        },
        "TaperMethod": {
          "comment": "Tapering mode - one of the following:\n PEBTM_None - No tapering is applied\n PEBTM_Full - Taper the beam relative to source-->target, regardless of current beam length\n PEBTM_Partial - Taper the beam relative to source-->location, 0=source,1=endpoint"
        },
        "TaperScale": {
          "comment": "Tapering scaling\n This is intended to be either a constant, uniform or a ParticleParam.\n If a curve is used, 0/1 mapping of source/target... which could be integrated into\n the taper factor itself, and therefore makes no sense."
        }
      },
      "structs": {
        "BeamTargetData": {
          "properties": {
            "TargetName": {
              "comment": "Name of the target."
            },
            "TargetPercentage": {
              "comment": "Percentage chance the target will be selected (100 = always)."
            }
          }
        }
      }
    },
    "ParticleModuleTypeDataMesh": {
      "properties": {
        "CameraFacingUpAxisOption": {
          "comment": "The axis of the mesh to point up when camera facing the X-axis.\n CameraFacing_NoneUP No attempt to face an axis up or down.\n CameraFacing_ZUp Z-axis of the mesh should attempt to point up.\n CameraFacing_NegativeZUp Z-axis of the mesh should attempt to point down.\n CameraFacing_YUp Y-axis of the mesh should attempt to point up.\n CameraFacing_NegativeYUp Y-axis of the mesh should attempt to point down."
        },
        "CastShadows": {
          "comment": "If TRUE, has the meshes cast shadows"
        },
        "DoCollisions": {
          "comment": "UNUSED (the collision module dictates doing collisions)"
        },
        "bApplyParticleRotationAsSpin": {
          "comment": "If TRUE, apply 'sprite' particle rotation about the orientation axis (direction mesh is pointing).\n If FALSE, apply 'sprite' particle rotation about the camera facing axis."
        },
        "bCameraFacing": {
          "comment": "If TRUE, then point the X-axis of the mesh towards the camera.\n When set, AxisLockOption as well as all other locked axis/screen alignment settings are ignored."
        },
        "CameraFacingOption": {
          "comment": "The camera facing option to use:\n All camera facing options without locked axis assume X-axis will be facing the camera.\n XAxisFacing_NoUp - X-axis camera facing, no attempt to face an axis up or down.\n XAxisFacing_ZUp - X-axis camera facing, Z-axis of the mesh should attempt to point up.\n XAxisFacing_NegativeZUp - X-axis camera facing, Z-axis of the mesh should attempt to point down.\n XAxisFacing_YUp - X-axis camera facing, Y-axis of the mesh should attempt to point up.\n XAxisFacing_NegativeYUp - X-axis camera facing, Y-axis of the mesh should attempt to point down.\n All axis-locked camera facing options assume the AxisLockOption is set. EPAL_NONE will be treated as EPAL_X.\n LockedAxis_ZAxisFacing - X-axis locked on AxisLockOption axis, rotate Z-axis of the mesh to face towards camera.\n LockedAxis_NegativeZAxisFacing - X-axis locked on AxisLockOption axis, rotate Z-axis of the mesh to face away from camera.\n LockedAxis_YAxisFacing - X-axis locked on AxisLockOption axis, rotate Y-axis of the mesh to face towards camera.\n LockedAxis_NegativeYAxisFacing - X-axis locked on AxisLockOption axis, rotate Y-axis of the mesh to face away from camera.\n All velocity-aligned options do NOT require the ScreenAlignment be set to PSA_Velocity.\n Doing so will result in additional work being performed... (it will orient the mesh twice).\n VelocityAligned_ZAxisFacing - X-axis aligned to the velocity, rotate the Z-axis of the mesh to face towards camera.\n VelocityAligned_NegativeZAxisFacing - X-axis aligned to the velocity, rotate the Z-axis of the mesh to face away from camera.\n VelocityAligned_YAxisFacing - X-axis aligned to the velocity, rotate the Y-axis of the mesh to face towards camera.\n VelocityAligned_NegativeYAxisFacing - X-axis aligned to the velocity, rotate the Y-axis of the mesh to face away from camera."
        },
        "bAllowMotionBlur": {
          "comment": "Allow this mesh emitter to render using motion blur. This adds a velocity rendering pass"
        },
        "bOverrideMaterial": {
          "comment": "If TRUE, use the emitter material when rendering rather than the one applied \n to the static mesh model."
        },
        "Mesh": {
          "comment": "The static mesh to render at the particle positions"
        },
        "MeshAlignment": {
          "comment": "The alignment to use on the meshes emitted.\n The RequiredModule->ScreenAlignment MUST be set to PSA_TypeSpecific to use.\n One of the following:\n PSMA_MeshFaceCameraWithRoll\n Face the camera allowing for rotation around the mesh-to-camera vector \n (amount provided by the standard particle sprite rotation). \n PSMA_MeshFaceCameraWithSpin\n Face the camera allowing for the mesh to rotate about the tangential axis. \n PSMA_MeshFaceCameraWithLockedAxis\n Face the camera while maintaining the up vector as the locked direction."
        },
        "AxisLockOption": {
          "comment": "The axis to lock the mesh on. This overrides TypeSpecific mesh alignment as well as the LockAxis module.\n EPAL_NONE - No locking to an axis.\n EPAL_X - Lock the mesh X-axis facing towards +X.\n EPAL_Y - Lock the mesh X-axis facing towards +Y.\n EPAL_Z - Lock the mesh X-axis facing towards +Z.\n EPAL_NEGATIVE_X - Lock the mesh X-axis facing towards -X.\n EPAL_NEGATIVE_Y - Lock the mesh X-axis facing towards -Y.\n EPAL_NEGATIVE_Z - Lock the mesh X-axis facing towards -Z.\n EPAL_ROTATE_X - Ignored for mesh emitters. Treated as EPAL_NONE.\n EPAL_ROTATE_Y - Ignored for mesh emitters. Treated as EPAL_NONE.\n EPAL_ROTATE_Z - Ignored for mesh emitters. Treated as EPAL_NONE."
        },
        "Pitch": {
          "comment": "The 'pre' rotation pitch (in degrees) to apply to the static mesh used."
        },
        "Roll": {
          "comment": "The 'pre' rotation roll (in degrees) to apply to the static mesh used."
        },
        "Yaw": {
          "comment": "The 'pre' rotation yaw (in degrees) to apply to the static mesh used."
        }
      }
    },
    "ParticleModuleTypeDataMeshPhysX": {
      "properties": {
        "RenderInstance": {
          "comment": "Non-exposed reference to emitter instance used for fast rendering. \nSupports combined, instanced rendering for all emitter instances \nsharing this module."
        },
        "PhysXParSys": {
          "comment": "Actual wrapper for NxFluid PhsyX SDK object"
        },
        "VerticalLod": {
          "comment": "Parameters for Vertical LOD: See ParticleModuleTypeDataPhysX.uc"
        }
      }
    },
    "ParticleModuleTypeDataPhysX": {
      "properties": {
        "PhysXParSys": {
          "comment": "Actual wrapper for NxFluid PhsyX SDK object"
        }
      },
      "structs": {
        "PhysXEmitterVerticalLodProperties": {
          "comment": "Configuration parameters for LOD behaviour",
          "properties": {
            "RelativeFadeoutTime": {
              "comment": "Defines the fraction of the particle lifetime that is used for \nearly fading out. This setting should correspond with \nthe time span which is used to fade out particles, reducing \nsize or opacity. Range: [0,1]"
            },
            "SpawnLodRateVsLifeBias": {
              "comment": "Bias for spawn time LOD. Range: [0,1]\n1.0: spawn volume reduction by culling spawned particles. \n0.0: spawn volume reduction by lowering particle lifetimes."
            },
            "WeightForFifo": {
              "comment": "Priority for removing old particles from this emitter.\nRelative low values give other emitters precedence for giving \nup old particles."
            },
            "WeightForSpawnLod": {
              "comment": "Priority for spawn time particle culling and lifetime reduction.\nRelative low values give other emitters precedence for dropping \nparticles and reducing lifetimes at spawn time."
            }
          }
        }
      }
    },
    "ParticleModuleTypeDataRibbon": {
      "properties": {
        "MaxTessellationBetweenParticles": {
          "comment": "The maximum amount to tessellate between two particles of the trail. \n Depending on the distance between the particles and the tangent change, the \n system will select a number of tessellation points \n [0..MaxTessellationBetweenParticles]"
        },
        "bRenderGeometry": {
          "comment": "If TRUE, render the trail geometry (this should typically be on)"
        },
        "bRenderSpawnPoints": {
          "comment": "If TRUE, render stars at each spawned particle point along the trail"
        },
        "bRenderTangents": {
          "comment": "If TRUE, render a line showing the tangent at each spawned particle point along the trail"
        },
        "bRenderTessellation": {
          "comment": "If TRUE, render the tessellated path between spawned particles"
        },
        "DistanceTessellationStepSize": {
          "comment": "The distance step size for tessellation.\n # Tessellation Points = Trunc((Distance Between Spawned Particles) / DistanceTessellationStepSize))"
        },
        "TangentTessellationScalar": {
          "comment": "The tangent scalar for tessellation.\n Angles between tangent A and B are mapped to [0.0f .. 1.0f]\n This is then multiplied by TangentTessellationScalar to give the number of points to tessellate"
        },
        "TilingDistance": {
          "comment": "The (estimated) covered distance to tile the 2nd UV set at.\n If 0.0, a second UV set will not be passed in."
        },
        "TangentSpawningScalar": {
          "comment": "The tangent scalar for spawning.\n Angles between tangent A and B are mapped to [0.0f .. 1.0f]\n This is then multiplied by TangentTessellationScalar to give the number of particles to spawn"
        },
        "bClipSourceSegement": {
          "comment": "If true, do not join the trail to the source position"
        },
        "bDeadTrailsOnDeactivate": {
          "comment": "If true, when the system is deactivated, mark trails as dead.\n This means they will still render, but will not have more particles\n added to them, even if the system re-activates..."
        },
        "bDeadTrailsOnSourceLoss": {
          "comment": "If true, when the source of a trail is 'lost' (ie, the source particle\n dies), mark the current trail as dead."
        },
        "bEnablePreviousTangentRecalculation": {
          "comment": "If true, recalculate the previous tangent when a new particle is spawned"
        },
        "bTangentRecalculationEveryFrame": {
          "comment": "If true, recalculate tangents every frame to allow velocity/acceleration to be applied"
        },
        "MaxParticleInTrailCount": {
          "comment": "Max particles per trail"
        },
        "MaxTrailCount": {
          "comment": "The number of live trails"
        },
        "RenderAxis": {
          "comment": "The 'render' axis for the trail (what axis the trail is stretched out on)\n Trails_CameraUp - Traditional camera-facing trail.\n Trails_SourceUp - Use the up axis of the source for each spawned particle.\n Trails_WorldUp - Use the world up axis."
        },
        "SheetsPerTrail": {
          "comment": "The number of sheets to render for the trail."
        }
      }
    },
    "ParticleModuleTypeDataTrail2": {
      "properties": {
        "Sheets": {
          "comment": "The number of sheets to render"
        },
        "TessellationFactorDistance": {
          "comment": "The distance between particles for full TessellationFactor"
        },
        "bClearTangents": {
          "comment": "If true, clear the tangents (old bug behavior)\n This is present to preserve existing content..."
        },
        "bClipSourceSegement": {
          "comment": "If true, do not join the trail to the source position"
        },
        "MaxParticleInTrailCount": {
          "comment": "Max particles per trail"
        },
        "MaxTrailCount": {
          "comment": "The number of live trails"
        },
        "TessellationFactor": {
          "comment": "The tessellation amount to use for each trail"
        },
        "TessellationStrength": {
          "comment": "The strength to apply to the tangents"
        },
        "TextureTile": {
          "comment": "The number of times to tile the texture along each trail"
        }
      }
    },
    "ParticleModuleUberBase": {
      "properties": {
        "RequiredModules": {
          "comment": "Required modules"
        }
      }
    },
    "ParticleModuleUberLTISIVCL": {
      "properties": {
        "AlphaOverLife": {
          "comment": "AlphaOverLife - Gives the alpha to apply to the particles"
        },
        "ColorOverLife": {
          "comment": "ColorOverLife - Gives the color to apply to the particles"
        },
        "Lifetime": {
          "comment": "Lifetime - Gives the lifetime of the particles"
        },
        "StartSize": {
          "comment": "Size - Gives the size of the particles"
        },
        "StartVelocity": {
          "comment": "StartVelociy - Gives the start velocity of the particles"
        },
        "StartVelocityRadial": {
          "comment": "StartRadialVelociy - Gives the start radial velocity of the particles"
        }
      }
    },
    "ParticleModuleUberLTISIVCLIL": {
      "properties": {
        "AlphaOverLife": {
          "comment": "AlphaOverLife - Gives the alpha to apply to the particles"
        },
        "ColorOverLife": {
          "comment": "ColorOverLife - Gives the color to apply to the particles"
        },
        "Lifetime": {
          "comment": "Lifetime - Gives the lifetime of the particles"
        },
        "StartLocation": {
          "comment": "StartLocation - Gives the start location of particles"
        },
        "StartSize": {
          "comment": "Size - Gives the size of the particles"
        },
        "StartVelocity": {
          "comment": "StartVelociy - Gives the start velocity of the particles"
        },
        "StartVelocityRadial": {
          "comment": "StartRadialVelociy - Gives the start radial velocity of the particles"
        }
      }
    },
    "ParticleModuleUberLTISIVCLILIRSSBLIRR": {
      "properties": {
        "AlphaOverLife": {
          "comment": "AlphaOverLife - Gives the alpha to apply to the particles"
        },
        "ColorOverLife": {
          "comment": "ColorOverLife - Gives the color to apply to the particles"
        },
        "Lifetime": {
          "comment": "Lifetime - Gives the lifetime of the particles"
        },
        "StartLocation": {
          "comment": "StartLocation - Gives the start location of particles"
        },
        "StartRotation": {
          "comment": "StartRotation - Gives the rotation of particles in turns (1 = 360 degrees)"
        },
        "StartRotationRate": {
          "comment": "StartRotationRate - Gives the rotation rate of particles in turns per second"
        },
        "SizeLifeMultiplier": {
          "comment": "SizeLifeMultiplier - Size scale factor"
        },
        "SizeMultiplyX": {
          "comment": "MultiplyX - If TRUE, scale along the X size axis"
        },
        "SizeMultiplyY": {
          "comment": "MultiplyY - If TRUE, scale along the Y size axis"
        },
        "SizeMultiplyZ": {
          "comment": "MultiplyZ - If TRUE, scale along the Z size axis"
        },
        "StartSize": {
          "comment": "Size - Gives the size of the particles"
        },
        "StartVelocity": {
          "comment": "StartVelociy - Gives the start velocity of the particles"
        },
        "StartVelocityRadial": {
          "comment": "StartRadialVelociy - Gives the start radial velocity of the particles"
        }
      }
    },
    "ParticleModuleUberRainDrops": {
      "properties": {
        "ColorOverLife": {
          "comment": "ColorOverLife Module Members"
        },
        "LifetimeMin": {
          "comment": "Lifetime Module Members"
        },
        "bIsUsingCylinder": {
          "comment": "PrimitiveCylinder Module Members"
        },
        "StartLocationMin": {
          "comment": "Location Module Members"
        },
        "StartSizeMin": {
          "comment": "Size Module Members"
        },
        "StartVelocityMin": {
          "comment": "Velocity Module Members"
        }
      }
    },
    "ParticleModuleUberRainImpacts": {
      "properties": {
        "ColorOverLife": {
          "comment": "ColorOverLife Module Members"
        },
        "Lifetime": {
          "comment": "Lifetime Module Members"
        },
        "bIsUsingCylinder": {
          "comment": "PrimitiveCylinder Module Members"
        },
        "StartRotation": {
          "comment": "MeshRotation Module Members"
        },
        "LifeMultiplier": {
          "comment": "SizeByLife Module Members"
        },
        "StartSize": {
          "comment": "Size Module Members"
        }
      }
    },
    "ParticleModuleUberRainSplashA": {
      "properties": {
        "ColorOverLife": {
          "comment": "ColorOverLife Module Members"
        },
        "Lifetime": {
          "comment": "Lifetime Module Members"
        },
        "StartRotation": {
          "comment": "MeshRotation Module Members"
        },
        "LifeMultiplier": {
          "comment": "SizeByLife Module Members"
        },
        "StartSize": {
          "comment": "Size Module Members"
        }
      }
    },
    "ParticleModuleUberRainSplashB": {
      "properties": {
        "ColorOverLife": {
          "comment": "ColorOverLife Module Members"
        },
        "Lifetime": {
          "comment": "Lifetime Module Members"
        },
        "StartRotationRate": {
          "comment": "Initial RotationRate Module Members"
        },
        "LifeMultiplier": {
          "comment": "SizeByLife Module Members"
        },
        "StartSize": {
          "comment": "Size Module Members"
        }
      }
    },
    "ParticleModuleVelocity": {
      "properties": {
        "StartVelocity": {
          "comment": "The velocity to apply to a particle when it is spawned.\n Value is retrieved using the EmitterTime of the emitter."
        },
        "StartVelocityRadial": {
          "comment": "The velocity to apply to a particle along its radial direction.\n Direction is determined by subtracting the location of the emitter from the particle location at spawn.\n Value is retrieved using the EmitterTime of the emitter."
        }
      }
    },
    "ParticleModuleVelocityBase": {
      "properties": {
        "bApplyOwnerScale": {
          "comment": "If true, then apply the particle system components scale to the velocity value."
        },
        "bInWorldSpace": {
          "comment": "If true, then treat the velocity as world-space defined.\n NOTE: LocalSpace emitters that are moving will see strange results..."
        }
      }
    },
    "ParticleModuleVelocityInheritParent": {
      "properties": {
        "Scale": {
          "comment": "The scale to apply tot he parent velocity prior to adding it to the particle velocity during spawn.\n Value is retrieved using the EmitterTime of the emitter."
        }
      }
    },
    "ParticleModuleVelocityOverLifetime": {
      "properties": {
        "Absolute": {
          "comment": "If true, the velocity will be SET to the value from the above dist.\n If false, the velocity will be scaled by the above dist."
        },
        "VelOverLife": {
          "comment": "The scaling value applied to the velocity.\n Value is retrieved using the RelativeTime of the particle."
        }
      }
    },
    "ParticleModuleVelocity_Seeded": {
      "properties": {
        "RandomSeedInfo": {
          "comment": "The random seed(s) to use for looking up values in StartLocation"
        }
      }
    },
    "ParticleSystem": {
      "properties": {
        "BackgroundColor": {
          "comment": "The background color to display in Cascade"
        },
        "bHasPhysics": {
          "comment": "Set during load time to indicate that physics is used..."
        },
        "bLit": {
          "comment": "Deprecated, ParticleSystemLOD::bLit is used instead."
        },
        "bRegenerateLODDuplicate": {
          "comment": "Internal value that tracks the regenerate LOD levels preference.\n If TRUE, when autoregenerating LOD levels in code, the low level will\n be a duplicate of the high."
        },
        "bShouldResetPeakCounts": {
          "comment": "EDITOR ONLY: Indicates that Cascade would like to have the PeakActiveParticles count reset"
        },
        "CurveEdSetup": {
          "comment": "Used for curve editor to remember curve-editing setup."
        },
        "EditorLODSetting": {
          "comment": "LOD setting for intepolation (set by Cascade) Range [0..100]"
        },
        "Emitters": {
          "comment": "Emitters - internal - the array of emitters in the system"
        },
        "PreviewComponent": {
          "comment": "The component used to preview the particle system in Cascade"
        },
        "ThumbnailAngle": {
          "comment": "The angle to use when rendering the thumbnail image"
        },
        "ThumbnailDistance": {
          "comment": "The distance to place the system when rendering the thumbnail image"
        },
        "ThumbnailImage": {
          "comment": "Internal: The PSys thumbnail image"
        },
        "ThumbnailImageOutOfDate": {
          "comment": "Internal: Indicates the PSys thumbnail image is out of date"
        },
        "UpdateTime_Delta": {
          "comment": "UpdateTime_Delta - internal"
        },
        "bUseFixedRelativeBoundingBox": {
          "comment": "Whether to use the fixed relative bounding box or calculate it every frame."
        },
        "FixedRelativeBoundingBox": {
          "comment": "Fixed relative bounding box for particle system."
        },
        "bUseDelayRange": {
          "comment": "If TRUE, select the emitter delay from the range \n [DelayLow..Delay]"
        },
        "Delay": {
          "comment": "How long this Particle system should delay when ActivateSystem is called on it."
        },
        "DelayLow": {
          "comment": "The low end of the emitter delay if using a range."
        },
        "LODDistanceCheckTime": {
          "comment": "How often (in seconds) the system should perform the LOD distance check."
        },
        "LODDistances": {
          "comment": "The array of distances for each LOD level in the system.\n Used when LODMethod is set to PARTICLESYSTEMLODMETHOD_Automatic.\n Example: System with 3 LOD levels\n LODDistances(0) = 0.0\n LODDistances(1) = 2500.0\n LODDistances(2) = 5000.0\n In this case, when the system is [ 0.0 .. 2499.9] from the camera, LOD level 0 will be used.\n [2500.0 .. 4999.9] from the camera, LOD level 1 will be used.\n [5000.0 .. INFINITY] from the camera, LOD level 2 will be used."
        },
        "LODMethod": {
          "comment": "The method of LOD level determination to utilize for this particle system\n PARTICLESYSTEMLODMETHOD_Automatic - Automatically set the LOD level, checking every LODDistanceCheckTime seconds.\n PARTICLESYSTEMLODMETHOD_DirectSet - LOD level is directly set by the game code.\n PARTICLESYSTEMLODMETHOD_ActivateAutomatic - LOD level is determined at Activation time, then left alone unless directly set by game code."
        },
        "MacroUVPosition": {
          "comment": "Local space position that UVs generated with the ParticleMacroUV material node will be centered on."
        },
        "MacroUVRadius": {
          "comment": "World space radius that UVs generated with the ParticleMacroUV material node will tile based on."
        },
        "bUseMobilePointSprites": {
          "comment": "For mobile only, whether to use point sprite rendering to speed up particle rendering"
        },
        "CustomOcclusionBounds": {
          "comment": "The occlusion bounds to use if OcclusionBoundsMethod is set to EPSOBM_CustomBounds"
        },
        "OcclusionBoundsMethod": {
          "comment": "Which occlusion bounds method to use for this particle system.\n EPSOBM_None - Don't determine occlusion for this system.\n EPSOBM_ParticleBounds - Use the bounds of the component when determining occlusion."
        },
        "bOrientZAxisTowardCamera": {
          "comment": "If true, the system's Z axis will be oriented toward the camera"
        },
        "bSkipSpawnCountCheck": {
          "comment": "When TRUE, do NOT perform the spawning limiter check.\n Intended for effects used in pre-rendered cinematics."
        },
        "SecondsBeforeInactive": {
          "comment": "Number of seconds of emitter not being rendered that need to pass before it\n no longer gets ticked/ becomes inactive."
        },
        "SystemUpdateMode": {
          "comment": "FixedTime - update via a fixed time step"
        },
        "UpdateTime_FPS": {
          "comment": "UpdateTime_FPS - the frame per second to update at in FixedTime mode"
        },
        "WarmupTime": {
          "comment": "WarmupTime - the time to warm-up the particle system when first rendered"
        },
        "bUseRealtimeThumbnail": {
          "comment": "Inidicates the old 'real-time' thumbnail rendering should be used"
        },
        "ThumbnailWarmup": {
          "comment": "The time to warm-up the system for the thumbnail image"
        }
      },
      "functions": {
        "GetCurrentLODMethod": {
          "comment": "Return the currently set LOD method"
        },
        "GetLODDistance": {
          "comment": "Return the distance for the given LOD level"
        },
        "GetLODLevelCount": {
          "comment": "Return the number of LOD levels for this particle system"
        },
        "GetMaxLifespan": {
          "comment": "Get the longest possible lifespan for this particle system.",
          "params": {
            "InComponentDelay": "The delay from the component using the emitter"
          }
        },
        "SetCurrentLODMethod": {
          "comment": "Set the LOD method"
        },
        "SetLODDistance": {
          "comment": "Set the distance for the given LOD index"
        }
      },
      "structs": {
        "LODSoloTrack": {
          "comment": "Temporary array for tracking 'solo' emitter mode.\n Entry will be true if emitter was enabled"
        },
        "ParticleSystemLOD": {
          "comment": "Structure containing per-LOD settings that pertain to the entire UParticleSystem.",
          "properties": {
            "bLit": {
              "comment": "Boolean to indicate whether the particle system accepts lights or not.\n This must not be changed in-game, it can only be changed safely in the editor through Cascade."
            }
          }
        }
      }
    },
    "ParticleSystemComponent": {
      "properties": {
        "AccumLODDistanceCheckTime": {
          "comment": "LOD updating..."
        },
        "AccumTickTime": {
          "comment": "Used to accumulate total tick time to determine whether system can be skipped ticking if not visible."
        },
        "bDeferredBeamUpdate": {
          "comment": "Set this to TRUE to have beam emitters defer their update until the data is being passed to the render thread."
        },
        "bForcedInActive": {
          "comment": "This is set when any of our \"don't tick me\" timeout values have fired"
        },
        "bIsActive": {
          "comment": "INTERNAL\n Set to TRUE when InitParticles has been called.\n Set to FALSE when ResetParticles has been called.\n Used to quick-out of Tick and Render calls\n (when caching PSysComps and emitter instances)."
        },
        "bIsCachedInPool": {
          "comment": "bCanBeCachedInPool\n If this is true, when the PSC completes it will do the following:\n bHidden = TRUE\n This is used for Particles which are cached in a pool where you need\n to make certain to NOT kill off the EmitterInstances so we do not\n re allocate.\n @see ActivateSystem() where it rewinds the indiv emitters if they need it"
        },
        "bIsViewRelevanceDirty": {
          "comment": "If TRUE, the ViewRelevanceFlags are dirty and should be recached"
        },
        "bIsWarmingUp": {
          "comment": "This is set when the particle system component is warming up"
        },
        "bJustAttached": {
          "comment": "Indicates that the component has not been ticked since being attached."
        },
        "bRecacheViewRelevance": {
          "comment": "If TRUE, the VRF were updated and should be passed to the proxy."
        },
        "bSkipBoundsUpdate": {
          "comment": "Flag indicating that the bounds should not be updated for the particle system.\n Should only be used when the particle system is being ticked in a controlled environment."
        },
        "bSkipSpawnCountCheck": {
          "comment": "Check the spawn count and govern if needed"
        },
        "bSkipUpdateDynamicDataDuringTick": {
          "comment": "Flag indicating that dynamic updating of render data should NOT occur during Tick.\n This is used primarily to allow for warming up and simulated effects to a certain state."
        },
        "bUpdateComponentInTick": {
          "comment": "Set this to TRUE to have the PSysComponent update during the tick if 'dirty'."
        },
        "bUpdateOnDedicatedServer": {
          "comment": "whether to update the particle system on dedicated servers"
        },
        "CachedViewRelevanceFlags": {
          "comment": "The view relevance flags for each LODLevel."
        },
        "CollisionEvents": {
          "comment": "The Collision events that occurred in this PSysComp."
        },
        "DeathEvents": {
          "comment": "The Death events that occurred in this PSysComp."
        },
        "EditorLODLevel": {
          "comment": "INTERNAL. Used by the editor to set the LODLevel"
        },
        "EmitterDelay": {
          "comment": "This is created at start up and then added to each emitter"
        },
        "KismetEvents": {
          "comment": "The Kismet events that occurred for this PSysComp."
        },
        "LightEnvironmentClass": {
          "comment": "Class of the light environment that will get created for lit particle systems."
        },
        "LightEnvironmentSharedInstigator": {
          "comment": "Lit particle components created from the emitter pool will only share particle DLE's if they have matching SharedInstigator's."
        },
        "MaxLightEnvironmentPooledReuses": {
          "comment": "Limit on the number of particle components that can reuse the same particle light environment. \n This controls the trade off between performance and particle lighting update rate."
        },
        "MaxTimeBeforeForceUpdateTransform": {
          "comment": "Time between forced UpdateTransforms for systems that use dynamically calculated bounds,\n Which is effectively how often the bounds are shrunk."
        },
        "ReleaseResourcesFence": {
          "comment": "Command fence used to shut down properly"
        },
        "ReplayClipIDNumber": {
          "comment": "Clip ID number we're either playing back or capturing to, depending on the value of ReplayState."
        },
        "ReplayFrameIndex": {
          "comment": "The current replay frame for playback"
        },
        "ReplayState": {
          "comment": "Current particle 'replay state'. This setting controls whether we're currently simulating/rendering particles normally, or whether we should capture or playback particle replay data instead."
        },
        "SkelMeshComponents": {
          "comment": "The skeletal mesh components used with the socket location module.\n This is to prevent them from being garbage collected."
        },
        "SMComponents": {
          "comment": "The static mesh components for a mesh emitter.\n This is to prevent the SMCs from being garbage collected."
        },
        "SMMaterialInterfaces": {
          "comment": "The static mesh MaterialInterfaces for a mesh emitter.\n This is to prevent them from being garbage collected."
        },
        "SpawnEvents": {
          "comment": "The Spawn events that occurred in this PSysComp."
        },
        "TimeSinceLastForceUpdateTransform": {
          "comment": "Tracks the time since the last forced UpdateTransform."
        },
        "ViewMBInfoArray": {
          "comment": "Emitter instance motion blur info stored per view"
        },
        "bOverrideLODMethod": {
          "comment": "indicates that the component's LODMethod overrides the Template's"
        },
        "LODMethod": {
          "comment": "The method of LOD level determination to utilize for this particle system"
        },
        "bAutoActivate": {
          "comment": "If true, activate on creation."
        },
        "CustomTimeDilation": {
          "comment": "Scales DeltaTime in UParticleSystemComponent::Tick(...)"
        },
        "InstanceParameters": {
          "comment": "Array holding name instance parameters for this ParticleSystemComponent.\n Parameters can be used in Cascade using DistributionFloat/VectorParticleParameters."
        },
        "ReplayClips": {
          "comment": "Array of replay clips for this particle system component. These are serialized to disk. You really should never add anything to this in the editor. It's exposed so that you can delete clips if you need to, but be careful when doing so!"
        },
        "SecondsBeforeInactive": {
          "comment": "Number of seconds of emitter not being rendered that need to pass before it\n no longer gets ticked/ becomes inactive."
        }
      },
      "functions": {
        "ClearParameter": {
          "comment": "clears the specified parameter, returning it to the default value set in the template",
          "params": {
            "ParameterName": "name of parameter to remove",
            "ParameterType": "type of parameter to remove; if omitted or PSPT_None is specified, all parameters with the given name are removed"
          }
        },
        "DetermineLODLevelForLocation": {
          "comment": "This will determine which LOD to use based off the specific ParticleSystem passed in\n and the distance to where that PS is being displayed.\n NOTE: This is distance based LOD not perf based. Perf and distance are orthogonal concepts."
        },
        "GetActorParameter": {
          "comment": "Retrieve the Actor parameter value for the given name.",
          "params": {
            "InName": "Name of the parameter",
            "OutActor": "The value of the parameter found"
          }
        },
        "GetColorParameter": {
          "comment": "Retrieve the Color parameter value for the given name.",
          "params": {
            "InName": "Name of the parameter",
            "OutColor": "The value of the parameter found"
          }
        },
        "GetFloatParameter": {
          "comment": "Retrieve the Float parameter value for the given name.",
          "params": {
            "InName": "Name of the parameter",
            "OutFloat": "The value of the parameter found"
          }
        },
        "GetLODLevel": {
          "comment": "GetLODLevel - gets the LOD level currently set."
        },
        "GetMaterialParameter": {
          "comment": "Retrieve the Material parameter value for the given name.",
          "params": {
            "InName": "Name of the parameter",
            "OutMaterial": "The value of the parameter found"
          }
        },
        "GetMaxLifespan": {
          "comment": "Get the longest possible lifespan for this particle system."
        },
        "GetSkipBoundsUpdate": {
          "comment": "Function for retrieving the bSkipBoundsUpdate flag."
        },
        "GetSkipUpdateDynamicDataDuringTick": {
          "comment": "Function for retrieving the bSkipUpdateDynamicDataDuringTick flag."
        },
        "GetVectorParameter": {
          "comment": "Retrieve the Vector parameter value for the given name.",
          "params": {
            "InName": "Name of the parameter",
            "OutVector": "The value of the parameter found"
          }
        },
        "KillParticlesInEmitter": {
          "comment": "Kill the particles in the specified emitter(s)",
          "params": {
            "InEmitterName": "The name of the emitter to kill the particles in."
          }
        },
        "ResetToDefaults": {
          "comment": "stops the emitter, detaches the component, and resets the component's properties to the values of its template"
        },
        "RewindEmitterInstance": {
          "comment": "Rewind emitter instances."
        },
        "SetActive": {
          "comment": "calls ActivateSystem() or DeactivateSystem() only if the component is not already activated/deactivated\n necessary because ActivateSystem() resets already active emitters so it shouldn't be called multiple times on looping effects",
          "params": {
            "bNowActive": "whether the system should be active",
            "bFlagAsJustAttached": "if TRUE, then pass the 'JustAttached' value into the ActivateSystem call"
          }
        },
        "SetBeamDistance": {
          "comment": "Set the beam distance",
          "params": {
            "EmitterIndex": "The index of the emitter to set it on",
            "Distance": "The value to set it to"
          }
        },
        "SetBeamEndPoint": {
          "comment": "Set the beam end point",
          "params": {
            "EmitterIndex": "The index of the emitter to set it on",
            "NewEndPoint": "The value to set it to"
          }
        },
        "SetBeamSourcePoint": {
          "comment": "Set the beam source point",
          "params": {
            "EmitterIndex": "The index of the emitter to set it on",
            "NewSourcePoint": "The value to set it to",
            "SourceIndex": "Which beam within the emitter to set it on"
          }
        },
        "SetBeamSourceStrength": {
          "comment": "Set the beam source strength",
          "params": {
            "EmitterIndex": "The index of the emitter to set it on",
            "NewSourceStrength": "The value to set it to",
            "SourceIndex": "Which beam within the emitter to set it on"
          }
        },
        "SetBeamSourceTangent": {
          "comment": "Set the beam source tangent",
          "params": {
            "EmitterIndex": "The index of the emitter to set it on",
            "NewTangentPoint": "The value to set it to",
            "SourceIndex": "Which beam within the emitter to set it on"
          }
        },
        "SetBeamTargetPoint": {
          "comment": "Set the beam target point",
          "params": {
            "EmitterIndex": "The index of the emitter to set it on",
            "NewTargetPoint": "The value to set it to",
            "TargetIndex": "Which beam within the emitter to set it on"
          }
        },
        "SetBeamTargetStrength": {
          "comment": "Set the beam target strength",
          "params": {
            "EmitterIndex": "The index of the emitter to set it on",
            "NewTargetStrength": "The value to set it to",
            "TargetIndex": "Which beam within the emitter to set it on"
          }
        },
        "SetBeamTargetTangent": {
          "comment": "Set the beam target tangent",
          "params": {
            "EmitterIndex": "The index of the emitter to set it on",
            "NewTangentPoint": "The value to set it to",
            "TargetIndex": "Which beam within the emitter to set it on"
          }
        },
        "SetBeamTessellationFactor": {
          "comment": "Set the beam tessellation factor",
          "params": {
            "EmitterIndex": "The index of the emitter to set it on",
            "NewFactor": "The value to set it to"
          }
        },
        "SetBeamType": {
          "comment": "Set the beam type",
          "params": {
            "EmitterIndex": "The index of the emitter to set it on",
            "NewMethod": "The new method/type of beam to generate"
          }
        },
        "SetKillOnCompleted": {
          "comment": "SetKillOnDeactivate is used to set the KillOnCompleted( flag. If true, when\n the particle system is completed, it will immediately kill the emitter\n instance.\n Set this to true for cached ParticleSystems",
          "params": {
            "EmitterIndex": "The index of the emitter to set it on",
            "bKill": "The value to set it to"
          }
        },
        "SetKillOnDeactivate": {
          "comment": "SetKillOnDeactivate is used to set the KillOnDeactivate flag. If true, when\n the particle system is deactivated, it will immediately kill the emitter\n instance. If false, the emitter instance live particles will complete their\n lifetime.\n Set this to true for cached ParticleSystems",
          "params": {
            "EmitterIndex": "The index of the emitter to set it on",
            "bKill": "value to set KillOnDeactivate to"
          }
        },
        "SetLODLevel": {
          "comment": "SetLODLevel - sets the LOD level to use for this instance."
        },
        "SetSkipBoundsUpdate": {
          "comment": "Function for setting the bSkipBoundsUpdate flag."
        },
        "SetSkipUpdateDynamicDataDuringTick": {
          "comment": "Function for setting the bSkipUpdateDynamicDataDuringTick flag."
        },
        "SetStopSpawning": {
          "comment": "Calls SetStopSpawning with the given emitter instance passing in the given value.",
          "params": {
            "InEmitterIndex": "The index of the emitter instance to call SetHaltSpawning on; -1 for ALL",
            "bInStopSpawning": "The value to pass into the EmitterInstance SetHaltSpawning call"
          }
        },
        "SystemHasCompleted": {
          "comment": "Return the HasCompleted result"
        }
      },
      "structs": {
        "ParticleEmitterInstanceMotionBlurInfo": {
          "comment": "Stores motion blur transform info for particles",
          "properties": {
            "ParticleMBInfoMap": {
              "comment": "Maps unique particle Id to its motion blur info"
            }
          }
        },
        "ParticleEventCollideData": {
          "comment": "Collision particle event data.",
          "properties": {
            "BoneName": {
              "comment": "Name of bone we hit (for skeletal meshes)."
            },
            "Item": {
              "comment": "Primitive data item which was hit, INDEX_NONE=none."
            },
            "Normal": {
              "comment": "Normal vector in coordinate system of the returner. Zero=none."
            },
            "ParticleTime": {
              "comment": "The particle time at collision."
            },
            "Time": {
              "comment": "Time until hit, if line check."
            }
          }
        },
        "ParticleEventData": {
          "comment": "The base class for all particle event data.",
          "properties": {
            "Direction": {
              "comment": "The direction of the particle at the time of the event."
            },
            "EmitterTime": {
              "comment": "The emitter time at the event."
            },
            "EventName": {
              "comment": "The name of the event."
            },
            "Location": {
              "comment": "The location of the event."
            },
            "Type": {
              "comment": "The type of event that was generated."
            },
            "Velocity": {
              "comment": "The velocity at the time of the event."
            }
          }
        },
        "ParticleEventDeathData": {
          "comment": "Killed particle event data.",
          "properties": {
            "ParticleTime": {
              "comment": "The particle time at its death."
            }
          }
        },
        "ParticleEventKismetData": {
          "comment": "Kismet particle event data.",
          "properties": {
            "Normal": {
              "comment": "Normal vector in coordinate system of the returner. Zero=none."
            },
            "UsePSysCompLocation": {
              "comment": "If TRUE, use the particle system component location as spawn location."
            }
          }
        },
        "ParticleEventSpawnData": {
          "comment": "Spawn particle event data."
        },
        "ParticleSysParam": {
          "comment": "Struct used for a particular named instance parameter for this ParticleSystemComponent.",
          "properties": {
            "Name": {
              "comment": "The name of the parameter"
            },
            "ParamType": {
              "comment": "The type of parameters\n PSPT_None - There is no data type\n PSPT_Scalar - Use the scalar value\n PSPT_ScalarRand - Select a scalar value in the range [Scalar_Low..Scalar)\n PSPT_Vector - Use the vector value\n PSPT_VectorRand - Select a vector value in the range [Vector_Low..Vector)\n PSPT_Color - Use the color value\n PSPT_Actor - Use the actor value\n PSPT_Material - Use the material value"
            }
          }
        },
        "ViewParticleEmitterInstanceMotionBlurInfo": {
          "comment": "Stores motion blur transform info for emitter instances",
          "properties": {
            "EmitterInstanceMBInfoMap": {
              "comment": "Maps unique emitter instance via ptr to its particle motion blur info"
            }
          }
        }
      }
    },
    "ParticleSystemReplay": {
      "properties": {
        "Frames": {
          "comment": "Ordered list of frames"
        },
        "ClipIDNumber": {
          "comment": "Unique ID number for this replay clip"
        }
      },
      "structs": {
        "ParticleEmitterReplayFrame": {
          "properties": {
            "EmitterType": {
              "comment": "Type of emitter (EDynamicEmitterType)"
            },
            "FrameState": {
              "comment": "State for the emitter this frame. The actual object type"
            },
            "OriginalEmitterIndex": {
              "comment": "Original index into the particle systems list of particle emitter indices. This is currently"
            }
          }
        },
        "ParticleSystemReplayFrame": {
          "comment": "A single frame within this replay",
          "properties": {
            "Emitters": {
              "comment": "Emitter frame state data"
            }
          }
        }
      }
    },
    "PathConstraint": {
      "properties": {
        "NextConstraint": {
          "comment": "Next constraint in the list"
        }
      }
    },
    "PathGoalEvaluator": {
      "properties": {
        "GeneratedGoal": {
          "comment": "Goal that was reached"
        },
        "MaxPathVisits": {
          "comment": "maximum number of NavigationPoints to test before giving up"
        },
        "NextEvaluator": {
          "comment": "Next goal evaluator"
        }
      }
    },
    "PathTargetPoint": {
      "functions": {
        "ShouldBeHiddenBySHOW_NavigationNodes": {
          "comment": "replaces IsA(NavigationPoint) check for primitivecomponents"
        }
      }
    },
    "Path_AlongLine": {
      "properties": {
        "Direction": {
          "comment": "Direction to move in"
        }
      }
    },
    "Path_AvoidInEscapableNodes": {
      "comment": "- this constraint will throw out nodes which the pathing bot could get to, but not get away from. Normally this\n is not necessary as you're usually pathing somewhere so a node which you can't get out of is thrown out by A*, but if \n you're doing some sort of generic search (ie. for a node in range of something) you could end up with a node the bot can't\n escape from, thus causing him to be forever stuck.. this constraint will prevent that from happening"
    },
    "Path_MinDistBetweenSpecsOfType": {
      "comment": "penalizes specs of a certain class if they are within a set distance of another mantle in the predecessor chain",
      "properties": {
        "InitLocation": {
          "comment": "can be used to indicate we last mantled at this location in previous path and we shouldn't take mantles within"
        },
        "MinDistBetweenSpecTypes": {
          "comment": "min dist between specs of the specified type type"
        },
        "ReachSpecClass": {
          "comment": "the class of the reach spec we want to enforce minimum distance between\n @NOTE: this must be the exact class, child classes will not match"
        }
      }
    },
    "Path_TowardGoal": {
      "properties": {
        "GoalActor": {
          "comment": "Goal trying to find path toward"
        }
      }
    },
    "Path_TowardPoint": {
      "properties": {
        "GoalPoint": {
          "comment": "Goal trying to find path toward"
        }
      }
    },
    "Path_WithinDistanceEnvelope": {
      "properties": {
        "bOnlyThrowOutNodesThatLeaveEnvelope": {
          "comment": "when bSoft is false, should we throw out nodes whose start and end are both outside the envelope?"
        },
        "bSoft": {
          "comment": "if this is on instead of throwing out nodes outside traversal distance they will be gradiently penalized the further out they are"
        },
        "MaxDistance": {
          "comment": "outer distance of envelope (distance from test actor)"
        },
        "MinDistance": {
          "comment": "inner distance of envelope (distance from test actor)"
        },
        "SoftStartPenalty": {
          "comment": "when a path exceeds specified traversal distance this penalty will be applied, and scaled up depending on how far outside the dist it is"
        }
      }
    },
    "Path_WithinTraversalDist": {
      "properties": {
        "bSoft": {
          "comment": "if this is on instead of throwing out nodes outside traversal distance they will be gradiently penalized the further out they are"
        },
        "MaxTraversalDist": {
          "comment": "Maximum distance to traverse along a branch"
        },
        "SoftStartPenalty": {
          "comment": "when a path exceeds specified traversal distance this penantly will be applied, and scaled up depending on how far outside the dist it is"
        }
      }
    },
    "Pawn": {
      "properties": {
        "AIMaxFallSpeedFactor": {
          "comment": "AI will take paths that require a landing velocity less than (MaxFallSpeed * AIMaxFallSpeedFactor)"
        },
        "AllowedYawError": {
          "comment": "Max difference between pawn's Rotation.Yaw and DesiredRotation.Yaw for pawn to be considered as having reached its desired rotation"
        },
        "bDesiredRotationSet": {
          "comment": "DesiredRotation is set by somebody - Pawn's default behavior (using direction for desiredrotation) does not work"
        },
        "bDisplayPathErrors": {
          "comment": "if set, display \"MAP HAS PATHING ERRORS\" and message in the log when a Pawn fails a full path search"
        },
        "bForceRegularVelocity": {
          "comment": "this flag forces APawn::CalcVelocity() to never use root motion derived velocity"
        },
        "bForceRMVelocity": {
          "comment": "this flag forces APawn::CalcVelocity() to just use RMVelocity directly"
        },
        "bLimitFallAccel": {
          "comment": "Maximum step height for getting out of water"
        },
        "bLockDesiredRotation": {
          "comment": "Do not overwrite current DesiredRotation"
        },
        "bNeedsBaseTickedFirst": {
          "comment": "Controls whether the pawn needs the base ticked before this one can be ticked"
        },
        "bPathfindsAsVehicle": {
          "comment": "set if Pawn counts as a vehicle for pathfinding checks (so don't use bBlockedForVehicles nodes, etc)"
        },
        "bPrevBypassSimulatedClientPhysics": {
          "comment": "Previously used ShouldBypassSimulatedClientPhysics flag"
        },
        "BreathTime": {
          "comment": "if true, replicate this Pawn's health to all clients; otherwise, only if owned by or ViewTarget of a client"
        },
        "bReducedSpeed": {
          "comment": "Used by movement natives to slow pawn as it reaches its destination to prevent overshooting"
        },
        "bReplicateHealthToAll": {
          "comment": "normal maximum health of Pawn - defaults to default.Health unless explicitly set otherwise"
        },
        "bRootMotionFromInterpCurve": {
          "comment": "NOTE: Currently assumes blending isn't altering the root bone"
        },
        "bScriptTickSpecial": {
          "comment": "If true, call the script TickSpecial() event."
        },
        "bUnlockWhenReached": {
          "comment": "Unlock DesiredRotation when Reached to the destination\n This is used when bLockDesiredRotation=TRUE\n This will set bLockDesiredRotation = FALSE when reached to DesiredRotation"
        },
        "Controller": {
          "comment": "Controller currently possessing this Pawn"
        },
        "FacialAudioComp": {
          "comment": "AudioComponent used by FaceFX"
        },
        "FailedLandingCount": {
          "comment": "@HACK: count of times processLanded() was called but it failed without changing physics for some reason\n so we can detect and avoid a rare case where Pawns get stuck in that state"
        },
        "FiringMode": {
          "comment": "firing mode used when firing"
        },
        "FlashCount": {
          "comment": "increased when weapon fires. 0 = not firing. 1 - 255 = firing"
        },
        "FlashLocation": {
          "comment": "Hit Location of instant hit weapons. vect(0,0,0) = not firing."
        },
        "InterpGroupList": {
          "comment": "List of Matinee InterpGroup controlling this actor."
        },
        "InventoryManagerClass": {
          "comment": "Inventory Manager"
        },
        "LastFiringFlashLocation": {
          "comment": "last FlashLocation that was an actual shot, i.e. not counting clears to (0,0,0)\n this is used to make sure we set unique values to FlashLocation for consecutive shots even when there was a clear in between,\n so that if a client missed the clear due to low net update rate, it still gets the new firing location"
        },
        "LedgeCheckThreshold": {
          "comment": "Used in determining if pawn is going off ledge. If the ledge is \"shorter\" than this value then the pawn will be able to walk off it."
        },
        "MaxOutOfWaterStepHeight": {
          "comment": "z velocity applied when pawn tries to get out of water"
        },
        "MIC_PawnMat": {
          "comment": "General material used to control common pawn material parameters (e.g. burning)"
        },
        "NetRelevancyTime": {
          "comment": "Used for cacheing net relevancy test"
        },
        "NextPawn": {
          "comment": "Chained pawn list"
        },
        "NonPreferredVehiclePathMultiplier": {
          "comment": "Pawn multiplies cost of NavigationPoints that don't have bPreferredVehiclePath set by this number"
        },
        "PathConstraintList": {
          "comment": "List of search constraints for pathing"
        },
        "PhysicsPushBody": {
          "comment": "Physics object created to create contacts with physics objects, used to push them around."
        },
        "PreRagdollCollisionComponent": {
          "comment": "set in InitRagdoll() to old CollisionComponent (since it must be Mesh for ragdolls) so that TermRagdoll() can restore it"
        },
        "RemoteViewPitch": {
          "comment": "replicated to we can see where remote clients are looking"
        },
        "RMVelocity": {
          "comment": "RootMotion derived velocity calculated by APawn::CalcVelocity() (used when replaying client moves in net games (since can't rely on animation when replaying moves))"
        },
        "ShotCount": {
          "comment": "tracks the number of consecutive shots. Note that this is not replicated, so it's not correct on remote clients. It's only updated when the pawn is relevant."
        },
        "SlotNodes": {
          "comment": "Array of Slots"
        },
        "Weapon": {
          "comment": "Weapon currently held by Pawn"
        },
        "DesiredRotation": {
          "comment": "In future I will uncomment this change. Currently Actor has the variable"
        },
        "WalkingPhysics": {
          "comment": "Physics to use when walking. Typically set to PHYS_Walking or PHYS_NavMeshWalking"
        },
        "HealthMax": {
          "comment": "amount of health this Pawn has"
        },
        "VehicleCheckRadius": {
          "comment": "Radius that is checked for nearby vehicles when pressing use"
        }
      },
      "functions": {
        "AddAnimSets": {
          "comment": "Add a given list of anim sets on the top of the list (so they override the other ones\n !! Only use within BuildScriptAnimSetList() !!"
        },
        "AnimSetListUpdated": {
          "comment": "Called after UpdateAnimSetList does its job"
        },
        "BaseChange": {
          "comment": "Event called after actor's base changes."
        },
        "BeginAnimControl": {
          "comment": "Called when we start an AnimControl track operating on this Actor. Supplied is the set of AnimSets we are going to want to play from."
        },
        "BuildScriptAnimSetList": {
          "comment": "Build AnimSet list Script version, called by UpdateAnimSetList()"
        },
        "CacheAnimNodes": {
          "comment": "Save off commonly used nodes so the tree doesn't need to be iterated over often"
        },
        "CanActorPlayFaceFXAnim": {
          "comment": "Returns FALSE??? if Actor can play facefx\n Implement in sub-class."
        },
        "CanBeBaseForPawn": {
          "comment": "Are we allowing this Pawn to be based on us?"
        },
        "CheckDesiredRotation": {
          "comment": "CheckDesiredRotation function\n Check to see if DesiredRotation is met, and it need to be clear or not\n This is called by physicsRotation to make sure it needs to be cleared"
        },
        "ClearAnimNodes": {
          "comment": "Remove references to the saved nodes"
        },
        "ClearFlashCount": {
          "comment": "Clear flashCount variable. and call WeaponStoppedFiring event.\n Call this on the server and local player.\n Network: Server or Local Player"
        },
        "ClearFlashLocation": {
          "comment": "Reset flash location variable. and call stop firing.\n Network: Server only"
        },
        "CreatePathConstraint": {
          "comment": "Path shaping creation functions...\n these functions by default will just new the class, but this offers a handy\n interface to override for to do things like pool the constraints"
        },
        "CrushedBy": {
          "comment": "CrushedBy()\nCalled for pawns that have bCanBeBaseForPawns=false when another pawn becomes based on them"
        },
        "DetachFromController": {
          "comment": "Call this function to detach safely pawn from its controller",
          "params": {
            "bDestroyController": "if true, then destroy controller. (only AI Controllers, not players)"
          }
        },
        "Died": {
          "comment": "This pawn has died.",
          "params": {
            "Killer": "Who killed this pawn",
            "DamageType": "What killed it",
            "HitLocation": "Where did the hit occur"
          }
        },
        "DisplayDebug": {
          "comment": "list important Pawn variables on canvas. HUD will call DisplayDebug() on the current ViewTarget when\n the ShowDebug exec is used",
          "params": {
            "HUD": "HUD with canvas to draw on\n \n@input out_YL - Height of the current font\n \n@input out_YPos - Y position on Canvas. out_YPos += out_YL, gives position to draw text for next debug line."
          }
        },
        "DoKismetAttachment": {
          "comment": "Performs actual attachment. Can be subclassed for class specific behaviors."
        },
        "DrawHUD": {
          "comment": "Hook called from HUD actor. Gives access to HUD and Canvas"
        },
        "EndCrouch": {
          "comment": "Event called from native code when Pawn stops crouching.\n Called on non owned Pawns through bIsCrouched replication.\n Network: ALL",
          "params": {
            "HeightAdjust": "height difference in unreal units between default collision height, and actual crouched cylinder height."
          }
        },
        "FaceFXAudioFinished": {
          "comment": "Called via delegate when FacialAudioComp is finished."
        },
        "FinishAnimControl": {
          "comment": "Called when we are done with the AnimControl track."
        },
        "FiringModeUpdated": {
          "comment": "Called when FiringMode has been updated.\n Network: ALL"
        },
        "FlashCountUpdated": {
          "comment": "Called when FlashCount has been updated.\n Trigger appropritate events based on FlashCount's value.\n = 0 means Weapon Stopped firing\n > 0 means Weapon just fired\n Network: ALL"
        },
        "FlashLocationUpdated": {
          "comment": "Called when FlashLocation has been updated.\n Trigger appropritate events based on FlashLocation's value.\n == (0,0,0) means Weapon Stopped firing\n != (0,0,0) means Weapon just fired\n Network: ALL"
        },
        "GetActorEyesViewPoint": {
          "comment": "returns the point of view of the actor.\n note that this doesn't mean the camera, but the 'eyes' of the actor.\n For example, for a Pawn, this would define the eye height location,\n and view rotation (which is different from the pawn rotation which has a zeroed pitch component).\n A camera first person view will typically use this view point. Most traces (weapon, AI) will be done from this view point.\n @output out_Location, location of view point\n @output out_Rotation, view rotation of actor."
        },
        "GetActorFaceFXAsset": {
          "comment": "Used by Matinee in-game to mount FaceFXAnimSets before playing animations."
        },
        "GetAdjustedAimFor": {
          "comment": "Adjusts weapon aiming direction.\n Gives Pawn a chance to modify its aiming. For example aim error, auto aiming, adhesion, AI help...\n Requested by weapon prior to firing.",
          "params": {
            "W,": "weapon about to fire",
            "StartFireLoc,": "world location of weapon fire start trace, or projectile spawn loc.",
            "BaseAimRot,": "original aiming rotation without any modifications."
          }
        },
        "GetBaseAimRotation": {
          "comment": "returns base Aim Rotation without any adjustment (no aim error, no autolock, no adhesion.. just clean initial aim rotation!)"
        },
        "GetCollisionHeight": {
          "comment": "Returns the collision height of our cylinder\n collision component."
        },
        "GetCollisionRadius": {
          "comment": "Returns the collision radius of our cylinder\n collision component."
        },
        "GetDamageScaling": {
          "comment": "returns the amount this pawn's damage should be scaled by"
        },
        "GetDefaultCameraMode": {
          "comment": "returns default camera mode when viewing this pawn.\n Mainly called when controller possesses this pawn.",
          "params": {
            "PlayerController": "requesting the default camera view"
          }
        },
        "GetFaceFXAudioComponent": {
          "comment": "Used to let FaceFX know what component to play dialogue audio on."
        },
        "GetFallDuration": {
          "comment": "GetFallDuration\n returns time before impact if pawn falls from current position with current velocity"
        },
        "GetPawnViewLocation": {
          "comment": "returns the Eye location of the Pawn."
        },
        "GetWeaponFiringMode": {
          "comment": "Return FiringMode currently in use by weapon InWeapon"
        },
        "GetWeaponStartTraceLocation": {
          "comment": "Return world location to start a weapon fire trace from."
        },
        "IncrementFlashCount": {
          "comment": "This function's responsibility is to signal clients that non-instant hit shot\n has been fired. Call this on the server and local player.\n Network: Server and Local Player"
        },
        "InFreeCam": {
          "comment": "return true if player is viewing this Pawn in FreeCam"
        },
        "InitRagdoll": {
          "comment": "Does the following:\n - Assign the SkeletalMeshComponent 'Mesh' to the CollisionComponent\n - Call InitArticulated on the SkeletalMeshComponent.\n - Change the physics mode to PHYS_RigidBody"
        },
        "InterpolationFinished": {
          "comment": "called when a SeqAct_Interp action finished interpolating this Actor\n \n@note this function is called on clients for actors that are interpolated clientside via MatineeActor",
          "params": {
            "InterpAction": "the SeqAct_Interp that was affecting the Actor"
          }
        },
        "InterpolationStarted": {
          "comment": "called when a SeqAct_Interp action starts interpolating this Actor via matinee\n \n@note this function is called on clients for actors that are interpolated clientside via MatineeActor",
          "params": {
            "InterpAction": "the SeqAct_Interp that is affecting the Actor"
          }
        },
        "IsActorPlayingFaceFXAnim": {
          "comment": "Returns TRUE if Actor is playing a FaceFX anim.\n Implement in sub-class."
        },
        "IsAliveAndWell": {
          "comment": "Returns TRUE if Pawn is alive and doing well"
        },
        "IsDesiredRotationInUse": {
          "comment": "IsDesiredRotationInUse()\n See if DesiredRotation is used by somebody"
        },
        "IsDesiredRotationLocked": {
          "comment": "IsDesiredRotationLocked()\n See if DesiredRotation is locked by somebody"
        },
        "IsHumanControlled": {
          "comment": "IsHumanControlled()",
          "params": {
            "PawnController": "optional parameter so you can pass a controller that is associated with this pawn but is not attached to it"
          }
        },
        "IsInvisible": {
          "comment": "@RETURN true if pawn is invisible to AI"
        },
        "IsPlayerPawn": {
          "comment": "IsPlayerPawn()\nreturn true if controlled by a Player (AI or human) on local machine (any controller on server, localclient's pawn on client)"
        },
        "IsSameTeam": {
          "comment": "Returns true of pawns are on the same team, false otherwise"
        },
        "IsStationary": {
          "comment": "Pawns by nature are not stationary. Override if you want exact findings"
        },
        "IsValidEnemyTargetFor": {
          "comment": "returns if we are a valid enemy for PRI\n checks things like whether we're alive, teammates, etc\n works on clients and servers"
        },
        "LockDesiredRotation": {
          "comment": "LockDesiredRotation function",
          "params": {
            "Lock:": "Lock or Unlock CurrentDesiredRotation",
            "InUnlockWhenReached:": "Unlock when reached desired rotation. This is only valid when Lock = true"
          }
        },
        "MAT_BeginAnimControl": {
          "comment": "Start AnimControl. Add required AnimSets."
        },
        "MAT_FinishAnimControl": {
          "comment": "End AnimControl. Release required AnimSets"
        },
        "MAT_SetAnimPosition": {
          "comment": "Update AnimTree from track info"
        },
        "MAT_SetAnimWeights": {
          "comment": "Update AnimTree from track weights"
        },
        "MessagePlayer": {
          "comment": "For debugging. Causes a string to be displayed on the HUD."
        },
        "NeedToTurn": {
          "comment": "returns whether we need to turn to fire at the specified location"
        },
        "NotifyTakeHit": {
          "comment": "sends any notifications to anything that needs to know this pawn has taken damage"
        },
        "NotifyTeamChanged": {
          "comment": "NotifyTeamChanged()\nCalled when PlayerReplicationInfo is replicated to this pawn, or PlayerReplicationInfo team property changes.\nNetwork: client"
        },
        "OnAssignController": {
          "comment": "Deletes the current controller if it exists and creates a new one\n using the specified class.\n Event called from Kismet.",
          "params": {
            "inAction": "scripted action that was activated"
          }
        },
        "OnGiveInventory": {
          "comment": "Iterates through the list of item classes specified in the action\n and creates instances that are addeed to this Pawn's inventory.",
          "params": {
            "inAction": "scripted action that was activated"
          }
        },
        "OnPlayFaceFXAnim": {
          "comment": "Function for handling the SeqAct_PlayFaceFXAnim Kismet action working on this Actor."
        },
        "OnSetVelocity": {
          "comment": "Handler for the SeqAct_SetVelocity action. Allows level designer to impart a velocity on the actor."
        },
        "OnTeleport": {
          "comment": "Kismet teleport handler, overridden so that updating rotation properly updates our Controller as well"
        },
        "PlayActorFaceFXAnim": {
          "comment": "Play FaceFX animations on this Actor.\n Returns TRUE if succeeded, if failed, a log warning will be issued."
        },
        "PlayFootStepSound": {
          "comment": "PlayFootStepSound()\n called by AnimNotify_Footstep\n FootDown specifies which foot hit"
        },
        "PlayWeaponSwitch": {
          "comment": "Player just changed weapon. Called from InventoryManager::ChangedWeapon().\n Network: Local Player and Server.",
          "params": {
            "OldWeapon": "Old weapon held by Pawn.",
            "NewWeapon": "New weapon held by Pawn."
          }
        },
        "ProcessViewRotation": {
          "comment": "Called from PlayerController UpdateRotation() -> ProcessViewRotation() to (pre)process player ViewRotation\n adds delta rot (player input), applies any limits and post-processing\n returns the final ViewRotation set on PlayerController",
          "params": {
            "DeltaTime,": "time since last frame",
            "ViewRotation,": "actual PlayerController view rotation\n \n@input out_DeltaRot, delta rotation to be applied on ViewRotation. Represents player's input."
          }
        },
        "PruneDamagedBoneList": {
          "comment": "Take a list of bones passed to TakeRadiusDamageOnBones and remove the ones that don't matter"
        },
        "ReplicatedEvent": {
          "comment": "Check on various replicated data and act accordingly."
        },
        "ResetDesiredRotation": {
          "comment": "ResetDesiredRotation function\n Clear RotationRate/Flag to go back to default behavior\n Unless it's locked."
        },
        "SetAnimPosition": {
          "comment": "Called each from while the Matinee action is running, with the desired sequence name and position we want to be at."
        },
        "SetDesiredRotation": {
          "comment": "SetDesiredRotation function",
          "params": {
            "TargetDesiredRotation:": "DesiredRotation you want",
            "InLockDesiredRotation:": "I'd like to lock up DesiredRotation, please nobody else can touch it until I say it's done",
            "InUnlockWhenReached:": "When you lock, set this to TRUE if you want it to be auto Unlock when reached desired rotation",
            "InterpolationTime:": "Give interpolation time to get to the desired rotation - Ignore default RotationRate, but use this to get there"
          }
        },
        "SetDyingPhysics": {
          "comment": "Set physics for dying pawn\n Always set to falling, unless already a ragdoll"
        },
        "SetFiringMode": {
          "comment": "Set firing mode replication for remote clients trigger update notification.\n Network: LocalPlayer and Server"
        },
        "SetFlashLocation": {
          "comment": "This function sets up the Location of a hit to be replicated to all remote clients.\n It is also responsible for fudging a shot at (0,0,0).\n Network: Server only (unless using client-side hit detection)"
        },
        "SetMorphWeight": {
          "comment": "Called each frame by Matinee to update the weight of a particular MorphNodeWeight."
        },
        "SetRemoteViewPitch": {
          "comment": "Set Pawn ViewPitch, so we can see where remote clients are looking.",
          "params": {
            "NewRemoteViewPitch": "Pitch component to replicate to remote (non owned) clients."
          }
        },
        "SetScalarParameterInterp": {
          "comment": "Set a ScalarParameter to Interpolate"
        },
        "SetSkelControlScale": {
          "comment": "Called each frame by Matinee to update the scaling on a SkelControl."
        },
        "SetWalking": {
          "comment": "Called every frame from PlayerInput or PlayerController::MoveAutonomous()\n Sets bIsWalking flag, which defines if the Pawn is walking or not (affects velocity)",
          "params": {
            "bNewIsWalking,": "new walking state."
          }
        },
        "ShouldCrouch": {
          "comment": "Controller is requesting that pawn crouches.\n This is not guaranteed as it depends if crouching collision cylinder can fit when Pawn is located.",
          "params": {
            "bCrouch": "true if Pawn should crouch."
          }
        },
        "SoakPause": {
          "comment": "For AI debugging"
        },
        "SpawnDefaultController": {
          "comment": "Spawn default controller for this Pawn, get possessed by it."
        },
        "Speak": {
          "comment": "Simple interface for handling pawn dialogue."
        },
        "SpecialMoveTo": {
          "comment": "Give pawn the chance to do something special moving between points"
        },
        "StartCrouch": {
          "comment": "Event called from native code when Pawn starts crouching.\n Called on non owned Pawns through bIsCrouched replication.\n Network: ALL",
          "params": {
            "HeightAdjust": "height difference in unreal units between default collision height, and actual crouched cylinder height."
          }
        },
        "StartDriving": {
          "comment": "StartDriving() and StopDriving() also called on clients\n on transitions of DrivenVehicle variable.\n Network: ALL"
        },
        "StartFire": {
          "comment": "Pawn starts firing!\n Called from PlayerController::StartFiring\n Network: Local Player",
          "params": {
            "FireModeNum": "fire mode number"
          }
        },
        "StopActorFaceFXAnim": {
          "comment": "Stop any matinee FaceFX animations on this Actor."
        },
        "StopDriving": {
          "comment": "StartDriving() and StopDriving() also called on clients\n on transitions of DrivenVehicle variable.\n Network: ALL"
        },
        "StopFire": {
          "comment": "Pawn stops firing!\n i.e. player releases fire button, this may not stop weapon firing right away. (for example press button once for a burst fire)\n Network: Local Player",
          "params": {
            "FireModeNum": "fire mode number"
          }
        },
        "StuckOnPawn": {
          "comment": "Called when pawn cylinder embedded in another pawn. (Collision bug that needs to be fixed)."
        },
        "SuggestJumpVelocity": {
          "comment": "SuggestJumpVelocity()\n returns true if succesful jump from start to destination is possible\n returns a suggested initial falling velocity in JumpVelocity\n Uses GroundSpeed and JumpZ as limits",
          "params": {
            "JumpVelocity": "The vector to fill with the calculated jump velocity",
            "Destination": "The destination location of the jump",
            "Start": "The start location of the jump",
            "bRequireFallLanding": "If true, the jump calculated will have a velocity in the negative Z at the destination"
          }
        },
        "TakeRadiusDamageOnBones": {
          "comment": "Damage radius applied to specific bones on the skeletal mesh"
        },
        "TermRagdoll": {
          "comment": "the opposite of InitRagdoll(); resets CollisionComponent to the default,\n sets physics to PHYS_Falling, and calls TermArticulated() on the SkeletalMeshComponent"
        },
        "ThrowActiveWeapon": {
          "comment": "Toss active weapon using default settings (location+velocity).",
          "params": {
            "DamageType": "allows this function to do different behaviors based on the damage type"
          }
        },
        "ThrowWeaponOnDeath": {
          "comment": "called to throw any weapon(s) that should be thrown on death"
        },
        "TickSpecial": {
          "comment": "Called if bScriptTickSpecial is set\n This tick function is called after physics has executed"
        },
        "TurnOff": {
          "comment": "TurnOff()\nFreeze pawn - stop sounds, animations, physics, weapon firing"
        },
        "UnCrouch": {
          "comment": "Makes sure a Pawn is not crouching, telling it to stand if necessary."
        },
        "UpdateAnimSetList": {
          "comment": "Update list of AnimSets for this Pawn"
        },
        "UpdatePawnRotation": {
          "comment": "Script function callable from C++ to update the Pawn's rotation, and goes through the FaceRotation logic to apply rotation constraints"
        },
        "ValidAnchor": {
          "comment": "Is the current anchor valid?"
        },
        "WeaponFired": {
          "comment": "Called when a pawn's weapon has fired and is responsibile for\n delegating the creation of all of the different effects.\n bViaReplication denotes if this call in as the result of the\n flashcount/flashlocation being replicated. It's used filter out\n when to make the effects.\n Network: ALL"
        },
        "WeaponStoppedFiring": {
          "comment": "Called when a pawn's weapon has stopped firing and is responsibile for\n delegating the destruction of all of the different effects.\n bViaReplication denotes if this call in as the result of the\n flashcount/flashlocation being replicated.\n Network: ALL"
        }
      },
      "structs": {
        "ScalarParameterInterpStruct": {
          "properties": {
            "InterpTime": {
              "comment": "Desired Interpolation Time"
            },
            "ParameterName": {
              "comment": "Name of parameter to change"
            },
            "ParameterValue": {
              "comment": "Desired Parameter Value"
            },
            "WarmUpTime": {
              "comment": "Time before interpolation starts"
            }
          }
        }
      }
    },
    "PBRuleNodeAlternate": {
      "properties": {
        "ASize": {
          "comment": "Fixed size of A parts (usually columnes)"
        },
        "bEqualSizeAB": {
          "comment": "If TRUE, A and B will be the same size. BMaxSize controls this size, and defines how many meshes will be inserted."
        },
        "bInvertPatternOrder": {
          "comment": "If TRUE, pattern will be BABAB instead of ABABA"
        },
        "BMaxSize": {
          "comment": "Maximum size of stretchable part between As, before inserting another A and B"
        },
        "RepeatAxis": {
          "comment": "Axis that repeating should be done along"
        }
      }
    },
    "PBRuleNodeBase": {
      "properties": {
        "RulePosX": {
          "comment": "Visual X position of this rule in editor"
        },
        "RulePosY": {
          "comment": "Visual Y position of this rule in editor"
        },
        "Comment": {
          "comment": "User defined comment, shown above node"
        }
      }
    },
    "PBRuleNodeComment": {
      "properties": {
        "bFilled": {
          "comment": "If we are drawing a box, should it be filled, or just an outline."
        },
        "BorderColor": {
          "comment": "If we are drawing a box for this comment object, what colour should the border be."
        },
        "BorderWidth": {
          "comment": "Width of border of comment box in pixels."
        },
        "FillColor": {
          "comment": "If bFilled is true, what colour should the background be."
        },
        "SizeX": {
          "comment": "Horizontal size of comment box in pixels."
        },
        "SizeY": {
          "comment": "Vertical size of comment box in pixels."
        }
      }
    },
    "PBRuleNodeCorner": {
      "properties": {
        "Angles": {
          "comment": "Set of angles of corner angle, each corresponds to an output of this node"
        },
        "bNoMeshForConcaveCorners": {
          "comment": "If TRUE, no space left or mesh added in concave corners."
        },
        "bUseAdjacentRulesetForRightGap": {
          "comment": "If TRUE, look at face on the right to see how much gap to leave on right edge. If FALSE, just use CornerSize on left and right side \n Note, this only works when rulesets have the same corner size down the entire height - when looking at adjacent face, the top-left corner size is used."
        },
        "CornerShapeOffset": {
          "comment": "How far from start of curve mesh region to actually chamfer/round adjust roff poly corner"
        },
        "CornerSize": {
          "comment": "Amount to split off left (and maybe right) of supplied scope, based on left/right edge angles"
        },
        "CornerType": {
          "comment": "How to adjust the roof/floor poly to fit with this corner mesh"
        },
        "FlatThreshold": {
          "comment": "Angle in degrees at which point surfaces are considered co-planar, and corner mesh is not added"
        },
        "RoundCurvature": {
          "comment": "Controls the curvature when using EPBC_Round- essentially 'pulls' the tangent handles further."
        },
        "RoundTesselation": {
          "comment": "If CornerType is set to EPBC_Round, how many tesselation steps to take around the corner"
        }
      },
      "structs": {
        "RBCornerAngleInfo": {
          "comment": "Struct containing info about each decision angle",
          "properties": {
            "Angle": {
              "comment": "Angle (in degrees)"
            },
            "CornerSize": {
              "comment": "If non-zero, overrides the base CornerSize for this particular angle"
            }
          }
        }
      }
    },
    "PBRuleNodeCycle": {
      "properties": {
        "bFixRepeatSize": {
          "comment": "Whether each output should be a fixed size (and hence output a scope from the Remainder output). If FALSE, acts just like Repeat Rule."
        },
        "CycleSize": {
          "comment": "How big each 'cycle' is (ie how many outputs will be created"
        },
        "RepeatAxis": {
          "comment": "Axis to break input scope up along"
        },
        "RepeatSize": {
          "comment": "How big each repeat should be"
        }
      }
    },
    "PBRuleNodeEdgeAngle": {
      "properties": {
        "Angles": {
          "comment": "Set of angles of edge connection, each corresponds to an output of this node"
        },
        "Edge": {
          "comment": "Edge of scope that we want to look at angle of"
        }
      },
      "structs": {
        "RBEdgeAngleInfo": {
          "comment": "Struct containing info about each decision angle",
          "properties": {
            "Angle": {
              "comment": "Angle (in degrees)"
            }
          }
        }
      }
    },
    "PBRuleNodeEdgeMesh": {
      "properties": {
        "FlatThreshold": {
          "comment": "Angle in degrees at which point surfaces are considered co-planar, and edge mesh is not added"
        },
        "MainXPullIn": {
          "comment": "Amount to 'pull in' the main face from each edge, to reduce overlap between edge mesh and face meshes"
        }
      }
    },
    "PBRuleNodeLODQuad": {
      "properties": {
        "MassiveLODDistanceScale": {
          "comment": "This controls how far away this region will change to a simple quad, as a scale of the SimpleMeshMassiveLODDistance of the lowest LOD mesh. Should be less than 1.0"
        }
      }
    },
    "PBRuleNodeMesh": {
      "properties": {
        "bBlockAll": {
          "comment": "If TRUE, this mesh will block all, including players"
        },
        "bDoOcclusionTest": {
          "comment": "If TRUE, will test region is not occluded (or is partially occluded) before placing mesh."
        },
        "BuildingMeshes": {
          "comment": "Set of meshes to pick from."
        },
        "PartialOccludedBuildingMesh": {
          "comment": "Mesh to use if this scope if partially occluded. If a mesh is not specified, will just use one of the BuildingMeshes array."
        }
      },
      "functions": {
        "PickRandomBuildingMesh": {
          "comment": "Util to pick a random building mesh from the BuildingMeshes array, using the Chance specified"
        }
      },
      "structs": {
        "BuildingMatOverrides": {
          "comment": "Stores all the options that can be applied to one section of a mesh",
          "properties": {
            "MaterialOptions": {
              "comment": "Array of materials, one of which will be selected for a certain section"
            }
          }
        },
        "BuildingMeshInfo": {
          "comment": "Information about one mesh used as part of the building construction",
          "properties": {
            "bMeshScaleTranslation": {
              "comment": "If TRUE, the Translation specified is scaled by any scaling applied to the mesh"
            },
            "bOverrideMeshLightMapRes": {
              "comment": "If TRUE, use OverriddenLightMapRes instead of resolution set on the mesh."
            },
            "Chance": {
              "comment": "Chance of this building mesh being picked"
            },
            "DimX": {
              "comment": "Defined X length of mesh, when used in building"
            },
            "DimZ": {
              "comment": "Defined Z length of mesh, when used in building"
            },
            "MaterialOverrides": {
              "comment": "DEPRECATED"
            },
            "Mesh": {
              "comment": "Actual mesh to use"
            },
            "OverriddenMeshLightMapRes": {
              "comment": "Resolution to use for lighting on this mesh, if bOverrideMeshLightMapRes is TRUE."
            },
            "Rotation": {
              "comment": "Optional rotation (in degrees) applied to to mesh"
            },
            "SectionOverrides": {
              "comment": "Specifies options for overriding material on each section of the mesh"
            },
            "Translation": {
              "comment": "Optional translation applied to to mesh"
            }
          }
        }
      }
    },
    "PBRuleNodeQuad": {
      "properties": {
        "bDisableMaterialRepeat": {
          "comment": "If TRUE, UV range will just be 0-1, and not repeating based on RepeatMaxSize"
        },
        "Material": {
          "comment": "Material to apply to created quad."
        },
        "QuadLightmapRes": {
          "comment": "Resolution of lightmap on this quad"
        },
        "RepeatMaxSizeX": {
          "comment": "How large each repeat of the texture is allowed to be along X."
        },
        "RepeatMaxSizeZ": {
          "comment": "How large each repeat of the texture is allowed to be along Z."
        },
        "YOffset": {
          "comment": "Amount to offset this quad along Y"
        }
      }
    },
    "PBRuleNodeRandom": {
      "properties": {
        "MaxNumExecuted": {
          "comment": "Max number of the outputs will be executed"
        },
        "MinNumExecuted": {
          "comment": "Min number of the outputs will be executed"
        },
        "NumOutputs": {
          "comment": "How many outputs are created for this node"
        }
      }
    },
    "PBRuleNodeSize": {
      "properties": {
        "bUseTopLevelScopeSize": {
          "comment": "If TRUE, uses the size of the entire building face, rather than just the area passed in to this rule"
        },
        "DecisionSize": {
          "comment": "If size if less than this, fire < output, otherwise fire >="
        },
        "SizeAxis": {
          "comment": "Axis to check size of"
        }
      }
    },
    "PBRuleNodeSubRuleset": {
      "properties": {
        "SubRuleset": {
          "comment": "This controls how far away this region will change to a simple quad, as a scale of the SimpleMeshMassiveLODDistance of the lowest LOD mesh. Should be less than 1.0"
        }
      }
    },
    "PBRuleNodeTransform": {
      "properties": {
        "Rotation": {
          "comment": "Rotation (in degrees) applied to to scope"
        },
        "Scale": {
          "comment": "Scaling applied to to scope"
        },
        "Translation": {
          "comment": "Translation applied to to scope"
        }
      }
    },
    "PBRuleNodeVariation": {
      "properties": {
        "bVariationOfScopeOnLeft": {
          "comment": "If TRUE, choose output based on variation of scope to left of this one, rather than this one."
        }
      }
    },
    "PBRuleNodeWindowWall": {
      "properties": {
        "bScaleWindowWithCell": {
          "comment": "If TRUE, window is scaled down as cell is"
        },
        "CellMaxSizeX": {
          "comment": "How large each repeat of the texture is allowed to be along X."
        },
        "CellMaxSizeZ": {
          "comment": "How large each repeat of the texture is allowed to be along Z."
        },
        "Material": {
          "comment": "Material to apply to created quad."
        },
        "WindowPosX": {
          "comment": "X location of window within cell - 0 means left, 1 means right, 0.5 is middle"
        },
        "WindowPosZ": {
          "comment": "Z location of window within cell - 0 means left, 1 means right, 0.5 is middle"
        },
        "WindowSizeX": {
          "comment": "X dimension of window within cell"
        },
        "WindowSizeZ": {
          "comment": "Z dimension of window within cell"
        },
        "YOffset": {
          "comment": "Amount to offset mesh along Y"
        }
      }
    },
    "PhysicalMaterial": {
      "properties": {
        "AnisoFrictionDir": {
          "comment": "Direction (in physics object local space) for FrictionV to be applied."
        },
        "bEnableAnisotropicFriction": {
          "comment": "Enable support for different friction in different directions."
        },
        "FrictionV": {
          "comment": "Friction to be applied in AnisoFrictionDir - Friction will be used for the other direction."
        },
        "FractureSoundExplosion": {
          "comment": "Sound cue to play when multiple fracture parts are dislodged from a mesh"
        },
        "FractureSoundSingle": {
          "comment": "Sound cue to play when a single piece is removed from mesh."
        },
        "ImpactEffect": {
          "comment": "Particle effect to play at impact location"
        },
        "ImpactReFireDelay": {
          "comment": "Min time between effect/sound being triggered"
        },
        "ImpactSound": {
          "comment": "Sound to play"
        },
        "ImpactThreshold": {
          "comment": "How hard an impact must be to trigger effect/sound"
        },
        "Parent": {
          "comment": "The PhysicalMaterial objects now have a parent reference / pointer. This allows\n you to make single inheritance hierarchies of PhysicalMaterials. Specifically\n this allows one to set default data and then have subclasses over ride that data.\n (e.g. For all materials in the game we are going to say the default Impact Sound\n is SoundA. Now for a Tin Shed we can make a Metal Physical Material and set its\n parent pointer to the Default Material. And then for our Metal PhysicalMaterial\n we say: Play SoundB for Pistols and Rifles. Leaving everything else blank, our\n code can now traverse up the tree to the Default PhysicalMaterial and read the\n values out of that.\n This allows for very specific and interesting behavior that is for the most part\n completely in the hands of your content creators.\n A programmer is needed only to create the orig set of parameters and then it is\n all data driven parameterization!"
        },
        "SlideEffect": {
          "comment": "Effect to place at contact position and enable while sliding"
        },
        "SlideReFireDelay": {
          "comment": "How long since last slide before sound/effect can be re-triggered"
        },
        "SlideSound": {
          "comment": "Looping sound to play while objects are sliding"
        },
        "SlideThreshold": {
          "comment": "How fast an object must slide to trigger effect/sound"
        }
      },
      "functions": {
        "FindFractureSounds": {
          "comment": "Look up PhysicalMaterial heriarchy to find fracture sounds"
        },
        "FindPhysEffectInfo": {
          "comment": "Walk up the PhysMat heirarchy to fill in the supplied PhysEffectInfo struct."
        },
        "GetPhysicalMaterialProperty": {
          "comment": "finds a physical material property of the desired class, querying the parent if this material doesn't have it",
          "params": {
            "DesiredClass": "the class of physical material property to search for"
          }
        }
      }
    },
    "PhysicsAsset": {
      "properties": {
        "BodySetup": {
          "comment": "Array of RB_BodySetup objects. Stores information about collision shape etc. for each body.\n Does not include body position - those are taken from mesh."
        },
        "BodySetupIndexMap": {
          "comment": "This caches the BodySetup Index by BodyName to speed up FindBodyIndex"
        },
        "BoundsBodies": {
          "comment": "Index of bodies that are marked bConsiderForBounds"
        },
        "ConstraintSetup": {
          "comment": "Array of RB_ConstraintSetup objects. \n Stores information about a joint between two bodies, such as position relative to each body, joint limits etc."
        },
        "DefaultInstance": {
          "comment": "Default per-instance paramters for this PhysicsAsset."
        },
        "DefaultSkelMesh": {
          "comment": "Default skeletal mesh to use when previewing this PhysicsAsset etc. \n Is the one that was used as the basis for creating this Asset."
        }
      },
      "functions": {
        "FindBodyIndex": {
          "comment": "Update the BodySetup Array Index Map."
        }
      }
    },
    "PhysicsAssetInstance": {
      "properties": {
        "AngularDampingScale": {
          "comment": "Scaling factor to AngularDriveDamping in all RB_ConstraintInstances within this instance."
        },
        "AngularForceLimitScale": {
          "comment": "Scaling factor to AngularDriveForceLimit in all RB_ConstraintInstances within this instance."
        },
        "AngularSpringScale": {
          "comment": "Scaling factor to AngularDriveSpring in all RB_ConstraintInstances within this instance."
        },
        "bInitBodies": {
          "comment": "Allows initialization of bodies to be deferred"
        },
        "Bodies": {
          "comment": "Array of RB_BodyInstance objects, storing per-instance state about about each body."
        },
        "CollisionDisableTable": {
          "comment": "Table indicating which pairs of bodies have collision disabled between them. Used internally."
        },
        "Constraints": {
          "comment": "Array of RB_ConstraintInstance structs, storing per-instance state about each constraint."
        },
        "LinearDampingScale": {
          "comment": "Scaling factor to LinearDriveDamping in all RB_ConstraintInstances within this instance."
        },
        "LinearForceLimitScale": {
          "comment": "Scaling factor to LinearDriveForceLimit in all RB_ConstraintInstances within this instance."
        },
        "LinearSpringScale": {
          "comment": "Scaling factor to LinearDriveSpring in all RB_ConstraintInstances within this instance."
        },
        "Owner": {
          "comment": "Actor that owns this PhysicsAsset instance.\n Filled in by InitInstance, so we don't need to save it."
        },
        "RootBodyIndex": {
          "comment": "Index of the 'Root Body', or top body in the asset heirarchy. Used by PHYS_RigidBody to get new location for Actor.\n Filled in by InitInstance, so we don't need to save it."
        }
      },
      "functions": {
        "FindBodyInstance": {
          "comment": "Find instance of the body that matches the name supplied."
        },
        "FindConstraintInstance": {
          "comment": "Find instance of the constraint that matches the name supplied."
        },
        "ForceAllBodiesBelowUnfixed": {
          "comment": "Set all of the bones below passed in bone to be UnFixed AND also set the bForceUnfixed flag to TRUE.",
          "params": {
            "InbInstanceAlwaysFullAnimWeight": "whether or not the bones below should be bInstanceAlwaysFullAnimWeight"
          }
        },
        "GetTotalMassBelowBone": {
          "comment": "Utility which returns total mass of all bones below the supplied one in the hierarchy (including this one)."
        },
        "SetAllBodiesFixed": {
          "comment": "Fix or unfix all bodies"
        },
        "SetAllMotorsAngularDriveParams": {
          "comment": "Set Angular Drive motors params for all constraint instance"
        },
        "SetAllMotorsAngularPositionDrive": {
          "comment": "Enable or Disable AngularPositionDrive"
        },
        "SetAllMotorsAngularVelocityDrive": {
          "comment": "Enable or Disable AngularVelocityDrive based on a list of bone names"
        },
        "SetFullAnimWeightBlockRigidBody": {
          "comment": "Use to toggle collision on particular bodies in the asset."
        },
        "SetFullAnimWeightBonesFixed": {
          "comment": "Allows you to fix/unfix bodies where bAlwaysFullAnimWeight is set to TRUE in the BodySetup."
        },
        "SetLinearDriveScale": {
          "comment": "Enable/Disable collision on all bodies below the named bone"
        },
        "SetNamedBodiesBlockRigidBody": {
          "comment": "Use to toggle collision on particular bodies in the asset."
        },
        "SetNamedBodiesFixed": {
          "comment": "Fix or unfix a list of bodies, by name"
        },
        "SetNamedMotorsAngularPositionDrive": {
          "comment": "Enable or Disable AngularPositionDrive based on a list of bone names"
        },
        "SetNamedMotorsAngularVelocityDrive": {
          "comment": "Enable or Disable AngularVelocityDrive based on a list of bone names"
        },
        "SetNamedRBBoneSprings": {
          "comment": "Use to toggle and set RigidBody angular and linear bone springs (see RB_BodyInstance)."
        }
      }
    },
    "PhysicsVolume": {
      "properties": {
        "ZoneVelocity": {
          "comment": "This property is a bit like gravity, though it can be used to apply force in any\ndirection using the three axes. Objects within the volume will be accelerated\nup to the designated velocity while taking friction values into effect"
        }
      },
      "functions": {
        "ModifyPlayer": {
          "comment": "called from GameInfo::SetPlayerDefaults() on the Pawn's PhysicsVolume after the its default movement properties have been restored\n allows the volume to reapply any movement modifiers on the Pawn"
        },
        "NotifyPawnBecameViewTarget": {
          "comment": "notification when a Pawn inside this volume becomes the ViewTarget for a PlayerController"
        },
        "OnSetDamageInstigator": {
          "comment": "Kismet hook to set DamageInstigator"
        }
      }
    },
    "PhysXParticleSystem": {
      "properties": {
        "MaxParticles<UIMin=1|UIMax=65535>": {
          "comment": "Maximum number of particles to simulate."
        },
        "ParticleSpawnReserve<UIMin=0|UIMax=4096>": {
          "comment": "Maximum number of particles that will be deleted per frame to make room for newly spawned particles if MaxParticles is reached."
        },
        "bDynamicCollision": {
          "comment": "Whether to collide with dynamic shapes. Disabling this option can improve performance."
        },
        "CollisionDistance": {
          "comment": "Distance between particles and collision geometry maintained during simulation."
        },
        "FrictionWithDynamicShapes<ClampMin=0.0|ClampMax=1.0>": {
          "comment": "Dynamic friction with dynamic objects."
        },
        "FrictionWithStaticShapes<ClampMin=0.0|ClampMax=1.0>": {
          "comment": "Dynamic friction with static objects."
        },
        "RBChannel": {
          "comment": "Enum indicating what type of object this particle should be considered for rigid body collision."
        },
        "RBCollideWithChannels": {
          "comment": "Types of objects that this particle will collide with."
        },
        "RestitutionWithDynamicShapes<ClampMin=0.0|ClampMax=1.0>": {
          "comment": "\"Bounciness\" against dynamic objects."
        },
        "RestitutionWithStaticShapes<ClampMin=0.0|ClampMax=1.0>": {
          "comment": "\"Bounciness\" against static objects."
        },
        "StaticFrictionWithDynamicShapes<ClampMin=0.0|UIMax=1.0>": {
          "comment": "Static friction with dynamic objects."
        },
        "StaticFrictionWithStaticShapes<ClampMin=0.0|UIMax=1.0>": {
          "comment": "Static friction with static objects."
        },
        "bDisableGravity": {
          "comment": "Disable gravity."
        },
        "Damping<ClampMin=0.0|UIMax=1.0>": {
          "comment": "Velocity damping coefficient."
        },
        "ExternalAcceleration": {
          "comment": "Acceleration applied to each particle."
        },
        "MaxMotionDistance": {
          "comment": "Distance fluid can travel in one simulation step. Decreasing this value can improve performance."
        },
        "bStaticCollision": {
          "comment": "Whether to collide with static shapes. Disabling this flag isn't recommended."
        },
        "bTwoWayCollision": {
          "comment": "Whether dynamic particle collision affects the shapes the particles collide with."
        },
        "CollisionResponseCoefficient<ClampMin=0.0|UIMax=1.0>": {
          "comment": "Impulse transfer from particles to colliding dynamic shapes, if bTwoWayCollision has been set."
        },
        "KernelRadiusMultiplier<UIMin=1.0|UIMax=3.0>": {
          "comment": "Sphere of influence for SPH fluid particles."
        },
        "PacketSizeMultiplier": {
          "comment": "Packet size can influence collision performance."
        },
        "RestDensity<ClampMin=0.0>": {
          "comment": "Particle mass = RestParticleDistance^3 * RestDensity. Also target density for SPH fluid particles."
        },
        "RestParticleDistance": {
          "comment": "Particle mass = RestParticleDistance^3 * RestDensity. Also rest state for SPH fluid particles."
        },
        "SimulationMethod": {
          "comment": "Use SPH particles if you want particles to interact with each other."
        },
        "Stiffness<ClampMin=0.0|UIMin=1.0|UIMax=200.0>": {
          "comment": "Affects compressibility of SPH fluid particles. Low values are more compressible. Higher values could result in unstable simulation."
        },
        "Viscosity<ClampMin=0.0|UIMin=5.0|UIMax=300.0>": {
          "comment": "Viscosity for SPH fluid particles. Higher values will result in honey-like behavior."
        }
      }
    },
    "PickupFactory": {
      "properties": {
        "bRespawnPaused": {
          "comment": "set when the respawn process has been paused because DelayRespawn() is returning true"
        },
        "OriginalFactory": {
          "comment": "similarly, set this property on the replacement to point to the original so\n that it can optimally anchor itself on the path network"
        },
        "ReplacementFactory": {
          "comment": "when replacing a pickup factory with another (e.g. mutators), set this property on the original to point to the replacement\n so that AI queries can be redirected to the right one"
        }
      },
      "functions": {
        "GiveTo": {
          "comment": "give pickup to player"
        },
        "RecheckValidTouch": {
          "comment": "Pickup was touched through a wall. Check to see if touching pawn is no longer obstructed"
        },
        "SetPickupHidden": {
          "comment": "Make pickup mesh and associated effects hidden."
        },
        "SetPickupVisible": {
          "comment": "Make pickup mesh and associated effects visible."
        }
      }
    },
    "Player": {
      "properties": {
        "PP_DesaturationMultiplier": {
          "comment": "Global multiplier for scene desaturation PP effect."
        },
        "PP_HighlightsMultiplier": {
          "comment": "Global multiplier for scene highlights PP effect."
        },
        "PP_MidTonesMultiplier": {
          "comment": "Global multiplier for scene midtones PP effect."
        },
        "PP_ShadowsMultiplier": {
          "comment": "Global multiplier for scene shadows PP effect."
        }
      },
      "functions": {
        "SwitchController": {
          "comment": "Dynamically assign Controller to Player and set viewport.",
          "params": {
            "PC": "new player controller to assign to player"
          }
        }
      }
    },
    "PlayerController": {
      "properties": {
        "bBlockCameraAnimsFromOverridingPostProcess": {
          "comment": "Whether camera anims should be blocked from overriding post process"
        },
        "bCheckRelevancyThroughPortals": {
          "comment": "if true, check relevancy of Actors through portals listed in VisiblePortals array"
        },
        "bCheckSoundOcclusion": {
          "comment": "If true, do a trace to check if sound is occluded, and reduce the effective sound radius if so"
        },
        "bCinemaDisableInputLook": {
          "comment": "The state of the inputs from cinematic mode"
        },
        "bCinemaDisableInputMove": {
          "comment": "The state of the inputs from cinematic mode"
        },
        "bCinematicMode": {
          "comment": "Is this player currently in cinematic mode? Prevents rotation/movement/firing/etc"
        },
        "bClientSimulatingViewTarget": {
          "comment": "True if clients are handling setting their own viewtarget and the server should not replicate it (e.g. during certain matinees)"
        },
        "bDebugCameraAnims": {
          "comment": "Whether to print the list of current camera anims to the screen"
        },
        "BestNextHostPeers": {
          "comment": "Sorted list of peers to be the next host. Client peers will determine if they are the new host by looking at this list."
        },
        "bHasVoiceHandshakeCompleted": {
          "comment": "Indicates that the server and client"
        },
        "bIgnoreLookInput": {
          "comment": "Ignores look input. Stacked state storage, use accessor function IgnoreLookInput()."
        },
        "bIgnoreMoveInput": {
          "comment": "Ignores movement input. Stacked state storage, Use accessor function IgnoreMoveInput()"
        },
        "bIgnoreNetworkMessages": {
          "comment": "Whether to ignore network error messages from now on"
        },
        "bIsControllerConnected": {
          "comment": "True if the controller is connected for this player"
        },
        "bIsExternalUIOpen": {
          "comment": "True if there is externally controlled UI that should pause the game"
        },
        "bIsUsingStreamingVolumes": {
          "comment": "Whether this controller is using streaming volumes"
        },
        "BlendedTargetViewRotation": {
          "comment": "used for smoothing the viewrotation of spectated players"
        },
        "bLogHearSoundOverflow": {
          "comment": "option to print out list of sounds when MaxConcurrentHearSounds is exceeded"
        },
        "ClientCap": {
          "comment": "Cap set by server on bandwidth from client to server in bytes/sec (only has impact if >=2600)"
        },
        "ConnectedPeers": {
          "comment": "List of net ids for peer connections relative to this player. If a player is missing a connected peer then voice packets are routed through server."
        },
        "ControllingDirTrackInst": {
          "comment": "Director track that's currently possessing this player controller, or none if not possessed."
        },
        "DelayedJoinSessionName": {
          "comment": "Used to cache the session name to join until the timer fires"
        },
        "DynamicPingThreshold": {
          "comment": "ping replication and netspeed adjustment based on ping"
        },
        "FOVAngle": {
          "comment": "field of view angle in degrees"
        },
        "GameplayVoiceMuteList": {
          "comment": "List of players muted via gameplay"
        },
        "HiddenActors": {
          "comment": "the actors which the camera shouldn't see - e.g. used to hide actors which the camera penetrates"
        },
        "InteractDistance": {
          "comment": "Maximum distance to search for interactable actors"
        },
        "LastPingUpdate": {
          "comment": "Client time when last ping update was sent to server."
        },
        "LastSpectatorStateSynchTime": {
          "comment": "Used to make sure the client is kept synchronized when in a spectator state"
        },
        "LastSpeedHackLog": {
          "comment": "Last time possible speedhack was logged in server log."
        },
        "LODDistanceFactor": {
          "comment": "last used FOV based multiplier to distance to an object when determining if it exceeds the object's cull distance\n @note: only valid on client"
        },
        "MaxConcurrentHearSounds": {
          "comment": "component pooling for sounds played through PlaySound()/ClientHearSound()"
        },
        "MigratedSearchToJoin": {
          "comment": "Holds the migrated session sent by the new host. Client peers will join this migrated session."
        },
        "MinRespawnDelay": {
          "comment": "minimum time before can respawn after dying"
        },
        "MyCoverReplicator": {
          "comment": "handles copying and replicating old cover changes from WorldInfo.CoverReplicatorBase on creation as well as replicating new changes"
        },
        "NetPlayerIndex": {
          "comment": "index identifying players using the same base connection (splitscreen clients)\n Used by netcode to match replicated PlayerControllers to the correct splitscreen viewport and child connection\n replicated via special internal code, not through normal variable replication"
        },
        "OnlinePlayerData": {
          "comment": "The data store that holds any online player data"
        },
        "OnlineSub": {
          "comment": "Cached online subsystem variable"
        },
        "PendingMapChangeLevelNames": {
          "comment": "list of names of levels the server is in the middle of sending us for a PrepareMapChange() call"
        },
        "PendingSwapConnection": {
          "comment": "this is set on the OLD PlayerController when performing a swap over a network connection\n so we know what connection we're waiting on acknowledgement from to finish destroying this PC\n (or when the connection is closed)\n @see GameInfo::SwapPlayerControllers()"
        },
        "SavedMoveClass": {
          "comment": "SavedMoveClass should be changed for network player move replication where different properties need to be replicated from the base engine implementation."
        },
        "SpectatorCameraSpeed": {
          "comment": "How fast spectator camera is allowed to move"
        },
        "VoiceInterface": {
          "comment": "Cached online voice interface variable"
        },
        "VoiceMuteList": {
          "comment": "List of players that are explicitly muted (outside of gameplay)"
        },
        "VoicePacketFilter": {
          "comment": "The list of combined players to filter voice packets for"
        }
      },
      "functions": {
        "AddDebugText": {
          "comment": "Add debug text for a specific actor to be displayed via DrawDebugTextList(). If the debug text is invalid then it will\n attempt to remove any previous entries via RemoveDebugText()."
        },
        "AddPeer": {
          "comment": "Keep track of a newly added peer for this player and also replicate to server.",
          "params": {
            "PeerNetId": "net id of remote client peer being added",
            "NATType": "NAT of remote peer"
          }
        },
        "AdjustFOV": {
          "comment": "AdjustFOV()\nFOVAngle smoothly interpolates to DesiredFOV"
        },
        "AdjustPlayerWalkingMoveAccel": {
          "comment": "Allow player controllers to adjust the acceleration in PlayerWalking",
          "params": {
            "NewAccel": "the acceleration used by PlayerWalking::PlayerMove"
          }
        },
        "AimHelpDot": {
          "comment": "AimHelpDot()"
        },
        "BugIt": {
          "comment": "This function is used to print out the BugIt location. It prints out copy and paste versions for both IMing someone to type in\n and also a gameinfo ?options version so that you can append it to your launching url and be taken to the correct place.\n Additionally, it will take a screen shot so reporting bugs is a one command action!"
        },
        "BugItGo": {
          "comment": "This will move the player and set their rotation to the passed in values.\n We have this version of the BugIt family as it is easier to type in just raw numbers in the console."
        },
        "BugItGoString": {
          "comment": "This will move the player and set their rotation to the passed in values."
        },
        "BugItStringCreator": {
          "comment": "This will create a BugItGo string for us. Nice for calling form c++ where you just want the string and no Screenshots"
        },
        "BugItWorker": {
          "comment": "This will move the player and set their rotation to the passed in values.\n This actually does the location / rotation setting. Additionally it will set you as ghost as the level may have"
        },
        "Camera": {
          "comment": "Change Camera mode",
          "params": {
            "New": "camera mode to set"
          }
        },
        "CameraLookAtFinished": {
          "comment": "The function called when a CameraLookAt action is deactivated from kismet"
        },
        "CanAllPlayersPlayOnline": {
          "comment": "Validates that each local player can play online"
        },
        "CanCommunicate": {
          "comment": "Overridden by specific games"
        },
        "CanUnpauseControllerConnected": {
          "comment": "Callback that checks to see if the controller is connected before unpausing"
        },
        "CanUnpauseExternalUI": {
          "comment": "Callback that checks the external UI state before allowing unpause"
        },
        "CanViewUserCreatedContent": {
          "comment": "Checks for parental controls blocking user created content"
        },
        "CE": {
          "comment": "Shortcut version for LDs who get tired of typing 'CauseEvent' all day. :-)"
        },
        "CleanUpAudioComponents": {
          "comment": "Clears out 'left-over' audio components."
        },
        "CleanupPawn": {
          "comment": "When the Controller is destroyed, the controlled pawn will need to be killed, but not the vehicle"
        },
        "ClearInviteDelegates": {
          "comment": "Clears all of the invite delegates"
        },
        "ClearOnlineDelegates": {
          "comment": "Unregisters all delegates previously registered with the online subsystem. Called when the player controller is being\n destroyed and/or replaced.\n @note: in certain cases (i.e. when the channel is closed from the server's end), the player controller will no longer have\n a reference its ULocalPlayer object. these delegates won't be cleared, but GC should clear the references for us."
        },
        "ClientArbitratedMatchEnded": {
          "comment": "Called when an arbitrated match has ended and we need to disconnect"
        },
        "ClientCancelPendingMapChange": {
          "comment": "tells client to cancel any pending map change"
        },
        "ClientClearKismetText": {
          "comment": "Stop drawing a kismet message on the HUD"
        },
        "ClientCommitMapChange": {
          "comment": "actually performs the level transition prepared by PrepareMapChange()"
        },
        "ClientDrawKismetText": {
          "comment": "Start drawing a kismet message on the HUD"
        },
        "ClientEndOnlineGame": {
          "comment": "Ends the online game using the session name in the PRI"
        },
        "ClientFlushLevelStreaming": {
          "comment": "tells the client to block until all pending level streaming actions are complete\n happens at the end of the tick\n primarily used to force update the client ASAP at join time"
        },
        "ClientForceGarbageCollection": {
          "comment": "forces GC at the end of the tick on the client"
        },
        "ClientIgnoreLookInput": {
          "comment": "calls IgnoreLookInput on client"
        },
        "ClientIgnoreMoveInput": {
          "comment": "calls IgnoreMoveInput on client"
        },
        "ClientInitializeDataStores": {
          "comment": "Initializes this client's Player data stores after seamless map travel"
        },
        "ClientMutePlayer": {
          "comment": "Locally mutes a remote player",
          "params": {
            "PlayerNetId": "the remote player to mute"
          }
        },
        "ClientNotifyPartyHostLeaving": {
          "comment": "RPC notification to client that a party host is about to leave the match",
          "params": {
            "PartyHostPlayerId": "net id of the party host that is leaving"
          }
        },
        "ClientPauseRumble": {
          "comment": "Pause force-feedback for this player.",
          "params": {
            "bShouldPauseRumble": "indicates whether force-feedback should be paused or unpaused."
          }
        },
        "ClientPlayActorFaceFXAnim": {
          "comment": "plays a FaceFX anim on the specified actor for the client"
        },
        "ClientPlayCameraShake": {
          "comment": "Play Camera Shake"
        },
        "ClientPlayForceFeedbackWaveform": {
          "comment": "Tells the client to play a waveform for the specified damage type",
          "params": {
            "FFWaveform": "The forcefeedback waveform to play",
            "FFWaveformInstigator": "the actor causing the waveform to play"
          }
        },
        "ClientPrepareMapChange": {
          "comment": "asynchronously loads the given level in preparation for a streaming map transition.\n the server sends one function per level name since dynamic arrays can't be replicated",
          "params": {
            "LevelNames": "the names of the level packages to load. LevelNames[0] will be the new persistent (primary) level",
            "bFirst": "whether this is the first item in the list (so clear the list first)",
            "bLast": "whether this is the last item in the list (so start preparing the change after receiving it)"
          }
        },
        "ClientPrestreamTextures": {
          "comment": "Forces the streaming system to disregard the normal logic for the specified duration and\n instead always load all mip-levels for all textures used by the specified actor.",
          "params": {
            "ForcedActor": "The actor whose textures should be forced into memory.",
            "ForceDuration": "Number of seconds to keep all mip-levels in memory, disregarding the normal priority logic.",
            "bEnableStreaming": "Whether to start (TRUE) or stop (FALSE) streaming",
            "CinematicTextureGroups": "Bitfield indicating which texture groups that use extra high-resolution mips"
          }
        },
        "ClientRegisterForArbitration": {
          "comment": "Tells the client to register with arbitration. The client must notify the\n server once that is complete or it will be kicked from the match"
        },
        "ClientRegisterHostStatGuid": {
          "comment": "Registers the host's stat guid with the online subsystem",
          "params": {
            "StatGuid": "the stat guid to register"
          }
        },
        "ClientReturnToParty": {
          "comment": "Used when a host is telling a client to return to their party host from the\n current session. It looks for the session named 'Party' and does a travel to\n it. If it's not available, it just does a \"disconnect\"",
          "params": {
            "RequestingPlayerId": "net id of the player that is requesting the travel"
          }
        },
        "ClientSetBlockOnAsyncLoading": {
          "comment": "sets bRequestedBlockOnAsyncLoading which will later bring up a loading screen and then finish any async loading in progress\n called automatically on all clients whenever something triggers it on the server"
        },
        "ClientSetCameraMode": {
          "comment": "Replicated function to set camera style on client",
          "params": {
            "NewCamMode,": "name defining the new camera mode"
          }
        },
        "ClientSetCinematicMode": {
          "comment": "called by the server to synchronize cinematic transitions with the client"
        },
        "ClientSetForceMipLevelsToBeResident": {
          "comment": "Forces the streaming system to disregard the normal logic for the specified duration and\n instead always load all mip-levels for all textures used by the specified material.",
          "params": {
            "Material": "The material whose textures should be forced into memory.",
            "ForceDuration": "Number of seconds to keep all mip-levels in memory, disregarding the normal priority logic.",
            "CinematicTextureGroups": "Bitfield indicating which texture groups that use extra high-resolution mips"
          }
        },
        "ClientSetHostUniqueId": {
          "comment": "Sets the host's net id for handling dropped arbitrated matches",
          "params": {
            "InHostId": "the host's unique net id to report the drop for"
          }
        },
        "ClientSetOnlineStatus": {
          "comment": "Looks at the current game state and uses that to set the\n rich presence strings\n Licensees should override this in their player controller derived class"
        },
        "ClientSetProgressMessage": {
          "comment": "server to client RPC for server-generated network messages that aren't part of the connection process (e.g. being kicked)"
        },
        "ClientSpawnCameraLensEffect": {
          "comment": "Spawn a camera lens effect (e.g. blood)."
        },
        "ClientStartNetworkedVoice": {
          "comment": "Tells this client that it should send voice data over the network"
        },
        "ClientStartOnlineGame": {
          "comment": "Starts the online game using the session name in the PRI"
        },
        "ClientStopForceFeedbackWaveform": {
          "comment": "Tells the client to stop any waveform that is playing. Note if the optional\n parameter is passed in, then the waveform is only stopped if it matches",
          "params": {
            "FFWaveform": "The forcefeedback waveform to stop"
          }
        },
        "ClientStopNetworkedVoice": {
          "comment": "Tells this client that it should not send voice data over the network"
        },
        "ClientTravel": {
          "comment": "Travel to a different map or IP address. Calls the PreClientTravel event before doing anything.",
          "params": {
            "URL": "a string containing the mapname (or IP address) to travel to, along with option key/value pairs",
            "TravelType": "specifies whether the client should append URL options used in previous travels; if TRUE is specified\n for the bSeamlesss parameter, this value must be TRAVEL_Relative.",
            "bSeamless": "indicates whether to use seamless travel (requires TravelType of TRAVEL_Relative)",
            "MapPackageGuid": "the GUID of the map package to travel to - this is used to find the file when it has been autodownloaded,\n so it is only needed for clients"
          }
        },
        "ClientTravelToSession": {
          "comment": "Used when a host is telling a client to go to a specific Internet session",
          "params": {
            "SessionName": "the name of the session to register",
            "SearchClass": "the search that should be populated with the session",
            "PlatformSpecificInfo": "the binary data to place in the platform specific areas"
          }
        },
        "ClientUnmutePlayer": {
          "comment": "Locally unmutes a remote player",
          "params": {
            "PlayerNetId": "the remote player to unmute"
          }
        },
        "ClientUpdateBestNextHosts": {
          "comment": "Update the list of sorted next hosts on clients. This is used during host migration.\n All clients should agree on the best next host.",
          "params": {
            "SortedNextHosts": "array of player net ids to be the next host when disconnect occurs",
            "NumEntries": "number of valid entries in array of next hosts"
          }
        },
        "ClientUpdatePosition": {
          "comment": "Called from PlayerTick after receiving ClientAdjustPosition call from server (and setting the bUpdating flag)\n Client has already had position information corrected\n This function plays through previously saved moves that haven't been acknowledged by the server, predicting where the client\n should be after the server correction"
        },
        "ClientVoiceHandshakeComplete": {
          "comment": "Tells the client that the server has all the information it needs and that it\n is ok to start sending voice packets. The server will already send voice packets\n when this function is called, since it is set server side and then forwarded\n NOTE: This is done as an RPC instead of variable replication because ordering matters"
        },
        "ClientWriteLeaderboardStats": {
          "comment": "Tells the clients to write the stats using the specified stats object",
          "params": {
            "OnlineStatsWriteClass": "the stats class to write with",
            "bIsIncomplete": "TRUE if the match wasn't finished at the time of the write"
          }
        },
        "ClientWriteOnlinePlayerScores": {
          "comment": "Writes the scores for all active players. Override this in your\n playercontroller class to provide custom scoring",
          "params": {
            "LeaderboardId": "the leaderboard the scores are being written to"
          }
        },
        "ConditionalPause": {
          "comment": "Toggles the game's paused state if it does not match the desired pause state.",
          "params": {
            "bDesiredPauseState": "TRUE indicates that the game should be paused."
          }
        },
        "ConsoleKey": {
          "comment": "console control commands, useful when remote debugging so you can't touch the console the normal way"
        },
        "CreateTTSSoundCue": {
          "comment": "Constructs a SoundCue, performs text-to-wavedata conversion."
        },
        "DebugCameraAnims": {
          "comment": "Toggle camera animation debug output"
        },
        "DebugLogPRIs": {
          "comment": "Logs the list of active PRIs in the game"
        },
        "DelayedPrepareMapChange": {
          "comment": "used to wait until a map change can be prepared when one was already in progress"
        },
        "DisplayDebug": {
          "comment": "list important PlayerController variables on canvas. HUD will call DisplayDebug() on the current ViewTarget when\n the ShowDebug exec is used",
          "params": {
            "HUD": "HUD with canvas to draw on\n \n@input out_YL - Height of the current font\n \n@input out_YPos - Y position on Canvas. out_YPos += out_YL, gives position to draw text for next debug line."
          }
        },
        "DoForceFeedbackForScreenShake": {
          "comment": "Attempts to play force-feedback that matches the camera shake. To be implemented at a higher level (see GameFramework)."
        },
        "DrawDebugTextList": {
          "comment": "Iterate through list of debug text and draw it over the associated actors in world space.\n Also handles culling null entries, and reducing the duration for timed debug text."
        },
        "DrawHUD": {
          "comment": "Hook called from HUD actor. Gives access to HUD and Canvas"
        },
        "DumpOnlineSessionState": {
          "comment": "Logs the current session state for the online layer"
        },
        "DumpPeers": {
          "comment": "Logs the list of active peer connections for this player"
        },
        "DumpVoiceMutingState": {
          "comment": "Logs the current muting state of the server"
        },
        "FellOutOfWorld": {
          "comment": "called when the actor falls out of the world 'safely' (below KillZ and such)"
        },
        "FindConnectedPeerIndex": {
          "comment": "Find the index of the entry in the connected peer list",
          "params": {
            "PeerNetId": "net id of remote client peer to find"
          }
        },
        "FindVehicleToDrive": {
          "comment": "Tries to find a vehicle to drive within a limited radius. Returns true if successful"
        },
        "ForceClearUnpauseDelegates": {
          "comment": "Tells the game info to forcibly remove this player's CanUnpause delegates from its list of Pausers.\n Called when the player controller is being destroyed to prevent the game from being stuck in a paused state when a PC that\n paused the game is destroyed before the game is unpaused."
        },
        "ForceSingleNetUpdateFor": {
          "comment": "forces a full replication check of the specified Actor on only the client that owns this PlayerController\n (equivalent to setting bForceNetUpdate and bNetDirty to true, but only for that client)\n this function has no effect if this PC is not a remote client or if the Actor is not relevant to that client"
        },
        "GameplayMutePlayer": {
          "comment": "Mutes a remote player on the server and then tells the client to mute",
          "params": {
            "PlayerNetId": "the remote player to mute"
          }
        },
        "GameplayUnmutePlayer": {
          "comment": "Unmutes a remote player on the server and then tells the client to unmute",
          "params": {
            "PlayerNetId": "the remote player to unmute"
          }
        },
        "GetAchievementProgression": {
          "comment": "Get the completion amount for a game achievement.",
          "params": {
            "AchievementId": "the id for the achievement to get the completion percetage for",
            "CurrentValue": "the current number of times the event required to unlock the achievement has occurred.",
            "MaxValue": "the value that represents 100% completion."
          }
        },
        "GetAdjustedAimFor": {
          "comment": "Adjusts weapon aiming direction.\n Gives controller a chance to modify the aiming of the pawn. For example aim error, auto aiming, adhesion, AI help...\n Requested by weapon prior to firing.",
          "params": {
            "W,": "weapon about to fire",
            "StartFireLoc,": "world location of weapon fire start trace, or projectile spawn loc.",
            "BaseAimRot,": "original aiming rotation without any modifications."
          }
        },
        "GetFOVAngle": {
          "comment": "returns player's FOV angle"
        },
        "GetOnlineSubsystem": {
          "comment": "Wrapper for getting reference to the OnlineSubsystem"
        },
        "GetPartyGameTypeName": {
          "comment": "Returns the party game info name for this game"
        },
        "GetPartyMapName": {
          "comment": "Returns the party map name for this game"
        },
        "GetPlayerControllerFromNetId": {
          "comment": "Returns the player controller associated with this net id",
          "params": {
            "PlayerNetId": "the id to search for"
          }
        },
        "GetPlayerViewPoint": {
          "comment": "Returns Player's Point of View\n For the AI this means the Pawn's 'Eyes' ViewPoint\n For a Human player, this means the Camera's ViewPoint\n @output out_Location, view location of player\n @output out_rotation, view rotation of player"
        },
        "GetPooledAudioComponent": {
          "comment": "get an audio component from the HearSound pool\n creates a new component if the pool is empty and MaxConcurrentHearSounds has not been exceeded\n the component is initialized with the values passed in, ready to call Play() on\n its OnAudioFinished delegate is set to this PC's HearSoundFinished() function",
          "params": {
            "ASound": "the sound to play",
            "SourceActor": "the Actor to attach the sound to (if None, attached to self)",
            "bStopWhenOwnerDestroyed": "whether the sound stops if SourceActor is destroyed",
            "bUseLocation": "(optional) - whether to use the SourceLocation parameter for the sound's location (otherwise, SourceActor's location)",
            "SourceLocation": "(optional) - if bUseLocation, the location for the sound"
          }
        },
        "GetRegisteredPlayersInSession": {
          "comment": "Get the list of registered players in a session",
          "params": {
            "SessionName": "name of session to get players from",
            "OutRegisteredPlayers": "array of players in the session"
          }
        },
        "GetSeamlessTravelActorList": {
          "comment": "called on client during seamless level transitions to get the list of Actors that should be moved into the new level\n PlayerControllers, Role < ROLE_Authority Actors, and any non-Actors that are inside an Actor that is in the list\n (i.e. Object.Outer == Actor in the list)\n are all autmoatically moved regardless of whether they're included here\n only dynamic (!bStatic and !bNoDelete) actors in the PersistentLevel may be moved (this includes all actors spawned during gameplay)\n this is called for both parts of the transition because actors might change while in the middle (e.g. players might join or leave the game)\n \n@see also GameInfo::GetSeamlessTravelActorList() (the function that's called on servers)",
          "params": {
            "bToEntry": "true if we are going from old level -> entry, false if we are going from entry -> new level",
            "ActorList": "(out) list of actors to maintain"
          }
        },
        "GetSplitscreenPlayerByIndex": {
          "comment": "Returns the PRI associated with the player at the specified index.",
          "params": {
            "PlayerIndex": "the index [into the local player's GamePlayers array] for the player PRI to find"
          }
        },
        "GetSplitscreenPlayerCount": {
          "comment": "Returns the number of split-screen players playing on this player's machine."
        },
        "GetTriggerUseList": {
          "comment": "Looks at all nearby triggers, looking for any that can be\n interacted with.",
          "params": {
            "interactDistanceToCheck": "distance to search for nearby triggers",
            "crosshairDist": "distance from the crosshair that\n triggers must be, else they will be filtered out",
            "minDot": "minimum dot product between trigger and the\n camera orientation needed to make the list",
            "bUsuableOnly": "if true, event must return true from\n SequenceEvent::CheckActivate()",
            "out_useList": "the list of triggers found to be\n usuable"
          }
        },
        "GetUIController": {
          "comment": "Returns the interaction that manages the UI system."
        },
        "HasClientLoadedCurrentWorld": {
          "comment": "returns whether the client has completely loaded the server's current world (valid on server only)"
        },
        "HasPeerConnection": {
          "comment": "Determine if this player has a peer connection for the given net id",
          "params": {
            "PeerNetId": "net id of remote client peer"
          }
        },
        "HearSoundFinished": {
          "comment": "hooked up to the OnAudioFinished delegate of AudioComponents created through PlaySound() to return them to the pool"
        },
        "IgnoreLookInput": {
          "comment": "Toggles look input. FALSE means look input is cleared."
        },
        "IgnoreMoveInput": {
          "comment": "Toggles move input. FALSE means movement input is cleared."
        },
        "InviteHasEnoughSpace": {
          "comment": "Counts the number of local players to verify there is enough space"
        },
        "IsBestHostPeer": {
          "comment": "Determine if the player in our list of connected peers is at the top of the best next host list.\n Only peers that have lost their connection to the server are considered.\n If there is a player higher on the list that has also lost connection to server then not hosting.",
          "params": {
            "PeerNetId": "net id of player to check as best host"
          }
        },
        "IsLocalController": {
          "comment": "returns whether this controller is a local controller.\n @RETURN true if NM_Standalone, or is local playercontroller"
        },
        "IsLocalPlayerController": {
          "comment": "returns whether this Controller is a locally controlled PlayerController\n @note not valid until the Controller is completely spawned (i.e, unusable in Pre/PostBeginPlay())"
        },
        "IsLookInputIgnored": {
          "comment": "return TRUE if look input is ignored."
        },
        "IsMoveInputIgnored": {
          "comment": "return TRUE if movement input is ignored."
        },
        "IsPartyLeader": {
          "comment": "Wrapper for determining whether a player is the party leader."
        },
        "IsPaused": {
          "comment": "Returns whether the game is currently paused."
        },
        "IsPlayerMuted": {
          "comment": "Native function to determine if voice data should be received from this player.\n Only called on the server to determine whether voice packet replication\n should happen for the given sender.\n NOTE: This function is final because it can be called n^2 number of times\n in a given frame, where n is the number of players. Change/overload this\n function with caution as this can affect your network performance.",
          "params": {
            "Sender": "the player to check for mute status"
          }
        },
        "IsPrimaryPlayer": {
          "comment": "Wrapper for determining whether this player is the first player on their console."
        },
        "IsShowingSubtitles": {
          "comment": "This will turn return whether the subtitles are on or off"
        },
        "IsSplitscreenPlayer": {
          "comment": "Determines whether this player is playing split-screen.",
          "params": {
            "out_SplitscreenPlayerIndex": "receives the index [into the player's local GamePlayers array] for this player, if playing splitscreen.\n ."
          }
        },
        "LimitSpectatorVelocity": {
          "comment": "Adjust spectator velocity if \"out of bounds\"\n (above stallz or below killz)"
        },
        "LimitViewRotation": {
          "comment": "Limit the player's view rotation. (Pitch component)."
        },
        "ListConsoleEvents": {
          "comment": "Lists all console events to the HUD."
        },
        "LogLoc": {
          "comment": "Logs the current location in bugit format without taking screenshot and further routing."
        },
        "MigrateNewHost": {
          "comment": "Attempt host migration for the current player."
        },
        "ModifyClientURL": {
          "comment": "Allows the game to modify the URL that clients will use to connect to a server (should be called\n by pretty much anyone who calls GetResolvedConnectString())"
        },
        "NotifyDirectorControl": {
          "comment": "notification when a matinee director track starts or stops controlling the ViewTarget of this PlayerController"
        },
        "NotifyHostMigrationStarted": {
          "comment": "Notification on this client that the host migration process has started\n May or may not complete successfully from this point"
        },
        "NotifyInviteFailed": {
          "comment": "Override to display a message to the user"
        },
        "NotifyLoadedWorld": {
          "comment": "called clientside when it is loaded a new world via seamless travelling",
          "params": {
            "WorldPackageName": "the name of the world package that was loaded",
            "bFinalDest": "whether this world is the destination map for the travel (i.e. not the transition level)"
          }
        },
        "NotifyNotAllPlayersCanJoinInvite": {
          "comment": "Override to display a message to the user"
        },
        "NotifyNotEnoughSpaceInInvite": {
          "comment": "Override to display a message to the user"
        },
        "NotifyPeerDisconnectHost": {
          "comment": "Notification that one of the peer connections has lost his connection to the server. RPC is received through peer net driver.",
          "params": {
            "PeerNetId": "net id of player that lost his connection"
          }
        },
        "NotifyTakeHit": {
          "comment": "Notification from pawn that it has received damage\n via TakeDamage()."
        },
        "OnArbitrationRegisterComplete": {
          "comment": "Delegate that is notified when registration is complete. Forwards the call\n to the server so that it can finalize processing",
          "params": {
            "SessionName": "the name of the session this is for",
            "bWasSuccessful": "whether registration worked or not"
          }
        },
        "OnCameraShake": {
          "comment": "Scripting hook for camera shakes."
        },
        "OnConsoleCommand": {
          "comment": "Kismet hook to trigger console events"
        },
        "OnControllerChanged": {
          "comment": "Attempts to pause/unpause the game when a controller becomes\n disconnected/connected",
          "params": {
            "ControllerId": "the id of the controller that changed",
            "bIsConnected": "whether the controller is connected or not"
          }
        },
        "OnDestroyForInviteComplete": {
          "comment": "Delegate called once the destroy of an online game before accepting an invite\n is complete. From here, the game invite can be accepted",
          "params": {
            "SessionName": "the name of the session being ended",
            "bWasSuccessful": "whether the end completed ok or not"
          }
        },
        "OnEndForInviteComplete": {
          "comment": "Delegate called once the destroy of an online game before accepting an invite\n is complete. From here, the game invite can be accepted",
          "params": {
            "SessionName": "the name of the session being ended",
            "bWasSuccessful": "whether the end completed ok or not"
          }
        },
        "OnEngineInitialTick": {
          "comment": "An event that is called after the first tick of GEngine"
        },
        "OnExternalUIChanged": {
          "comment": "Attempts to pause/unpause the game when the UI opens/closes. Note: pausing\n only happens in standalone mode",
          "params": {
            "bIsOpening": "whether the UI is opening or closing"
          }
        },
        "OnFlyThroughHasEnded": {
          "comment": "This is used to notify the PlayerController that a fly through has ended and then quit if we are doing a Sentinel run"
        },
        "OnForceFeedback": {
          "comment": "Kismet interface for playing/stopping force feedback."
        },
        "OnGameInviteAccepted": {
          "comment": "Delegate called when the user accepts a game invite externally. This allows\n the game code a chance to clean up before joining the game via\n AcceptGameInvite() call.\n NOTE: There must be space for all signed in players to join the game. All\n players must also have permission to play online too.",
          "params": {
            "InviteResult": "the search/settings for the game we're to join"
          }
        },
        "OnHostMigratedOnlineGame": {
          "comment": "Delegate called once the session migration on the host completed.",
          "params": {
            "SessionName": "the name of the session being migrated",
            "bWasSuccessful": "whether the session migration completed ok or not"
          }
        },
        "OnInviteJoinComplete": {
          "comment": "Once the join completes, use the platform specific connection information\n to connect to it",
          "params": {
            "SessionName": "the name of the session that was joined",
            "bWasSuccessful": "whether the join worked or not"
          }
        },
        "OnJoinMigratedGame": {
          "comment": "Delegate called once the join/migration of the session has completed.",
          "params": {
            "SessionName": "the name of the session being joined/migrated",
            "bWasSuccessful": "whether the join/migrate completed ok or not"
          }
        },
        "OnJoinTravelToSessionComplete": {
          "comment": "Called when the join for the travel destination has completed",
          "params": {
            "SessionName": "the name of the session the event is for",
            "bWasSuccessful": "whether it worked or not"
          }
        },
        "OnPartyMemberListChanged": {
          "comment": "Is called when someone joins/leaves the player's party chat session",
          "params": {
            "bJoinedOrLeft": "true if the player joined, false if they left",
            "PlayerName": "the name of the player that was affected",
            "PlayerId": "the net id of the player that left"
          }
        },
        "OnPartyMembersInfoChanged": {
          "comment": "Is called when someone in your party chat has their custom data change (game controlled)",
          "params": {
            "PlayerName": "the name of the player that was affected",
            "PlayerId": "the net id of the player that had data change",
            "CustomData1": "the first 4 bytes of the custom data",
            "CustomData2": "the second 4 bytes of the custom data",
            "CustomData3": "the third 4 bytes of the custom data",
            "CustomData4": "the fourth 4 bytes of the custom data"
          }
        },
        "OnRegisterHostStatGuidComplete": {
          "comment": "Called once the host registration has completed. Sends the host this clients stat guid",
          "params": {
            "bWasSuccessful": "true if the registration worked, false otherwise"
          }
        },
        "OnSetSoundMode": {
          "comment": "A trivial way to handle the SetSoundMode kismet action"
        },
        "OnToggleCinematicMode": {
          "comment": "Handles switching the player in/out of cinematic mode."
        },
        "OnUnregisterPlayerCompleteForHostMigrate": {
          "comment": "Delegate called after each iteration of unregistering a player",
          "params": {
            "SessionName": "the name of the session to unregister player from",
            "PlayerId": "net id of player that was unregistered",
            "bWasSuccessful": "whether the unregister completed ok or not"
          }
        },
        "OnUnregisterPlayerCompleteForJoinMigrate": {
          "comment": "Delegate called after each iteration of unregistering a player",
          "params": {
            "SessionName": "the name of the session to unregister player from",
            "PlayerId": "net id of player that was unregistered",
            "bWasSuccessful": "whether the unregister completed ok or not"
          }
        },
        "PauseRumbleForAllPlayers": {
          "comment": "Pause force-feedback for all players.",
          "params": {
            "bShouldPauseRumble": "indicates whether force-feedback should be paused or unpaused."
          }
        },
        "PeerDesignatedAsClient": {
          "comment": "This peer player has been to told to travel with a migrated session to new host.",
          "params": {
            "SessionName": "Name of the session that was migrated. Can be 'None' if migrating without a session"
          }
        },
        "PeerDesignatedAsHost": {
          "comment": "This peer player has been selected as the new host.\n Notify all other clients that have also lost their server connection to begin traveling to the newly migrated session.\n Begin traveling as the new host.",
          "params": {
            "SessionName": "Name of the session that was migrated. Can be 'None' if migrating without a session"
          }
        },
        "PeerReceivedMigratedSession": {
          "comment": "Notification when client peer received a migrated session. The session is joined via migration and the client travels to the new host once the join succeeds.",
          "params": {
            "FromPeerNetId": "peer player that that sent us the migrated session. This is the new host",
            "SearchClass": "Search class being used by the game session on the host",
            "PlatformSpecificInfo": "Byte array with secure session info"
          }
        },
        "PeerTravelAsHost": {
          "comment": "Delay and then travel as the new host to the given URL",
          "params": {
            "TravelCountdownTimer": "Seconds to delay before initiating the travel",
            "URL": "browse path for the map/game to load as host"
          }
        },
        "PerformedUseAction": {
          "comment": "return true if player the Use action was handled"
        },
        "PlayerTick": {
          "comment": "PlayerTick is only called if the PlayerController has a PlayerInput object. Therefore, it will not be called on servers for non-locally controlled playercontrollers"
        },
        "PlayRumble": {
          "comment": "This will take an AnimNotify_Rumble and then grab out the correct waveform to be played"
        },
        "PostControllerIdChange": {
          "comment": "Notification that the ControllerId for this PC's LocalPlayer has been changed. Re-register all player data stores and any delegates that\n require a ControllerId."
        },
        "PreClientTravel": {
          "comment": "Called when the local player is about to travel to a new map or IP address. Provides subclass with an opportunity\n to perform cleanup or other tasks prior to the travel."
        },
        "PreControllerIdChange": {
          "comment": "Notification that the ControllerId for this PC LocalPlayer is about to change. Provides the PC a chance to cleanup anything that was\n associated with the old ControllerId. When this method is called, LocalPlayer.ControllerId is still the old value."
        },
        "PreJoinUpdateGameSettings": {
          "comment": "Last chance to fixup game settings values before joining a game with those settings",
          "params": {
            "SessionName": "name of the session that is about to be joined",
            "GameSettings": "settings object to be modified"
          }
        },
        "ProcessViewRotation": {
          "comment": "Processes the player's ViewRotation\n adds delta rot (player input), applies any limits and post-processing\n returns the final ViewRotation set on PlayerController",
          "params": {
            "DeltaTime,": "time since last frame",
            "ViewRotation,": "current player ViewRotation",
            "DeltaRot,": "player input added to ViewRotation"
          }
        },
        "ReceivedGameClass": {
          "comment": "This function will be called to notify the player controller that the world has received it's game class. In the case of a client\n we need to initialize the Input System here.\n @Param GameClass - The Class of the game that was replicated"
        },
        "ReceivedPlayer": {
          "comment": "Called after this PlayerController's viewport/net connection is associated with this player controller."
        },
        "RegisterCustomPlayerDataStores": {
          "comment": "Creates and initializes the \"PlayerOwner\" and \"PlayerSettings\" data stores. This function assumes that the PlayerReplicationInfo\n for this player has not yet been created."
        },
        "RegisterOnlineDelegates": {
          "comment": "Registers any handlers for delegates in the OnlineSubsystem. Called when a player is being created and/or ControllerId is changing."
        },
        "RegisterPlayerDataStores": {
          "comment": "Register all player data stores."
        },
        "RegisterStandardPlayerDataStores": {
          "comment": "Register any player data stores which do not require special initialization."
        },
        "ReloadProfileSettings": {
          "comment": "Refetches this player's profile settings."
        },
        "RemoteEvent": {
          "comment": "triggers a SeqEvent_RemoteEvent instead of a console event; LDs specifically requested separate commands"
        },
        "RemoveAllDebugStrings": {
          "comment": "Remove all debug text"
        },
        "RemoveDebugText": {
          "comment": "Remove debug text for the specific actor."
        },
        "RemoveMissingPeersFromSession": {
          "comment": "Find all players in the session that is about to be migrated. Unregister\n the players that have missing peer connections as they won't migrate.\n Begin migration once this is complete.",
          "params": {
            "SessionName": "name of session to be migrated"
          }
        },
        "RemovePeer": {
          "comment": "Keep track of a removed peer for this player and also replicate to server.",
          "params": {
            "PeerNetId": "net id of remote client peer being removed"
          }
        },
        "ResetCameraMode": {
          "comment": "Reset Camera Mode to default"
        },
        "ResetPlayerMovementInput": {
          "comment": "reset input to defaults"
        },
        "SaveActorConfig": {
          "comment": "Force a save config on the specified actor."
        },
        "SaveClassConfig": {
          "comment": "Force a save config on the specified class."
        },
        "SeamlessTravelFrom": {
          "comment": "called when seamless travelling and the specified PC is being replaced by this one\n copy over data that should persist\n (not called if PlayerControllerClass is the same for the from and to gametypes)"
        },
        "SeamlessTravelTo": {
          "comment": "called when seamless travelling and we are being replaced by the specified PC\n clean up any persistent state (post process chains on LocalPlayers, for example)\n (not called if PlayerControllerClass is the same for the from and to gametypes)"
        },
        "Sentinel_PostAcquireTravelTheWorldPoints": {
          "comment": "This function is called after we acquire the travel points right before we start traveling."
        },
        "Sentinel_PreAcquireTravelTheWorldPoints": {
          "comment": "This function is called before we acquire the travel points."
        },
        "Sentinel_SetupForGamebasedTravelTheWorld": {
          "comment": "This is a function which is called when sentinel is able to start TravelTheWorld. This allows the specific game\n to do things such as turning off UI/HUD and to not enter some default starting the game state."
        },
        "ServerAddPeer": {
          "comment": "Replicate newly added peer for this player to server.",
          "params": {
            "PeerNetId": "net id of remote client peer being added",
            "NATType": "NAT of remote peer"
          }
        },
        "ServerCauseEvent": {
          "comment": "Attempts to match the name passed in to a SeqEvent_Console\n object and then activate it.",
          "params": {
            "eventName": "name of the event to cause"
          }
        },
        "ServerMoveHandleClientError": {
          "comment": "called after movement in ServerMove() to check for and handle any potential error between server and client position\n by setting PendingAdjustment appropriately"
        },
        "ServerMutePlayer": {
          "comment": "Updates the server side information by adding to the mute list. Tells the\n player controller that owns the specified net id to also mute this PC.",
          "params": {
            "PlayerNetId": "the remote player to mute"
          }
        },
        "ServerNotifyLoadedWorld": {
          "comment": "called to notify the server when the client has loaded a new world via seamless travelling",
          "params": {
            "WorldPackageName": "the name of the world package that was loaded"
          }
        },
        "ServerNotifyPartyHostLeaving": {
          "comment": "RPC notification to server that a party host is about to leave the match.",
          "params": {
            "PartyHostPlayerId": "net id of the party host that is leaving"
          }
        },
        "ServerRegisterClientStatGuid": {
          "comment": "Registers the client's stat guid with the online subsystem",
          "params": {
            "StatGuid": "the stat guid to register"
          }
        },
        "ServerRegisteredForArbitration": {
          "comment": "Notifies the server that the arbitration registration is complete",
          "params": {
            "bWasSuccessful": "whether the registration with arbitration worked"
          }
        },
        "ServerRemovePeer": {
          "comment": "Replicate removed peer for this player to server.",
          "params": {
            "PeerNetId": "net id of remote client peer being removed"
          }
        },
        "ServerSetSpectatorLocation": {
          "comment": "when spectating, tells server where the client is (client is authoritative on location when spectating)"
        },
        "ServerUnmutePlayer": {
          "comment": "Updates the server side information by removing from the mute list. Tells the\n player controller that owns the specified net id to also unmute this PC.",
          "params": {
            "PlayerNetId": "the remote player to unmute"
          }
        },
        "ServerUpdateCamera": {
          "comment": "If PlayerCamera.bUseClientSideCameraUpdates is set, client will replicate camera positions to the server."
        },
        "ServerUpdateLevelVisibility": {
          "comment": "called when the client adds/removes a streamed level\n the server will only replicate references to Actors in visible levels so that it's impossible to send references to\n Actors the client has not initialized",
          "params": {
            "PackageName": "the name of the package for the level whose status changed"
          }
        },
        "ServerUse": {
          "comment": "Player pressed UseKey"
        },
        "SetAllowMatureLanguage": {
          "comment": "Whether or not to allow mature language"
        },
        "SetAudioGroupVolume": {
          "comment": "Sets the Audio Group to this the value passed in"
        },
        "SetCameraMode": {
          "comment": "Set new camera mode",
          "params": {
            "NewCamMode,": "new camera mode."
          }
        },
        "SetCinematicMode": {
          "comment": "Server/SP only function for changing whether the player is in cinematic mode. Updates values of various state variables, then replicates the call to the client\n to sync the current cinematic mode.",
          "params": {
            "bInCinematicMode": "specify TRUE if the player is entering cinematic mode; FALSE if the player is leaving cinematic mode.",
            "bHidePlayer": "specify TRUE to hide the player's pawn (only relevant if bInCinematicMode is TRUE)",
            "bAffectsHUD": "specify TRUE if we should show/hide the HUD to match the value of bCinematicMode",
            "bAffectsMovement": "specify TRUE to disable movement in cinematic mode, enable it when leaving",
            "bAffectsTurning": "specify TRUE to disable turning in cinematic mode or enable it when leaving",
            "bAffectsButtons": "specify TRUE to disable button input in cinematic mode or enable it when leaving."
          }
        },
        "SetControllerTiltActive": {
          "comment": "sets whether or not the Tilt functionality is turned on"
        },
        "SetControllerTiltDesiredIfAvailable": {
          "comment": "sets whether or not the the player wants to utilize the Tilt functionality"
        },
        "SetOnlyUseControllerTiltInput": {
          "comment": "sets whether or not to ONLY use the tilt input controls"
        },
        "SetRumbleScale": {
          "comment": "Scales the amount the rumble will play on the gamepad",
          "params": {
            "ScaleBy": "The amount to scale the waveforms by"
          }
        },
        "SetShowSubtitles": {
          "comment": "This will turn the subtitles on or off depending on the value of bValue",
          "params": {
            "bValue": "to show or not to show"
          }
        },
        "SetUseTiltForwardAndBack": {
          "comment": "sets whether or not to use the tilt forward and back input controls"
        },
        "SetViewTargetWithBlend": {
          "comment": "Wrapper to SetViewTarget with useful defaults"
        },
        "SoakPause": {
          "comment": "For AI debugging"
        },
        "SpawnCoverReplicator": {
          "comment": "spawns MyCoverReplicator and tells it to replicate any changes that have already occurred"
        },
        "TellPeerToTravel": {
          "comment": "Notify client peer to travel to the new host. RPC is sent through peer net driver.",
          "params": {
            "ToPeerNetId": "peer player to find connection for"
          }
        },
        "TellPeerToTravelToSession": {
          "comment": "Notify client peer to travel to the new host via its migrated session. RPC is sent through peer net driver.",
          "params": {
            "ToPeerNetId": "peer player to find connection for",
            "SessionName": "Name of session that was migrated to travel to",
            "SearchClass": "Search class being used by the current game session",
            "PlatformSpecificInfo": "Byte array with secure session info",
            "PlatformSpecificInfoSize": "Size in bytes of PlatformSpecificInfo"
          }
        },
        "TriggerInteracted": {
          "comment": "Examines the nearby enviroment and generates a priority sorted\n list of interactable actors, and then attempts to activate each\n of them until either one was successfully activated, or no more\n actors are available."
        },
        "UnregisterPlayerDataStores": {
          "comment": "Unregisters the \"PlayerOwner\" data store for this player. Called when this PlayerController is destroyed."
        },
        "UnregisterStandardPlayerDataStores": {
          "comment": "Unregisters all player data stores that remain after unregistering all player data stores that require custom unregister logic."
        },
        "UpdateStateFromAdjustment": {
          "comment": "Called by LongClientAdjustPosition()",
          "params": {
            "NewState": "is the state recommended by the server"
          }
        },
        "Use": {
          "comment": "Entry point function for player interactions with the world,\n re-directs to ServerUse."
        },
        "UsingFirstPersonCamera": {
          "comment": "return whether viewing in first person mode"
        },
        "ViewAPlayer": {
          "comment": "View next active player in PRIArray.",
          "params": {
            "dir": "is the direction to go in the array"
          }
        },
        "ViewShake": {
          "comment": "Updates any camera view shaking that is going on"
        }
      },
      "structs": {
        "ConnectedPeerInfo": {
          "comment": "Info about a connected peer relative to this player",
          "properties": {
            "bLostConnectionToHost": {
              "comment": "TRUE if remote peer has lost connecttion to the game host"
            },
            "NATType": {
              "comment": "NAT type of remote peer connection"
            },
            "PlayerId": {
              "comment": "Unique net id for the remote peer player"
            }
          }
        },
        "DebugTextInfo": {
          "comment": "List of actors and debug text to draw, @see AddDebugText(), RemoveDebugText(), and DrawDebugTextList()",
          "properties": {
            "bAbsoluteLocation": {
              "comment": "whether the offset should be treated as absolute world location of the string"
            },
            "bKeepAttachedToActor": {
              "comment": "If the actor moves does the text also move with it?"
            },
            "DebugText": {
              "comment": "Text to display"
            },
            "Duration": {
              "comment": "Duration used to lerp desired offset"
            },
            "Font": {
              "comment": "The Font which to display this as. Will Default to GetSmallFont("
            },
            "OrigActorLocation": {
              "comment": "When we first spawn store off the original actor location for use with bKeepAttachedToActor"
            },
            "SrcActor": {
              "comment": "Actor to draw DebugText over"
            },
            "SrcActorDesiredOffset": {
              "comment": "Desired offset to interpolate to"
            },
            "SrcActorOffset": {
              "comment": "Offset from SrcActor.Location to apply"
            },
            "TextColor": {
              "comment": "Text color"
            },
            "TimeRemaining": {
              "comment": "Time remaining for the debug text, -1.f == infinite"
            }
          }
        },
        "InputEntry": {
          "comment": "Individual entry to input matching sequences",
          "properties": {
            "Action": {
              "comment": "What type of match is this?"
            },
            "TimeDelta": {
              "comment": "Max amount of time since last match before sequence resets"
            },
            "Type": {
              "comment": "Type of input to match"
            },
            "Value": {
              "comment": "Min value required to consider as a valid match"
            }
          }
        },
        "InputMatchRequest": {
          "comment": "Contains information to match a series of a inputs and call the given\n function upon a match. Processed by PlayerInput, defined in the\n PlayerController.",
          "properties": {
            "FailedFuncName": {
              "comment": "Name of function to call upon a failed partial match"
            },
            "Inputs": {
              "comment": "Number of inputs to match, in sequence"
            },
            "LastMatchTime": {
              "comment": "Last time an input entry in Inputs was matched"
            },
            "MatchActor": {
              "comment": "Actor to call below functions on"
            },
            "MatchFuncName": {
              "comment": "Name of function to call upon successful match"
            },
            "MatchIdx": {
              "comment": "Current index into Inputs that is being matched"
            },
            "RequestName": {
              "comment": "Name of this input request, mainly for debugging"
            }
          }
        }
      }
    },
    "PlayerInput": {
      "properties": {
        "AutoUnlockTurnTime": {
          "comment": "Time remaining to disable bLockTurnUntilRelease"
        },
        "bEnableFOVScaling": {
          "comment": "if true, mouse smoothing is enabled"
        },
        "bInvertTurn": {
          "comment": "if true, mouse y axis is inverted from normal FPS mode"
        },
        "bLockTurnUntilRelease": {
          "comment": "If TRUE turn input will be ignored until the stick is released"
        },
        "bUsingGamepad": {
          "comment": "Player is giving input through a gamepad"
        },
        "bWasForward": {
          "comment": "if true, mouse x axis is inverted from normal FPS mode"
        },
        "DoubleClickTime": {
          "comment": "max double click interval for double click move"
        },
        "MouseSamples": {
          "comment": "Current average mouse movement/sample"
        },
        "MouseSamplingTotal": {
          "comment": "Number of mouse samples since mouse movement has been zero"
        },
        "MouseSensitivity": {
          "comment": "stores time of first click for potential double click"
        },
        "RawJoyLookRight": {
          "comment": "Joypad right thumbstick, horizontal axis. Range [-1,+1]"
        },
        "RawJoyLookUp": {
          "comment": "Joypad right thumbstick, vertical axis. Range [-1,+1]"
        },
        "RawJoyRight": {
          "comment": "Joypad left thumbstick, horizontal axis. Range [-1,+1]"
        },
        "RawJoyUp": {
          "comment": "Joypad left thumbstick, vertical axis. Range [-1,+1]"
        },
        "SmoothedMouse[2]": {
          "comment": "How long received mouse movement has been zero."
        },
        "LookRightScale": {
          "comment": "Yaw turn speed scaling"
        },
        "LookUpScale": {
          "comment": "pitch turn speed scaling"
        },
        "MoveForwardSpeed": {
          "comment": "move forward speed scaling"
        },
        "MoveStrafeSpeed": {
          "comment": "strafe speed scaling"
        }
      },
      "functions": {
        "ClientInitInputSystem": {
          "comment": "Called via replication to tell the Client to Init it's input system"
        },
        "DrawHUD": {
          "comment": "Hook called from HUD actor. Gives access to HUD and Canvas"
        },
        "InitInputSystem": {
          "comment": "The player controller will call this function directly after creating the input system"
        },
        "PreClientTravel": {
          "comment": "The player controll will call this function directly before traveling"
        },
        "ProcessInputMatching": {
          "comment": "Iterates through all InputRequests on the PlayerController and\n checks to see if a new input has been matched, or if the entire\n match sequence should be reset.",
          "params": {
            "DeltaTime": "time since last tick"
          }
        },
        "SmoothMouse": {
          "comment": "SmoothMouse()\nSmooth mouse movement, because mouse sampling doesn't match up with tick time.\n \n@note: if we got sample event for zero mouse samples (so we\ndidn't have to guess whether a 0 was caused by no sample occuring during the tick (at high frame rates) or because the mouse actually stopped)",
          "params": {
            ":": "Index is 0 for X axis, 1 for Y axis"
          }
        }
      }
    },
    "PlayerReplicationInfo": {
      "properties": {
        "Avatar": {
          "comment": "The online avatar for this player. May be None if we haven't downloaded it yet, or player doesn't have one."
        },
        "bAdmin": {
          "comment": "Player logged in as Administrator"
        },
        "bBot": {
          "comment": "True if this PRI is associated with an AIController"
        },
        "bFromPreviousLevel": {
          "comment": "indicates this is a PRI from the previous level of a seamless travel,\n waiting for the player to finish the transition before creating a new one\n this is used to avoid preserving the PRI in the InactivePRIArray if the player leaves"
        },
        "bHasBeenWelcomed": {
          "comment": "client side flag - whether this player has been welcomed or not (player entered message)"
        },
        "bIsInactive": {
          "comment": "Means this PRI came from the GameInfo's InactivePRIArray"
        },
        "bIsSpectator": {
          "comment": "Whether this player is currently a spectator"
        },
        "bOnlySpectator": {
          "comment": "Whether this player can only ever be a spectator"
        },
        "bOutOfLives": {
          "comment": "Can't respawn once out of lives"
        },
        "bReadyToPlay": {
          "comment": "Whether this player has confirmed ready to play"
        },
        "bWaitingPlayer": {
          "comment": "Whether this player is waiting to enter match"
        },
        "Deaths": {
          "comment": "Number of player's deaths."
        },
        "ExactPing": {
          "comment": "Exact ping as float (rounded and compressed in Ping)"
        },
        "GameMessageClass": {
          "comment": "Message class to use for PRI originated localized messages"
        },
        "Kills": {
          "comment": "Kills by this player. Not replicated."
        },
        "NumLives": {
          "comment": "Number of lives used by this player"
        },
        "OldName": {
          "comment": "Previous playername. Saved on client-side to detect playername changes."
        },
        "Ping": {
          "comment": "Replicated compressed ping for this player (holds ping in msec divided by 4)"
        },
        "PlayerID": {
          "comment": "Unique id number."
        },
        "PlayerName": {
          "comment": "Player name, or blank if none."
        },
        "SavedNetworkAddress": {
          "comment": "Used to match up InactivePRI with rejoining playercontroller."
        },
        "Score": {
          "comment": "Player's current score."
        },
        "SessionName": {
          "comment": "The session that the player needs to join/remove from as it is created/leaves"
        },
        "StartTime": {
          "comment": "Elapsed time on server when this PRI was first created."
        },
        "StringSpectating": {
          "comment": "Used for reporting player location"
        },
        "Team": {
          "comment": "Player team"
        },
        "TTSSpeaker": {
          "comment": "Voice to use for TTS"
        },
        "UniqueId": {
          "comment": "The id used by the network to uniquely identify a player.\n NOTE: this property should *never* be exposed to the player as it's transient"
        }
      },
      "functions": {
        "IsInvalidName": {
          "comment": "Validates that the new name matches the profile if the player is logged in"
        },
        "RegisterPlayerWithSession": {
          "comment": "The base implementation registers the player with the online session so that\n recent players list and session counts are updated."
        },
        "SeamlessTravelTo": {
          "comment": "called by seamless travel when initializing a player on the other side - copy properties to the new PRI that should persist"
        },
        "SetUniqueId": {
          "comment": "Sets the player's unique net id on the server."
        },
        "ShouldBroadCastWelcomeMessage": {
          "comment": "Returns true if should broadcast player welcome/left messages."
        },
        "UnregisterPlayerFromSession": {
          "comment": "The base implementation unregisters the player with the online session so that\n session counts are updated."
        },
        "UpdatePing": {
          "comment": "update average ping based on newly received round trip timestamp."
        }
      },
      "structs": {
        "AutomatedTestingDatum": {
          "properties": {
            "NumberOfMatchesPlayed": {
              "comment": "Number of matches played (maybe remove this before shipping) This is really useful for doing soak testing and such to see how long you lasted! NOTE: This is not replicated out to clients atm."
            },
            "NumMapListCyclesDone": {
              "comment": "Keeps track of the current run so when we have repeats and such we know how far along we are"
            }
          }
        }
      }
    },
    "PlayerStart": {
      "properties": {
        "TeamIndex": {
          "comment": "Team specific player start, 255 for any team"
        }
      }
    },
    "PointLightComponent": {
      "properties": {
        "MinShadowFalloffRadius": {
          "comment": "The minimum radius at which the point light's shadow begins to attenuate."
        },
        "ShadowPlane": {
          "comment": "Plane used for planar shadows on mobile."
        },
        "ShadowRadiusMultiplier": {
          "comment": "used to control when point light shadow mapping goes to a hack mode, the ShadowRadiusMultiplier is multiplied by the radius of object's bounding sphere"
        },
        "LightmassSettings<ScriptOrder=true>": {
          "comment": "The Lightmass settings for this object."
        },
        "FalloffExponent": {
          "comment": "Controls the radial falloff of the light"
        },
        "ShadowFalloffExponent": {
          "comment": "falloff for shadow when using LightShadow_Modulate"
        }
      },
      "functions": {
        "OnUpdatePropertyBrightness": {
          "comment": "Called from matinee code when Brightness property changes."
        },
        "OnUpdatePropertyLightColor": {
          "comment": "Called from matinee code when LightColor property changes."
        },
        "SetTranslation": {
          "comment": "Update the PreviewLightSourceRadius"
        }
      }
    },
    "PointLightToggleable": {
      "functions": {
        "ShouldSaveForCheckpoint": {
          "comment": "Returns true if the light supports being toggled off and on on-the-fly"
        }
      }
    },
    "PortalMarker": {
      "comment": "this Actor marks PortalTeleporters on the navigation network",
      "properties": {
        "MyPortal": {
          "comment": "the portal being marked by this PortalMarker"
        }
      },
      "functions": {
        "CanTeleport": {
          "comment": "returns whether this NavigationPoint is a teleporter that can teleport the given Actor"
        }
      }
    },
    "PortalTeleporter": {
      "properties": {
        "bAlwaysTeleportNonPawns": {
          "comment": "if true, non-Pawn actors are always teleporter, regardless of their bCanTeleport flag"
        },
        "bCanTeleportVehicles": {
          "comment": "whether or not this PortalTeleporter works on vehicles"
        },
        "MyMarker": {
          "comment": "marker on path network for AI"
        },
        "bMovablePortal": {
          "comment": "whether or not encroachers (movers, vehicles, and such) can move this portal"
        },
        "SisterPortal": {
          "comment": "destination portal"
        },
        "TextureResolutionX": {
          "comment": "resolution for texture render target; must be a power of 2"
        },
        "TextureResolutionY": {
          "comment": "resolution for texture render target; must be a power of 2"
        }
      },
      "functions": {
        "CreatePortalTexture": {
          "comment": "creates and initializes a TextureRenderTarget2D with size equal to our TextureResolutionX and TextureResolutionY properties"
        },
        "TransformActor": {
          "comment": "teleport an actor to be relative to SisterPortal, including transforming its velocity, acceleration, and rotation",
          "params": {
            "A": "the Actor to teleport"
          }
        },
        "TransformHitLocation": {
          "comment": "transform the given location to be relative to SisterPortal"
        },
        "TransformVectorDir": {
          "comment": "transform the given movement vector to be relative to SisterPortal"
        }
      }
    },
    "PortalVolume": {
      "comment": "Used to define areas of a map by portal",
      "properties": {
        "Portals": {
          "comment": "List of teleporters residing in this volume"
        }
      }
    },
    "PostProcessChain": {
      "properties": {
        "Effects": {
          "comment": "Post process effects active in this chain. Rendered in order"
        }
      },
      "functions": {
        "FindPostProcessEffect": {
          "comment": "Returns the index of the named post process effect, None if not found."
        }
      }
    },
    "PostProcessEffect": {
      "comment": "A PostProcessEffect operates on an input render target and writes to an output target\n These effects can be chained together in a PostProcessChain\n Derive your own effects from this class",
      "properties": {
        "bAffectsLightingOnly": {
          "comment": "If true, the effect should be rendered after lighting and not at the end of the DPG."
        },
        "NodePosY": {
          "comment": "Variables for post process Editor support"
        },
        "bShowInEditor": {
          "comment": "Whether to apply the effect in the Editor"
        },
        "bShowInGame": {
          "comment": "Whether to apply the effect in the Game"
        },
        "bUseWorldSettings": {
          "comment": "Controls whether the effect should take its settings from the world's post process settings."
        },
        "EffectName": {
          "comment": "Name of the effect, used by e.g. FindEffectByName"
        },
        "SceneDPG": {
          "comment": "controls which scene DPG to render this post-process effect in (mirrors ESceneDepthPriorityGroup)"
        }
      }
    },
    "PostProcessVolume": {
      "comment": "Used to affect post process settings in the game and editor.",
      "properties": {
        "NextLowerPriorityVolume": {
          "comment": "Next volume in linked listed, sorted by priority in descending order."
        },
        "bEnabled": {
          "comment": "Whether this volume is enabled or not."
        },
        "Priority": {
          "comment": "Priority of this volume. In the case of overlapping volumes the one with the highest priority\n is chosen. The order is undefined if two or more overlapping volumes have the same priority."
        },
        "Settings": {
          "comment": "Post process settings to use for this volume."
        }
      },
      "functions": {
        "OnToggle": {
          "comment": "Kismet support for toggling bDisabled."
        }
      },
      "structs": {
        "LUTBlender": {
          "comment": "LUT Blender for efficient Color Grading (LUT: color look up table, RGB_new = LUT[RGB_old]) blender.",
          "properties": {
            "bHasChanged": {
              "comment": "Whether this LUTBlender contains new parameters and should regenerate the LUT Texture."
            }
          }
        },
        "PostProcessSettings": {
          "comment": "@return count",
          "properties": {
            "bAllowAmbientOcclusion<editcondition=bOverride_AllowAmbientOcclusion>": {
              "comment": "Whether to allow ambient occlusion."
            },
            "bEnableBloom<editcondition=bOverride_EnableBloom>": {
              "comment": "Whether to use bloom effect."
            },
            "bEnableDOF<editcondition=bOverride_EnableDOF>": {
              "comment": "Whether to use depth of field effect."
            },
            "bEnableMotionBlur<editcondition=bOverride_EnableMotionBlur>": {
              "comment": "Whether to use motion blur effect."
            },
            "bEnableSceneEffect<editcondition=bOverride_EnableSceneEffect>": {
              "comment": "Whether to use the material/ scene effect."
            },
            "Bloom_InterpolationDuration<editcondition=bOverride_Bloom_InterpolationDuration>": {
              "comment": "Duration over which to interpolate values to."
            },
            "Bloom_Scale<editcondition=bOverride_Bloom_Scale>": {
              "comment": "Scale for the blooming."
            },
            "Bloom_ScreenBlendThreshold<editcondition=bOverride_Bloom_ScreenBlendThreshold>": {
              "comment": "Bloom screen blend threshold"
            },
            "Bloom_Threshold<editcondition=bOverride_Bloom_Threshold>": {
              "comment": "Bloom threshold"
            },
            "Bloom_Tint<editcondition=bOverride_Bloom_Tint>": {
              "comment": "Bloom tint color"
            },
            "bOverrideRimShaderColor<editcondition=bOverride_OverrideRimShaderColor>": {
              "comment": "Whether to override the rim shader color."
            },
            "bOverride_AllowAmbientOcclusion": {
              "comment": "Determines if bAllowAmbientOcclusion variable will be overridden."
            },
            "bOverride_Bloom_InterpolationDuration": {
              "comment": "Determines if Bloom_InterpolationDuration variable will be overridden."
            },
            "bOverride_Bloom_Scale": {
              "comment": "Determines if Bloom_Scale variable will be overridden."
            },
            "bOverride_Bloom_ScreenBlendThreshold": {
              "comment": "Determines if Bloom_ScreenBlendThreshold variable will be overridden."
            },
            "bOverride_Bloom_Threshold": {
              "comment": "Determines if Bloom_Threshold variable will be overridden."
            },
            "bOverride_Bloom_Tint": {
              "comment": "Determines if Bloom_Tint variable will be overridden."
            },
            "bOverride_DOF_BlurBloomKernelSize": {
              "comment": "Determines if DOF_BlurBloomKernelSize variable will be overridden."
            },
            "bOverride_DOF_BlurKernelSize": {
              "comment": "Determines if DOF_BlurKernelSize variable will be overridden."
            },
            "bOverride_DOF_BokehTexture": {
              "comment": "Determines if DOF_BokehTexture variable will be overridden."
            },
            "bOverride_DOF_FalloffExponent": {
              "comment": "Determines if DOF_FalloffExponent variable will be overridden."
            },
            "bOverride_DOF_FocusDistance": {
              "comment": "Determines if DOF_FocusDistance variable will be overridden."
            },
            "bOverride_DOF_FocusInnerRadius": {
              "comment": "Determines if DOF_FocusInnerRadius variable will be overridden."
            },
            "bOverride_DOF_FocusPosition": {
              "comment": "Determines if DOF_FocusPosition variable will be overridden."
            },
            "bOverride_DOF_FocusType": {
              "comment": "Determines if DOF_FocusType variable will be overridden."
            },
            "bOverride_DOF_InterpolationDuration": {
              "comment": "Determines if DOF_InterpolationDuration variable will be overridden."
            },
            "bOverride_DOF_MaxFarBlurAmount": {
              "comment": "Determines if DOF_MaxFarBlurAmount variable will be overridden."
            },
            "bOverride_DOF_MaxNearBlurAmount": {
              "comment": "Determines if DOF_MaxNearBlurAmount variable will be overridden."
            },
            "bOverride_DOF_MinBlurAmount": {
              "comment": "Determines if DOF_MinBlurAmount variable will be overridden."
            },
            "bOverride_EnableBloom": {
              "comment": "Determines if bEnableBloom variable will be overridden."
            },
            "bOverride_EnableDOF": {
              "comment": "Determines if bEnableDOF variable will be overridden."
            },
            "bOverride_EnableMotionBlur": {
              "comment": "Determines if bEnableMotionBlur variable will be overridden."
            },
            "bOverride_EnableSceneEffect": {
              "comment": "Determines if bEnableSceneEffect variable will be overridden."
            },
            "bOverride_MotionBlur_Amount": {
              "comment": "Determines if MotionBlur_Amount variable will be overridden."
            },
            "bOverride_MotionBlur_CameraRotationThreshold": {
              "comment": "Determines if MotionBlur_CameraRotationThreshold variable will be overridden."
            },
            "bOverride_MotionBlur_CameraTranslationThreshold": {
              "comment": "Determines if MotionBlur_CameraTranslationThreshold variable will be overridden."
            },
            "bOverride_MotionBlur_FullMotionBlur": {
              "comment": "Determines if MotionBlur_FullMotionBlur variable will be overridden."
            },
            "bOverride_MotionBlur_InterpolationDuration": {
              "comment": "Determines if MotionBlur_InterpolationDuration variable will be overridden."
            },
            "bOverride_MotionBlur_MaxVelocity": {
              "comment": "Determines if MotionBlur_MaxVelocity variable will be overridden."
            },
            "bOverride_OverrideRimShaderColor": {
              "comment": "Determines if bOverrideRimShaderColor variable will be overridden."
            },
            "bOverride_RimShader_Color": {
              "comment": "Determines if RimShader_Color variable will be overridden."
            },
            "bOverride_RimShader_InterpolationDuration": {
              "comment": "Determines if RimShader_InterpolationDuration variable will be overridden."
            },
            "bOverride_Scene_ColorGradingLUT": {
              "comment": "Determines if ColorGrading_LookupTable variable will be overridden."
            },
            "bOverride_Scene_Colorize": {
              "comment": "Determines if Scene_Colorize variable will be overridden."
            },
            "bOverride_Scene_Desaturation": {
              "comment": "Determines if Scene_Desaturation variable will be overridden."
            },
            "bOverride_Scene_HighLights": {
              "comment": "Determines if Scene_HighLights variable will be overridden."
            },
            "bOverride_Scene_ImageGrainScale": {
              "comment": "Determines if Scene_ImageGrainScale variable will be overridden."
            },
            "bOverride_Scene_InterpolationDuration": {
              "comment": "Determines if Scene_InterpolationDuration variable will be overridden."
            },
            "bOverride_Scene_MidTones": {
              "comment": "Determines if Scene_MidTones variable will be overridden."
            },
            "bOverride_Scene_Shadows": {
              "comment": "Determines if Scene_Shadows variable will be overridden."
            },
            "bOverride_Scene_TonemapperScale": {
              "comment": "Determines if Scene_TonemapperScale variable will be overridden."
            },
            "bTwoLayerSimpleDepthOfField": {
              "comment": "Whether to use two layer simple depth of field effect."
            },
            "ColorGradingLUT": {
              "comment": "Used to blend color grading LUT in a very similar way we blend scalars"
            },
            "ColorGrading_LookupTable<editcondition=bOverride_Scene_ColorGradingLUT>": {
              "comment": "Name of the LUT texture e.g. MyPackage01.LUTNeutral, empty if not used"
            },
            "DOF_BlurBloomKernelSize<editcondition=bOverride_DOF_BlurBloomKernelSize>": {
              "comment": "The radius of the bloom effect"
            },
            "DOF_BlurKernelSize<editcondition=bOverride_DOF_BlurKernelSize>": {
              "comment": "affects the radius of the DepthOfField bohek / how blurry the scene gets"
            },
            "DOF_BokehTexture<editcondition=bOverride_DOF_BokehTexture>": {
              "comment": "Name of the Bokeh texture e.g. EngineMaterial.BokehTexture, empty if not used"
            },
            "DOF_FalloffExponent<editcondition=bOverride_DOF_FalloffExponent>": {
              "comment": "Exponent to apply to blur amount after it has been normalized to [0,1]."
            },
            "DOF_FocusDistance<editcondition=bOverride_DOF_FocusDistance>": {
              "comment": "Used when FOCUS_Distance is enabled."
            },
            "DOF_FocusInnerRadius<editcondition=bOverride_DOF_FocusInnerRadius>": {
              "comment": "Inner focus radius."
            },
            "DOF_FocusPosition<editcondition=bOverride_DOF_FocusPosition>": {
              "comment": "Used when FOCUS_Position is enabled."
            },
            "DOF_FocusType<editcondition=bOverride_DOF_FocusType>": {
              "comment": "Controls how the focus point is determined."
            },
            "DOF_InterpolationDuration<editcondition=bOverride_DOF_InterpolationDuration>": {
              "comment": "Duration over which to interpolate values to."
            },
            "DOF_MaxFarBlurAmount<editcondition=bOverride_DOF_MaxFarBlurAmount|DisplayName=MaxFar>": {
              "comment": "[0,1] value for clamping how much blur to apply to items behind the focus plane."
            },
            "DOF_MaxNearBlurAmount<editcondition=bOverride_DOF_MaxNearBlurAmount|DisplayName=MaxNear>": {
              "comment": "[0,1] value for clamping how much blur to apply to items in front of the focus plane."
            },
            "DOF_MinBlurAmount<editcondition=bOverride_DOF_MinBlurAmount|DisplayName=Min>": {
              "comment": "[0,1] value for clamping how much blur to apply."
            },
            "MotionBlur_Amount<editcondition=bOverride_MotionBlur_Amount>": {
              "comment": "This is a scalar on the blur"
            },
            "MotionBlur_CameraRotationThreshold<editcondition=bOverride_MotionBlur_CameraRotationThreshold>": {
              "comment": "Threshold for when to turn off motion blur when the camera rotates swiftly during a single frame (in degrees)."
            },
            "MotionBlur_CameraTranslationThreshold<editcondition=bOverride_MotionBlur_CameraTranslationThreshold>": {
              "comment": "Threshold for when to turn off motion blur when the camera translates swiftly during a single frame (in world units)."
            },
            "MotionBlur_FullMotionBlur<editcondition=bOverride_MotionBlur_FullMotionBlur>": {
              "comment": "Whether everything (static/dynamic objects) should motion blur or not. If disabled, only moving objects may blur."
            },
            "MotionBlur_InterpolationDuration<editcondition=bOverride_MotionBlur_InterpolationDuration>": {
              "comment": "Duration over which to interpolate values to."
            },
            "MotionBlur_MaxVelocity<editcondition=bOverride_MotionBlur_MaxVelocity>": {
              "comment": "Maximum blur velocity amount. This is a clamp on the amount of blur."
            },
            "RimShader_Color<editcondition=bOverride_RimShader_Color>": {
              "comment": "Controlling rim shader color."
            },
            "RimShader_InterpolationDuration<editcondition=bOverride_RimShader_InterpolationDuration>": {
              "comment": "Duration over which to interpolate values to."
            },
            "Scene_Colorize<editcondition=bOverride_Scene_Colorize>": {
              "comment": "Colorize (color tint after desaturate)"
            },
            "Scene_Desaturation<editcondition=bOverride_Scene_Desaturation>": {
              "comment": "Desaturation amount."
            },
            "Scene_HighLights<editcondition=bOverride_Scene_HighLights>": {
              "comment": "Controlling white point."
            },
            "Scene_ImageGrainScale<editcondition=bOverride_Scene_ImageGrainScale>": {
              "comment": "Image grain scale, only affects the darks, >=0, 0:none, 1(strong) should be less than 1"
            },
            "Scene_InterpolationDuration<editcondition=bOverride_Scene_InterpolationDuration>": {
              "comment": "Duration over which to interpolate values to."
            },
            "Scene_MidTones<editcondition=bOverride_Scene_MidTones>": {
              "comment": "Controlling gamma curve."
            },
            "Scene_Shadows<editcondition=bOverride_Scene_Shadows>": {
              "comment": "Controlling black point."
            },
            "Scene_TonemapperScale<editcondition=bOverride_Scene_TonemapperScale>": {
              "comment": "HDR tone mapper scale, only used if tone mapper is on, >=0, 0:black, 1(default), >1 brighter"
            }
          }
        }
      }
    },
    "PrecomputedVisibilityOverrideVolume": {
      "properties": {
        "OverrideInvisibleActors": {
          "comment": "Array of actors that will always be considered invisible by Precomputed Visibility when viewed from inside this volume."
        },
        "OverrideVisibleActors": {
          "comment": "Array of actors that will always be considered visible by Precomputed Visibility when viewed from inside this volume."
        }
      }
    },
    "Prefab": {
      "properties": {
        "PrefabArchetypes": {
          "comment": "Array of archetypes, one for each object in the prefab."
        },
        "PrefabPreview": {
          "comment": "Snapshot of Prefab used for thumbnail in the browser."
        },
        "PrefabSequence": {
          "comment": "The Kismet sequence that associated with this Prefab."
        },
        "PrefabVersion": {
          "comment": "Version number of this prefab."
        },
        "RemovedArchetypes": {
          "comment": "Array of archetypes that used to be in this Prefab, but no longer are."
        }
      }
    },
    "PrefabInstance": {
      "properties": {
        "ArchetypeToInstanceMap": {
          "comment": "Mapping from archetypes in the source prefab (TemplatePrefab) to instances of those archetypes in this PrefabInstance."
        },
        "PI_PackageVersion": {
          "comment": "Contains the epic+licensee version that this PrefabInstance's package was saved with."
        },
        "SequenceInstance": {
          "comment": "Kismet sequence that was created for this PrefabInstance."
        },
        "TemplatePrefab": {
          "comment": "The prefab that this is an instance of."
        },
        "TemplateVersion": {
          "comment": "The version of the Prefab that this is an instance of.\n This allows us to detect if the prefab has changed, and the instance needs to be updated."
        }
      }
    },
    "PrefabSequence": {
      "properties": {
        "OwnerPrefab": {
          "comment": "the PrefabInstance actor that created this PrefabSequence."
        }
      },
      "functions": {
        "GetOwnerPrefab": {
          "comment": "Wrapper for retrieving the current value of OwnerPrefab."
        },
        "SetOwnerPrefab": {
          "comment": "Accessor for setting the value of OwnerPrefab.",
          "params": {
            "InOwner": "the PrefabInstance that created this PrefabSequence."
          }
        }
      }
    },
    "PrimitiveComponent": {
      "properties": {
        "AlwaysCheckCollision": {
          "comment": "when this is on, this primitive component get collision tests even if it isn't the actor's collision component"
        },
        "AlwaysLoadOnClient": {
          "comment": "If this is True, this component must always be loaded on clients, even if HiddenGame && !CollideActors."
        },
        "AlwaysLoadOnServer": {
          "comment": "If this is True, this component must always be loaded on servers, even if !CollideActors."
        },
        "bAcceptsDecals": {
          "comment": "replaced with bAcceptsStaticDecals,bAcceptsDynamicDecals Deprecated April 2008"
        },
        "bAllowShadowFade": {
          "comment": "Determines whether or not we allow shadowing fading. Some objects (especially in cinematics) having the shadow fade/pop out looks really bad."
        },
        "bCullModulatedShadowOnBackfaces": {
          "comment": "If TRUE, the primitive backfaces won't allow for modulated shadows to be cast on them.\n If FALSE, could help performance since the mesh doesn't have to be drawn again to cull the backface shadows"
        },
        "bCullModulatedShadowOnEmissive": {
          "comment": "If TRUE, the emissive areas of the primitive won't allow for modulated shadows to be cast on them.\n If FALSE, could help performance since the mesh doesn't have to be drawn again to cull the emissive areas in shadow"
        },
        "bFirstFrameOcclusion": {
          "comment": "If this is True, this component will return 0.0f as their occlusion when first rendered."
        },
        "bHasExplicitShadowParent": {
          "comment": "TRUE if ShadowParent was set through SetShadowParent, \n FALSE if ShadowParent is set automatically based on Owner->bShadowParented."
        },
        "bIgnoreNearPlaneIntersection": {
          "comment": "If True, this component will still be queried for occlusion even when it intersects the near plane."
        },
        "bSelectable": {
          "comment": "If this is True, this component can be selected in the editor."
        },
        "bUseAsOccluder": {
          "comment": "Whether to render the primitive in the depth only pass. \n Setting this to FALSE will cause artifacts with dominant light shadows and potentially large performance loss,\n So it should be TRUE on all lit objects, setting it to FALSE is mostly only useful for debugging."
        },
        "bUseViewOwnerDepthPriorityGroup": {
          "comment": "True if the primitive should be rendered using ViewOwnerDepthPriorityGroup if viewed by its owner."
        },
        "CachedCullDistance": {
          "comment": "Legacy, renamed to CachedMaxDrawDistance deprecated june 2008"
        },
        "CullDistance": {
          "comment": "Legacy, renamed to MaxDrawDistance deprecated june 2008"
        },
        "DecalList": {
          "comment": "Current list of active decals attached to the primitive"
        },
        "DecalsToReattach": {
          "comment": "Decals that are detached from the primitive and need to be reattached"
        },
        "DetachFence": {
          "comment": "A fence to track when the primitive is detached from the scene in the rendering thread."
        },
        "FogVolumeComponent": {
          "comment": "Keeps track of which fog component this primitive is using."
        },
        "LastRenderTime": {
          "comment": "The value of WorldInfo->TimeSeconds for the frame when this actor was last rendered. This is written\n from the render thread, which is up to a frame behind the game thread, so you should allow this time to\n be at least a frame behind the game thread's world time before you consider the actor non-visible.\n There's an equivalent variable in PrimitiveComponent."
        },
        "LastSubmitTime": {
          "comment": "Last time the component was submitted for rendering (called FScene::AddPrimitive)."
        },
        "LightEnvironment": {
          "comment": "The lighting environment to take the primitive's lighting from."
        },
        "MotionBlurInfoIndex": {
          "comment": "The index for the primitive component in the MotionBlurInfo array of the scene.\n Render-thread usage only.\n This assumes that there is only one scene that requires motion blur, as there is only\n a single index... If the application requires a primitive component to exist in multiple\n scenes and have motion blur in each of them, this can be changed into a mapping of the\n scene pointer to the index. (Associated functions would have to be updated as well...)"
        },
        "OverrideLightComponent": {
          "comment": "If specified, only OverrideLightComponent can affect the primitive."
        },
        "PreviewEnvironmentShadowing": {
          "comment": "Environment shadow factor used when previewing unbuilt lighting on this primitive."
        },
        "PreviousLightEnvironment": {
          "comment": "Stores the previous light environment if SetLightEnvironment is called while the primitive is attached, so that Detach can notify the previous light environment correctly."
        },
        "SceneInfo": {
          "comment": "The primitive's scene info."
        },
        "ScriptRigidBodyCollisionThreshold": {
          "comment": "if > 0, the script RigidBodyCollision() event will be called on our Owner when a physics collision involving\n this PrimitiveComponent occurs and the relative velocity is greater than or equal to this"
        },
        "ViewOwnerDepthPriorityGroup": {
          "comment": "The scene depth priority group to draw the primitive in, if it's being viewed by its owner."
        },
        "VisibilityId": {
          "comment": "Used for precomputed visibility"
        },
        "bBlockFootPlacement": {
          "comment": "If TRUE will block foot placement line checks (default). FALSE will skip right through."
        },
        "CanBlockCamera": {
          "comment": "TRUE if this primitive is eligible to block camera traces, FALSE if the camera should ignore it."
        },
        "RBChannel": {
          "comment": "Enum indicating what type of object this should be considered for rigid body collision."
        },
        "RBCollideWithChannels": {
          "comment": "Types of objects that this physics objects will collide with."
        },
        "bAcceptsDynamicDominantLightShadows": {
          "comment": "Optimization for objects which don't need to receive dominant light shadows. \n This is useful for objects which eat up a lot of GPU time and are heavily texture bound yet never receive noticeable shadows from dominant lights like trees."
        },
        "bAcceptsDynamicLights": {
          "comment": "Whether this primitives accepts dynamic lights\n controls whether the object should be affected by dynamic lights."
        },
        "bAcceptsLights": {
          "comment": "Does this primitive accept lights?\n controls whether the primitive accepts any lights. Should be set to FALSE for e.g. unlit objects as its a nice optimization - especially for larger objects."
        },
        "bCastDynamicShadow": {
          "comment": "If false, primitive does not cast dynamic shadows.\n controls whether the primitive should cast shadows in the case of non precomputed shadowing like e.g. the primitive being in between a light and a dynamic object. This flag is only used if CastShadow is TRUE. Currently dynamic primitives will not receive shadows from static objects unless both this flag and CastShadow are enabled."
        },
        "bCastHiddenShadow": {
          "comment": "If TRUE, the primitive will cast shadows even if bHidden is TRUE.\n Controls whether the primitive should cast shadows when hidden.\n This flag is only used if CastShadow is TRUE."
        },
        "bCastShadowAsTwoSided": {
          "comment": "Whether this primitive should cast dynamic shadows as if it were a two sided material."
        },
        "bCastStaticShadow": {
          "comment": "Whether the primitive casts static shadows."
        },
        "bForceDirectLightMap": {
          "comment": "If true, forces all static lights to use light-maps for direct lighting on this primitive, regardless of the light's UseDirectLightMap property.\n forces the use of lightmaps for all static lights affecting this primitive even though the light might not be set to use light maps. This means that the primitive will not receive any shadows from dynamic objects obstructing static lights. It will correctly shadow in the case of dynamic lights"
        },
        "bSelfShadowOnly": {
          "comment": "If true, the primitive will only shadow itself and will not cast a shadow on other primitives. \n This can be used as an optimization when the shadow on other primitives won't be noticeable."
        },
        "bUseOnePassLightingOnTranslucency": {
          "comment": "If TRUE, dynamically lit translucency on this primitive will render in one pass, \n Which is cheaper and ensures correct blending but approximates lighting using one directional light and all other lights in an unshadowed SH environment.\n If FALSE, dynamically lit translucency will render in multiple passes which uses more shader instructions and results in incorrect blending."
        },
        "bUsePrecomputedShadows": {
          "comment": "Whether the primitive supports/ allows static shadowing"
        },
        "CastShadow": {
          "comment": "Whether to cast any shadows or not\n controls whether the primitive component should cast a shadow or not. Currently dynamic primitives will not receive shadows from static objects unless both this flag and bCastDynamicSahdow are enabled."
        },
        "LightingChannels": {
          "comment": "Lighting channels controlling light/ primitive interaction. Only allows interaction if at least one channel is shared"
        },
        "bDisableAllRigidBody": {
          "comment": "Never create any physics engine representation for this body."
        },
        "bFluidDrain": {
          "comment": "Whether this object should act as a 'drain' for fluid, and destroy fluid particles when they contact it."
        },
        "bFluidTwoWay": {
          "comment": "Indicates that fluid interaction with this object should be 'two-way' - that is, force should be applied to both fluid and object."
        },
        "bIgnoreForceField": {
          "comment": "Will ignore force field applied to this component."
        },
        "bIgnoreRadialForce": {
          "comment": "Will ignore radial forces applied to this component."
        },
        "bIgnoreRadialImpulse": {
          "comment": "Will ignore radial impulses applied to this component."
        },
        "bNotifyRigidBodyCollision": {
          "comment": "Flag that indicates if OnRigidBodyCollision function should be called for physics collisions involving this PrimitiveComponent."
        },
        "bSkipRBGeomCreation": {
          "comment": "When creating rigid body, will skip normal geometry creation step, and will rely on ModifyNxActorDesc to fill in geometry."
        },
        "bUseCompartment": {
          "comment": "Place into a NxCompartment that will run in parallel with the primary scene's physics with potentially different simulation parameters."
        },
        "PhysMaterialOverride": {
          "comment": "Allows you to override the PhysicalMaterial to use for this PrimitiveComponent."
        },
        "RBDominanceGroup": {
          "comment": "Used for creating one-way physics interactions (via constraints or contacts)\n Groups with lower RBDominanceGroup push around higher values in a 'one way' fashion. Must be <32."
        },
        "bIgnoreHiddenActorsMembership": {
          "comment": "Allow certain components to render even if the parent actor is part of the camera's HiddenActors array."
        },
        "BoundsScale<UIMin=1|UIMax=10.0>": {
          "comment": "Scales the bounds of the object.\n This is useful when using World Position Offset to animate the vertices of the object outside of its bounds. \n Warning: Increasing the bounds of an object will reduce performance and shadow quality!\n Currently only used by StaticMeshComponent and SkeletalMeshComponent."
        },
        "bAcceptsDynamicDecals": {
          "comment": "If TRUE, this primitive accepts dynamic decals spawned during gameplay."
        },
        "bAcceptsStaticDecals": {
          "comment": "If TRUE, this primitive accepts static level placed decals in the editor."
        },
        "bAllowApproximateOcclusion": {
          "comment": "If this is True, this component doesn't need exact occlusion info."
        },
        "bAllowCullDistanceVolume": {
          "comment": "Whether to accept cull distance volumes to modify cached cull distance."
        },
        "bForceMipStreaming": {
          "comment": "If TRUE, forces mips for textures used by this component to be resident when this component's level is loaded."
        },
        "bIgnoreOwnerHidden": {
          "comment": "If true, bHidden on the Owner of this component will be ignored."
        },
        "bOnlyOwnerSee": {
          "comment": "If this is True, this component will only be visible when the view actor is the component's owner, directly or indirectly."
        },
        "bOwnerNoSee": {
          "comment": "If this is True, this component won't be visible when the view actor is the component's owner, directly or indirectly."
        },
        "CachedMaxDrawDistance": {
          "comment": "The distance to cull this primitive at. \n A CachedMaxDrawDistance of 0 indicates that the primitive should not be culled by distance."
        },
        "DepthPriorityGroup": {
          "comment": "The scene depth priority group to draw the primitive in."
        },
        "DetailMode": {
          "comment": "If detail mode is >= system detail mode, primitive won't be rendered."
        },
        "MassiveLODDistance": {
          "comment": "The distance at which the renderer will switch from parent (low LOD) to children (high LOD).\n This is basically the same as MinDrawDistance, except that the low LOD will draw even up close, if there are no children.\n This is needed so the high lod meshes can be in a streamable sublevel, and if streamed out, the low LOD will draw up close."
        },
        "MaxDrawDistance": {
          "comment": "Max draw distance exposed to LDs. The real max draw distance is the min (disregarding 0) of this and volumes affecting this object. \n This is renamed to LDMaxDrawDistance in c++"
        },
        "MinDrawDistance": {
          "comment": "The minimum distance at which the primitive should be rendered, \n measured in world space units from the center of the primitive's bounding sphere to the camera position."
        },
        "MotionBlurInstanceScale": {
          "comment": "Scalar controlling the amount of motion blur to be applied when object moves.\n 0=none, 1=full instance motion blur(default), value should be 0 or bigger"
        },
        "ReplacementPrimitive": {
          "comment": "Replacement primitive to draw instead of this one (multiple UPrim's will point to the same Replacement)"
        },
        "TranslucencySortPriority": {
          "comment": "Translucent objects with a lower sort priority draw behind objects with a higher priority.\n Translucent objects with the same priority are rendered from back-to-front based on their bounds origin.\n Ignored if the object is not translucent. The default priority is zero.\n Warning: This should never be set to a non-default value unless you know what you are doing, as it will prevent the renderer from sorting correctly. \n It is especially problematic on dynamic gameplay effects."
        }
      },
      "functions": {
        "AddForce": {
          "comment": "Add a force to this component.\n \n This is like a thruster. Good for adding a burst over some (non zero) time.",
          "params": {
            "Force": "Force vector to apply. Magnitude indicates strength of force.",
            "Position": "Position on object to apply force. If (0,0,0), force is applied at center of mass.",
            "BoneName": "Used in the skeletal case to apply a force to a single body."
          }
        },
        "AddImpulse": {
          "comment": "Add an impulse to the physics of this PrimitiveComponent.\n Good for zero time. One time insta burst.",
          "params": {
            "Impulse": "Magnitude and direction of impulse to apply.",
            "Position": "Point in world space to apply impulse at. If Position is (0,0,0), impulse is applied at center of mass ie. no rotation.",
            "BoneName": "If a SkeletalMeshComponent, name of bone to apply impulse to.",
            "bVelChange": "If true, the Strength is taken as a change in velocity instead of an impulse (ie. mass will have no affect)."
          }
        },
        "AddRadialForce": {
          "comment": "Add a force originating from the supplied world-space location.",
          "params": {
            "Origin": "Origin of force in world space.",
            "Radius": "Radius within which to apply the force.",
            "Strength": "Strength of force to apply.",
            "Falloff": "Allows you to control the strength of the force as a function of distance from Origin."
          }
        },
        "AddRadialImpulse": {
          "comment": "Add an impulse to this component, radiating out from the specified position.\n In the case of a skeletal mesh, may affect each bone of the mesh.",
          "params": {
            "Origin": "Point of origin for the radial impulse blast",
            "Radius": "Size of radial impulse. Beyond this distance from Origin, there will be no affect.",
            "Strength": "Maximum strength of impulse applied to body.",
            "Falloff": "Allows you to control the strength of the impulse as a function of distance from Origin.",
            "bVelChange": "If true, the Strength is taken as a change in velocity instead of an impulse (ie. mass will have no affect)."
          }
        },
        "AddTorque": {
          "comment": "Add a torque to this component.",
          "params": {
            "Torque": "Force vector to apply. Magnitude indicates strength of force.",
            "BoneName": "Used in the skeletal case to apply a force to a single body."
          }
        },
        "ClosestPointOnComponentToComponent": {
          "comment": "Calculates the closest point this component to another component",
          "params": {
            "PrimitiveComponent": "Another Primitive Component",
            "PointOnComponentA": "Point on this primitive closest to other primitive",
            "PointOnComponentB": "Point on other primitive closest to this primitive"
          }
        },
        "ClosestPointOnComponentToPoint": {
          "comment": "Calculates the closest point on this primitive to a point given",
          "params": {
            "POI": "Point in world space to determine closest point to",
            "Extent": "Convex primitive",
            "OutPointA": "The point closest on the extent box",
            "OutPointB": "Point on this primitive closest to the extent box"
          }
        },
        "GetRootBodyInstance": {
          "comment": "returns the physics RB_BodyInstance for the root body of this component (if any)"
        },
        "GetRotation": {
          "comment": "Returns rotation of the component, in world space."
        },
        "InitRBPhys": {
          "comment": "initializes rigid body physics for this component\n this is done automatically for PrimitiveComponents attached via Actor defaults,\n but if a component is attached at runtime you may need to call this function to set it up\n @note: this function does nothing if not attached or bDisableAllRigidBody is set"
        },
        "PutRigidBodyToSleep": {
          "comment": "Put a simulation back to sleep."
        },
        "RetardRBLinearVelocity": {
          "comment": "Reduce velocity of rigid body physics in the direction supplied. This decomposes body velocity into that along supplied vector and that perpendicular to the vector.\n That along vector, if in same direction as vector, is scale by VelScale. If it is moving in the opposite direction to supplied vector it is not affected.",
          "params": {
            "RetardDir": "Unit vector indicating direction to check velocity of physics against",
            "VelScale": "Value from 0.0 to 1.0 - 1.0 will stop all motion along RetardDir"
          }
        },
        "RigidBodyIsAwake": {
          "comment": "Returns if the body is currently awake and simulating.\n If a SkeletalMeshComponent, and no BoneName is specified, will pick a random bone -\n so does not make much sense if not all bones are jointed together."
        },
        "SetBlockRigidBody": {
          "comment": "Change the value of BlockRigidBody.",
          "params": {
            "NewBlockRigidBody": "The value to assign to BlockRigidBody."
          }
        },
        "SetCullDistance": {
          "comment": "Changes the value of CullDistance.",
          "params": {
            "NewCullDistance": "The value to assign to CullDistance."
          }
        },
        "SetDepthPriorityGroup": {
          "comment": "Changes the value of DepthPriorityGroup.",
          "params": {
            "NewDepthPriorityGroup": "The value to assign to DepthPriorityGroup."
          }
        },
        "SetHidden": {
          "comment": "Changes the value of HiddenGame.",
          "params": {
            "NewHidden": "The value to assign to HiddenGame."
          }
        },
        "SetIgnoreOwnerHidden": {
          "comment": "Changes the value of bIgnoreOwnerHidden."
        },
        "SetLightEnvironment": {
          "comment": "Changes the value of LightEnvironment.",
          "params": {
            "NewLightEnvironment": "The value to assign to LightEnvironment."
          }
        },
        "SetLightingChannels": {
          "comment": "Changes the value of LightingChannels.",
          "params": {
            "NewLightingChannels": "The value to assign to LightingChannels."
          }
        },
        "SetNotifyRigidBodyCollision": {
          "comment": "Changes the value of bNotifyRigidBodyCollision",
          "params": {
            "bNewNotifyRigidBodyCollision": "The value to assign to bNotifyRigidBodyCollision"
          }
        },
        "SetOnlyOwnerSee": {
          "comment": "Changes the value of bOnlyOwnerSee."
        },
        "SetOwnerNoSee": {
          "comment": "Changes the value of bOwnerNoSee."
        },
        "SetPhysMaterialOverride": {
          "comment": "Changes the current PhysMaterialOverride for this component.\n Note that if physics is already running on this component, this will _not_ alter its mass/inertia etc, it will only change its\n surface properties like friction and the damping."
        },
        "SetRBAngularVelocity": {
          "comment": "Set the angular velocity of the rigid body physics of this PrimitiveComponent. If no rigid-body physics is active, will do nothing.\n In the case of a SkeletalMeshComponent will affect all bones - and will apply the linear velocity necessary to get all bones to rotate around the root.\n This should be used cautiously - it may be better to use AddForce or AddImpulse.",
          "params": {
            "NewAngVel": "New angular velocity to apply to physics.",
            "bAddToCurrent": "If true, NewAngVel is added to the existing velocity of the body."
          }
        },
        "SetRBChannel": {
          "comment": "Changes the rigid-body channel that this object is defined in."
        },
        "SetRBCollidesWithChannel": {
          "comment": "Changes a member of the RBCollideWithChannels container for this PrimitiveComponent.",
          "params": {
            "bNewCollides": "whether or not to collide with passed in channel"
          }
        },
        "SetRBCollisionChannels": {
          "comment": "Sets the collision channels based on the settings in the Channel container.",
          "params": {
            "Channels": "is a list of channels with which the component should collide"
          }
        },
        "SetRBDominanceGroup": {
          "comment": "Used for creating one-way physics interactions.\n @see RBDominanceGroup"
        },
        "SetRBLinearVelocity": {
          "comment": "Set the linear velocity of the rigid body physics of this PrimitiveComponent. If no rigid-body physics is active, will do nothing.\n In the case of a SkeletalMeshComponent will affect all bones.\n This should be used cautiously - it may be better to use AddForce or AddImpulse.",
          "params": {
            "NewVel": "New linear velocity to apply to physics.",
            "bAddToCurrent": "If true, NewVel is added to the existing velocity of the body."
          }
        },
        "SetRBPosition": {
          "comment": "Called if you want to move the physics of a component which has dynamics running (ie actor is in PHYS_RigidBody).\n Be careful calling this when this is jointed to something else, or when it does not fit in the destination (no checking is done).",
          "params": {
            "NewPos": "new position of the body",
            "BoneName": "(SkeletalMeshComponent only) if specified, the bone to change position of\n if not specified for a SkeletalMeshComponent, all bodies are moved by the delta\n between the desired location and that of the root body."
          }
        },
        "SetRBRotation": {
          "comment": "Called if you want to rotate the physics of a component which has dynamics running (ie actor is in PHYS_RigidBody).",
          "params": {
            "NewRot": "new rotation of the body",
            "BoneName": "(SkeletalMeshComponent only) if specified, the bone to change rotation of\n if not specified for a SkeletalMeshComponent, all bodies are moved by the delta\n between the desired rotation and that of the root body."
          }
        },
        "SetShadowParent": {
          "comment": "Changes the value of ShadowParent.",
          "params": {
            "NewShadowParent": "The value to assign to ShadowParent."
          }
        },
        "SetViewOwnerDepthPriorityGroup": {
          "comment": "Changes the value of bUseViewOwnerDepthPriorityGroup and ViewOwnerDepthPriorityGroup.",
          "params": {
            "bNewUseViewOwnerDepthPriorityGroup": "The value to assign to bUseViewOwnerDepthPriorityGroup.",
            "NewViewOwnerDepthPriorityGroup": "The value to assign to ViewOwnerDepthPriorityGroup."
          }
        },
        "ShouldComponentAddToScene": {
          "comment": "Looking at various values of the component, determines if this\n component should be added to the scene"
        },
        "WakeRigidBody": {
          "comment": "Ensure simulation is running for this component.\n If a SkeletalMeshComponent and no BoneName is specified, will wake all bones in the PhysicsAsset."
        }
      },
      "structs": {
        "MaterialViewRelevance": {
          "comment": "Mirrored from Scene.h"
        },
        "RBCollisionChannelContainer": {
          "comment": "Container for indicating a set of collision channel that this object will collide with.\n Mirrored manually in UnPhysPublic.h"
        }
      }
    },
    "ProcBuilding": {
      "properties": {
        "AttachedBuildings": {
          "comment": "Set of buildings which are directly attached to this one (using Base pointer)"
        },
        "bQuickEdited": {
          "comment": "If TRUE, this actor has been edited in 'quick' mode, and needs regen-ing when quick mode exits."
        },
        "BuildingInstanceVersion": {
          "comment": "Current version of building - set to PROCBUILDING_VERSION when building meshed."
        },
        "BuildingMatParamMICs": {
          "comment": "Array of MICs created to set BuildingMaterialParams on meshes in this building."
        },
        "CurrentSimpleMeshActor": {
          "comment": "This is the actor that owns the simple mesh component (either the building itself, or the LowLODPersistentActor) (transient as it's only valid while updating building)"
        },
        "CurrentSimpleMeshComp": {
          "comment": "This is the low detail component, either owned by this actor or in another level (transient as it's only really valid while updating building)"
        },
        "EdgeInfos": {
          "comment": "Set of all edges between scopes, indicating which scopes the edge connects, as well as angle and location"
        },
        "LODMeshComps": {
          "comment": "Components that are used for intermediate LOD, which should be hidden when generating render-to-texture"
        },
        "LODMeshUVInfos": {
          "comment": "UV Information about quads used for intermediate LOD - each element corresponds to element in LODMeshComps"
        },
        "MaxFacadeZ": {
          "comment": "Top-most z value of facade scopes"
        },
        "MinFacadeZ": {
          "comment": "Bottom-most z value of facade scopes"
        },
        "NumMeshedTopLevelScopes": {
          "comment": "This is the divider between TopLevelScopes that are used for meshing, and those used as bounds not non-rect polys for generating texture."
        },
        "OverlappingBuildings": {
          "comment": "Temporarty set of buildings that overlap this building."
        },
        "TopLevelScopeInfos": {
          "comment": "Array of rulesets applied to each TopLevelScope of building"
        },
        "TopLevelScopes": {
          "comment": "List of the top level rectangular scopes building"
        },
        "TopLevelScopeUVInfos": {
          "comment": "List of UV info for each top level scope, should match size of TopLevelScopes."
        },
        "bDebugDrawEdgeInfo": {
          "comment": "If TRUE, show face->edge relationships when this building is selected."
        },
        "bDebugDrawScopes": {
          "comment": "If TRUE, show scopes extracted from brushes."
        },
        "bApplyRulesToFloor": {
          "comment": "If TRUE, meshing rules are applied to floor of building, instead of just leaving it as a flat poly"
        },
        "bApplyRulesToRoof": {
          "comment": "If TRUE, meshing rules are applied to roof of building, instead of just leaving it as a flat poly"
        },
        "bBuildingBrushCollision": {
          "comment": "Controls if the simple brush has collision."
        },
        "bGenerateFloorMesh": {
          "comment": "If TRUE, generate a poly to fill the hole on the bottom of the building volume"
        },
        "bGenerateRoofMesh": {
          "comment": "If TRUE, generate a poly to fill the hole on the top of the building"
        },
        "bSplitWallsAtRoofLevels": {
          "comment": "If TRUE, wall scopes will be split at each roof/floor level in the building group."
        },
        "bSplitWallsAtWallEdges": {
          "comment": "If TRUE, wall scopes will be split when another wall ends in the middle of a face."
        },
        "BuildingFracMeshCompInfos": {
          "comment": "Array of information about each fractured mesh making up the final building"
        },
        "BuildingMaterialParams": {
          "comment": "Optional parameters than are set on all MICs applied to building."
        },
        "BuildingMeshCompInfos": {
          "comment": "Array of information about each component making up the final building"
        },
        "LODRenderToTextureScale<UIMin=0.25|UIMax=4.0>": {
          "comment": "Amount to scale the resolution of LOD color and lighting textures, generated using render-to-texture"
        },
        "LowLODPersistentActor": {
          "comment": "Since we want the low lod mesh of the building to be always loaded, we need an actor in the P map (or other always loaded level); this is that actor"
        },
        "NonRectWallLightmapRes": {
          "comment": "Light map resolution used for generated non-rectangular wall meshes"
        },
        "ParamSwatchName": {
          "comment": "Name of the parameter 'swatch' (stored in the Ruleset) that is applied to this building"
        },
        "RenderToTexturePullBackAmount": {
          "comment": "Amount to pull back from the face to render from (caging depth). Nearby meshes closer than this will be rendered into the buildings RTT."
        },
        "RoofLightmapRes": {
          "comment": "Light map resolution used for generated roof plane mesh"
        },
        "Ruleset": {
          "comment": "Pointer to ruleset in package used to build facade geometry for building"
        },
        "SimpleMeshComp": {
          "comment": "Component used to display simple one-mesh version of building"
        },
        "SimpleMeshMassiveLODDistance": {
          "comment": "Distance at which MassiveLOD will kick in and change between high detail meshes and the SimpleMeshComp / LowLODPersistentActor"
        }
      },
      "functions": {
        "BreakFractureComponent": {
          "comment": "Will break pieces off the specified fracture component that are within the specified box."
        },
        "ClearBuildingMeshes": {
          "comment": "Remove all the building meshes from this building"
        },
        "FindComponentsForTopLevelScope": {
          "comment": "Util for finding all building components that form one top level scope."
        },
        "FindEdgeForTopLevelScope": {
          "comment": "Given an index of a scope in the TopLevelsScopes array (and which edge of that scope), returns index into EdgeInfos with that edge's info.\n Value of INDEX_NONE may be returned, indicating edge could not be found, which may indicate this is a scope-poly edge instead of scope-scope."
        },
        "GetAllGroupedProcBuildings": {
          "comment": "Get the set of all ProcBuildings (including this one) that are grouped together (using Base pointer)"
        },
        "GetBaseMostBuilding": {
          "comment": "Walks up Base chain to find the root building of the attachment chain"
        }
      },
      "structs": {
        "PBEdgeInfo": {
          "comment": "Struct that contains info about an edge between two scopes.",
          "properties": {
            "EdgeAngle": {
              "comment": "Angle at this edge, in degrees. 0 means flat, positive is convex (outside) corner, negative is interior"
            },
            "EdgeEnd": {
              "comment": "End point (in building space) of this edge"
            },
            "EdgeStart": {
              "comment": "Start point (in building space) of this edge"
            },
            "ScopeAEdge": {
              "comment": "What edge of ScopeA this edge forms"
            },
            "ScopeAIndex": {
              "comment": "Index of first scope that meets at this edge, in the ToplevelScopes array"
            },
            "ScopeBEdge": {
              "comment": "What edge of ScopeB this edge forms"
            },
            "ScopeBIndex": {
              "comment": "Index of second scope that meets at this edge, in the ToplevelScopes array"
            }
          }
        },
        "PBFaceUVInfo": {
          "comment": "Struct that contains information about the UVs of one face in the low detail mesh",
          "properties": {
            "Offset": {
              "comment": "Offset into the texture page"
            },
            "Size": {
              "comment": "Size of the face's region in the texture page"
            }
          }
        },
        "PBFracMeshCompInfo": {
          "properties": {
            "FracMeshComp": {
              "comment": "Fractured mesh instance used to make up facade"
            },
            "TopLevelScopeIndex": {
              "comment": "Index into TopLevelScopes of scope that this mesh makes up part of"
            }
          }
        },
        "PBMaterialParam": {
          "comment": "Struct used to store information for building-wide material instances",
          "properties": {
            "Color": {
              "comment": "Value to set parameter to in all building MICs"
            },
            "ParamName": {
              "comment": "Name of parameter to set in all building MICs"
            }
          }
        },
        "PBMeshCompInfo": {
          "comment": "Struct that gives information about each component making up the facades of a building",
          "properties": {
            "MeshComp": {
              "comment": "Mesh instance used to make up facade"
            },
            "TopLevelScopeIndex": {
              "comment": "Index into TopLevelScopes of scope that this mesh makes up part of"
            }
          }
        },
        "PBScope2D": {
          "comment": "Struct that defines a 2D 'scope' - region of a building face",
          "properties": {
            "DimX": {
              "comment": "Size of scope along its X axis"
            },
            "DimZ": {
              "comment": "Size of scope along its Z axis"
            },
            "ScopeFrame": {
              "comment": "Transform (in actor space) of the bottom-left corner of scope"
            }
          }
        },
        "PBScopeProcessInfo": {
          "comment": "Additional information about each scope of the building",
          "properties": {
            "bGenerateLODPoly": {
              "comment": "Whether we want to generate a RTT poly for this scope in the low LOD building"
            },
            "bPartOfNonRect": {
              "comment": "If this scope is within non-rectangular polygon."
            },
            "OwningBuilding": {
              "comment": "Building (could be 'child' building) that generated this scope."
            },
            "Ruleset": {
              "comment": "Which building ruleset is applied to this scope"
            },
            "RulesetVariation": {
              "comment": "Name of the ruleset variation desired on this scope"
            }
          }
        }
      }
    },
    "ProcBuildingRuleset": {
      "properties": {
        "bBeingEdited": {
          "comment": "Used to avoid editing the same ruleset in multiple Facade windows at the same time."
        },
        "Comments": {
          "comment": "Array of comment nodes (for drawing comment boxes) - not connected, so need this so they are serialized."
        },
        "RootRule": {
          "comment": "Pointer to first rule to execute"
        },
        "DefaultFloorMaterial": {
          "comment": "Material applied to floor surface by default (can be overridden)"
        },
        "FloorPolyInset": {
          "comment": "Amount to 'pull in' vertices of the generated floor poly."
        },
        "FloorZOffset": {
          "comment": "Offset applied to floor poly if at very bottom of overall building"
        },
        "NotFloorZOffset": {
          "comment": "Offset applied to floor poly if not at very bottom of overall building"
        },
        "bEnableInteriorTexture": {
          "comment": "Whether to have any 'interior' texture on the LOD building windows"
        },
        "bLODOnlyRoof": {
          "comment": "If TRUE, roof only displays in when building drops to low-detail version"
        },
        "BuildingLODSpecular": {
          "comment": "Amount of specular to apply to low LOD building material"
        },
        "InteriorTexture": {
          "comment": "Texture to use for 'interior' of LOD building windows"
        },
        "LODCubemap": {
          "comment": "Cubemap texture to use for the LOD version of the building."
        },
        "bPickRandomSwatch": {
          "comment": "If TRUE, then pick a random swatch if a building is currently None (or not supported by current ruleset)"
        },
        "DefaultNonRectWallMaterial": {
          "comment": "Material applied to non-rectangular surfaces by default (can be overridden)"
        },
        "ParamSwatches": {
          "comment": "Pre-defined, names 'swatches' (or sets) of parameters that can be selected on a building"
        },
        "Variations": {
          "comment": "Array of 'variations' supported within this ruleset"
        },
        "DefaultRoofMaterial": {
          "comment": "Material applied to roof surface by default (can be overridden)"
        },
        "NotRoofZOffset": {
          "comment": "Offset applied to roof poly if not at very top of overall building"
        },
        "RoofEdgeScopeRaise": {
          "comment": "How much to raise top of scopes that meet the roof of the building, forming a short wall around the roof."
        },
        "RoofPolyInset": {
          "comment": "Amount to 'pull in' vertices of the generated roof poly."
        },
        "RoofZOffset": {
          "comment": "Offset applied to floor poly if at very top of overall building"
        }
      },
      "structs": {
        "PBParamSwatch": {
          "comment": "Struct holding a defined 'swatch' of parameters that can be selected by name",
          "properties": {
            "Params": {
              "comment": "Set of parameters that should be applied when this swatch is selected for a building"
            },
            "SwatchName": {
              "comment": "Name of this swatch"
            }
          }
        },
        "PBVariationInfo": {
          "comment": "Struct contain information about 'variations' supported within this ruleset",
          "properties": {
            "bMeshOnTopOfFacePoly": {
              "comment": "If TRUE, meshes are placed on top of simple face poly, rather than making hole for meshes."
            },
            "VariationName": {
              "comment": "Name of this variation"
            }
          }
        }
      }
    },
    "Projectile": {
      "properties": {
        "bBlockedByInstigator": {
          "comment": "If false, instigator does not collide with this projectile"
        },
        "bIgnoreFoliageTouch": {
          "comment": "If true, ignore foliage entirely"
        },
        "bRotationFollowsVelocity": {
          "comment": "If true, this projectile will have its rotation updated each frame to match its velocity"
        },
        "bSwitchToZeroCollision": {
          "comment": "If collisionextent nonzero, and hit actor with bBlockNonZeroExtents=0, switch to zero extent collision."
        },
        "ZeroCollider": {
          "comment": "The actor that the switch to zero collision occurred on (WorldInfo in the case of BSP)."
        },
        "ZeroColliderComponent": {
          "comment": "The component that the switch to zero collision occurred on (NULL in the case of BSP)."
        },
        "Damage": {
          "comment": "Damage done by the projectile"
        },
        "DamageRadius": {
          "comment": "Radius of effect in which damage is applied."
        },
        "ImpactSound": {
          "comment": "Sound made when projectile hits something."
        },
        "MaxSpeed": {
          "comment": "Limit on speed of projectile (0 means no limit)."
        },
        "MomentumTransfer": {
          "comment": "Momentum magnitude imparted by impacting projectile."
        },
        "SpawnSound": {
          "comment": "Sound made when projectile is spawned."
        },
        "Speed": {
          "comment": "Initial speed of projectile."
        }
      },
      "functions": {
        "ApplyFluidSurfaceImpact": {
          "comment": "Called when this actor touches a fluid surface"
        },
        "GetRange": {
          "comment": "returns the maximum distance this projectile can travel"
        },
        "GetTimeToLocation": {
          "comment": "returns the amount of time it would take the projectile to get to the specified location"
        },
        "HurtRadius": {
          "comment": "HurtRadius()\n Hurt locally authoritative actors within the radius."
        },
        "ProjectileHurtRadius": {
          "comment": "Adjusts HurtOrigin up to avoid world geometry, so more traces to actors around explosion will succeed"
        },
        "StaticGetTimeToLocation": {
          "comment": "static version of GetTimeToLocation()"
        }
      }
    },
    "Pylon": {
      "properties": {
        "bBuildThisPylon": {
          "comment": "when FALSE this pylon's navmesh will not be cleared, nor built during 'build paths' -- useful for building subsets of the map at once"
        },
        "bImportedMesh": {
          "comment": "Indicates if this pylon is associated with an imported mesh"
        },
        "bNeedsCostCheck": {
          "comment": "indicates that this pylon's CostFor function needs to be called when considering edges owned by it"
        },
        "BrokenSprite": {
          "comment": "sprite comp to be used when this pylon is broken somehow"
        },
        "bUseExpansionSphereOverride": {
          "comment": "when TRUE, center of sphere used for expansion bounds will be ExpansionSphereCenter rather than this.location"
        },
        "DynamicObstacleMesh": {
          "comment": "Obstacle mesh used for \"can-go\" raycasts - built from dynamic obstacles!"
        },
        "MaxExpansionRadius": {
          "comment": "Used to prevent exploration from wrapping past the 65536 available indices in a WORD"
        },
        "NavMeshPtr": {
          "comment": "Navigation mesh created for this pylon"
        },
        "NextPassSeedList": {
          "comment": "Seed points created by last round of cover info"
        },
        "NextPylon": {
          "comment": "Next pylon in the linked list"
        },
        "ObstacleMesh": {
          "comment": "Obstacle mesh used for \"can-go\" raycasts"
        },
        "OctreeId": {
          "comment": "ID member var for octree functionality"
        },
        "OctreeIWasAddedTo": {
          "comment": "pointer to the octree this pylon was added to (so we can tell when the octree changes"
        },
        "PathObjectsThatAffectThisPylon": {
          "comment": "internally used list of pathobjects which affect this pylon's mesh. Used only at navmesh generation time"
        },
        "RenderingComp": {
          "comment": "pointer to this pylon's rendering component"
        },
        "WorkingSetPtr": {
          "comment": "Working set ptr - used internally for building nav mesh"
        },
        "ExpansionRadius": {
          "comment": "radius within which expansion will be allowed. Note if this pylon has an expansion volume linked to it, this parameter has no effect"
        },
        "ExpansionVolumes": {
          "comment": "A list of volumes within which is valid to explore Note this trumps expansion radius"
        },
        "ImposterPylons": {
          "comment": "Imposter pylon - this is another pylon which at some point will replace this one due to a gameplay event or some such. Meshbuild of this\n pylon will ignore collisions with the imposter pylon (e.g. build through it)"
        },
        "OnBuild_DisableCollisionForThese": {
          "comment": "when this pylon is being built, disable collision for these actors"
        },
        "OnBuild_EnableCollisionForThese": {
          "comment": "when this pylon is being built, enable collision for these actors"
        }
      },
      "functions": {
        "OnPylonStatusChange": {
          "comment": "called whenever this pylon is turned on or off.. will do necessary work \n in area to make sure the state of the mesh is up to date"
        }
      }
    },
    "RadialBlurActor": {
      "properties": {
        "RadialBlur": {
          "comment": "Blur component created for the actor"
        }
      }
    },
    "RadialBlurComponent": {
      "properties": {
        "LocalToWorld": {
          "comment": "The current parent to world transform of the component"
        },
        "bEnabled": {
          "comment": "if TRUE the effect is enabled and rendered in the scene"
        },
        "BlurFalloffExponent": {
          "comment": "Exponent for falloff rate of blur vectors"
        },
        "BlurOpacity": {
          "comment": "Amount to alpha blend the blur effect with the existing scene"
        },
        "BlurScale": {
          "comment": "Scale for the overall blur vectors"
        },
        "bRenderAsVelocity": {
          "comment": "if TRUE then radial blur vectors are rendered to the velocity buffer \n instead of being used to manually sampling scene color values"
        },
        "DepthPriorityGroup": {
          "comment": "Scene DPG determines order in which effect is drawn"
        },
        "DistanceFalloffExponent": {
          "comment": "Rate of falloff based on distance from view origin"
        },
        "Material": {
          "comment": "Material to affect radial blur opacity/color"
        },
        "MaxCullDistance": {
          "comment": "Max distance where effect is rendered. If further than this then culled"
        }
      },
      "functions": {
        "OnUpdatePropertyBlurFalloffExponent": {
          "comment": "Called from matinee code when BlurFalloffExponent property changes."
        },
        "OnUpdatePropertyBlurOpacity": {
          "comment": "Called from matinee code when BlurOpacity property changes."
        },
        "OnUpdatePropertyBlurScale": {
          "comment": "Called from matinee code when BlurScale property changes."
        }
      }
    },
    "RB_BodyInstance": {
      "properties": {
        "bForceUnfixed": {
          "comment": "An override to say whether this body has been forced (by gameplay code) to be unfixed or not. This\n allows for the existing functionality and not having to change all of the existing code for setting\n fixed/unfixed on body instances. Useful for chopping off limbs and having Pawn go to ragdoll and back and still\n be able to play animations."
        },
        "bInstanceAlwaysFullAnimWeight": {
          "comment": "If this is true that all of the \"updatetransform\" data should come from the physics and not the anim data.\n NOTE: If an animation is played on the bones and there is no actual BodyInstance (e.g. ragdolls usually have finger\n and those indiv finger bones do not have a body instance on them) then the animation will still play as there is no\n body instance which is being checked for this override."
        },
        "BodyData": {
          "comment": "Internal use. Physics-engine representation of this body."
        },
        "BodyIndex": {
          "comment": "Index of this BodyInstance within the PhysicsAssetInstance/PhysicsAsset."
        },
        "BoneSpring": {
          "comment": "Internal use. Physics-engine representation of the spring on this body."
        },
        "BoneSpringKinActor": {
          "comment": "If bUseKinActorForBoneSpring is true, this is the Physics-engine representation of the kinematic actor the spring is attached to."
        },
        "LastEffectPlayedTime": {
          "comment": "For per-bodyinstance effects this keeps track of the last time one played. Could be used for items like gib effects."
        },
        "OwnerComponent": {
          "comment": "PrimitiveComponent containing this body. \n Due to the way the BodyInstance pooling works, this MUST BE FIRST PROPERTY OF THE CLASS."
        },
        "PreviousVelocity": {
          "comment": "Previous frame Velocity of this BodyInstance. Only updated if this is the root body of the CollisionComponent of an Actor in PHYS_RigidBody\n used for collision events since by the time the event is sent, Velocity would have been updated with the post-collision velocity"
        },
        "SceneIndex": {
          "comment": "Physics scene index."
        },
        "Velocity": {
          "comment": "Current linear velocity of this BodyInstance. Only updated if this is the root body of the CollisionComponent of an Actor in PHYS_RigidBody"
        },
        "bDisableOnOverextension": {
          "comment": "If true, bone spring will automatically disable if it ever gets longer than the OverextensionThreshold."
        },
        "bEnableBoneSpringAngular": {
          "comment": "Enable angular 'spring' between the physics body for this bone, and the world-space location of the animation bone."
        },
        "bEnableBoneSpringLinear": {
          "comment": "Enable linear 'spring' between the physics body for this bone, and the world-space location of the animation bone."
        },
        "bMakeSpringToBaseCollisionComponent": {
          "comment": "When using bone springs, connect them to the physics body of the Base's CollisionComponent.\n When using this option, SetBoneSpringTarget must be given a matrix for this bone relative to the other bone,\n rather than relative to the world."
        },
        "bNotifyOwnerOnOverextension": {
          "comment": "Send notification to Owning Actor when overextended, by calling Actor::OnRigidBody"
        },
        "BoneAngularDamping": {
          "comment": "Damping on angular spring to animated bone."
        },
        "BoneAngularSpring": {
          "comment": "Strength of angular spring to animated bone."
        },
        "BoneLinearDamping": {
          "comment": "Damping on linear spring to animated bone."
        },
        "BoneLinearSpring": {
          "comment": "Strength of linear spring to animated bone."
        },
        "bTeleportOnOverextension": {
          "comment": "This will teleport the whole PhysicsAssetInstance if this spring gets too long, to reduce to error to zero.\n Note - having this set on more than one body in a PhysicsAssetInstance will have unpredictable results."
        },
        "bUseKinActorForBoneSpring": {
          "comment": "When using bone springs, connect them to a kinematic body and animate that, rather than animating the attachment location on the 'world'.\n This adds some overhead, but tracks rapidly moving targets better."
        },
        "OverextensionThreshold": {
          "comment": "If bDisableOnOverextension is on, the bone spring will be disabled if it stretches more than this amount."
        },
        "bEnableCollisionResponse": {
          "comment": "Enables physics response for this body (on by default). If FALSE, contacts are still generated and reported. Useful for \"sensor\" bodies."
        },
        "bOnlyCollideWithPawns": {
          "comment": "This body should only collide with other bodies with their components marked bConsiderPawnForRBCollision.\n Useful for flappy bits you do not want to collide with the world."
        },
        "bPushBody": {
          "comment": "Denotes body as a \"push\" body. Also disables collision response, by definition."
        },
        "ContactReportForceThreshold": {
          "comment": "Used for force-based collision filtering. Note: this is NOT an additional filter on top of normal\n pairwise filtering. It is essentially a new kind of reporting. It can be used in conjuction\n with pairwise reporting, however.\n To disable this feature, set the threshold to a negative number."
        },
        "InstanceDampingScale": {
          "comment": "Per-instance scaling of linear/angular damping"
        },
        "InstanceMassScale": {
          "comment": "Per-instance scaling of mass"
        },
        "PhysMaterialOverride": {
          "comment": "Allows you to override the PhysicalMaterial to use for this body. \n Due to the way the BodyInstance pooling works, this MUST BE LAST PROPERTY OF THE CLASS."
        },
        "CustomGravityFactor": {
          "comment": "The force applied to the body to address custom gravity for the actor is multiplied CustomGravityFactor, allowing bodies to individually control how \n custom gravity settings affectthem"
        }
      },
      "functions": {
        "EnableBoneSpring": {
          "comment": "Used to turn the angular/linear bone spring on and off. \n InBoneTarget is in world space, unless bMakeSpringToBaseCollisionComponent is TRUE, in which case it is relative to that body."
        },
        "EnableCollisionResponse": {
          "comment": "Enable/disable response to contacts."
        },
        "GetBodyMass": {
          "comment": "Returns the body's mass"
        },
        "GetPhysicsAssetInstance": {
          "comment": "Returns the PhysicsAssetInstance that owns this RB_BodyInstance (if there is one)"
        },
        "GetUnrealWorldAngularVelocity": {
          "comment": "Get current angular velocity in world space from physics body."
        },
        "GetUnrealWorldTM": {
          "comment": "Get current transform in world space from physics body."
        },
        "GetUnrealWorldVelocity": {
          "comment": "Get current velocity in world space from physics body."
        },
        "GetUnrealWorldVelocityAtPoint": {
          "comment": "Get current velocity of a point on this physics body, in world space. Point is specified in world space."
        },
        "IsFixed": {
          "comment": "Returns TRUE if this body is fixed"
        },
        "IsValidBodyInstance": {
          "comment": "See if this body is valid."
        },
        "SetBlockRigidBody": {
          "comment": "Used to disable rigid body collisions for this body. Overrides the bNoCollision flag in the BodySetup for this body."
        },
        "SetBoneSpringParams": {
          "comment": "Used to set the spring stiffness and damping parameters for the bone spring."
        },
        "SetBoneSpringTarget": {
          "comment": "Used to set desired target location of this spring. Usually called by UpdateRBBonesFromSpaceBases. \n InBoneTarget is in world space, unless bMakeSpringToBaseCollisionComponent is TRUE, in which case it is relative to that body."
        },
        "SetContactReportForceThreshold": {
          "comment": "Set a new contact report force threhold. Threshold < 0 disables this feature."
        },
        "SetFixed": {
          "comment": "Force this body to be fixed (kinematic) or not. Overrides the BodySetup for this body."
        },
        "SetPhysMaterialOverride": {
          "comment": "Set physical material override for this body"
        },
        "UpdateDampingProperties": {
          "comment": "Update instance's linear and angular damping"
        },
        "UpdateMassProperties": {
          "comment": "Update instance's mass properties (mass, inertia and center-of-mass offset) based on MassScale, InstanceMassScale and COMNudge."
        }
      }
    },
    "RB_BodySetup": {
      "properties": {
        "CollisionGeom": {
          "comment": "Cache of physics-engine specific collision shapes at different scales. Physics engines do not normally support per-instance collision shape scaling."
        },
        "CollisionGeomScale3D": {
          "comment": "Scale factors for each CollisionGeom entry. CollisionGeom.Length == CollisionGeomScale3D.Length."
        },
        "PreCachedPhysData": {
          "comment": "Array of cached convex physics data."
        },
        "PreCachedPhysDataVersion": {
          "comment": "Version of cached physics data."
        },
        "bAlwaysFullAnimWeight": {
          "comment": "If true (and bEnableFullAnimWeightBodies in SkelMeshComp is true), the physics of this bone will always be blended into the skeletal mesh, regardless of what PhysicsWeight of the SkelMeshComp is. \n This is useful for bones that should always be physics, even when blending physics in and out for hit reactions (eg cloth or pony-tails)."
        },
        "bBlockNonZeroExtent": {
          "comment": "When doing line checks against this PhysicsAsset, this body should return hits with non-zero-extent (ie swept-box) checks."
        },
        "bBlockZeroExtent": {
          "comment": "When doing line checks against this PhysicsAsset, this body should return hits with zero-extent (ie line) checks."
        },
        "bConsiderForBounds": {
          "comment": "Should this BodySetup be considered for the bounding box of the PhysicsAsset (and hence SkeletalMeshComponent).\n There is a speed improvement from having less BodySetups processed each frame when updating the bounds."
        },
        "bEnableContinuousCollisionDetection": {
          "comment": "Turn on continuous collision detection for this body.\n This should avoid it passing through other objects when moving quickly."
        },
        "bFixed": {
          "comment": "No dynamics on this body - fixed relative to the world."
        },
        "bNoCollision": {
          "comment": "This body will not collide with anything."
        },
        "BoneName": {
          "comment": "Used in the PhysicsAsset case. Associates this Body with Bone in a skeletal mesh."
        },
        "MassScale": {
          "comment": "The mass of a body is calculated automatically based on the volume of the collision geometry and the density specified by the PhysicalMaterial.\n This parameters allows you to scale the auto-generated value for this specific body."
        },
        "PhysMaterial": {
          "comment": "Physical material to use for this body. Encodes information about density, friction etc."
        },
        "PreCachedPhysScale": {
          "comment": "Scales to pre-cache physics data for this collision at."
        },
        "SleepFamily": {
          "comment": "The set of values used in considering when put this body to sleep."
        }
      },
      "structs": {
        "KCachedConvexData": {
          "comment": "Script mittot of cached pre-cooked physics data for this simplified collision"
        },
        "KCachedConvexDataElement": {
          "comment": "Script mirror of cached pre-cooked physics data for one convex hull"
        }
      }
    },
    "RB_ConstraintActor": {
      "properties": {
        "ConstraintActor1": {
          "comment": "Used for checking that this constraint is valid buring map build"
        }
      },
      "functions": {
        "OnDestroy": {
          "comment": "When destroyed using Kismet, break the constraint."
        },
        "OnToggle": {
          "comment": "When destroyed using Kismet, break the constraint."
        },
        "OnToggleConstraintDrive": {
          "comment": "Handle 'Toggle Constraint Drive' kismet action"
        }
      }
    },
    "RB_ConstraintActorSpawnable": {
      "comment": "RB_ConstraintActor spawnable during gameplay"
    },
    "RB_ConstraintDrawComponent": {
      "properties": {
        "LimitMaterial": {
          "comment": "Retrieves the materials used in this component \n \n \n@param OutMaterials The list of used materials."
        }
      }
    },
    "RB_ConstraintInstance": {
      "properties": {
        "bInHardware": {
          "comment": "Whether we are in the hardware or software scene."
        },
        "bTerminated": {
          "comment": "Indicates that this constraint has been terminated"
        },
        "ConstraintData": {
          "comment": "Internal use. Physics-engine representation of this constraint."
        },
        "ConstraintIndex": {
          "comment": "Indicates position of this constraint within the array in an PhysicsAssetInstance.\n Will correspond to RB_ConstraintSetup position in PhysicsAsset."
        },
        "DummyKinActor": {
          "comment": "If bMakeKinForBody1 is true, this is the kinematic body that is made for Body1. \n Due to the way the ConstraintInstance pooling works, this MUST BE LAST PROPERTY OF THE CLASS."
        },
        "Owner": {
          "comment": "Actor that owns this constraint instance.\n Could be a ConstraintActor, or an actor using a PhysicsAsset containing this constraint.\n Due to the way the ConstraintInstance pooling works, this MUST BE FIRST PROPERTY OF THE CLASS."
        },
        "OwnerComponent": {
          "comment": "PrimitiveComponent containing this constraint."
        },
        "SceneIndex": {
          "comment": "Physics scene index."
        }
      },
      "functions": {
        "GetConstraintLocation": {
          "comment": "Get the position of this constraint in world space."
        },
        "GetPhysicsAssetInstance": {
          "comment": "Returns the PhysicsAssetInstance that owns this RB_ConstraintInstance (if there is one)"
        },
        "InitConstraint": {
          "comment": "Create physics engine constraint.\n If bMakeKinForBody1 is TRUE, then a non-colliding kinematic body is created for Body1 and used instead."
        },
        "MoveKinActorTransform": {
          "comment": "If bMakeKinForBody1 was used, this function allows the kinematic body to be moved."
        },
        "SetAngularDOFLimitScale": {
          "comment": "Scale Angular Limit Constraints (as defined in RB_ConstraintSetup)"
        },
        "SetLinearLimitSize": {
          "comment": "Allows you to dynamically change the size of the linear limit 'sphere'."
        }
      }
    },
    "RB_ConstraintSetup": {
      "properties": {
        "Pos1": {
          "comment": "Location of constraint in Body1 reference frame. Physics scale."
        },
        "Pos2": {
          "comment": "Location of constraint in Body2 reference frame. Physics scale."
        },
        "PriAxis1": {
          "comment": "Primary (twist) axis in Body1 reference frame."
        },
        "PriAxis2": {
          "comment": "Primary (twist) axis in Body2 reference frame."
        },
        "SecAxis1": {
          "comment": "Seconday axis in Body1 reference frame. Orthogonal to PriAxis1."
        },
        "SecAxis2": {
          "comment": "Seconday axis in Body2 reference frame. Orthogonal to PriAxis2."
        },
        "bEnableProjection": {
          "comment": "If distance error between bodies exceeds 0.1 units, or rotation error exceeds 10 degrees, body will be projected to fix this.\n For example a chain spinning too fast will have its elements appear detached due to velocity, this will project all bodies so they still appear attached to each other."
        },
        "ConstraintBone1": {
          "comment": "Name of first bone (body) that this constraint is connecting. \n This will be the 'child' bone in a PhysicsAsset."
        },
        "ConstraintBone2": {
          "comment": "Name of second bone (body) that this constraint is connecting. \n This will be the 'parent' bone in a PhysicsAset."
        },
        "JointName": {
          "comment": "Name of bone that this joint is associated with."
        }
      },
      "structs": {
        "LinearDOFSetup": {
          "comment": "Struct specying one Linear Degree Of Freedom for this constraint.\n Defaults to a ball-and-socket joint.",
          "properties": {
            "bLimited": {
              "comment": "Whether this DOF has any limit on it."
            },
            "LimitSize": {
              "comment": "'Half-length' of limit gap. Can shift it by fiddling Pos1/2.\n A size of 0.0 results in 'locking' the linear DOF."
            }
          }
        }
      }
    },
    "RB_CylindricalForceActor": {
      "comment": "DO NOT USE, try the NxForceField classes instead!",
      "properties": {
        "bForceActive": {
          "comment": "Indicates whether the force is active at the moment."
        },
        "bForceApplyToCloth": {
          "comment": "Apply force field to cloth"
        },
        "bForceApplyToFluid": {
          "comment": "Apply force field to fluid"
        },
        "bForceApplyToProjectiles": {
          "comment": "Apply force field to projectiles like rockets"
        },
        "bForceApplyToRigidBodies": {
          "comment": "Apply force field to rigid bodies"
        },
        "CollideWithChannels": {
          "comment": "Which types of object to apply this force field to"
        },
        "EscapeVelocity": {
          "comment": "Velocity above which the radial force is ignored."
        },
        "ForceHeight": {
          "comment": "Height of force cylinder"
        },
        "ForceRadius": {
          "comment": "Radius of influence of the force at the bottom of the cylinder."
        },
        "ForceTopRadius": {
          "comment": "Radius of the force field at the top"
        },
        "HeightOffset": {
          "comment": "Offset from the actor base to the center of the force field"
        },
        "LiftFalloffHeight": {
          "comment": "Lift falloff height, 0-1, lift starts to fall off in a linear way above this height"
        },
        "LiftStrength": {
          "comment": "Strength of the force applied along the cylinder axis"
        },
        "RadialStrength": {
          "comment": "Strength of the force applied by this actor."
        },
        "RenderComponent": {
          "comment": "Used to preview the radius of the force."
        },
        "RotationalStrength": {
          "comment": "Rotational strength of the force applied around the cylinder axis."
        }
      },
      "functions": {
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        }
      }
    },
    "RB_ForceFieldExcludeVolume": {
      "properties": {
        "ForceFieldChannel": {
          "comment": "Used to identify which force fields this excluder applies to, ie if the channel ID matches then the excluder"
        }
      }
    },
    "RB_Handle": {
      "properties": {
        "bInHardware": {
          "comment": "Whether we are in the hardware or software scene."
        },
        "SceneIndex": {
          "comment": "Physics scene index."
        },
        "LinearDampingScale3D": {
          "comment": "Scales the handle spring damping along each axis (in local space of handle)"
        },
        "LinearStiffnessScale3D": {
          "comment": "Scales the handle spring stiffness along each axis (in local space of handle)"
        }
      },
      "functions": {
        "UpdateSmoothLocation": {
          "comment": "Adjust interpolation goal location while respecting current interpolation timing. Useful for interpolating to a moving target."
        }
      }
    },
    "RB_LineImpulseActor": {
      "properties": {
        "bCauseFracture": {
          "comment": "If true, will cause FracturedStaticMeshActor fragment hit by ray to break."
        },
        "bStopAtFirstHit": {
          "comment": "If an impulse should only be applied to the first thing the line hits, or all things in the lines path."
        },
        "bVelChange": {
          "comment": "If true, the Strength is taken as a change in velocity instead of an impulse (ie. mass will have no affect)."
        },
        "ImpulseRange": {
          "comment": "Length of line to check along."
        },
        "ImpulseStrength": {
          "comment": "Strength of impulse to apply to actors hit by the line check."
        }
      },
      "functions": {
        "FireLineImpulse": {
          "comment": "Do the line check and apply impulse now."
        },
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        }
      }
    },
    "RB_RadialForceActor": {
      "comment": "DO NOT USE, try the NxForceField classes instead!",
      "properties": {
        "RenderComponent": {
          "comment": "Used to preview the radius of the force."
        },
        "bForceActive": {
          "comment": "Indicates whether the force is active at the moment."
        },
        "bForceApplyToCloth": {
          "comment": "Apply force field to cloth"
        },
        "bForceApplyToFluid": {
          "comment": "Apply force field to fluid"
        },
        "bForceApplyToProjectiles": {
          "comment": "Apply force field to projectiles like rockets"
        },
        "bForceApplyToRigidBodies": {
          "comment": "Apply force field to rigid bodies"
        },
        "CollideWithChannels": {
          "comment": "Which types of object to apply this force field to"
        },
        "ForceFalloff": {
          "comment": "Way in which the force falls off as objects are further away from the location."
        },
        "ForceRadius": {
          "comment": "Radius of influence of the force."
        },
        "ForceStrength": {
          "comment": "Strength of the force applied by this actor. Positive forces are applied outwards."
        },
        "RadialForceMode": {
          "comment": "Indicates which type of force mode is used."
        },
        "SpinTorque": {
          "comment": "How strongly to spin objects around their local Z."
        },
        "SwirlStrength": {
          "comment": "How strongly objects orbit around Z axis of actor."
        }
      },
      "functions": {
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        }
      }
    },
    "RB_RadialImpulseActor": {
      "functions": {
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        }
      }
    },
    "RB_RadialImpulseComponent": {
      "properties": {
        "bCauseFracture": {
          "comment": "If true, will cause any FracturedStaticMeshActor pieces within expolsion to break."
        }
      },
      "functions": {
        "FireImpulse": {
          "comment": "Update the component's bounds"
        }
      }
    },
    "RB_Spring": {
      "properties": {
        "bInHardware": {
          "comment": "Whether we are in the hardware or software scene."
        },
        "BoneName1": {
          "comment": "Optional name of bone inside Component1 that spring is attached to (for PhysicsAsset case)."
        },
        "BoneName2": {
          "comment": "Optional name of bone inside Component2 that spring is attached to (for PhysicsAsset case)."
        },
        "Component1": {
          "comment": "PrimitiveComponent attached to one end of this spring."
        },
        "Component2": {
          "comment": "PrimitiveComponent attached to other end of this spring."
        },
        "MinBodyMass": {
          "comment": "Minimum mass of bodies connected by spring."
        },
        "SceneIndex": {
          "comment": "Physics scene index."
        },
        "SpringData": {
          "comment": "Internal phyiscs engine use."
        },
        "TimeSinceActivation": {
          "comment": "Zeroed when SetComponents is called, this indicates the time the spring has been acting."
        },
        "bEnableForceMassRatio": {
          "comment": "Allows you to limit the maximum force applied by spring based on MinBodyMass."
        },
        "DampMaxForce": {
          "comment": "Maximum velocity damping force applied between sprung bodies."
        },
        "DampSaturateVel": {
          "comment": "Linear velocity (along spring direction) at which damping force is maximum."
        },
        "MaxForceMassRatio": {
          "comment": "If bEnableForceMassRatio is true, this is maximum allowed ratio between MinBodyMass and the applied spring force."
        },
        "SpringMaxForce": {
          "comment": "Max linear force applied by spring. Multiplied by SpringMaxForceTimeScale before being passed to simulation."
        },
        "SpringMaxForceTimeScale": {
          "comment": "Allows scaling of spring force over time. Time is zeroed when SetComponents is called,\n and this curve is a scaling of SpringMaxForce over time from then (in seconds)."
        },
        "SpringSaturateDist": {
          "comment": "Spring extension at which maximum spring force is applied. Force linear ramps up to this point and is constant beyond it."
        }
      }
    },
    "RB_Thruster": {
      "properties": {
        "bThrustEnabled": {
          "comment": "If thrust should be applied at the moment."
        },
        "ThrustStrength": {
          "comment": "Strength of thrust force applied to the base object."
        }
      },
      "functions": {
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        }
      }
    },
    "ReachSpec": {
      "properties": {
        "bAddToNavigationOctree": {
          "comment": "whether or not this ReachSpec should be added to the navigation octree"
        },
        "bCanCutCorners": {
          "comment": "If true, pawns moving along this path can cut corners transitioning between this reachspec and adjacent reachspecs"
        },
        "bCheckForObstructions": {
          "comment": "whether AI should check for dynamic obstructions (Actors with bBlocksNavigation=true) when traversing this ReachSpec"
        },
        "BlockedBy": {
          "comment": "Actor that is blocking this ReachSpec, making it temporarily unusable"
        },
        "bSkipPrune": {
          "comment": "Prune paths should skip trying to prune along these"
        },
        "Distance": {
          "comment": "return TRUE if it's safe to skip ahead past this edge, FALSE otherwise"
        },
        "NavOctreeObject": {
          "comment": "pointer to object in navigation octree"
        },
        "PruneSpecList": {
          "comment": "Can always prune against these types of specs (even though class doesn't match)"
        },
        "bDisabled": {
          "comment": "Reachspec has been disabled/blocked by kismet"
        }
      },
      "functions": {
        "CostFor": {
          "comment": "CostFor()\nReturns the \"cost\" in unreal units\nfor Pawn P to travel from the start to the end of this reachspec"
        },
        "GetDirection": {
          "comment": "Returns direction of this reach spec (considers non-static nodes)"
        },
        "GetEnd": {
          "comment": "Returns nav point reference at end of spec"
        }
      }
    },
    "ReverbVolume": {
      "comment": "Used to affect reverb settings in the game and editor.",
      "properties": {
        "NextLowerPriorityVolume": {
          "comment": "Next volume in linked listed, sorted by priority in descending order."
        },
        "AmbientZoneSettings": {
          "comment": "Interior settings used for this volume"
        },
        "Priority": {
          "comment": "Priority of this volume. In the case of overlapping volumes the one with the highest priority\n is chosen. The order is undefined if two or more overlapping volumes have the same priority."
        },
        "Settings": {
          "comment": "Reverb settings to use for this volume."
        },
        "bEnabled": {
          "comment": "whether this volume is currently enabled and able to affect sounds"
        }
      },
      "structs": {
        "InteriorSettings": {
          "comment": "Struct encapsulating settings for interior areas."
        },
        "ReverbSettings": {
          "comment": "Struct encapsulating settings for reverb effects.",
          "properties": {
            "FadeTime": {
              "comment": "Time to fade from the current reverb settings into this setting, in seconds."
            },
            "ReverbType": {
              "comment": "The reverb preset to employ."
            },
            "Volume": {
              "comment": "Volume level of the reverb affect."
            }
          }
        }
      }
    },
    "Route": {
      "properties": {
        "FudgeFactor": {
          "comment": "Fudge factor for adjusting to next route position faster"
        },
        "RouteIndexOffset": {
          "comment": "routeindex offset (if you want the routeindex to be offset from the 'closest' route point you can plug an offset in here)"
        },
        "RouteList": {
          "comment": "List of move targets in order"
        },
        "RouteType": {
          "comment": "Move from beginning to end, then start at beginning again"
        }
      },
      "functions": {
        "MoveOntoRoutePath": {
          "comment": "Find the closest navigation point in the route\n (that is also within tether distance)"
        }
      }
    },
    "SavedMove": {
      "functions": {
        "PrepMoveFor": {
          "comment": "Called before PlayerController.ClientUpdatePosition uses this SavedMove to make a predictive correction"
        },
        "ResetMoveFor": {
          "comment": "Called after PlayerController.ClientUpdatePosition used this SavedMove to make a predictive correction"
        }
      }
    },
    "SaveGameSummary": {
      "properties": {
        "BaseLevel": {
          "comment": "Name of level this savegame is saved against. The level must be already in memory\n before the savegame can be applied."
        },
        "Description": {
          "comment": "Human readable description"
        }
      }
    },
    "SceneCapture2DActor": {
      "properties": {
        "DrawFrustum": {
          "comment": "used to draw the frustum lines and the texture surface"
        }
      }
    },
    "SceneCapture2DComponent": {
      "properties": {
        "bUpdateMatrices": {
          "comment": "set to false to disable automatic updates of the view/proj matrices"
        },
        "ProjMatrix": {
          "comment": "projection matrix used for rendering"
        },
        "ViewMatrix": {
          "comment": "view matrix used for rendering"
        },
        "FarPlane": {
          "comment": "far plane clip distance: <= 0 means no far plane"
        },
        "FieldOfView": {
          "comment": "horizontal field of view"
        },
        "NearPlane": {
          "comment": "near plane clip distance"
        },
        "TextureTarget": {
          "comment": "render target resource to set as target for capture"
        }
      },
      "functions": {
        "SetCaptureParameters": {
          "comment": "interface for changing TextureTarget, FOV, and clip planes"
        },
        "SetView": {
          "comment": "changes the view location and rotation\n @note: unless bUpdateMatrices is false, this will get overwritten as soon as the component or its owner moves"
        }
      }
    },
    "SceneCapture2DHitMaskComponent": {
      "properties": {
        "FadingDurationTime": {
          "comment": "Fading duration time since fading starts - in second"
        },
        "FadingIntervalTime": {
          "comment": "Fading interval - in second"
        },
        "FadingPercentage": {
          "comment": "What % of color to apply - Range of 0 to 1"
        },
        "FadingStartTimeSinceHit": {
          "comment": "Fading start time after hit - in second - by default 10 seconds \n Infinite if less than zero"
        },
        "ForceLOD": {
          "comment": "To do this properly we need to use ForcedLOD system of SkeletalMeshComponent"
        },
        "HitMaskCullDistance": {
          "comment": "Hit Mask Cull Distance. If a point is further than this distance, it will ignore"
        },
        "MaterialIndex": {
          "comment": "Which section to render for mask"
        },
        "TextureTarget": {
          "comment": "render target resource to set as target for capture"
        },
        "SkeletalMeshComp": {
          "comment": "mesh to render to target resource - Owner's SkeletalMes"
        }
      },
      "functions": {
        "SetCaptureParameters": {
          "comment": "interface for changing parameters"
        },
        "SetCaptureTargetTexture": {
          "comment": "interface for changing target texture"
        },
        "SetFadingStartTimeSinceHit": {
          "comment": "interface for changing fading parameter. Negative will disable it."
        }
      }
    },
    "SceneCaptureActor": {
      "properties": {
        "SceneCapture": {
          "comment": "component that renders the scene to a texture"
        }
      },
      "functions": {
        "OnToggle": {
          "comment": "Toggling enables or disables the scene capture."
        }
      }
    },
    "SceneCaptureComponent": {
      "properties": {
        "CaptureInfo": {
          "comment": "ptr to the scene capture probe"
        },
        "PostProcessProxies": {
          "comment": "Stores post-process scene proxies created from the post process chain that are eventually copied to the scene view."
        },
        "ViewState": {
          "comment": "pointer to the persistent view state for this scene capture"
        },
        "bEnabled": {
          "comment": "Turn the scene capture on/off"
        },
        "bEnableFog": {
          "comment": "toggle fog"
        },
        "bEnablePostProcess": {
          "comment": "toggle scene post-processing"
        },
        "bSkipRenderingDepthPrepass": {
          "comment": "if true, skip the depth prepass when rendering the scene capture."
        },
        "bSkipUpdateIfOwnerOccluded": {
          "comment": "if true, skip updating the scene capture if the Owner of the component has not been rendered recently"
        },
        "bSkipUpdateIfTextureUsersOccluded": {
          "comment": "if true, skip updating the scene capture if the users of the texture have not been rendered recently"
        },
        "bUseMainScenePostProcessSettings": {
          "comment": "If TRUE then use the main scene's post process settings when capturing"
        },
        "ClearColor": {
          "comment": "background color"
        },
        "FrameRate": {
          "comment": "rate to capture the scene,\n TimeBetweenCaptures = Max( 1/FrameRate, DeltaTime),\n if the FrameRate is 0 then the scene is captured only once"
        },
        "MaxStreamingUpdateDist": {
          "comment": "if > 0, skip streaming texture updates for the scene capture if the Owner is further than this many units away from the viewer.\n if == 0, then view information for this scene capture is not used by texture streaming manager for updates."
        },
        "MaxUpdateDist": {
          "comment": "if > 0, skip updating the scene capture if the Owner is further than this many units away from the viewer"
        },
        "MaxViewDistanceOverride": {
          "comment": "if > 0, sets a maximum render distance override. Can be used to cull distant objects from a reflection if"
        },
        "PostProcess": {
          "comment": "Chain of post process effects for this post process view"
        },
        "SceneLOD": {
          "comment": "NOT IMPLEMENTED! level-of-detail setting"
        },
        "ViewMode": {
          "comment": "how to draw the scene"
        }
      },
      "functions": {
        "SetEnabled": {
          "comment": "Enable or disable this SceneCaptureComponent."
        },
        "SetFrameRate": {
          "comment": "modifies the value of FrameRate"
        }
      }
    },
    "SceneCaptureCubeMapActor": {
      "properties": {
        "CubeMaterialInst": {
          "comment": "material instance used to apply the target texture to the static mesh"
        },
        "StaticMesh": {
          "comment": "for visualizing the cube capture"
        }
      }
    },
    "SceneCaptureCubeMapComponent": {
      "properties": {
        "WorldLocation": {
          "comment": "world location based on parent transform"
        },
        "FarPlane": {
          "comment": "far plane clip distance"
        },
        "NearPlane": {
          "comment": "near plane clip distance"
        },
        "TextureTarget": {
          "comment": "texture targets for the six cubemap faces"
        }
      }
    },
    "SceneCapturePortalComponent": {
      "properties": {
        "ScaleFOV": {
          "comment": "scale field of view so that there can be some overdraw"
        },
        "TextureTarget": {
          "comment": "render target resource to set as target for capture"
        },
        "ViewDestination": {
          "comment": "actor at the target view location for this portal"
        }
      },
      "functions": {
        "SetCaptureParameters": {
          "comment": "interface for changing TextureTarget, ScaleFOV, and ViewDestination"
        }
      }
    },
    "SceneCaptureReflectActor": {
      "properties": {
        "ReflectMaterialInst": {
          "comment": "material instance used to apply the target texture to the static mesh"
        },
        "StaticMesh": {
          "comment": "draws the face using a static mesh"
        }
      }
    },
    "SceneCaptureReflectComponent": {
      "properties": {
        "ScaleFOV": {
          "comment": "scale field of view so that there can be some overdraw"
        },
        "TextureTarget": {
          "comment": "render target resource to set as target for capture"
        }
      }
    },
    "Scout": {
      "properties": {
        "DefaultReachSpecClass": {
          "comment": "Specifies the default class to use when constructing reachspecs connecting NavigationPoints"
        },
        "bHightlightOneWayReachSpecs": {
          "comment": "when this is TRUE a dashed-red line will be drawn across the gap of a one-way edge to highlight those situations"
        }
      },
      "structs": {
        "PathSizeInfo": {
          "comment": "Builds the per-level nav lists and then assembles the world list."
        }
      }
    },
    "ScriptedTexture": {
      "properties": {
        "bNeedsUpdate": {
          "comment": "whether the texture needs to be redrawn. Render() will be called at the end of the tick, just before all other rendering."
        },
        "bSkipNextClear": {
          "comment": "whether or not to clear the texture before the next call of the Render delegate"
        }
      }
    },
    "SeqAct_AccessObjectList": {
      "properties": {
        "OutputObject": {
          "comment": "SeqAct_AccessObjectList determines which of its outputs should be\n set to active"
        }
      }
    },
    "SeqAct_ActivateRemoteEvent": {
      "properties": {
        "bStatusIsOk": {
          "comment": "For use in Kismet, to indicate if this variable is ok. Updated in UpdateStatus."
        },
        "EventName": {
          "comment": "Name of the event to activate"
        },
        "Instigator": {
          "comment": "Instigator to use in the event"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_ActorFactory": {
      "properties": {
        "bIsSpawning": {
          "comment": "Is this factory currently in the process of spawning?"
        },
        "LastSpawnIdx": {
          "comment": "Last index used to spawn at, for PS_Normal/PS_Reverse"
        },
        "RemainingDelay": {
          "comment": "Remaining time before attempting the next spawn"
        },
        "SpawnedCount": {
          "comment": "Number of actors spawned so far"
        },
        "bCheckSpawnCollision": {
          "comment": "Prevent spawning at locations with bBlockActors"
        },
        "bEnabled": {
          "comment": "Is this factory enabled?"
        },
        "Factory": {
          "comment": "Type of actor factory to use when creating the actor"
        },
        "PointSelection": {
          "comment": "Method of spawn point selection"
        },
        "SpawnCount": {
          "comment": "Number of actors to create"
        },
        "SpawnDelay": {
          "comment": "Delay applied after creating an actor before creating the next one"
        },
        "SpawnLocations": {
          "comment": "The position where Objects will be spawned, if SpawnPoints is empty"
        },
        "SpawnOrientations": {
          "comment": "The orientation of spawned Objects, if SpawnPoints is empty"
        },
        "SpawnPoints": {
          "comment": "Set of points where Objects will be spawned"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_AddRemoveFaceFXAnimSet": {
      "properties": {
        "FaceFXAnimSets": {
          "comment": "List of FaceFXAnimSets to add to Pawn Target"
        }
      }
    },
    "SeqAct_AIMoveToActor": {
      "properties": {
        "LastDestinationChoice": {
          "comment": "Last destination chosen by an AI"
        },
        "bInterruptable": {
          "comment": "Should this move be interruptable?"
        },
        "bPickClosest": {
          "comment": "Should the AI pick the closest destination?"
        },
        "Destination": {
          "comment": "List of destinations to pick from"
        },
        "MovementSpeedModifier": {
          "comment": "Controls the max speed of the AI while moving"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_AndGate": {
      "properties": {
        "bOpen": {
          "comment": "Is this gate currently open?"
        },
        "LinkedOutputFiredStatus": {
          "comment": "Mirrors the InputLinks array, hold data whether a specific input has fired."
        },
        "LinkedOutputs": {
          "comment": "Cached array of linked input ops for this gate, so we can track that they have all fired."
        }
      }
    },
    "SeqAct_AttachToActor": {
      "properties": {
        "bDetach": {
          "comment": "if true, then attachments will be detached."
        },
        "bHardAttach": {
          "comment": "Should hard attach to the actor"
        },
        "BoneName": {
          "comment": "Bone Name to use for attachment"
        },
        "bUseRelativeOffset": {
          "comment": "true if attachment should be set relatively to the target, using an offset"
        },
        "bUseRelativeRotation": {
          "comment": "Use relative rotation offset"
        },
        "RelativeOffset": {
          "comment": "offset to use when attaching"
        },
        "RelativeRotation": {
          "comment": "relative rotation"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_AttachToEvent": {
      "properties": {
        "bPreferController": {
          "comment": "prefer to attach events to Controllers instead of Pawns (for events you want to persist beyond the target dying and respawning)"
        }
      }
    },
    "SeqAct_CameraFade": {
      "properties": {
        "CachedPCs": {
          "comment": "List of PCs this action is applied to"
        },
        "FadeAlpha": {
          "comment": "Range of alpha to fade, FadeAlpha.X + ((1.f - FadeTimeRemaining/FadeTime) * (FadeAlpha.Y - FadeAlpha.X))"
        },
        "FadeTimeRemaining": {
          "comment": "Time left before reaching full alpha"
        },
        "bPersistFade": {
          "comment": "Should the fade persist?"
        },
        "FadeColor": {
          "comment": "Color to use as the fade"
        },
        "FadeOpacity<ClampMin=0.0|ClampMax=1.0>": {
          "comment": "The opacity that the camera will fade to"
        },
        "FadeTime<ClampMin=0.0>": {
          "comment": "How long to fade to FadeOpacity from the camera's current fade opacity"
        }
      }
    },
    "SeqAct_CameraLookAt": {
      "properties": {
        "bAdjustCamera": {
          "comment": "DEPRECATED. Functionally replaced by bTurnInPlace for clarity in version 4."
        },
        "bUsedTimer": {
          "comment": "Whether this event used a timer or not"
        },
        "bAffectCamera": {
          "comment": "Should this affect the camera?"
        },
        "bAffectHead": {
          "comment": "Should this turn the character's head?"
        },
        "bAlwaysFocus": {
          "comment": "If FALSE, focus only if point roughly in view; if TRUE, focus no matter where player is looking"
        },
        "bCheckLineOfSight": {
          "comment": "TRUE to validate visibility of lookat target before doing any camera changes"
        },
        "bDisableInput": {
          "comment": "Don't allow input"
        },
        "bIgnoreTrace": {
          "comment": "If TRUE, ignore world trace to find a good spot"
        },
        "bLeaveCameraRotation": {
          "comment": "Leave the camera focused on the actor?"
        },
        "bRotatePlayerWithCamera": {
          "comment": "Should this turn affect the player's rotation?"
        },
        "bToggleGodMode": {
          "comment": "Set this player in god mode? Only works if bAffectCamera == TRUE"
        },
        "bTurnInPlace": {
          "comment": "If TRUE, camera will rotate in place. If FALSE, camera can move as necessary."
        },
        "CameraFOV<ClampMin=1.0|ClampMax=179.0>": {
          "comment": "If >= 0, override camera fov to be this."
        },
        "FocusBoneName": {
          "comment": "Name of bone to focus on if available"
        },
        "InFocusFOV": {
          "comment": "How tight the focus should be"
        },
        "InterpSpeedRange": {
          "comment": "Speed range of interpolation to focus camera"
        },
        "TextDisplay": {
          "comment": "Text to display while camera is focused"
        },
        "TotalTime<ClampMin=0.0>": {
          "comment": "The total amount of time the camera lookat will happen"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_CameraShake": {
      "properties": {
        "bDoControllerVibration": {
          "comment": "Whether or not to do do controller vibration. Code shakes only for now."
        },
        "bOrientTowardRadialEpicenter<editcondition=bRadialShake>": {
          "comment": "If true, camera shake is rotated to be relative to the shake epicenter before application (e.g. a shake that moves -X will always move away from the shake's origin). Only valid for Radial shakes. Overrides PlaySpace."
        },
        "bRadialShake": {
          "comment": "A radial shake shakes the camera for all nearby players. If FALSE, shake only the cameras of specified players."
        },
        "PlaySpace": {
          "comment": "Defined how to orient the shaking offsets before applying to the camera. CameraLocal is normal. Is UserDefined, rotation of the LocationActor is used. Ignored for Radial Shakes"
        },
        "RadialShake_Falloff<ClampMin=0.0|editcondition=bRadialShake>": {
          "comment": "Falloff exponent, defines falloff between inner and outer radii. For CST_Radial shakes only."
        },
        "RadialShake_InnerRadius<ClampMin=0.0|editcondition=bRadialShake>": {
          "comment": "Radius inside which the shake is full magnitude. For radial shakes only."
        },
        "RadialShake_OuterRadius<ClampMin=0.0|editcondition=bRadialShake>": {
          "comment": "Radius at which the shake reaches 0 magnitude. For radial shakes only."
        },
        "Shake": {
          "comment": "Parameters that define the shake."
        },
        "ShakeScale": {
          "comment": "For easy overall scaling without tweaking the individual parameters. For oscillating shakes, scales amplitude only."
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_CastToInt": {
      "properties": {
        "bTruncate": {
          "comment": "If TRUE, the float value will be truncated into the integer rather than rounded into it."
        }
      }
    },
    "SeqAct_ChangeCollision": {
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_ConsoleCommand": {
      "properties": {
        "Command": {
          "comment": "deprecated. Use Commands array."
        },
        "Commands": {
          "comment": "Array of console commands to issue, in the order to execute them."
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_Delay": {
      "properties": {
        "bDelayActive": {
          "comment": "Is this delay currently active?"
        },
        "LastUpdateTime": {
          "comment": "Time at which this op was last updated, to prevent multiple updates per tick"
        },
        "RemainingTime": {
          "comment": "Remaining time left on the duration"
        },
        "bStartWillRestart": {
          "comment": "When set triggering start again with restart the time without triggering the finished output, otherwise default behavior of not changing the initial delay time"
        },
        "Duration<autocomment=true>": {
          "comment": "Default duration to use if no variables are linked"
        }
      }
    },
    "SeqAct_DrawText": {
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_FinishSequence": {
      "properties": {
        "OutputLabel": {
          "comment": "Text label to use on the sequence output link"
        }
      }
    },
    "SeqAct_ForceFeedback": {
      "properties": {
        "PredefinedWaveForm<AllowAbstract>": {
          "comment": "A predefined WaveForm, only works with start, stopping a predefined doesn't do anything, can't use for looping"
        }
      }
    },
    "SeqAct_Gate": {
      "properties": {
        "CurrentCloseCount": {
          "comment": "Current threshold for closing the gate (increments to keep pace with ActivateCount)"
        },
        "AutoCloseCount": {
          "comment": "Auto close after this many activations"
        },
        "bOpen<autocomment=true>": {
          "comment": "Is this gate currently open?"
        }
      }
    },
    "SeqAct_GetLocationAndRotation": {
      "properties": {
        "Location": {
          "comment": "The location of the actor"
        },
        "Rotation": {
          "comment": "A vector that holds floating point versions of the FRotator rotation"
        },
        "RotationVector": {
          "comment": "A normalized vector in the direction of the actor's rotation"
        },
        "SocketOrBoneName": {
          "comment": "OPTIONAL: Name of a socket or bone to get the world-space location and rotation of (if this actor contains a skeletal mesh)\n If left empty or there is no skeletal mesh, this action will still get the actor location and rotation"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_GetProperty": {
      "properties": {
        "PropertyName": {
          "comment": "Name of property to search for"
        }
      }
    },
    "SeqAct_GetVelocity": {
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_HeadTrackingControl": {
      "properties": {
        "ActorToComponentMap": {
          "comment": "Array of actor information"
        },
        "bDisableBeyondLimit": {
          "comment": "Interp back to zero strength if limit surpassed"
        },
        "LookAtActorRadius": {
          "comment": "Will pick up actor within this radius"
        },
        "LookAtTargets": {
          "comment": "List of objects to call the handler function on"
        },
        "MaxInterestTime": {
          "comment": "Once entered the radius, how long do I really care to look ? This affects rating. It will give benefit to the person who just entered"
        },
        "MaxLookAtTime": {
          "comment": "How long can one person to look at one"
        },
        "MinLookAtTime": {
          "comment": "At least this time to look at one"
        },
        "TrackControllerName": {
          "comment": "SkelControlLookAt name in the AnimTree of the SkeletalMesh"
        },
        "ActorClassesToLookAt": {
          "comment": "Actor classes to look at as 0 index being the highest priority if you have anything specific"
        },
        "bLookAtPawns": {
          "comment": "Quick check box for allowing it to look Pawn - due to Pawn not being listed in the Actor class"
        },
        "TargetBoneNames": {
          "comment": "Target Bone Names, where to look at - priority from top to bottom, if not found, it will continue search"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_Interp": {
      "properties": {
        "bIsBeingEdited": {
          "comment": "Indicates whether this SeqAct_Interp is currently open in the Matinee tool."
        },
        "bIsPlaying": {
          "comment": "If sequence is currently playing."
        },
        "bPaused": {
          "comment": "Sequence is initialised, but ticking will not increment its current position."
        },
        "bReversePlayback": {
          "comment": "If sequence playback should be reversed."
        },
        "bShouldShowGore": {
          "comment": "Cached value that indicates whether or not gore was enabled when the sequence was started"
        },
        "CameraCuts": {
          "comment": "Contains the camera world-position for each camera cut in the cinematic."
        },
        "GroupInst": {
          "comment": "Instance data for interp groups. One for each variable/group combination."
        },
        "InterpData": {
          "comment": "Actual track data. Can be shared between SeqAct_Interps."
        },
        "Position": {
          "comment": "Time position in sequence - starts at 0.0"
        },
        "ReplicatedActorClass": {
          "comment": "on a net server, actor spawned to handle replicating relevant data to the client"
        },
        "SavedActorTransforms": {
          "comment": "A map from actors to their pre-Matinee world-space positions/orientations. Includes actors attached to Matinee-affected actors."
        },
        "SavedActorVisibilities": {
          "comment": "A map from actors to their pre-Matinee visibility state"
        },
        "TerminationTime": {
          "comment": "last time TermInterp() was called on this action. Only updated in game"
        },
        "bClientSideOnly": {
          "comment": "Indicates that this interpolation does not affect gameplay. This means that:\n -it is not replicated via MatineeActor\n -it is not ticked if no affected Actors are visible\n -on dedicated servers, it is completely ignored"
        },
        "bDisableRadioFilter": {
          "comment": "If true, disables the realtime radio effect"
        },
        "bForceStartPos": {
          "comment": "Lets you force the sequence to always start at ForceStartPosition"
        },
        "bInterpForPathBuilding": {
          "comment": "Whether this action should be initialised and moved to the 'path building time' when building paths."
        },
        "bIsSkippable": {
          "comment": "Lets you skip the matinee with the CANCELMATINEE exec command. Triggers all events to the end along the way."
        },
        "bLooping": {
          "comment": "If sequence should pop back to beginning when finished.\n Note, if true, will never get Completed/Reversed events - sequence must be explicitly Stopped."
        },
        "bNoResetOnRewind": {
          "comment": "If true, when rewinding this interpolation, reset the 'initial positions' of any RelateToInitial movements to the current location.\n This allows the next loop of movement to proceed from the current locations."
        },
        "bRewindIfAlreadyPlaying": {
          "comment": "Only used if bRewindOnPlay if true. Defines what should happen if the Play input is activated while currently playing.\n If true, hitting Play while currently playing will pop the position back to the start and begin playback over again.\n If false, hitting Play while currently playing will do nothing."
        },
        "bRewindOnPlay": {
          "comment": "If true, sequence will rewind itself back to the start each time the Play input is activated."
        },
        "bSkipUpdateIfNotVisible": {
          "comment": "if bClientSideOnly is true, whether this matinee should be completely skipped if none of the affected Actors are visible"
        },
        "ForceStartPosition": {
          "comment": "Time position to always start at if bForceStartPos is set to TRUE."
        },
        "LinkedCover": {
          "comment": "Cover linked to this matinee that should be updated once path building time has been played"
        },
        "PlayRate": {
          "comment": "Time multiplier for playback."
        },
        "PreferredSplitScreenNum": {
          "comment": "Preferred local viewport number (when split screen is active) the director track should associate with, or zero for 'all'."
        },
        "RenderingOverrides": {
          "comment": "Rendering overrides of this matinee, which will be used if the matinee has a director track.\n Cinematics add a bunch of rendering cost with their lighting and shadowing, so we need to disable some features to make room for that."
        }
      },
      "functions": {
        "AddPlayerToDirectorTracks": {
          "comment": "adds the passed in PlayerController to all running Director tracks so that its camera is controlled\n all PCs that are available at playback start time are hooked up automatically, but this needs to be called to hook up\n any that are created during playback (player joining a network game during a cinematic, for example)",
          "params": {
            "PC": "the PlayerController to add"
          }
        },
        "SetPosition": {
          "comment": "sets the position of the interpolation\n \n@note if the interpolation is not currently active, this function doesn't send any Kismet or UnrealScript events",
          "params": {
            "NewPosition": "the new position to set the interpolation to",
            "bJump": "if true, teleport to the new position (don't trigger any events between the old and new positions, etc)"
          }
        },
        "Stop": {
          "comment": "stops playback at current position"
        }
      },
      "structs": {
        "CameraCutInfo": {
          "comment": "Helper struct for storing the camera world-position for each camera cut in the cinematic."
        },
        "SavedTransform": {
          "comment": "Helper type for storing actors' World-space locations/rotations."
        }
      }
    },
    "SeqAct_IsInObjectList": {
      "properties": {
        "bCheckForAllObjects": {
          "comment": "Determines whether or not we check for ALL or ANY objects referenced via Object(s)ToTest"
        }
      }
    },
    "SeqAct_Latent": {
      "properties": {
        "bAborted": {
          "comment": "Indicates whether or not this latent action has been aborted"
        },
        "LatentActors": {
          "comment": "List of all actors currently performing this op"
        }
      },
      "functions": {
        "AbortFor": {
          "comment": "Allows an actor to abort this current latent action, forcing\n the Aborted output link to be activated instead of the default\n one on normal completion.",
          "params": {
            "latentActor": "actor aborting the latent action"
          }
        },
        "Update": {
          "comment": "script tick interface\n the action deactivates when this function returns false and LatentActors is empty"
        }
      }
    },
    "SeqAct_LevelStreaming": {
      "properties": {
        "Level": {
          "comment": "LevelStreaming object that is going to be loaded/ unloaded on request"
        },
        "LevelName<autocomment=true>": {
          "comment": "LevelStreaming object name"
        }
      }
    },
    "SeqAct_LevelStreamingBase": {
      "properties": {
        "bMakeVisibleAfterLoad": {
          "comment": "Whether to make the level immediately visible after it finishes loading"
        },
        "bShouldBlockOnLoad": {
          "comment": "Whether we want to force a blocking load"
        }
      }
    },
    "SeqAct_LevelVisibility": {
      "properties": {
        "Level": {
          "comment": "LevelStreaming object that is going to be associated/ dissociated on request"
        },
        "LevelName<autocomment=true>": {
          "comment": "LevelStreaming object name"
        }
      }
    },
    "SeqAct_Log": {
      "properties": {
        "LogMessage": {
          "comment": "Cached log message to display"
        },
        "bIncludeObjComment": {
          "comment": "Should ObjComment be included in the log?"
        },
        "bOutputToScreen": {
          "comment": "Should this message be drawn on the screen as well as placed in the log?"
        },
        "TargetDuration": {
          "comment": "Time to leave text floating above Target actor"
        },
        "TargetOffset": {
          "comment": "Offset to apply to the Target actor location when positioning debug text"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_MITV_Activate": {
      "properties": {
        "DurationOfMITV": {
          "comment": "This is how long this MITV should last"
        }
      },
      "functions": {
        "Activated": {
          "comment": "Called when this event is activated."
        }
      }
    },
    "SeqAct_ModifyCover": {
      "properties": {
        "bManualAdjustPlayersOnly": {
          "comment": "New bPlayersOnly setting"
        },
        "ManualCoverType": {
          "comment": "New cover type to set for \"Manual Adjust\""
        },
        "Slots": {
          "comment": "List of slots to modify"
        }
      }
    },
    "SeqAct_ModifyHealth": {
      "properties": {
        "Instigator": {
          "comment": "Player that should take credit for the health change (Controller or Pawn)"
        },
        "Amount<autocomment=true>": {
          "comment": "Change in health"
        },
        "bFalloff": {
          "comment": "Whether amount should decay linearly based on distance from the target."
        },
        "bHeal": {
          "comment": "If true, Amount will be healed"
        },
        "bRadial": {
          "comment": "If true, health change will be radial"
        },
        "DamageType": {
          "comment": "Type of damage to apply"
        },
        "Momentum": {
          "comment": "Amount of momentum to apply"
        },
        "Radius": {
          "comment": "Distance to Instigator within which to damage actors"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_ModifyObjectList": {
      "comment": "@todo - this should be a conditional",
      "properties": {
        "ListEntriesCount": {
          "comment": "SeqAct_ModifyObjectList determines which of its outputs should be\n set to active"
        }
      }
    },
    "SeqAct_MultiLevelStreaming": {
      "properties": {
        "bUnloadAllOtherLevels": {
          "comment": "Should any levels not contained in Levels be unloaded?"
        },
        "Levels": {
          "comment": "Array of levels to load/ unload"
        }
      },
      "structs": {
        "LevelStreamingNameCombo": {
          "properties": {
            "Level": {
              "comment": "Cached LevelStreaming object that is going to be loaded/ unloaded on request."
            },
            "LevelName": {
              "comment": "LevelStreaming object name."
            }
          }
        }
      }
    },
    "SeqAct_ParticleEventGenerator": {
      "properties": {
        "EventDirection": {
          "comment": "The direction of the event."
        },
        "EventLocation": {
          "comment": "The location of the event."
        },
        "EventNames": {
          "comment": "Name of the event to generate."
        },
        "EventNormal": {
          "comment": "The (hit) normal of the event."
        },
        "EventTime": {
          "comment": "The 'time' the event occured."
        },
        "EventVelocity": {
          "comment": "The velocity of the event."
        },
        "Instigator": {
          "comment": "Player that trigger the event (Controller or Pawn)"
        },
        "bEnabled": {
          "comment": "Is this event generator enabled?"
        },
        "bUseEmitterLocation": {
          "comment": "If TRUE, use the Emitter target position as the Location."
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_PlayCameraAnim": {
      "properties": {
        "BlendInTime<ClampMin=0.0>": {
          "comment": "Time to interpolate in from zero, for smooth starts."
        },
        "BlendOutTime<ClampMin=0.0>": {
          "comment": "Time to interpolate out to zero, for smooth finishes."
        },
        "bLoop": {
          "comment": "True to loop the animation, false otherwise."
        },
        "bRandomStartTime": {
          "comment": "True to start the animation at a random time (good for things like looping shakes)"
        },
        "CameraAnim": {
          "comment": "Reference to CameraAnim to play."
        },
        "IntensityScale": {
          "comment": "Scalar for intensity. 1.0 is normal."
        },
        "PlaySpace": {
          "comment": "Space in which to play the camera anim"
        },
        "Rate<ClampMin=0.001>": {
          "comment": "Rate to play. 1.0 is normal."
        },
        "UserDefinedSpaceActor": {
          "comment": "Actor to use to specify the space for CAPS_UserDefined"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_PlayFaceFXAnim": {
      "properties": {
        "FaceFXAnimName": {
          "comment": "Name of FaceFX animation within the specified group to play. Case sensitive."
        },
        "FaceFXAnimSetRef": {
          "comment": "Reference to FaceFX AnimSet package the animation is in"
        },
        "FaceFXGroupName": {
          "comment": "Name of group within the FaceFXAsset to find the animation in. Case sensitive."
        },
        "SoundCueToPlay": {
          "comment": "The SoundCue to play with this FaceFX."
        }
      }
    },
    "SeqAct_PlaySound": {
      "properties": {
        "bStopped": {
          "comment": "Was this sound stopped?"
        },
        "SoundDuration": {
          "comment": "Remaining duration of sound, for timing activation of 'Finished' output"
        },
        "bSuppressSubtitles": {
          "comment": "TRUE to suppress display of any subtitles the soundcue may have. FALSE for normal subtitle behavior."
        },
        "ExtraDelay": {
          "comment": "Additional dead space to append to SoundDuration"
        },
        "FadeInTime": {
          "comment": "Time taken for sound to fade in when action is activated."
        },
        "FadeOutTime": {
          "comment": "Time take for sound to fade out when Stop input is fired."
        },
        "PitchMultiplier": {
          "comment": "Pitch multiplier propagated to audio component"
        },
        "PlaySound": {
          "comment": "Sound cue to play on the targeted actor(s)"
        },
        "VolumeMultiplier": {
          "comment": "Volume multiplier propagated to audio component"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_Possess": {
      "properties": {
        "bKillOldPawn": {
          "comment": "true if should kill old pawn"
        },
        "bTryToLeaveVehicle": {
          "comment": "Try to leave vehicle if manning one"
        }
      }
    },
    "SeqAct_PrepareMapChange": {
      "properties": {
        "bIsHighPriority": {
          "comment": "If this is TRUE, then a much larger time slice will be given to the loading code (useful for loading during a movie, etc)"
        },
        "InitiallyLoadedSecondaryLevelNames": {
          "comment": "Additional secondary levels that should be pre-loaded before the switcheroo."
        },
        "MainLevelName": {
          "comment": "The main level that should be transitioned to."
        }
      }
    },
    "SeqAct_ProjectileFactory": {
      "properties": {
        "BoneName": {
          "comment": "The name of the bone to spawn the muzzle flash at.\n If SocketName is set, it takes precedence over this."
        },
        "PSTemplate": {
          "comment": "The particle system to spawn as the muzzle flash."
        },
        "SocketName": {
          "comment": "The name of the socket to spawn the muzzle flash at.\n If set, takes precedence over the bone name."
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_RandomSwitch": {
      "properties": {
        "AutoDisabledIndices": {
          "comment": "List of indices we've already used once and disabled (for when bLooping and bAutoDisableLinks are both checked)"
        }
      }
    },
    "SeqAct_RangeSwitch": {
      "comment": "@todo - this should be a conditional"
    },
    "SeqAct_SetCameraTarget": {
      "properties": {
        "CameraTarget": {
          "comment": "Internal. Holds a ref to the new desired camera target."
        },
        "TransitionParams": {
          "comment": "Parameters that define how the camera will transition to the new target."
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_SetDOFParams": {
      "properties": {
        "InterpolateElapsed": {
          "comment": "Elapsed interpolation time"
        },
        "MaxFarBlurAmount": {
          "comment": "[0,1] value for clamping how much blur to apply to items behind the focus plane"
        },
        "MaxNearBlurAmount": {
          "comment": "[0,1] value for clamping how much blur to apply to items in front of the focus plane"
        },
        "MinBlurAmount": {
          "comment": "[0,1] value for clamping how much blur to apply"
        },
        "BlurKernelSize": {
          "comment": "affects the radius of the DepthOfField bohek / how blurry the scene gets"
        },
        "FalloffExponent": {
          "comment": "exponent to apply to blur amount after it has been normalized to [0,1]"
        },
        "FocusDistance": {
          "comment": "used when FOCUS_Distance is enabled"
        },
        "FocusInnerRadius": {
          "comment": "inner focus radius"
        },
        "FocusPosition": {
          "comment": "used when FOCUS_Position is enabled"
        },
        "InterpolateSeconds": {
          "comment": "Time to interpolate values over"
        }
      }
    },
    "SeqAct_SetFloat": {
      "properties": {
        "Target": {
          "comment": "Target property use to write to"
        },
        "Value<autocomment=true>": {
          "comment": "Value to apply"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_SetInt": {
      "properties": {
        "Target": {
          "comment": "Target property use to write to"
        },
        "Value<autocomment=true>": {
          "comment": "Value to apply"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_SetLocation": {
      "properties": {
        "Target": {
          "comment": "Object that will be moved"
        },
        "bSetLocation": {
          "comment": "Default value to use if no variables are linked"
        },
        "RotationValue": {
          "comment": "Default value to use if no variables are linked"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_SetMaterial": {
      "properties": {
        "MaterialIndex": {
          "comment": "Index in the Materials array to replace with NewMaterial when this action is activated."
        },
        "NewMaterial": {
          "comment": "Material to apply to target when action is activated."
        }
      }
    },
    "SeqAct_SetMatInstVectorParam": {
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_SetMesh": {
      "properties": {
        "bAllowDecalsToReattach": {
          "comment": "if True then any decals attached to the previous mesh will be reattached to the new mesh"
        },
        "bIsAllowedToMove": {
          "comment": "if True then the mesh will be treated as if it is movable"
        },
        "MeshType": {
          "comment": "Type of mesh to set"
        },
        "NewSkeletalMesh": {
          "comment": "New SkeletalMesh to use for the target actor"
        },
        "NewStaticMesh": {
          "comment": "New StaticMesh to use for the target actor"
        }
      }
    },
    "SeqAct_SetMotionBlurParams": {
      "properties": {
        "InterpolateElapsed": {
          "comment": "Elapsed interpolation time"
        },
        "InterpolateSeconds": {
          "comment": "Time to interpolate values over"
        },
        "MotionBlurAmount": {
          "comment": "This is a scalar on the blur"
        }
      }
    },
    "SeqAct_SetObject": {
      "properties": {
        "DefaultValue": {
          "comment": "Default value to use if no variables are linked"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_SetParticleSysParam": {
      "properties": {
        "bOverrideScalar": {
          "comment": "Should ScalarValue override any entries to InstanceParameters?"
        },
        "ScalarValue": {
          "comment": "Override scalar value"
        }
      }
    },
    "SeqAct_SetPhysics": {
      "properties": {
        "NewPhysics<autocomment=true>": {
          "comment": "Physics mode to change the Actor to."
        }
      }
    },
    "SeqAct_SetSkelControlTarget": {
      "properties": {
        "SkelControlName": {
          "comment": "Name of SkelControl to set target of"
        },
        "TargetActors": {
          "comment": "List of objects to call the handler function on"
        }
      }
    },
    "SeqAct_SetSoundMode": {
      "properties": {
        "bTopPriority": {
          "comment": "Whether this soundmode is the highest priority, game specific and ignored by PlayerController"
        },
        "SoundMode": {
          "comment": "SoundMode to use, or None for default."
        }
      },
      "functions": {
        "Activated": {
          "comment": "Call handler manually so we can assume PC without requiring one to be attached"
        },
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_SetString": {
      "properties": {
        "Target": {
          "comment": "Target property use to write to"
        },
        "Value<autocomment=true>": {
          "comment": "Value to apply"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_SetVector": {
      "properties": {
        "DefaultValue": {
          "comment": "Default value to use if no variables are linked"
        }
      }
    },
    "SeqAct_SetVelocity": {
      "properties": {
        "bVelocityRelativeToActorRotation": {
          "comment": "If TRUE given velocity is relative to actor rotation. Otherwise, velocity is in world space."
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_StreamInTextures": {
      "properties": {
        "bLocationBased": {
          "comment": "Whether we should stream in textures based on location or usage. If TRUE, textures surrounding the attached actors will start to stream in. If FALSE, textures used by the attached actors will start to stream in."
        },
        "bStreamingActive": {
          "comment": "Is this streaming currently active?"
        },
        "SelectedCinematicTextureGroups": {
          "comment": "Internal bitfield representing the selection in CinematicTextureGropus."
        },
        "StopTimestamp": {
          "comment": "Timestamp for when we should stop the forced texture streaming."
        },
        "CinematicTextureGroups": {
          "comment": "Texture groups that will use extra (higher resolution) mip-levels."
        },
        "ForceMaterials": {
          "comment": "Array of Materials to set bForceMiplevelsToBeResident on their textures for the duration of this action."
        },
        "LocationActors": {
          "comment": "Textures surrounding the LocationActors will begin to stream in"
        },
        "Seconds": {
          "comment": "Number of seconds to force the streaming system to stream in all of the target's textures or enforce bForceMiplevelsToBeResident"
        }
      }
    },
    "SeqAct_Switch": {
      "properties": {
        "bAutoDisableLinks": {
          "comment": "Automatically disable an output once its activated?"
        },
        "bLooping": {
          "comment": "Loop index back to beginning to cycle"
        },
        "IncrementAmount": {
          "comment": "Number to increment attached variables upon activation"
        },
        "Indices": {
          "comment": "List of links to activate"
        },
        "LinkCount": {
          "comment": "Total number of links to expose"
        }
      }
    },
    "SeqAct_Teleport": {
      "properties": {
        "bCheckOverlap": {
          "comment": "If TRUE, check to see if this actor overlaps any other colliding actors and don't teleport there if a better option exists"
        },
        "bUpdateRotation": {
          "comment": "If true, actor rotation will be aligned with destination actor"
        },
        "TeleportDistance": {
          "comment": "If actor is more than this far away, it will be teleported. Ignored if < 0"
        },
        "TeleportVolumes": {
          "comment": "If actor is NOT in one of these volumes, it will be teleported"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_Timer": {
      "properties": {
        "ActivationTime": {
          "comment": "World time at point of activation"
        },
        "Time": {
          "comment": "Amount of time this timer has been active"
        }
      }
    },
    "SeqAct_ToggleCinematicMode": {
      "properties": {
        "bDeadBodies": {
          "comment": "Destroy dead GearPawns"
        },
        "bDisableInput": {
          "comment": "Don't allow input"
        },
        "bDroppedPickups": {
          "comment": "Destroy dropped weapons and pickups"
        },
        "bHideHUD": {
          "comment": "Whether to hide the HUD during cinematics or not"
        }
      },
      "functions": {
        "Activated": {
          "comment": "Delete objects we don't want to keep around during cinematics"
        }
      }
    },
    "SeqAct_ToggleConstraintDrive": {
      "properties": {
        "bEnableAngularPositionDrive": {
          "comment": "If TRUE, when the Enable Drive input is fired, will enable angular position drive on the attached constraint actor"
        },
        "bEnableAngularVelocityDrive": {
          "comment": "If TRUE, when the Enable Drive input is fired, will enable angular velocity drive on the attached constraint actor"
        },
        "bEnableLinearPositionDrive": {
          "comment": "If TRUE, when the Enable Drive input is fired, will enable linear position drive on the attached constraint actor"
        },
        "bEnableLinearvelocityDrive": {
          "comment": "If TRUE, when the Enable Drive input is fired, will enable linear velocity drive on the attached constraint actor"
        }
      }
    },
    "SeqAct_ToggleHUD": {
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_Trace": {
      "properties": {
        "bTraceActors": {
          "comment": "Should actors be traced against?"
        },
        "bTraceWorld": {
          "comment": "Should the world be traced against?"
        },
        "TraceExtent": {
          "comment": "What extent should be used for the trace?"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_WaitForLevelsVisible": {
      "properties": {
        "bShouldBlockOnLoad": {
          "comment": "If TRUE engine will request blocking load if level is in process of being loaded."
        },
        "LevelNames": {
          "comment": "Names of levels to wait for visibility."
        }
      }
    },
    "SeqCond_CompareBool": {
      "properties": {
        "bResult": {
          "comment": "Result of comparison is written to this variable"
        }
      }
    },
    "SeqCond_IncrementFloat": {
      "properties": {
        "ValueA": {
          "comment": "Default value to use if no variables are linked to A"
        },
        "ValueB": {
          "comment": "Default value to use if no variables are linked to B"
        }
      }
    },
    "SeqCond_IsBenchmarking": {
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqCond_IsLoggedIn": {
      "comment": "Used to determine how many players are currently logged in",
      "properties": {
        "NumNeededLoggedIn": {
          "comment": "The number of users that need to be logged in for it to activate as true"
        }
      },
      "functions": {
        "CheckLogins": {
          "comment": "Checks with the OnlineSubsystem to determine if there are enough people logged in"
        }
      }
    },
    "SeqCond_IsPIE": {
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqCond_SwitchBase": {
      "functions": {
        "InsertValueEntry": {
          "comment": "Insert an empty element into this switch's value array at the specified index."
        },
        "IsFallThruEnabled": {
          "comment": "Returns whether fall through is enabled for the specified case value."
        },
        "RemoveValueEntry": {
          "comment": "Remove an element from this switch's value array at the specified index."
        },
        "VerifyDefaultCaseValue": {
          "comment": "Ensures that the last item in the value array represents the \"default\" item. Child classes should override this method to ensure that\n their value array stays synchronized with the OutputLinks array."
        }
      }
    },
    "SeqCond_SwitchClass": {
      "functions": {
        "InsertValueEntry": {
          "comment": "Insert an empty element into this switch's value array at the specified index."
        },
        "IsFallThruEnabled": {
          "comment": "Returns whether fall through is enabled for the specified case value."
        },
        "RemoveValueEntry": {
          "comment": "Remove an element from this switch's value array at the specified index."
        },
        "VerifyDefaultCaseValue": {
          "comment": "Ensures that the last item in the value array represents the \"default\" item. Child classes should override this method to ensure that\n their value array stays synchronized with the OutputLinks array."
        }
      },
      "structs": {
        "SwitchClassInfo": {
          "comment": "Stores class name to compare for each output link and whether it should fall through to next node"
        }
      }
    },
    "SeqCond_SwitchObject": {
      "properties": {
        "SupportedValues": {
          "comment": "Stores the list of values which are handled by this switch object."
        }
      },
      "functions": {
        "InsertValueEntry": {
          "comment": "Insert an empty element into this switch's value array at the specified index."
        },
        "IsFallThruEnabled": {
          "comment": "Returns whether fall through is enabled for the specified case value."
        },
        "RemoveValueEntry": {
          "comment": "Remove an element from this switch's value array at the specified index."
        },
        "VerifyDefaultCaseValue": {
          "comment": "Ensures that the last item in the value array represents the \"default\" item. Child classes should override this method to ensure that\n their value array stays synchronized with the OutputLinks array."
        }
      },
      "structs": {
        "SwitchObjectCase": {
          "comment": "Stores class name to compare for each output link and whether it should fall through to next node",
          "properties": {
            "bDefaultValue": {
              "comment": "true if this represents the default value option"
            },
            "bFallThru": {
              "comment": "indicates whether control should fall through to the next case upon a match"
            },
            "ObjectValue": {
              "comment": "the value of this case statement"
            }
          }
        }
      }
    },
    "SeqEvent_AISeeEnemy": {
      "properties": {
        "MaxSightDistance": {
          "comment": "Max distance before allowing activation"
        }
      }
    },
    "SeqEvent_Console": {
      "properties": {
        "ConsoleEventName<autocomment=true>": {
          "comment": "Name to match when entered from the console"
        },
        "EventDesc": {
          "comment": "Description to display when listing summary of all console events"
        }
      }
    },
    "SeqEvent_LevelLoaded": {
      "comment": "This event will be fired when a level is loaded and made visible. It is primarily \n used for notifying when a sublevel is associated with the world."
    },
    "SeqEvent_LOS": {
      "properties": {
        "bCheckForObstructions": {
          "comment": "Force a clear line of sight to the trigger?"
        },
        "ScreenCenterDistance": {
          "comment": "Distance from the screen center before activating this event"
        },
        "TriggerDistance": {
          "comment": "Distance from the trigger before activating this event"
        }
      }
    },
    "SeqEvent_Mover": {
      "properties": {
        "StayOpenTime": {
          "comment": "how long the mover should stay open before automatically closing (reverse playback)\n values <= 0.0 turn off this auto behavior and allow manual control (via the \"Completed\" and \"Reversed\" output links for the attached matinee action)"
        }
      },
      "functions": {
        "NotifyAttached": {
          "comment": "notification that an Actor has attached itself to the mover"
        },
        "NotifyDetached": {
          "comment": "notification that an Actor has been detached from the mover"
        },
        "NotifyEncroachingOn": {
          "comment": "notification that our linked Mover has encroached on the given Actor"
        },
        "NotifyFinishedOpen": {
          "comment": "notification that the mover has completed all opening actions and is now ready to close"
        }
      }
    },
    "SeqEvent_ParticleEvent": {
      "properties": {
        "EventEmitterTime": {
          "comment": "The emitter time of the event."
        },
        "EventNormal": {
          "comment": "The collision normal of the event."
        },
        "EventParticleTime": {
          "comment": "The particle time of the event."
        },
        "EventPosition": {
          "comment": "The particle position of the event."
        },
        "EventType": {
          "comment": "The type of event."
        },
        "EventVelocity": {
          "comment": "The particle velocity of the event."
        },
        "UseRelfectedImpactVector": {
          "comment": "If TRUE, use the impact direction reflected about the hit normal as the normal."
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqEvent_PickupStatusChange": {
      "comment": "event that is triggered when a PickupFactory's status changes"
    },
    "SeqEvent_RemoteEvent": {
      "properties": {
        "bStatusIsOk": {
          "comment": "For use in Kismet, to indicate if this variable is ok. Updated in UpdateStatus."
        },
        "EventName": {
          "comment": "Name of this event for remote activation"
        }
      }
    },
    "SeqEvent_RigidBodyCollision": {
      "properties": {
        "MinCollisionVelocity": {
          "comment": "Minimum impact speed (along contact normal) for this event to fire."
        }
      }
    },
    "SeqEvent_SequenceActivated": {
      "properties": {
        "InputLabel": {
          "comment": "Text label to use on the sequence input link"
        }
      }
    },
    "SeqEvent_TakeDamage": {
      "properties": {
        "CurrentDamage": {
          "comment": "Current damage amount"
        },
        "bResetDamageOnToggle": {
          "comment": "Should the damage counter be reset if this event is toggled?"
        },
        "DamageThreshold": {
          "comment": "Total amount of damage to take before activating the event"
        },
        "DamageTypes<AllowAbstract>": {
          "comment": "Types of damage that are counted"
        },
        "IgnoreDamageTypes<AllowAbstract>": {
          "comment": "Types of damage that are ignored"
        },
        "MinDamageAmount<autocomment=true>": {
          "comment": "Damage must exceed this value to be counted"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        },
        "HandleDamage": {
          "comment": "Applies the damage and checks for activation of the event."
        },
        "IsValidDamageType": {
          "comment": "Searches DamageTypes[] for the specified damage type.\n Default case is to return true for no damage types listed. This makes workflow a lot faster as you do not need to\n add a damage type each time you use this event."
        }
      }
    },
    "SeqEvent_Touch": {
      "properties": {
        "TouchedList": {
          "comment": "List of all actors that have activated this touch event, so that untouch may be properly fired."
        },
        "bAllowDeadPawns": {
          "comment": "whether dead (Health < 0) pawns can be considered touching"
        },
        "bForceOverlapping": {
          "comment": "Force the player to be overlapping at the time of activation?"
        },
        "bUseInstigator": {
          "comment": "Use Instigator, not actual Actor.\n For projectiles, it returns the instigator."
        },
        "ClassProximityTypes<AllowAbstract>": {
          "comment": "List of class types that are considered valid for this event"
        },
        "IgnoredClassProximityTypes<AllowAbstract>": {
          "comment": "List of class types that are considered valid for this event"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        },
        "NotifyTouchingPawnDied": {
          "comment": "notification that the given Pawn has died while touching an Actor with this event connected to it",
          "params": {
            "P": "the pawn that died"
          }
        }
      }
    },
    "SeqEvent_Used": {
      "properties": {
        "bAimToInteract": {
          "comment": "if true, requires player to aim at trigger to be able to interact with it. False, simple radius check will be performed"
        },
        "InteractDistance": {
          "comment": "Max distance from instigator to allow interactions."
        },
        "InteractIcon": {
          "comment": "Icon to display when looking at this event"
        },
        "InteractText": {
          "comment": "Text to display when looking at this event"
        },
        "ClassProximityTypes<AllowAbstract>": {
          "comment": "List of class types that are considered valid for this event"
        },
        "IgnoredClassProximityTypes<AllowAbstract>": {
          "comment": "List of class types that are considered valid for this event"
        }
      }
    },
    "Sequence": {
      "properties": {
        "ActiveSequenceOps": {
          "comment": "List of all currently active sequence objects (events, latent actions, etc)"
        },
        "DefaultViewX": {
          "comment": "Default position of origin when opening this sequence in Kismet."
        },
        "DelayedActivatedOps": {
          "comment": "List of impulses that are currently delayed"
        },
        "LogFile": {
          "comment": "Dedicated file log for tracking all script execution"
        },
        "NestedSequences": {
          "comment": "List of any nested sequences, to recursively execute in UpdateOp\n Do not rely on this in the editor - it is really built and accuracte only when play begins."
        },
        "SequenceObjects": {
          "comment": "List of all scripting objects contained in this sequence"
        },
        "UnregisteredEvents": {
          "comment": "List of events that failed to register on first pass"
        },
        "bEnabled": {
          "comment": "Is this sequence currently enabled?"
        }
      },
      "functions": {
        "FindSeqObjectsByClass": {
          "comment": "Fills supplied array with all sequence objects of the specified type."
        },
        "FindSeqObjectsByName": {
          "comment": "Fills supplied array with all sequence object of the specified name."
        }
      },
      "structs": {
        "ActivateOp": {
          "comment": "Used to save an op to activate and the impulse index.",
          "properties": {
            "ActivatorOp": {
              "comment": "the sequecne op that last activated the sequence op referenced by 'Op'"
            },
            "InputIdx": {
              "comment": "Input link idx to activate on Op"
            },
            "Op": {
              "comment": "Op pending activation"
            },
            "RemainingDelay": {
              "comment": "Remaining delay (for use with DelayedActivatedOps)"
            }
          }
        },
        "QueuedActivationInfo": {
          "comment": "Matches the SequenceEvent::ActivateEvent parms, for storing multiple activations per frame"
        }
      }
    },
    "SequenceAction": {
      "properties": {
        "bCallHandler": {
          "comment": "If true this action will call the handler function on all targeted actors"
        },
        "HandlerName": {
          "comment": "Handler function name for this action, if none will use the class name to autogenerate one: SeqAct_DoSomething sets HandlerName to \"OnDoSomething\""
        },
        "Targets": {
          "comment": "List of objects to call the handler function on"
        }
      }
    },
    "SequenceEvent": {
      "properties": {
        "ActivationTime": {
          "comment": "Last time this event was activated at"
        },
        "bRegistered": {
          "comment": "Has this event been successfully register?"
        },
        "DuplicateEvts": {
          "comment": "List of events that are in-place duplicates of this event, used to relay messages."
        },
        "Instigator": {
          "comment": "Instigator of the event activation, or the actor that caused the event to be activated. Can vary depending\n on the type of event."
        },
        "MaxWidth": {
          "comment": "Editor only, max width of the title bar?"
        },
        "Originator": {
          "comment": "Originator of this event, set at editor time. Usually the actor that this event is attached to."
        },
        "TriggerCount": {
          "comment": "Number of times this event has been activated"
        },
        "bClientSideOnly": {
          "comment": "if true, this event (and therefore all linked actions) is triggered on the client instead of the server\n use for events that don't affect gameplay\n @note: direct references to level placed actors used by client side events/actions require that the actors have\n bStatic or bNoDelete set; otherwise the reference will be NULL on the client"
        },
        "bEnabled": {
          "comment": "Is this event currently enabled?"
        },
        "bPlayerOnly": {
          "comment": "Require this event to be activated by a player?"
        },
        "MaxTriggerCount": {
          "comment": "How many times can this event be activated, 0 for infinite"
        },
        "Priority": {
          "comment": "Used by event managers (such as DialogueManager) to help filter out events that occur at same time"
        },
        "ReTriggerDelay": {
          "comment": "Delay between allowed activations"
        }
      },
      "functions": {
        "CheckActivate": {
          "comment": "Checks if this event could be activated, and if bTest == false\n then the event will be activated with the specified actor as the\n instigator.",
          "params": {
            "inOriginator": "actor to use as the originator",
            "inInstigator": "actor to use as the instigator",
            "bTest": "if true, then the event will not actually be\n activated, only tested for success",
            "ActivateIndices": "array of indices of output links to activate\n if the event is activated. If unspecified, the default\n is to activate all of them.",
            "bPushTop": "if true and the event is activated,\n adds it to the top of the stack (meaning it will be executed first), rather than the bottom"
          }
        },
        "RegisterEvent": {
          "comment": "Called when the sequence that contains this event is initialized (@see USequence::InitializeSequence). For events\n attached to actors, this will occur at level startup (@see USequence::BeginPlay())"
        },
        "Toggled": {
          "comment": "Called once this event is toggled via SeqAct_Toggle."
        }
      }
    },
    "SequenceFrame": {
      "properties": {
        "bDrawBox": {
          "comment": "Should we draw a box for this comment object, or leave it just as text."
        },
        "bFilled": {
          "comment": "If we are drawing a box, should it be filled, or just an outline."
        },
        "BorderColor": {
          "comment": "If we are drawing a box for this comment object, what colour should the border be."
        },
        "BorderWidth": {
          "comment": "Width of border of comment box in pixels."
        },
        "bTileFill": {
          "comment": "If bDrawBox and bFilled are true, and FillMaterial or FillTexture are true, should be tile it across the box or stretch to fit."
        },
        "FillColor": {
          "comment": "If bDrawBox and bFilled are true, what colour should the background be."
        },
        "FillMaterial": {
          "comment": "If bDrawBox and bFilled, you can optionally specify a material to fill the box with.\n If both FillTexture and FillMaterial are specified, the FillMaterial will be used."
        },
        "FillTexture": {
          "comment": "If bDrawBox and bFilled, you can optionally specify a texture to fill the box with.\n If both FillTexture and FillMaterial are specified, the FillMaterial will be used."
        },
        "SizeX": {
          "comment": "Horizontal size of comment box in pixels."
        },
        "SizeY": {
          "comment": "Vertical size of comment box in pixels."
        }
      }
    },
    "SequenceObject": {
      "properties": {
        "bDeletable": {
          "comment": "Whether or not this object is deletable."
        },
        "bDrawFirst": {
          "comment": "Should this object be drawn in the first pass?"
        },
        "bDrawLast": {
          "comment": "Should this object be drawn in the last pass?"
        },
        "DrawHeight": {
          "comment": "Cached drawing dimensions"
        },
        "DrawWidth": {
          "comment": "Cached drawing dimensions"
        },
        "ObjCategory": {
          "comment": "Editor category for this object. Determines which kismet submenu this object\n should be placed in"
        },
        "ObjColor": {
          "comment": "Color used to draw the object"
        },
        "ObjInstanceVersion": {
          "comment": "Class vs instance version, for offering updates in the Kismet editor"
        },
        "ObjName": {
          "comment": "Text label that describes this object"
        },
        "ObjPosX": {
          "comment": "Visual position of this object within a sequence"
        },
        "ObjPosY": {
          "comment": "Visual position of this object within a sequence"
        },
        "ObjRemoveInProject": {
          "comment": "List of games that do not want to display this object"
        },
        "ParentSequence": {
          "comment": "Sequence that contains this object"
        },
        "bOutputObjCommentToScreen": {
          "comment": "Should this object display ObjComment when activated?"
        },
        "bSuppressAutoComment": {
          "comment": "Should we suppress the 'auto' comment text - values of properties flagged with the 'autocomment' metadata string."
        },
        "ObjComment<MultilineWithMaxRows=5>": {
          "comment": "User editable text comment"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        },
        "GetWorldInfo": {
          "comment": "Returns the current world's WorldInfo, useful for spawning actors and such."
        },
        "IsPastingIntoLevelSequenceAllowed": {
          "comment": "Determines whether objects of this class are allowed to be pasted into level sequences."
        },
        "IsValidLevelSequenceObject": {
          "comment": "Determines whether this class should be displayed in the list of available ops in the level kismet editor."
        },
        "ScriptLog": {
          "comment": "Writes out the specified text to a dedicated scripting log file.",
          "params": {
            "LogText": "the text to print",
            "bWarning": "true if this is a warning message.\n Warning messages are also sent to the normal game log and appear onscreen if Engine's configurable bOnScreenKismetWarnings is true"
          }
        }
      }
    },
    "SequenceOp": {
      "properties": {
        "ActivateCount": {
          "comment": "Number of times that this Op has had Activate called on it. Used for finding often-hit ops and optimising levels."
        },
        "bActive": {
          "comment": "Is this operation currently active?"
        },
        "bAutoActivateOutputLinks": {
          "comment": "indicates whether all output links should be activated when this op has finished executing"
        },
        "bHaveMovingInputConnector": {
          "comment": "True if there is currently moving input connector"
        },
        "bHaveMovingOutputConnector": {
          "comment": "True if there is currently moving output connector"
        },
        "bHaveMovingVarConnector": {
          "comment": "True if there is currently a moving variable connector"
        },
        "bLatentExecution": {
          "comment": "Does this op use latent execution (can it stay active multiple updates?)"
        },
        "bPendingInputConnectorRecalc": {
          "comment": "True if there is a pending input connector position recalculation (I.E when a connector has just moved, or a connector as added or deleted"
        },
        "bPendingOutputConnectorRecalc": {
          "comment": "True if there is a pending output connector position recalculation (I.E when a connector has just moved, or a connector as added or deleted"
        },
        "bPendingVarConnectorRecalc": {
          "comment": "True if there is a pending variable connector position recalculation (I.E when a connector has just moved, or a connector as added or deleted"
        },
        "GamepadID": {
          "comment": "The ControllerId for the player that generated this action; generally only relevant in UI sequences."
        },
        "InputLinks": {
          "comment": "Activates this output link if bDisabled is not true"
        },
        "OutputLinks": {
          "comment": "Activates this output link if bDisabled is not true"
        },
        "PlayerIndex": {
          "comment": "The index [into the Engine.GamePlayers array] for the player that this action is associated with. Currently only used in UI sequences."
        },
        "SearchTag": {
          "comment": "used when searching for objects to avoid unnecessary recursion"
        },
        "VariableLinks": {
          "comment": "All variables used by this operation, both input/output."
        }
      },
      "functions": {
        "Activated": {
          "comment": "Called when this event is activated."
        },
        "ActivateNamedOutputLink": {
          "comment": "Activates an output link by searching for the one with a matching LinkDesc.",
          "params": {
            "LinkDesc": "the string used as the value for LinkDesc of the output link to activate."
          }
        },
        "ActivateOutputLink": {
          "comment": "Activates an output link by index",
          "params": {
            "OutputIdx": "output index to set impulse on (if it's not disabled)"
          }
        },
        "Deactivated": {
          "comment": "Called when this event is deactivated."
        },
        "GetController": {
          "comment": "utility to try to get a Controller out of the given Actor (tries looking for a Pawn if necessary)"
        },
        "GetInterpDataVars": {
          "comment": "Retrieve list of UInterpData objects connected to this sequence op."
        },
        "GetLinkedObjects": {
          "comment": "Gets all SequenceObjects that are contained by this SequenceObject.",
          "params": {
            "out_Objects": "will be filled with all ops that are linked to this op via\n the VariableLinks, OutputLinks, or InputLinks arrays. This array is NOT cleared first.",
            "ObjectType": "if specified, only objects of this class (or derived) will\n be added to the output array.",
            "bRecurse": "if TRUE, recurse into linked ops and add their linked ops to\n the output array, recursively."
          }
        },
        "GetObjectVars": {
          "comment": "Returns all the objects linked via SeqVar_Object, optionally specifying the\n link to filter by.\n @fixme - localization"
        },
        "GetPawn": {
          "comment": "utility to try to get a Pawn out of the given Actor (tries looking for a Controller if necessary)"
        },
        "HasLinkedOps": {
          "comment": "Determines whether this sequence op is linked to any other sequence ops through its variable, output, event or (optionally)\n its input links.",
          "params": {
            "bConsiderInputLinks": "specify TRUE to check this sequence ops InputLinks array for linked ops as well"
          }
        },
        "LinkedVariables": {
          "comment": "returns all linked variables that are of the specified class or a subclass",
          "params": {
            "VarClass": "the class of variable to return",
            "OutVariable": "(out) the returned variable for each iteration",
            "InDesc": "(optional) if specified, only variables connected to the link with the given description are returned\n@fixme - localization"
          }
        },
        "PopulateLinkedVariableValues": {
          "comment": "Copies the values from member variables contained by this sequence op into any VariableLinks attached to that member variable."
        },
        "PublishLinkedVariableValues": {
          "comment": "Copies the values from all VariableLinks to the member variable [of this sequence op] associated with that VariableLink."
        },
        "VersionUpdated": {
          "comment": "Called when the version is updated, in case any special handling is desired script-side."
        }
      },
      "structs": {
        "SeqEventLink": {
          "comment": "Represents an event linked to the operation, similar to a variable link. Necessary\n only since SequenceEvent does not derive from SequenceVariable.\n @todo native interfaces - could be avoided by using interfaces, but requires support for native interfaces",
          "properties": {
            "bClampedMax": {
              "comment": "True if the connector cant be moved to the right any further"
            },
            "bClampedMin": {
              "comment": "True if the connector cant be move to the left any further"
            },
            "bMoving": {
              "comment": "True if the connector is moving"
            },
            "OverrideDelta": {
              "comment": "The delta position that is applied to the connector in the event that it has moved"
            }
          }
        },
        "SeqOpInputLink": {
          "comment": "Represents an input link for a SequenceOp, that is\n connected via another SequenceOp's output link.",
          "properties": {
            "bClampedMax": {
              "comment": "True if the connector cant be moved to the right any further"
            },
            "bClampedMin": {
              "comment": "True if the connector cant be move to the left any further"
            },
            "bDisabled": {
              "comment": "Is this link disabled for debugging/testing?"
            },
            "bDisabledPIE": {
              "comment": "Is this link disabled for PIE?"
            },
            "bHasImpulse": {
              "comment": "Indicates whether this input is ready to provide data to this sequence operation."
            },
            "bMoving": {
              "comment": "True if the connector is moving"
            },
            "LinkDesc": {
              "comment": "Text description of this link"
            },
            "LinkedOp": {
              "comment": "Linked action that creates this input, for Sequences"
            },
            "OverrideDelta": {
              "comment": "The delta position that is applied to the connector in the event that it has moved"
            },
            "QueuedActivations": {
              "comment": "Number of activations received for this input when bHasImpulse == TRUE"
            }
          }
        },
        "SeqOpOutputInputLink": {
          "comment": "Individual output link entry, for linking an output link\n to an input link on another operation.",
          "properties": {
            "InputLinkIdx": {
              "comment": "Index to LinkedOp's InputLinks array that this is linked to"
            },
            "LinkedOp": {
              "comment": "SequenceOp this is linked to"
            }
          }
        },
        "SeqOpOutputLink": {
          "comment": "Actual output link for a SequenceOp, containing connection\n information to multiple InputLinks in other SequenceOps.",
          "properties": {
            "ActivateDelay": {
              "comment": "Delay applied before activating this output"
            },
            "bClampedMax": {
              "comment": "True if the connector cant be moved to the right any further"
            },
            "bClampedMin": {
              "comment": "True if the connector cant be move to the left any further"
            },
            "bDisabled": {
              "comment": "Is this link disabled for debugging/testing?"
            },
            "bDisabledPIE": {
              "comment": "Is this link disabled for PIE?"
            },
            "bHasImpulse": {
              "comment": "Indicates whether this link is pending activation. If true, the SequenceOps attached to this\n link will be activated the next time the sequence is ticked"
            },
            "bMoving": {
              "comment": "True if the connector is moving"
            },
            "LinkDesc": {
              "comment": "Text description of this link"
            },
            "LinkedOp": {
              "comment": "Linked op that creates this output, for Sequences"
            },
            "Links": {
              "comment": "List of actual connections for this output"
            },
            "OverrideDelta": {
              "comment": "The delta position that is applied to the connector in the event that it has moved"
            }
          }
        },
        "SeqVarLink": {
          "comment": "Represents a variable linked to the operation for manipulation upon\n activation.\n NOTE: if you are adding vars to this you will need recreate var links on existing kismet actions to get non default values propagated",
          "properties": {
            "bAllowAnyType": {
              "comment": "Does this link support any type of property?"
            },
            "bClampedMax": {
              "comment": "True if the connector cant be moved to the right any further"
            },
            "bClampedMin": {
              "comment": "True if the connector cant be move to the left any further"
            },
            "bHidden": {
              "comment": "Should draw this connector in Kismet."
            },
            "bModifiesLinkedObject": {
              "comment": "do the object(s) pointed to by this variable get modified by this op? (ignored if not an object variable)"
            },
            "bMoving": {
              "comment": "True if the connector is moving"
            },
            "bSequenceNeverReadsOnlyWritesToThisVar": {
              "comment": "Determines if this variable ONLY allowed to be written to by this SeqAct. (e.g. never grab data from it) This is needed to stop \n USequence::ExecuteActiveOps from immediately reading from a var and overwriting any member var data. Then the SeqAct \n will more than likely use PopulateLinkedVariableValues() in UpdateOp to push data to the vars which other kismet actions\n can read from."
            },
            "bWriteable": {
              "comment": "Is this variable written to by this op?"
            },
            "CachedProperty": {
              "comment": "Cached property ref"
            },
            "DrawX": {
              "comment": "For drawing."
            },
            "ExpectedType": {
              "comment": "Class of variable that can be attached to this connector."
            },
            "LinkDesc": {
              "comment": "Text description of this variable's use with this op"
            },
            "LinkedVariables": {
              "comment": "SequenceVariables that we are linked to."
            },
            "LinkVar": {
              "comment": "Name of the linked external variable that creates this link, for sub-Sequences"
            },
            "MaxVars": {
              "comment": "Maximum number of variables that should be attached to this connector."
            },
            "MinVars": {
              "comment": "Minimum number of variables that should be attached to this connector."
            },
            "OverrideDelta": {
              "comment": "The delta position that is applied to the connector in the event that it has moved"
            },
            "PropertyName": {
              "comment": "Name of the property this variable is associated with"
            }
          }
        }
      }
    },
    "SequenceVariable": {
      "properties": {
        "VarName": {
          "comment": "This is used by SeqVar_Named to find a variable anywhere in the levels sequence."
        }
      }
    },
    "SeqVar_Character": {
      "properties": {
        "PawnClass": {
          "comment": "Pawn class for the character we're looking for"
        }
      }
    },
    "SeqVar_External": {
      "properties": {
        "VariableLabel": {
          "comment": "Name of the variable link to create on the parent sequence"
        }
      }
    },
    "SeqVar_Group": {
      "properties": {
        "Actors": {
          "comment": "List of actors w/ matching Group, @note using Object simply for GetObjectRef(), typing isn't really important here"
        },
        "bCachedList": {
          "comment": "Has the list been cached?"
        }
      }
    },
    "SeqVar_Named": {
      "properties": {
        "bStatusIsOk": {
          "comment": "For use in Kismet, to indicate if this variable is ok. Updated in UpdateStatus."
        },
        "ExpectedType": {
          "comment": "Class that this variable will act as. Set automatically when connected to a SequenceOp variable connector."
        },
        "FindVarName": {
          "comment": "Will search entire level's sequences (ie all subsequences) to find a variable whose VarName matches FindVarName."
        }
      }
    },
    "SeqVar_Object": {
      "properties": {
        "ActorLocation": {
          "comment": "Local copy of the actor location, used as a dummy when treating an Actor as a vector, to prevent accidental writes to the Actor location"
        }
      },
      "functions": {
        "GetObjectValue": {
          "comment": "returns the object this variable is currently pointing to\n if this variable represents a list of objects, only returns the first one"
        },
        "SetObjectValue": {
          "comment": "sets the object this variable points to"
        }
      }
    },
    "SeqVar_ObjectList": {
      "properties": {
        "ObjList": {
          "comment": "this is our list of objects which this kismet variable holds"
        }
      }
    },
    "SeqVar_ObjectVolume": {
      "properties": {
        "ContainedObjects": {
          "comment": "List of objects contained within the volume"
        },
        "LastUpdateTime": {
          "comment": "Last time ContainedObjects was updated"
        },
        "bCollidingOnly": {
          "comment": "Should this volume account for non-colliding as well?"
        },
        "ExcludeClassList": {
          "comment": "List of object types to exclude"
        }
      }
    },
    "SeqVar_Player": {
      "properties": {
        "Players": {
          "comment": "Local list of players in the game"
        },
        "bAllPlayers": {
          "comment": "Return all player references?"
        },
        "PlayerIdx": {
          "comment": "Individual player selection for multiplayer scripting"
        }
      },
      "functions": {
        "UpdatePlayersList": {
          "comment": "updates the Players array with the list of Controllers in the game that count as players (humans or bot-players)"
        }
      }
    },
    "SeqVar_RandomFloat": {
      "properties": {
        "Max": {
          "comment": "Max value for randomness"
        },
        "Min": {
          "comment": "Min value for randomness"
        }
      }
    },
    "SeqVar_RandomInt": {
      "properties": {
        "Max": {
          "comment": "Max value for randomness"
        },
        "Min": {
          "comment": "Min value for randomness"
        }
      }
    },
    "Settings": {
      "comment": "Base class for any type of settings that can be manipulated by the UI",
      "properties": {
        "LocalizedSettings": {
          "comment": "The various localized string settings to use with the session"
        },
        "LocalizedSettingsMappings": {
          "comment": "Used to map a localized string setting to a human readable string"
        },
        "Properties": {
          "comment": "The properties used by the derived settings class"
        },
        "PropertyMappings": {
          "comment": "Used to map a property to a human readable string and validate its range"
        }
      },
      "functions": {
        "AppendContextsToURL": {
          "comment": "Appends contexts to the URL.",
          "params": {
            "OutURL": "String to append contexts to."
          }
        },
        "AppendDataBindingsToURL": {
          "comment": "Appends databindings to the URL.",
          "params": {
            "OutURL": "String to append bindings to."
          }
        },
        "AppendPropertiesToURL": {
          "comment": "Appends properties to the URL.",
          "params": {
            "OutURL": "String to append properties to."
          }
        },
        "BuildURL": {
          "comment": "Builds an URL out of the string settings and properties",
          "params": {
            "URL": "the string to populate"
          }
        },
        "EmptySettingsData": {
          "comment": "Empties an SettingsData structure",
          "params": {
            "Data": "the data structure to set the fields of"
          }
        },
        "GetFloatProperty": {
          "comment": "Reads a property of type SDT_Float into the value specified. Does nothing\n if the property is not of the right type.",
          "params": {
            "PropertyId": "the property to read the value of",
            "Value": "the out value containing the property's value"
          }
        },
        "GetIntProperty": {
          "comment": "Reads a property of type SDT_Int32 into the value specified. Does nothing\n if the property is not of the right type.",
          "params": {
            "PropertyId": "the property to change the value of",
            "Value": "the out value containing the property's value"
          }
        },
        "GetPropertyAsString": {
          "comment": "Converts a property to a string. Searches by id",
          "params": {
            "PropertyId": "the id to look up in the mappings table"
          }
        },
        "GetPropertyAsStringByName": {
          "comment": "Converts a property to a string. Searches by name",
          "params": {
            "PropertyName": "the name of the property to find"
          }
        },
        "GetPropertyColumnHeader": {
          "comment": "Finds the localized column header text for the property",
          "params": {
            "PropertyId": "the id to look up in the mappings table"
          }
        },
        "GetPropertyId": {
          "comment": "Searches the property array for the matching property and returns the id",
          "params": {
            "PropertyName": "the name of the property being searched for",
            "PropertyId": "the id of the context that matches the name"
          }
        },
        "GetPropertyMappingType": {
          "comment": "Determines the mapping type for the specified property",
          "params": {
            "PropertyId": "the ID to get the mapping type for",
            "OutType": "the out var the value is placed in"
          }
        },
        "GetPropertyName": {
          "comment": "Finds the human readable name for the property",
          "params": {
            "PropertyId": "the id to look up in the mappings table"
          }
        },
        "GetPropertyRange": {
          "comment": "Determines the min and max values of a property that is clamped to a range",
          "params": {
            "PropertyId": "the ID to get the mapping type for",
            "OutMinValue": "the out var the min value is placed in",
            "OutMaxValue": "the out var the max value is placed in",
            "RangeIncrement": "the amount the range can be adjusted by the UI in any single update",
            "bFormatAsInt": "whether the range's value should be treated as an int."
          }
        },
        "GetPropertyType": {
          "comment": "Determines the property type for the specified property id",
          "params": {
            "PropertyId": "the property to change the value of"
          }
        },
        "GetPropertyValueId": {
          "comment": "Retrieves the id for a mapped property's current value.",
          "params": {
            "PropertyId": "the property to change the value of",
            "ValueId": "receives the id of the property value"
          }
        },
        "GetQoSAdvertisedProperties": {
          "comment": "Scans the properties for the ones that need to be set via QoS data",
          "params": {
            "QoSProps": "the out array holding the list of properties to advertise via QoS"
          }
        },
        "GetQoSAdvertisedStringSettings": {
          "comment": "Scans the string settings for the ones that need to be set via QoS data",
          "params": {
            "QoSSettings": "the out array holding the list of settings to advertise via QoS"
          }
        },
        "GetRangedPropertyValue": {
          "comment": "Gets the value of a ranged property",
          "params": {
            "PropertyId": "the ID to get the value of",
            "OutValue": "the out var that receives the value"
          }
        },
        "GetSettingsDataBlob": {
          "comment": "Static function for copying data out the SettingsData union",
          "params": {
            "Data": "the data structure to copy the data from",
            "OutBlob": "the buffer to copy the data into"
          }
        },
        "GetSettingsDataDateTime": {
          "comment": "Static function for getting members of the SettingsData union",
          "params": {
            "Data": "the data structure to get the fields of",
            "OutInt1": "first half of the data to get",
            "OutInt2": "second half of the data to get"
          }
        },
        "GetSettingsDataFloat": {
          "comment": "Static function for copying data out of the SettingsData union",
          "params": {
            "Data": "the data structure to copy the data from"
          }
        },
        "GetSettingsDataInt": {
          "comment": "Static function for copying data out of the SettingsData union",
          "params": {
            "Data": "the data structure to copy the data from"
          }
        },
        "GetSettingsDataString": {
          "comment": "Static function for copying data out of the SettingsData union.",
          "params": {
            "Data": "the data structure to copy the data from"
          }
        },
        "GetStringProperty": {
          "comment": "Reads a property of type SDT_String into the value specified. Does nothing\n if the property is not of the right type.",
          "params": {
            "PropertyId": "the property to change the value of",
            "Value": "the out value containing the property's value"
          }
        },
        "GetStringSettingColumnHeader": {
          "comment": "Finds the localized column header text for the string setting",
          "params": {
            "StringSettingId": "the id to look up in the mappings table"
          }
        },
        "GetStringSettingId": {
          "comment": "Searches the context array for the matching string setting name and returns the id",
          "params": {
            "StringSettingName": "the name of the string setting being searched for",
            "StringSettingId": "the id of the context that matches the name"
          }
        },
        "GetStringSettingName": {
          "comment": "Finds the human readable name for the localized string setting",
          "params": {
            "StringSettingId": "the id to look up in the mappings table"
          }
        },
        "GetStringSettingValue": {
          "comment": "Searches the localized string setting array for the matching id and returns its value",
          "params": {
            "StringSettingId": "the string setting to find the value of",
            "ValueIndex": "the out value that is set when found"
          }
        },
        "GetStringSettingValueByName": {
          "comment": "Searches the localized string setting array for the matching name and returns its value",
          "params": {
            "StringSettingName": "the setting name to find the value of",
            "ValueIndex": "the out value that is set when found"
          }
        },
        "GetStringSettingValueName": {
          "comment": "Finds the human readable name for a string setting's value. Searches the\n string settings mappings for the specifc string setting and then searches\n the set of values for the specific value index and returns that value's\n human readable name",
          "params": {
            "StringSettingId": "the id to look up in the mappings table",
            "ValueIndex": "the value index to find the string value of"
          }
        },
        "GetStringSettingValueNameByName": {
          "comment": "Finds the human readable name for a string setting's value. Searches the\n string settings mappings for the specifc string setting and then searches\n the set of values for the specific value index and returns that value's\n human readable name",
          "params": {
            "StringSettingName": "the name of the string setting to find the string value of"
          }
        },
        "GetStringSettingValueNames": {
          "comment": "Searches the localized string setting array for the matching id and\n returns the list of possible values",
          "params": {
            "StringSettingId": "the string setting to find the value of",
            "Values": "the out value that is a list of value names and their ids"
          }
        },
        "HasProperty": {
          "comment": "Determines if a given property is present for this object",
          "params": {
            "PropertyId": "the ID to check on"
          }
        },
        "HasStringSetting": {
          "comment": "Determines if a given localized string setting is present for this object",
          "params": {
            "SettingId": "the ID to check on"
          }
        },
        "IncrementStringSettingValue": {
          "comment": "Searches the localized string setting array for the matching id and sets the selected value\n to the next (or prev) item in the list, wrapping if required",
          "params": {
            "StringSettingId": "the string setting to find the value of",
            "Direction": "the direction to move in the list (1 forward, -1 backward)",
            "bShouldWrap": "if true out of bound access wraps around, false clamps to min/max"
          }
        },
        "IsWildcardStringSetting": {
          "comment": "Determines if the value for the specified setting is a wildcard option",
          "params": {
            "StringSettingId": "the id to check for being a wildcard"
          }
        },
        "SetFloatProperty": {
          "comment": "Sets a property of type SDT_Float to the value specified. Does nothing\n if the property is not of the right type.",
          "params": {
            "PropertyId": "the property to change the value of",
            "Value": "the new value to assign"
          }
        },
        "SetIntProperty": {
          "comment": "Sets a property of type SDT_Int32 to the value specified. Does nothing\n if the property is not of the right type.",
          "params": {
            "PropertyId": "the property to change the value of",
            "Value": "the new value to assign"
          }
        },
        "SetPropertyFromStringByName": {
          "comment": "Searches for the property by name and sets the property to the value contained\n in the string",
          "params": {
            "PropertyName": "the name of the property to find",
            "NewValue": "the string value to use"
          }
        },
        "SetPropertyValueId": {
          "comment": "Change the current value for a mapped property's using a value id.",
          "params": {
            "PropertyId": "the property to change the value of",
            "ValueId": "the id for the value to set."
          }
        },
        "SetRangedPropertyValue": {
          "comment": "Sets the value of a ranged property, clamping to the min/max values",
          "params": {
            "PropertyId": "the ID of the property to set",
            "NewValue": "the new value to apply to the"
          }
        },
        "SetSettingsData": {
          "comment": "Static function for setting members of the SettingsData union",
          "params": {
            "Data": "the data structure to set the fields of",
            "Data2Copy": "the SettingsData object to copy"
          }
        },
        "SetSettingsDataBlob": {
          "comment": "Static function for setting members of the SettingsData union",
          "params": {
            "Data": "the data structure to set the fields of",
            "InBlob": "the 8 bytes to copy into the union"
          }
        },
        "SetSettingsDataDateTime": {
          "comment": "Static function for setting members of the SettingsData union",
          "params": {
            "Data": "the data structure to set the fields of",
            "InInt1": "first half of the data to set",
            "InInt2": "second half of the data to set"
          }
        },
        "SetSettingsDataFloat": {
          "comment": "Static function for setting members of the SettingsData union",
          "params": {
            "Data": "the data structure to set the fields of",
            "InFloat": "the float data to set in the union"
          }
        },
        "SetSettingsDataInt": {
          "comment": "Static function for setting members of the SettingsData union",
          "params": {
            "Data": "the data structure to set the fields of",
            "InInt": "the 32 bit integer data to set in the union"
          }
        },
        "SetSettingsDataString": {
          "comment": "Static function for setting members of the SettingsData union.",
          "params": {
            "Data": "the data structure to set the fields of",
            "InString": "the string data to set in the union"
          }
        },
        "SetStringProperty": {
          "comment": "Sets a property of type SDT_String to the value specified. Does nothing\n if the property is not of the right type.",
          "params": {
            "PropertyId": "the property to change the value of",
            "Value": "the new value to assign"
          }
        },
        "SetStringSettingValue": {
          "comment": "Searches the localized string setting array for the matching id and sets the value",
          "params": {
            "StringSettingId": "the string setting to set the value for",
            "ValueIndex": "the value of the string setting",
            "bShouldAutoAdd": "whether to add the context if it is missing"
          }
        },
        "SetStringSettingValueByName": {
          "comment": "Searches the localized string setting array for the matching name and sets the value",
          "params": {
            "StringSettingName": "the setting name to set the value for",
            "ValueIndex": "the value of the string setting",
            "bShouldAutoAdd": "whether to add the string setting if it is missing"
          }
        },
        "SetStringSettingValueFromStringByName": {
          "comment": "Searches for the string setting by name and sets the value index to the\n value contained in the string setting meta data",
          "params": {
            "StringSettingName": "the name of the string setting to find",
            "NewValue": "the string value to use"
          }
        },
        "UpdateFromURL": {
          "comment": "Updates the game settings object from parameters passed on the URL",
          "params": {
            "URL": "the URL to parse for settings"
          }
        },
        "UpdateProperties": {
          "comment": "Using the specified array, updates the matching properties to the new values\n in that array. Optionally, it will add properties that aren't currently part\n of this object.",
          "params": {
            "Props": "the list of properties to update",
            "bShouldAddIfMissing": "whether to automatically add the property if missing"
          }
        },
        "UpdateStringSettings": {
          "comment": "Using the specified array, updates the matching settings to the new values\n in that array. Optionally, it will add settings that aren't currently part\n of this object.",
          "params": {
            "Settings": "the list of settings to update",
            "bShouldAddIfMissing": "whether to automatically add the setting if missing"
          }
        }
      },
      "structs": {
        "IdToStringMapping": {
          "comment": "Maps an Id value to a string",
          "properties": {
            "Id": {
              "comment": "Id for the given string"
            },
            "Name": {
              "comment": "Human readable form of the Id"
            }
          }
        },
        "LocalizedStringSetting": {
          "comment": "Structure used to represent a string setting that has a restricted and\n localized set of value strings. For instance:\n GameType (id) Values = (0) Death Match, (1) Team Death Match, etc.\n This allows strings to be transmitted using only 8 bytes and each string\n is correct for the destination language irrespective of sender's language",
          "properties": {
            "AdvertisementType": {
              "comment": "How this setting should be presented to requesting clients: online or QoS"
            },
            "Id": {
              "comment": "The unique identifier for this localized string"
            },
            "ValueIndex": {
              "comment": "The unique index into the list of localized strings"
            }
          }
        },
        "LocalizedStringSettingMetaData": {
          "comment": "Contains the meta information for a given context",
          "properties": {
            "ColumnHeaderText": {
              "comment": "Localized text used for list column headers"
            },
            "Id": {
              "comment": "Id for the given string"
            },
            "Name": {
              "comment": "Human readable form of the Id"
            },
            "ValueMappings": {
              "comment": "Holds the mappings of localized string setting values to their human readable form"
            }
          }
        },
        "SettingsData": {
          "comment": "Structure to hold arbitrary data of a given type",
          "properties": {
            "Type": {
              "comment": "Enum (byte) indicating the type of data held in the value fields"
            },
            "Value1": {
              "comment": "This is a union of value types and should never be used in script"
            },
            "Value2": {
              "comment": "This is a union of value types and should never be used in script\n NOTE: It's declared as a pointer for 64bit systems"
            }
          }
        },
        "SettingsProperty": {
          "comment": "Structure used to hold non-localized string data. Properties can be\n arbitrary types.",
          "properties": {
            "AdvertisementType": {
              "comment": "How this setting should be presented to requesting clients: online or QoS"
            },
            "Data": {
              "comment": "The data stored for the type"
            },
            "PropertyId": {
              "comment": "The unique id for this property"
            }
          }
        },
        "SettingsPropertyPropertyMetaData": {
          "comment": "Contains the meta information needed to validate property data",
          "properties": {
            "ColumnHeaderText": {
              "comment": "Localized text used for list column headers"
            },
            "Id": {
              "comment": "Id for the given string"
            },
            "MappingType": {
              "comment": "Whether the value is ID mapped or should be string-ized"
            },
            "MaxVal": {
              "comment": "The max value for this property"
            },
            "MinVal": {
              "comment": "The min value for this property"
            },
            "Name": {
              "comment": "Human readable form of the Id"
            },
            "PredefinedValues": {
              "comment": "Holds a set of predefined values for a property when freeform editing isn't desired"
            },
            "RangeIncrement": {
              "comment": "The amount that this range can be incremented/decremented by"
            },
            "ValueMappings": {
              "comment": "Holds the mappings of value IDs to their human readable form"
            }
          }
        },
        "StringIdToStringMapping": {
          "comment": "Maps an Id value to a string",
          "properties": {
            "bIsWildcard": {
              "comment": "Whether this id is used to indicate a wildcard value or not"
            },
            "Id": {
              "comment": "Id for the given string"
            },
            "Name": {
              "comment": "Human readable form of the Id"
            }
          }
        }
      }
    },
    "ShadowMap2D": {
      "properties": {
        "bIsShadowFactorTexture": {
          "comment": "Indicates whether the texture contains shadow factors (0 for shadowed, 1 for unshadowed) or signed distance field values."
        },
        "Component": {
          "comment": "Optional instanced mesh component this shadowmap is used with"
        },
        "CoordinateBias": {
          "comment": "The bias which is applied to the shadow-map coordinates before sampling the shadow-map textures."
        },
        "CoordinateScale": {
          "comment": "The scale which is applied to the shadow-map coordinates before sampling the shadow-map textures."
        },
        "InstanceIndex": {
          "comment": "Optional instance index this shadowmap is used with. If this is non-zero, this shadowmap object is temporary"
        },
        "LightGuid": {
          "comment": "The GUID of the light which this shadow-map is for."
        },
        "Texture": {
          "comment": "The texture which contains the shadow-map data."
        }
      }
    },
    "ShadowMapTexture2D": {
      "properties": {
        "ShadowmapFlags": {
          "comment": "Bit-field of EShadowmapFlags."
        }
      }
    },
    "SkelControlBase": {
      "properties": {
        "AnimMetaDataUpdateTag": {
          "comment": "Tag to update MetaData"
        },
        "AnimMetadataWeight": {
          "comment": "Node weight when controlled by AnimMetadata"
        },
        "BlendTimeToGo": {
          "comment": "Amount of time left in the currently active blend."
        },
        "bShouldTickInScript": {
          "comment": "Whether this skeletal controller should call the script TickSkelControl() event when ticked"
        },
        "bShouldTickOwner": {
          "comment": "Call SkelControlTick() on Owner"
        },
        "CachedNodeList": {
          "comment": "Cached list of nodes to get strength from"
        },
        "ControlPosX": {
          "comment": "Used by editor."
        },
        "ControlPosY": {
          "comment": "Used by editor."
        },
        "ControlTickTag": {
          "comment": "Used to ensure we don't tick this SkelControl twice, if used in multiple different control chains.\n Compared against the SkeletalMeshComponent TickTag."
        },
        "NextControl": {
          "comment": "Next SkelControl in the linked list."
        },
        "StrengthTarget": {
          "comment": "This is the slider bare at the bottom of the control. Strength towards which we are currently ramping. This is used in the anim tree."
        },
        "bControlledByAnimMetada": {
          "comment": "if TRUE, weight default to 0, and metadata in animation will enable the node based on animation weight."
        },
        "bInvertMetadataWeight": {
          "comment": "If TRUE, weight defaults to 1, and metadata will set that to zero, disabling the node"
        },
        "BlendInTime": {
          "comment": "When calling SetActive passing in 'true', indicates how many seconds to take to reach a ControlStrength of 1.0."
        },
        "BlendOutTime": {
          "comment": "When calling SetActive passing in 'false', indicates how many seconds to take to reach a ControlStrength of 0.0."
        },
        "BlendType": {
          "comment": "BlendType - Easy in/out"
        },
        "BoneScale": {
          "comment": "This scaling is applied to the bone that this control is acting upon."
        },
        "bPostPhysicsController": {
          "comment": "If TRUE, this controller will be applied AFTER physics has been run, as part of the process of blending physics into the graphics skeleton."
        },
        "bPropagateSetActive": {
          "comment": "If true, calling SetSkelControlActive on this node will call SetSkelControlActive on the next one in the chain as well."
        },
        "bSetStrengthFromAnimNode": {
          "comment": "If true, Strength will be the same as given AnimNode(s). This is to make transitions easier between nodes and Controllers."
        },
        "ControlName": {
          "comment": "Name used to identify this SkelControl."
        },
        "ControlStrength": {
          "comment": "Used to control how much affect this SkelControl has.\n 1.0 means fully active, 0.0 means have no affect.\n Exactly how the control ramps up depends on the specific control type."
        },
        "StrengthAnimNodeNameList": {
          "comment": "List of AnimNode names, to get Strength from"
        },
        "bIgnoreWhenNotRendered": {
          "comment": "whether this control should be ignored if the SkeletalMeshComponent being composed hasn't been rendered recently\n @note this can be forced by the SkeletalMeshComponent's bIgnoreControllersWhenNotRendered flag"
        },
        "IgnoreAtOrAboveLOD": {
          "comment": "If the LOD of this skeletal mesh is at or above this LOD, then this SkelControl will not be applied."
        },
        "bEnableEaseInOut": {
          "comment": "This will change to BlendType in general"
        }
      },
      "functions": {
        "GetControlMetadataWeight": {
          "comment": "Accessor to get Metadataweight property value."
        },
        "SetSkelControlActive": {
          "comment": "Toggle the active state of the SkeControl.\n If passing in true, will take BlendInTime to reach a ControlStrength of 1.0.\n If passing in false, will take BlendOutTime to reach a ControlStrength of 0.0."
        },
        "SetSkelControlStrength": {
          "comment": "Set custom strength with optional blend time.",
          "params": {
            "NewStrength": "Target Strength for this controller.",
            "InBlendTime": "Time it will take to reach that new strength. (0.f == Instant)"
          }
        },
        "TickSkelControl": {
          "comment": "Called every tick if bShouldTickInScript is true"
        }
      }
    },
    "SkelControlFootPlacement": {
      "properties": {
        "bInvertFootUpAxis": {
          "comment": "If we should invert the axis used for aligning the foot to the floor, defined by FootUpAxis."
        },
        "bOnlyEnableForUpAdjustment": {
          "comment": "This control should be completely disabled if we are not doing an upwards adjustment on the foot."
        },
        "bOrientFootToGround": {
          "comment": "If we should attempt to align the foot bone with the surface normal of the ground."
        },
        "FootOffset": {
          "comment": "Vertical offset to apply to foot bone. This is applied along the vector between the hip position and the foot bone position."
        },
        "FootRotOffset": {
          "comment": "Rotation offset applied to foot matrix before taking the FootUpAxis."
        },
        "FootUpAxis": {
          "comment": "Axis of the foot bone to align to ground normal (if bOrientFootToGround is true)."
        },
        "MaxDownAdjustment": {
          "comment": "Maximum distance from animated post that foot will be moved down."
        },
        "MaxFootOrientAdjust": {
          "comment": "Maximum angle (in degrees) that we will rotate the foot from the animated orientation in an attempt to match the ground normal."
        },
        "MaxUpAdjustment": {
          "comment": "Maximum distance from animated post that foot will be moved up."
        }
      }
    },
    "SkelControlHandlebars": {
      "properties": {
        "SteerWheelBoneIndex": {
          "comment": "Cached index of the wheel bone"
        },
        "HandlebarRotateAxis": {
          "comment": "Axis around which steering occurs."
        },
        "WheelBoneName": {
          "comment": "Name of the bone whose rotation will control the steering"
        },
        "WheelRollAxis": {
          "comment": "Axis around which wheel rolling occurs."
        }
      }
    },
    "SkelControlLimb": {
      "properties": {
        "EffectorLocation": {
          "comment": "Where you want the controlled bone to be. Will be placed as close as possible within the constraints of the limb."
        },
        "EffectorLocationSpace": {
          "comment": "Reference frame that the DesiredLocation is defined in."
        },
        "EffectorSpaceBoneName": {
          "comment": "Name of bone used if DesiredLocationSpace is BCS_OtherBoneSpace or BCS_BaseMeshSpace."
        },
        "JointOffset": {
          "comment": "Apply an Offset to the Joint (Elbow) bone. This will create stretching!"
        },
        "JointOffsetBoneName": {
          "comment": "Optional bone name to be used by JoinOffsetSpace"
        },
        "JointOffsetSpace": {
          "comment": "Space this offset is in"
        },
        "JointTargetLocation": {
          "comment": "Point in space where the joint should move towards as it bends."
        },
        "JointTargetLocationSpace": {
          "comment": "Reference frame in which JointTargetLocation is defined."
        },
        "JointTargetSpaceBoneName": {
          "comment": "Name of bone used if JointTargetLocationSpace is BCS_OtherBoneSpace."
        },
        "bInvertBoneAxis": {
          "comment": "If we want to invert BoneAxis when constructing the transform for the bones."
        },
        "bInvertJointAxis": {
          "comment": "If we want to invert JointAxis when constructing the transform for the bones."
        },
        "bMaintainEffectorRelRot": {
          "comment": "If true, modify the relative rotation between the end 'effector' bone and its parent bone. If false,\n the rotation of the end bone will not be modified by this controller."
        },
        "BoneAxis": {
          "comment": "Axis of graphical bone to align along the length of the bone."
        },
        "bRotateJoint": {
          "comment": "Experiment to Rotate Joint Bone, rather than creating a new Matrix for it."
        },
        "bTakeRotationFromEffectorSpace": {
          "comment": "If true, rotation of effector bone is copied from the bone specified by EffectorSpaceBoneName."
        },
        "JointAxis": {
          "comment": "Axis of graphical bone to align along the hinge axis of the joint."
        },
        "bAllowStretching": {
          "comment": "Is Limb allowed to stretch to reach its target?"
        },
        "StretchLimits": {
          "comment": "Stretching limits.\n X represents the relative length of the limb at which it will start stretching.\n Y represents the maximum stretch factor allowed.\n For example (X=0.5,Y=2.f) will mean that the limb is allowed to stretch up to twice its length.\n And it will start stretching when shoulder to effector distance is half of the full arm length."
        },
        "StretchRollBoneName": {
          "comment": "Name of Roll Bone to stretch as well."
        }
      }
    },
    "SkelControlLookAt": {
      "properties": {
        "ActorSpaceLookAtTarget": {
          "comment": "Actor Space Look At Normal. So interpolation done is relative to the owner"
        },
        "BaseBonePos": {
          "comment": "Internal, base bone position in component space."
        },
        "BaseLookDir": {
          "comment": "Internal, base look dir, without skel controller's influence."
        },
        "ControlBoneIndex": {
          "comment": "Cached control bone index - which one index is this skelcontrol for"
        },
        "DesiredTargetLocation": {
          "comment": "Interpolation target for TargetLocation"
        },
        "LastCalcTime": {
          "comment": "Keep track of when the controller was last calculated.\n We need this to make sure BaseLookDir is accurate, when using CanLookAt()."
        },
        "LimitLookDir": {
          "comment": "internal, used to draw base orientation for limits"
        },
        "LookAtAlpha": {
          "comment": "LookAtAlpha allows to cancel head look when going beyond boundaries"
        },
        "AllowRotationSpace": {
          "comment": "Rotation space to check limits within"
        },
        "bAllowRotationX": {
          "comment": "Per rotation axis filtering"
        },
        "bDisableBeyondLimit": {
          "comment": "Interp back to zero strength if limit surpassed"
        },
        "bEnableLimit": {
          "comment": "If true, only allow a certain adjustment from the reference pose of the bone."
        },
        "bLimitBasedOnRefPose": {
          "comment": "By default limit is based on ref pose of the character"
        },
        "bNotifyBeyondLimit": {
          "comment": "Call event to notify owner of limit break"
        },
        "bShowLimit": {
          "comment": "If true, draw a cone in the editor to indicate the maximum allowed movement of the bone."
        },
        "DeadZoneAngle": {
          "comment": "Allowed error between the current look direction and the desired look direction."
        },
        "MaxAngle": {
          "comment": "The maximum rotation applied from the reference pose of the bone, in degrees."
        },
        "OuterMaxAngle": {
          "comment": "The outer maximum rotation applied from the reference pose of the bone, in degrees, that allows bone to stay in the MaxAngle"
        },
        "RotationAngleRangeX": {
          "comment": "Per rotation axis range of motion in degrees, relative to reference pose of the bone. First (negative) value is lowest relative angle, second is highest."
        },
        "bDefineUpAxis": {
          "comment": "If you want to also define which axis should try to point 'up' (world +Z)."
        },
        "bInvertLookAtAxis": {
          "comment": "Whether to invert the LookAtAxis, so it points away from the TargetLocation."
        },
        "bInvertUpAxis": {
          "comment": "Whether to invert the UpAxis, so it points down instead."
        },
        "LookAtAxis": {
          "comment": "Axis of the controlled bone that you wish to point at the TargetLocation."
        },
        "TargetLocation": {
          "comment": "Position in world space that this bone is looking at."
        },
        "TargetLocationInterpSpeed": {
          "comment": "Interpolation speed for TargetLocation to DesiredTargetLocation"
        },
        "TargetLocationSpace": {
          "comment": "Reference frame that TargetLocation is defined in."
        },
        "TargetSpaceBoneName": {
          "comment": "Name of bone used if TargetLocationSpace is BCS_OtherBoneSpace."
        },
        "UpAxis": {
          "comment": "Axis of bone to point upwards. Cannot be the same as LookAtAxis."
        }
      },
      "functions": {
        "CanLookAtPoint": {
          "comment": "returns TRUE if PointLoc is within cone of vision of look at controller. \n This requires the mesh to be rendered, SpaceBases has to be up to date.",
          "params": {
            "PointLoc": "Point in world space.",
            "bDrawDebugInfo": "if true, debug information will be drawn on hud."
          }
        },
        "InterpolateTargetLocation": {
          "comment": "Interpolate TargetLocation towards DesiredTargetLocation based on TargetLocationInterpSpeed"
        },
        "SetLookAtAlpha": {
          "comment": "Set LookAtAlpha. \n Allows the controller to blend in/out while still being processed.\n CalculateNewBoneTransforms() is still called when ControllerStength > 0 and LookAtAlpha <= 0"
        },
        "SetTargetLocation": {
          "comment": "Sets DesiredTargetLocation to a new location"
        }
      }
    },
    "SkelControlSingleBone": {
      "properties": {
        "bApplyRotation": {
          "comment": "Whether to modify the translation of this bone."
        },
        "bApplyTranslation": {
          "comment": "Whether to modify the translation of this bone."
        },
        "bAddRotation": {
          "comment": "If false, replaces rotation with BoneRotation. If true, adds to existing rotation."
        },
        "BoneRotation": {
          "comment": "New rotation of bone to apply."
        },
        "BoneRotationSpace": {
          "comment": "Reference frame to apply BoneRotation in."
        },
        "bRemoveMeshRotation": {
          "comment": "If bAddRotation and BCS_WorldSpace, then remove mesh relative rotation"
        },
        "RotationSpaceBoneName": {
          "comment": "Name of bone used if BoneRotationSpace is BCS_OtherBoneSpace."
        },
        "bAddTranslation": {
          "comment": "If false, replaces rotation with BoneRotation. If true, adds to existing rotation."
        },
        "BoneTranslation": {
          "comment": "New translation of bone to apply."
        },
        "BoneTranslationSpace": {
          "comment": "Reference frame to apply BoneTranslation in."
        },
        "TranslationSpaceBoneName": {
          "comment": "Name of bone used if BoneTranslationSpace is BCS_OtherBoneSpace."
        }
      }
    },
    "SkelControlSpline": {
      "properties": {
        "bInvertSplineBoneAxis": {
          "comment": "Invert the direction we get for the start of the spline."
        },
        "BoneRotMode": {
          "comment": "Controls how the rotation of each bone along the length of the spline is modified."
        },
        "EndSplineTension": {
          "comment": "Strength of tangent at the controlled bone."
        },
        "SplineBoneAxis": {
          "comment": "Axis of the controlled bone (ie the end of the spline) to use as the direction for the curve."
        },
        "SplineLength": {
          "comment": "Number of bones above the active one in the hierarchy to modify to make into a smooth curve."
        },
        "StartSplineTension": {
          "comment": "Strength of tangent at the start of the chain."
        }
      }
    },
    "SkelControlTrail": {
      "comment": "Allows a chain of bones to 'trail' behind its head.",
      "properties": {
        "bHadValidStrength": {
          "comment": "Did we have a non-zero ControlStrength last frame."
        },
        "OldLocalToWorld": {
          "comment": "LocalToWorld used last frame, used for building transform between frames."
        },
        "ThisTimstep": {
          "comment": "Internal use - we need the timestep to do the relaxation in CalculateNewBoneTransforms."
        },
        "TrailBoneLocations": {
          "comment": "Component-space locations of the bones from last frame. Each frame these are moved towards their 'animated' locations."
        },
        "bActorSpaceFakeVel": {
          "comment": "Whether 'fake' velocity should be applied in actor or world space."
        },
        "bInvertChainBoneAxis": {
          "comment": "Invert the direction specified in ChainBoneAxis."
        },
        "bLimitStretch": {
          "comment": "Limit the amount that a bone can stretch from its ref-pose length."
        },
        "ChainBoneAxis": {
          "comment": "Axis of the bones to point along trail."
        },
        "ChainLength": {
          "comment": "Number of bones above the active one in the hierarchy to modify."
        },
        "FakeVelocity": {
          "comment": "'Fake' velocity applied to bones."
        },
        "StretchLimit": {
          "comment": "If bLimitStretch is true, this indicates how long a bone can stretch beyond its length in the ref-pose."
        },
        "TrailRelaxation": {
          "comment": "How quickly we 'relax' the bones to their animated positions."
        }
      }
    },
    "SkelControlWheel": {
      "properties": {
        "bInvertWheelRoll": {
          "comment": "If we should invert the rotation applied to the wheel for rolling motion."
        },
        "bInvertWheelSteering": {
          "comment": "If we should invert rotation applied to the wheel for steering."
        },
        "WheelDisplacement": {
          "comment": "Units to move the wheel up vertically."
        },
        "WheelMaxRenderDisplacement": {
          "comment": "Maximum displacement that the wheel will be rendered at. Used to avoid graphical clipping of wheel into chassis etc"
        },
        "WheelRoll": {
          "comment": "Current rolling angle of wheel. In degrees."
        },
        "WheelRollAxis": {
          "comment": "Axis around which the wheel rolls."
        },
        "WheelSteering": {
          "comment": "Steering angle of wheel. In degrees."
        },
        "WheelSteeringAxis": {
          "comment": "Axis around which wheel steering occurs."
        }
      }
    },
    "SkelControl_CCD_IK": {
      "properties": {
        "IterationsCount": {
          "comment": "Iterations count for last render. Read only."
        },
        "AngleConstraint": {
          "comment": "Joint Angle Constraint"
        },
        "bNoTurnOptimization": {
          "comment": "if TRUE, skip update when turn is negligible."
        },
        "bStartFromTail": {
          "comment": "By default CCD starts at end of chain and goes backwards. If TRUE, do the opposite."
        },
        "MaxAngleSteps": {
          "comment": "Max Angle Steps"
        },
        "MaxPerBoneIterations": {
          "comment": "Loop MaxPerBoneIterations per bone in the chain."
        },
        "NumBones": {
          "comment": "Number of bones above the active one in the hierarchy to modify and apply CCD IK."
        },
        "Precision": {
          "comment": "Error tolerance to consider IK Target reached, in squared units."
        },
        "EffectorLocation": {
          "comment": "Where you want the controlled bone to be. Will be placed as close as possible within the constraints of the limb."
        },
        "EffectorLocationSpace": {
          "comment": "Reference frame that the DesiredLocation is defined in."
        },
        "EffectorSpaceBoneName": {
          "comment": "Name of bone used if DesiredLocationSpace is BCS_OtherBoneSpace."
        },
        "EffectorTranslationFromBone": {
          "comment": "Translation from bone"
        }
      }
    },
    "SkelControl_Multiply": {
      "properties": {
        "Multiplier": {
          "comment": "How much to scale the angle"
        }
      }
    },
    "SkelControl_TwistBone": {
      "properties": {
        "SourceBoneName": {
          "comment": "Name of source bone to use. For a forearm twist, that would be the hand bone name."
        },
        "TwistAngleScale": {
          "comment": "How much to scale down the roll angle"
        }
      }
    },
    "SkeletalMesh": {
      "properties": {
        "bHasVertexColors": {
          "comment": "Whether or not the mesh has vertex colors"
        },
        "CachedSoftBodyMeshes": {
          "comment": "Cache of pointers to NxSoftBodyMesh objects at different scales."
        },
        "CachedSoftBodyMeshScales": {
          "comment": "Scale of each of the NxSoftBodyMesh objects in cache. This array is same size as CachedSoftBodyMeshes."
        },
        "CachedStreamingTextureFactors": {
          "comment": "The cached streaming texture factors. If the array doesn't have MAX_TEXCOORDS entries in it, the cache is outdated."
        },
        "ClothIndexBuffer": {
          "comment": "Index buffer for simulation cloth."
        },
        "ClothMesh": {
          "comment": "Cache of ClothMesh objects at different scales."
        },
        "ClothMeshScale": {
          "comment": "Scale of each of the ClothMesh objects in cache. This array is same size as ClothMesh."
        },
        "ClothMovementScale": {
          "comment": "Scaling (per vertex) for how far cloth vert can move from its animated position"
        },
        "ClothToGraphicsVertMap": {
          "comment": "Mapping between each vertex in the simulation mesh and the graphics mesh. \n This is ordered so that 'free' vertices are first, and then after NumFreeClothVerts they are 'fixed' to the skinned mesh."
        },
        "ClothTornTriMap": {
          "comment": "Map which maps from a set of 3 triangle indices packet in a 64bit to the location in the index buffer,\n Used to update indices for torn triangles.\n Note: This structure is lazy initialized when a torn cloth mesh is created. (But could be precomputed\n in BuildClothMapping() if serialization is handled correctly)."
        },
        "ClothWeldedIndices": {
          "comment": "This will hold the indices to the reduced number of cloth vertices used for cooking the NxClothMesh."
        },
        "ClothWeldingDomain": {
          "comment": "This is the highest value stored in ClothWeldingMap"
        },
        "ClothWeldingMap": {
          "comment": "Mapping from index of rendered mesh to index of simulated mesh.\n This mapping applies before ClothToGraphicsVertMap which can then operate normally\n The reason for this mapping is to weld several vertices with the same position but different texture coordinates into one\n simulated vertex which makes it possible to run closed meshes for cloth."
        },
        "GraphicsIndexIsCloth": {
          "comment": "Saves if Graphics Vertex is simulated cloth or not"
        },
        "NumFreeClothVerts": {
          "comment": "Point in the simulation cloth vertex array where the free verts finish and we start having 'fixed' verts."
        },
        "PerPolyBoneKDOPs": {
          "comment": "KDOP tree's used for storing rigid triangle information for a subset of bones.\n Length of this array matches PerPolyCollisionBones"
        },
        "SkelMeshRUID": {
          "comment": "Runtime UID for this SkeletalMeshm, used when linking meshes to AnimSets."
        },
        "SoftBodySurfaceIndices": {
          "comment": "Index buffer of the triangles of the soft-body's surface mesh. Indices refer to entries in SoftBodySurfaceToGraphicsVertMap."
        },
        "SoftBodySurfaceToGraphicsVertMap": {
          "comment": "Mapping between each vertex of the simulated soft-body's surface-mesh and the graphics mesh."
        },
        "SoftBodyTetraIndices": {
          "comment": "Index buffer of the tetrahedra of the soft-body's tetra-mesh. Indices refer to the vertices in SoftBodyTetraVertsUnscaled."
        },
        "SoftBodyTetraLinks": {
          "comment": "Mapping between each vertex of the surface-mesh and its tetrahedron, with local positions given in barycentric coordinates."
        },
        "SoftBodyTetraVertsUnscaled": {
          "comment": "Base array of tetrahedron vertex positions. Used to generate the scaled versions from."
        },
        "bEnableClothBendConstraints": {
          "comment": "Enable constraints that attempt to minimize curvature or folding of the cloth."
        },
        "bEnableClothDamping": {
          "comment": "Enable damping forces on the cloth."
        },
        "bEnableClothLineChecks": {
          "comment": "Enable cloth line/extent/point checks. \n Note: line checks are performed with a raycast against the cloth, but point and swept extent checks are performed against the cloth AABB"
        },
        "bEnableClothTearing": {
          "comment": "Used to enable cloth tearing. Note, extra vertices/indices must be reserved using ClothTearReserve \n Also cloth tearing is not available when welding is enabled."
        },
        "bEnableValidBounds": {
          "comment": "Any cloth vertex that exceeds its valid bounds will be deleted if bEnableValidBounds is set. Tune ValidBoundMin and ValidBoundMax if valid bound is enabled."
        },
        "bHardStretchLimit": {
          "comment": "If TRUE, limit the total amount of stretch that is allowed in the cloth, based on HardStretchLimitFactor. \n Note that bLimitClothToAnimMesh must be TRUE for this to work."
        },
        "bLimitClothToAnimMesh": {
          "comment": "If TRUE, simulated verts are limited to a certain distance from"
        },
        "bUseClothCOMDamping": {
          "comment": "Enable center of mass damping of cloth internal velocities."
        },
        "ClothBendStiffness<UIMin=0.0|UIMax=1.0|ClampMin=0.0|ClampMax=1.0>": {
          "comment": "Controls strength of springs that stop the cloth from bending. \n bEnableClothBendConstraints must be true to take affect."
        },
        "ClothBones": {
          "comment": "Vertices with any weight to these bones are considered 'cloth'."
        },
        "ClothDamping<UIMin=0.0|UIMax=1.0|ClampMin=0.0|ClampMax=1.0>": {
          "comment": "Controls how much damping force is applied to cloth particles.\n bEnableClothDamping must be true to take affect."
        },
        "ClothDensity": {
          "comment": "This is multiplied by the size of triangles sharing a point to calculate the points mass.\n This cannot be modified after the cloth has been created."
        },
        "ClothFriction<UIMin=0.0|UIMax=1.0|ClampMin=0.0|ClampMax=1.0>": {
          "comment": "Controls movement of cloth when in contact with other bodies."
        },
        "ClothHierarchicalIterations": {
          "comment": "If ClothHierarchyLevels is more than 0, this number controls the number of iterations of the hierarchical solver."
        },
        "ClothHierarchyLevels": {
          "comment": "If greater than 1, will generate smaller meshes internally, used to improve simulation time and reduce stretching."
        },
        "ClothIterations": {
          "comment": "Increasing the number of solver iterations improves how accurately the cloth is simulated, but will also slow down simulation."
        },
        "ClothMovementScaleGenMode": {
          "comment": "Method to use to generate the ClothMovementScale table"
        },
        "ClothStretchStiffness<UIMin=0.0|UIMax=1.0|ClampMin=0.0|ClampMax=1.0>": {
          "comment": "Controls strength of springs that attempts to keep particles in the cloth together."
        },
        "ClothTearFactor": {
          "comment": "Stretch factor beyond which a cloth edge/vertex will tear. Should be greater than 1."
        },
        "ClothTearReserve": {
          "comment": "Number of vertices/indices to set aside to accomodate new triangles created as a result of tearing"
        },
        "ClothThickness": {
          "comment": "How thick the cloth is considered when doing collision detection."
        },
        "ClothToAnimMeshMaxDist": {
          "comment": "How far a simulated vertex can move from its animated location"
        },
        "HardStretchLimitFactor": {
          "comment": "If bHardStretchLimit is TRUE, how much stretch is allowed in the cloth. 1.0 is no stretch (but will cause jitter)"
        },
        "ValidBoundsMax": {
          "comment": "The maximum coordinates triplet of the cloth valid bound"
        },
        "ValidBoundsMin": {
          "comment": "The minimum coordinates triplet of the cloth valid bound"
        },
        "bClothMetal": {
          "comment": "Whether cloth simulation should be wrapped inside a Rigid Body and only be used upon impact"
        },
        "bEnableClothOrthoBendConstraints": {
          "comment": "Enable orthogonal bending resistance to minimize curvature or folding of the cloth. \n This technique uses angular springs instead of distance springs as used in\n 'bEnableClothBendConstraints'. This mode is slower but independent of stretching resistance."
        },
        "bEnableClothPressure": {
          "comment": "Enables pressure support. Simulates inflated objects like balloons."
        },
        "bEnableClothSelfCollision": {
          "comment": "Enables cloth self collision."
        },
        "bEnableClothTwoWayCollision": {
          "comment": "Enables two way collision with rigid-bodies."
        },
        "bForceNoWelding": {
          "comment": "Forces the Welding Code to be turned off even if the mesh has doubled vertices"
        },
        "ClothAttachmentResponseCoefficient": {
          "comment": "How much an attachment to a rigid body influences the cloth"
        },
        "ClothAttachmentTearFactor": {
          "comment": "How much extension an attachment can undergo before it tears/breaks"
        },
        "ClothCollisionResponseCoefficient": {
          "comment": "Response coefficient for cloth/rb collision"
        },
        "ClothMetalImpulseThreshold": {
          "comment": "Threshold for when deformation is allowed"
        },
        "ClothMetalMaxDeformationDistance": {
          "comment": "Maximum deviation of cloth particles from initial position"
        },
        "ClothMetalPenetrationDepth": {
          "comment": "Amount by which colliding objects are brought closer to the cloth"
        },
        "ClothPressure": {
          "comment": "Adjusts the internal \"air\" pressure of the cloth. Only has affect when bEnableClothPressure."
        },
        "ClothRelativeGridSpacing": {
          "comment": "Controls the size of the grid cells a cloth is divided into when performing broadphase collision. \n The cell size is relative to the AABB of the cloth."
        },
        "ClothSleepLinearVelocity": {
          "comment": "Maximum linear velocity at which cloth can go to sleep.\n If negative, the global default will be used."
        },
        "ClothSpecialBones": {
          "comment": "Vertices with any weight to these bones are considered cloth with special behavoir, currently\n they are attached to the physics asset with fixed or breakable attachments or tearlines."
        },
        "AddToParentPerPolyCollisionBone": {
          "comment": "For each of these bones, find the parent that is in PerPolyCollisionBones and add its polys to that bone."
        },
        "bForceCPUSkinning": {
          "comment": "All meshes default to GPU skinning. Set to True to enable CPU skinning. If CPU skinning is enabled, bUsePackedPosition can't be enabled"
        },
        "BoneBreakNames": {
          "comment": "Array of bone names that break for use in game/editor"
        },
        "BoneBreakOptions": {
          "comment": "Match with BoneBreakNames array"
        },
        "BoundsPreviewAsset": {
          "comment": "Asset used for previewing bounds in AnimSetViewer. Makes setting up LOD distance factors more reliable."
        },
        "bPerPolyUseSoftWeighting": {
          "comment": "If true, include triangles that are soft weighted to bones."
        },
        "bUseFullPrecisionUVs": {
          "comment": "If true, use 32 bit UVs. If false, use 16 bit UVs to save memory"
        },
        "bUseSimpleBoxCollision": {
          "comment": "If true, use PhysicsAsset for extent (swept box) collision checks. If false, use per-poly bone collision (if present)."
        },
        "bUseSimpleLineCollision": {
          "comment": "If true, use PhysicsAsset for line collision checks. If false, use per-poly bone collision (if present)."
        },
        "ClothingAssets": {
          "comment": "List of clothing assets associated with each material int this mesh."
        },
        "FaceFXAsset": {
          "comment": "The FaceFX asset the skeletal mesh uses for FaceFX operations."
        },
        "LODBiasPC": {
          "comment": "LOD bias to use for PC."
        },
        "LODBiasPS3": {
          "comment": "LOD bias to use for PS3."
        },
        "LODBiasXbox360": {
          "comment": "LOD bias to use for Xbox 360."
        },
        "LODInfo": {
          "comment": "Struct containing information for each LOD level, such as materials to use, whether to cast shadows, and when use the LOD."
        },
        "Materials": {
          "comment": "List of materials applied to this mesh."
        },
        "Origin": {
          "comment": "Origin in original coordinate system"
        },
        "PerPolyCollisionBones": {
          "comment": "For each bone specified here, all triangles rigidly weighted to that bone are entered into a kDOP, allowing per-poly collision checks."
        },
        "PreviewMorphSets": {
          "comment": "Asset used for previewing morph target animations in AnimSetViewer. Only for editor."
        },
        "RotOrigin": {
          "comment": "Amount to rotate when importing (mostly for yawing)"
        },
        "SkelMirrorTable": {
          "comment": "List of bones that should be mirrored."
        },
        "SourceFilePath": {
          "comment": "Path to the resource used to construct this skeletal mesh"
        },
        "SourceFileTimestamp": {
          "comment": "Date/Time-stamp of the file from the last import"
        },
        "StreamingDistanceMultiplier": {
          "comment": "Allows artists to adjust the distance where textures using UV 0 are streamed in/out.\n 1.0 is the default, whereas a higher value increases the streamed-in resolution."
        },
        "bEnableSoftBodyDamping": {
          "comment": "Enable damping forces on the softbody."
        },
        "bEnableSoftBodyLineChecks": {
          "comment": "Enable soft body line checks."
        },
        "bEnableSoftBodySelfCollision": {
          "comment": "Enables soft-body self collision."
        },
        "bEnableSoftBodyTwoWayCollision": {
          "comment": "Enables two way collision with rigid-bodies."
        },
        "bSoftBodyIsoSurface": {
          "comment": "If enabled, an iso-surface is generated around the original graphics-mesh before\n the tetrahedron-mesh is created."
        },
        "bUseSoftBodyCOMDamping": {
          "comment": "Enable center of mass damping of SoftBody internal velocities."
        },
        "SoftBodyAttachmentResponse": {
          "comment": "Defines a factor for the impulse transfer from the soft body to attached rigid bodies. \n bEnableSoftBodyTwoWayCollision must be true to take effect."
        },
        "SoftBodyAttachmentTearFactor": {
          "comment": "How much extension an attachment can undergo before it tears/breaks"
        },
        "SoftBodyAttachmentThreshold": {
          "comment": "Specifies the maximum distance a tetra-vertex is allowed to have from the \n surface-mesh to still end up attached to a bone."
        },
        "SoftBodyBones": {
          "comment": "Vertices with any weight to these bones are considered 'soft-body'."
        },
        "SoftBodyCollisionResponse": {
          "comment": "Defines a factor for the impulse transfer from the soft body to colliding rigid bodies. \n bEnableSoftBodyTwoWayCollision must be true to take effect."
        },
        "SoftBodyDamping": {
          "comment": "Controls how much damping force is applied to soft-body particles.\n bEnableSoftBodyDamping must be true to take affect."
        },
        "SoftBodyDensity": {
          "comment": "Density of the soft-body (mass per volume)."
        },
        "SoftBodyDetailLevel<ClampMin=0.0|ClampMax=1.0>": {
          "comment": "Controls how much the original graphics mesh is simplified before it is used\n to seed to tetrahedron-mesh generator."
        },
        "SoftBodyFriction": {
          "comment": "Controls movement of soft-body when in contact with other bodies."
        },
        "SoftBodyParticleRadius": {
          "comment": "Size of the soft-body particles used for collision detection."
        },
        "SoftBodyRelativeGridSpacing": {
          "comment": "Controls the size of the grid cells a soft-body is divided into when performing broadphase collision. \n The cell size is relative to the AABB of the soft-body."
        },
        "SoftBodySleepLinearVelocity": {
          "comment": "Maximum linear velocity at which a soft-body can go to sleep.\n If negative, the global default will be used."
        },
        "SoftBodySolverIterations": {
          "comment": "Increasing the number of solver iterations improves how accurately the soft-body is simulated, but will also slow down simulation."
        },
        "SoftBodySpecialBones": {
          "comment": "Vertices with any weight to these bones are considered softbody with special behavoir, currently\n they are attached to the physics asset with fixed or breakable attachments."
        },
        "SoftBodyStretchingStiffness": {
          "comment": "Defines how strongly the soft-body resists stretching motions. Range (0,1]."
        },
        "SoftBodySubdivisionLevel<ClampMin=1.0>": {
          "comment": "Controls how many tetrahedra are generated to approximate the surface-mesh."
        },
        "SoftBodyVolumeStiffness": {
          "comment": "Defines how strongly the soft-body resists motion that changes the rest volume. Range (0,1]."
        }
      },
      "structs": {
        "BoneMirrorExport": {
          "comment": "Structure to export/import bone mirroring information"
        },
        "BoneMirrorInfo": {
          "properties": {
            "BoneFlipAxis": {
              "comment": "Axis the bone is mirrored across."
            },
            "SourceIndex<ArrayClamp=RefSkeleton>": {
              "comment": "The bone to mirror."
            }
          }
        },
        "ClothSpecialBoneInfo": {
          "comment": "Used to specify a set of special cloth bones which are attached to the physics asset",
          "properties": {
            "AttachedVertexIndices": {
              "comment": "Array used to cache cloth indices which will be attached to this bone, created in BuildClothMapping(),\n Note: These are welded indices."
            },
            "BoneName": {
              "comment": "The bone name to attach to a cloth vertex"
            },
            "BoneType": {
              "comment": "The type of attachment"
            }
          }
        },
        "SkeletalMeshLODInfo": {
          "comment": "Struct containing information for a particular LOD level, such as materials and info for when to use it.",
          "properties": {
            "bDisableCompressions": {
              "comment": "Use compressed position XYZs(4 bytes saving 8 bytes). This is only useful for GPU skinning."
            },
            "bEnableShadowCasting": {
              "comment": "Per-section control over whether to enable shadow casting."
            },
            "DisplayFactor": {
              "comment": "Indicates when to use this LOD. A smaller number means use this LOD when further away."
            },
            "LODHysteresis": {
              "comment": "Used to avoid 'flickering' when on LOD boundary. Only taken into account when moving from complex->simple."
            },
            "LODMaterialMap": {
              "comment": "Mapping table from this LOD's materials to the SkeletalMesh materials array."
            },
            "TriangleSorting": {
              "comment": "Per-section sorting options"
            }
          }
        },
        "SoftBodySpecialBoneInfo": {
          "comment": "Used to specify a set of special softbody bones which are attached to the physics asset",
          "properties": {
            "AttachedVertexIndices": {
              "comment": "Array used to cache softbody indices which will be attached to this bone, created in BuildSoftBodyMapping(),\n Note: These are welded indices."
            },
            "BoneName": {
              "comment": "The bone name to attach to a cloth vertex"
            },
            "BoneType": {
              "comment": "The type of attachment"
            }
          }
        },
        "TriangleSortSettings": {
          "comment": "Struct containing triangle sort settings for a particular section"
        }
      }
    },
    "SkeletalMeshActor": {
      "properties": {
        "bCollideActors_OldValue": {
          "comment": "mirror of bCollideActors used for backwards compatibility with change of default bCollideActors to FALSE\n we save the value in previous package versions into this property instead and copy back\n thus preserving the value of the property in old content regardless of whether they modified it"
        },
        "InterpGroupList": {
          "comment": "List of Matinee InterpGroup controlling this actor."
        },
        "ReplicatedMaterial": {
          "comment": "used to replicate the material in index 0"
        },
        "ReplicatedMesh": {
          "comment": "Used to replicate mesh to clients"
        },
        "SavedAnimSeqName": {
          "comment": "This is only editor only, when exiting Matinee, it should preserve previous position"
        },
        "bForceSaveInCheckpoint": {
          "comment": "@hack: force saving positional data in checkpoint - some uses in Matinee require this"
        },
        "bShouldDoAnimNotifies": {
          "comment": "Whether or not this actor should respond to anim notifies - CURRENTLY ONLY AFFECTS PlayParticleEffect NOTIFIE"
        },
        "ControlTargets": {
          "comment": "Set of skel controls to update targets of, based on Actor location"
        }
      },
      "functions": {
        "CreateForceField": {
          "comment": "Called by AnimNotify_ForceField\n Looks for a socket name first then bone name",
          "params": {
            "AnimNotifyData": "The AnimNotify_ForceField which will have all of the various params on it"
          }
        },
        "DoKismetAttachment": {
          "comment": "Performs actual attachment. Can be subclassed for class specific behaviors."
        },
        "FinishAnimControl": {
          "comment": "Called when we are done with the AnimControl track."
        },
        "GetActorFaceFXAsset": {
          "comment": "Used by Matinee in-game to mount FaceFXAnimSets before playing animations."
        },
        "GetFaceFXAudioComponent": {
          "comment": "Used to let FaceFX know what component to play dialogue audio on."
        },
        "IsActorPlayingFaceFXAnim": {
          "comment": "Returns TRUE if this actor is playing a FaceFX anim."
        },
        "MAT_BeginAnimControl": {
          "comment": "Start AnimControl. Add required AnimSets."
        },
        "MAT_FinishAnimControl": {
          "comment": "End AnimControl. Release required AnimSets"
        },
        "OnPlayFaceFXAnim": {
          "comment": "Function for handling the SeqAct_PlayFaceFXAnim Kismet action working on this Actor."
        },
        "OnSetSkelControlTarget": {
          "comment": "Handle action to set skel control target from kismet."
        },
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        },
        "OnUpdatePhysBonesFromAnim": {
          "comment": "Handle action that forces bodies to sync to their animated location"
        },
        "PlayActorFaceFXAnim": {
          "comment": "Handler for Matinee wanting to play FaceFX animations in the game."
        },
        "PlayParticleEffect": {
          "comment": "Called by AnimNotify_PlayParticleEffect\n Looks for a socket name first then bone name",
          "params": {
            "AnimNotifyData": "The AnimNotify_PlayParticleEffect which will have all of the various params on it"
          }
        },
        "SkelMeshActorOnParticleSystemFinished": {
          "comment": "We so we detach the Component once we are done playing it"
        },
        "StopActorFaceFXAnim": {
          "comment": "Handler for Matinee wanting to stop FaceFX animations in the game."
        },
        "TakeDamage": {
          "comment": "Default behaviour when shot is to apply an impulse and kick the KActor."
        },
        "UpdateAnimSetList": {
          "comment": "Update list of AnimSets for this Pawn"
        }
      },
      "structs": {
        "SkelMeshActorControlTarget": {
          "comment": "Struct that stores info to update one skel control with a location target",
          "properties": {
            "ControlName": {
              "comment": "Name of SkelControl to update"
            },
            "TargetActor": {
              "comment": "Actor to use for location of skel control target."
            }
          }
        }
      }
    },
    "SkeletalMeshActorBasedOnExtremeContent": {
      "properties": {
        "ExtremeContent": {
          "comment": "The material to use for ExtremeContent (e.g. blood and gore!)"
        },
        "NonExtremeContent": {
          "comment": "The material to use for NonExtremeContent (e.g. blackness everywhere there used to be blood and gore)"
        }
      },
      "functions": {
        "SetMaterialBasedOnExtremeContent": {
          "comment": "This will set the material of this Actor based on the ExtremeContent setting."
        }
      },
      "structs": {
        "SkelMaterialSetterDatum": {
          "comment": "This is set so the LD can map specific MaterialIndex on the target to some material"
        }
      }
    },
    "SkeletalMeshActorMAT": {
      "comment": "Advanced version of SkeletalMeshCinematicActor which uses an AnimTree instead of having a single AnimNodeSequence defined in its defaultproperties",
      "properties": {
        "SlotNodes": {
          "comment": "Array of Slots"
        }
      },
      "functions": {
        "FinishAnimControl": {
          "comment": "Called when we are done with the AnimControl track."
        },
        "MAT_SetAnimPosition": {
          "comment": "Update AnimTree from track info"
        },
        "MAT_SetAnimWeights": {
          "comment": "Update AnimTree from track weights"
        },
        "SetAnimPosition": {
          "comment": "Called each from while the Matinee action is running, with the desired sequence name and position we want to be at."
        },
        "SetMorphWeight": {
          "comment": "Called each frame by Matinee to update the weight of a particular MorphNodeWeight."
        },
        "SetSkelControlScale": {
          "comment": "Called each frame by Matinee to update the scaling on a SkelControl."
        }
      }
    },
    "SkeletalMeshComponent": {
      "properties": {
        "ActiveCurveMorphs": {
          "comment": "Array indicating all active MorphTargets. This array is updated inside UpdateSkelPose based on the AnimTree's st of MorphNodes."
        },
        "ActiveMorphs": {
          "comment": "Array indicating all active MorphTargets. This array is updated inside UpdateSkelPose based on the AnimTree's st of MorphNodes."
        },
        "AnimAlwaysTickArray": {
          "comment": "Special Array of nodes that should always be ticked, even when not relevant."
        },
        "AnimTickArray": {
          "comment": "Array of all AnimNodes in entire tree, in the order they should be ticked - that is, all parents appear before a child."
        },
        "AnimTickRelevancyArray": {
          "comment": "Anim nodes relevancy status. Matching AnimTickArray size and indices."
        },
        "AnimTickWeightsArray": {
          "comment": "Anim nodes weights. Matching AnimTickArray size and indices."
        },
        "ApexClothing": {
          "comment": "Contains a pointer to the active APEX clothing instance."
        },
        "AttachedToSkelComponent": {
          "comment": "The SkeletalMeshComponent that this one is possibly attached to."
        },
        "bAlwaysUseInstanceWeights": {
          "comment": "If TRUE, always use instanced vertex influences for this mesh"
        },
        "bAnimTreeInitialised": {
          "comment": "If true, AnimTree has been initialised."
        },
        "bCacheAnimSequenceNodes": {
          "comment": "Should anim sequence nodes cache the calculated values when not actually playing an animation?"
        },
        "bCanHighlightSelectedSections": {
          "comment": "Whether or not we can highlight selected sections - this should really only be done in the editor"
        },
        "bChartDistanceFactor": {
          "comment": "If true, DistanceFactor for this SkeletalMeshComponent will be added to global chart."
        },
        "bDisableWarningWhenAnimNotFound": {
          "comment": "Disable warning when an AnimSequence is not found. FALSE by default."
        },
        "bDisplayBones": {
          "comment": "Draw the skeleton hierarchy for this skel mesh."
        },
        "bEnableFullAnimWeightBodies": {
          "comment": "Enables blending in of physics bodies with the bAlwaysFullAnimWeight flag set. (e.g. hair and other flappy bits!)"
        },
        "bEnableLineCheckWithBounds": {
          "comment": "If TRUE, line checks will test against the bounding box of this skeletal mesh component and return a hit if there is a collision."
        },
        "bForceMeshObjectUpdate": {
          "comment": "If TRUE, UpdateTransform will always result in a call to MeshObject->Update."
        },
        "bForceRefpose": {
          "comment": "If true, force the mesh into the reference pose - is an optimization."
        },
        "bHasHadPhysicsBlendedIn": {
          "comment": "Used for consistency checking. Indicates that the results of physics have been blended into SpaceBases this frame."
        },
        "bIgnoreControllersWhenNotRendered": {
          "comment": "If true, do not apply any SkelControls when owner has not been rendered recently."
        },
        "bNeedsInstanceWeightUpdate": {
          "comment": "If TRUE, update the instanced vertex influences for this mesh during the next update"
        },
        "bNeedsToDeleteHitMask": {
          "comment": "if TRUE, when detach, send message to renderthread to delete this component from hit mask list"
        },
        "bNotUpdatingKinematicDueToDistance": {
          "comment": "If this is true, we are not updating kinematic bones and motors based on animation because the skeletal mesh is too far from any viewer."
        },
        "bOldForceRefPose": {
          "comment": "If bForceRefPose was set last tick."
        },
        "BoneVisibilityStates": {
          "comment": "Array of bone visibilities (containing one of the values in EBoneVisibilityStatus for each bone). A bone is only visible if it is *exactly* 1 (BVS_Visible)"
        },
        "bOverrideAttachmentOwnerVisibility": {
          "comment": "if set, components that are attached to us have their bOwnerNoSee and bOnlyOwnerSee properties overridden by ours"
        },
        "bPauseAnims": {
          "comment": "pauses this component's animations (doesn't tick them)"
        },
        "bProcessingRootMotion": {
          "comment": "Flag set when processing root motion."
        },
        "bRecentlyRendered": {
          "comment": "TRUE if mesh has been recently rendered, FALSE otherwise"
        },
        "bRMMOneFrameDelay": {
          "comment": "Handle one frame delay with PendingRMM"
        },
        "bRootMotionExtractedNotify": {
          "comment": "if TRUE, the event RootMotionExtracted() will be called on this owning actor,\n after root motion has been extracted, and before it's been used.\n This notification can be used to alter extracted root motion before it is forwarded to physics."
        },
        "bRootMotionModeChangeNotify": {
          "comment": "if TRUE, notify owning actor of root motion mode changes.\n This calls the Actor.RootMotionModeChanged() event.\n This is useful for synchronizing movements.\n For intance, when using RMM_Translate, and the event is called, we know that root motion will kick in on next frame.\n It is possible to kill in-game physics, and then use root motion seemlessly."
        },
        "bShowPrePhysBones": {
          "comment": "Bool that enables debug drawing of the skeleton before it is passed to the physics. Useful for debugging animation-driven physics."
        },
        "bSkelCompFixed": {
          "comment": "Indicates whether this SkeletalMeshComponent is currently considered 'fixed' (ie kinematic)"
        },
        "bSkipAllUpdateWhenPhysicsAsleep": {
          "comment": "When true, if owned by a PHYS_RigidBody Actor, skip all update (bones and bounds) when physics are asleep. This is a very top level\n optimization flag for things we know are just physics (e.g. Kassets). Lots of things have physics on them that are asleep while the\n actor moves around the level and then are woken up. Setting this flag to true will stop those actors from having any updates which is not\n what we want in the general case."
        },
        "bSkipInitClothing": {
          "comment": "Don't attempt to initialize clothing when component is attached"
        },
        "bTickAnimNodesWhenNotRendered": {
          "comment": "If true, tick anim nodes even when our Owner has not been rendered recently"
        },
        "bUpdateComposeSkeletonPasses": {
          "comment": "TRUE if it needs to rebuild the required bones array for multi pass compose"
        },
        "bUpdatedFixedClothVerts": {
          "comment": "Whether we've updated fixed cloth verts since last attachment."
        },
        "bUseRawData": {
          "comment": "If TRUE, force usage of raw animation data when animating this skeletal mesh; if FALSE, use compressed data."
        },
        "bUseSingleBodyPhysics": {
          "comment": "Only instance Root Bone rigid body for physics. Mostly used by Vehicles.\n Other Rigid Bodies are ignored for physics, but still considered for traces."
        },
        "bValidTemporarySavedAnimSets": {
          "comment": "Flag to remember if cache saved is valid or not to make sure Save/Restore always happens with a pair"
        },
        "CachedFaceFXAudioComp": {
          "comment": "The audio component that we are using to play audio for a facial animation.\n Assigned in PlayFaceFXAnim and cleared in StopFaceFXAnim."
        },
        "CachedLocalAtoms": {
          "comment": "Cached Bones, for performance."
        },
        "ClothDirtyBufferFlag": {
          "comment": "flags to indicate which buffers were recently updated by the cloth simulation."
        },
        "ClothDynamicBlendWeight": {
          "comment": "Cloth blend weight, controlled by distance from camera."
        },
        "ClothMeshParentData": {
          "comment": "Cloth parent indices contain the index of the original vertex when a vertex is created during tearing.\n If it is an original vertex then the parent index is the same as the vertex index."
        },
        "ClothMeshWeldedPosData": {
          "comment": "buffers used for reverse lookups to unweld vertices to support wrapped UVs."
        },
        "ComposeOrderedRequiredBones": {
          "comment": "Required Bones array, re-ordered for 3 pass skeleton composing"
        },
        "CustomSortAlternateIndexMode": {
          "comment": "Editor only. Used for manually selecting the alternate indices for\n TRISORT_CustomLeftRight sections."
        },
        "FaceFXActorInstance": {
          "comment": "The FaceFX actor instance associated with the skeletal mesh component."
        },
        "FramesPhysicsAsleep": {
          "comment": "Used to keep track of how many frames physics has been asleep for (when using PHYS_RigidBody)."
        },
        "FrozenLocalToWorldPos": {
          "comment": "The state of the LocalToWorld pos at the point the cloth was frozen."
        },
        "FrozenLocalToWorldRot": {
          "comment": "The state of the LocalToWorld rotation at the point the cloth was frozen."
        },
        "LastClothLocation": {
          "comment": "Last location of our owner/base for checking MinDistanceForClothReset."
        },
        "LineCheckBoundsScale": {
          "comment": "If bEnableLineCheckWithBounds is TRUE, scale the bounds by this value before doing line check."
        },
        "LocalAtoms": {
          "comment": "Temporary array of local-space (ie relative to parent bone) rotation/translation for each bone."
        },
        "LocalToWorldBoneAtom": {
          "comment": "Cache of LocalToWorld BoneAtom."
        },
        "LowUpdateFrameRate": {
          "comment": "When updated at low frequency, rate of update.\n For example if set to 3, animations will be updated once every three frames.\n if games runs at 30 FPS, that's 10 FPS."
        },
        "MaxDistanceFactor": {
          "comment": "High (best) DistanceFactor that was desired for rendering this SkeletalMesh last frame. Represents how big this mesh was in screen space"
        },
        "MinDistFactorForKinematicUpdate": {
          "comment": "If non-zero, skeletal mesh component will not update kinematic bones and bone springs when distance factor is greater than this (or has not been rendered for a while).\n This also turns off BlockRigidBody, so you do not get collisions with 'left behind' ragdoll setups. Items will fall through\n the world if you move too far away from them and they are in RigigBody."
        },
        "MorphTargetIndexMap": {
          "comment": "Map of morph target to name"
        },
        "NumSoftBodyTetraIndices": {
          "comment": "Number of tetrahedron indices of the soft-body mesh (equal to four times the number of tetrahedra)."
        },
        "NumSoftBodyTetraVerts": {
          "comment": "Number of tetrahedron vertices of the soft-body mesh."
        },
        "ParentBoneMap": {
          "comment": "Mapping between bone indices in this component and the parent one. Each element is the index of the bone in the ParentAnimComponent.\n Size should be the same as SkeletalMesh.RefSkeleton size (ie number of bones in this skeleton)."
        },
        "PhysicsAssetInstance": {
          "comment": "Any instanced physics engine information for this SkeletalMeshComponent.\n This is only required when you want to run physics or you want physical interaction with this skeletal mesh."
        },
        "PreviousRMM": {
          "comment": "Previous Root Motion Mode, to catch changes"
        },
        "ProgressiveDrawingFraction": {
          "comment": "Editor only. Used for visualizing drawing order in Animset Viewer. If < 1.0,\n only the specified fraction of triangles will be rendered"
        },
        "RequiredBones": {
          "comment": "Temporary array of bone indices required this frame. Filled in by UpdateSkelPose."
        },
        "RootBoneTranslation": {
          "comment": "Offset of the root bone from the reference pose.\n Used to offset bounding box."
        },
        "RootMotionAccelScale": {
          "comment": "Scale applied in physics when RootMotionMode == RMM_Accel"
        },
        "RootMotionDelta": {
          "comment": "Root Motion extracted from animation."
        },
        "RootMotionVelocity": {
          "comment": "Root Motion velocity for this frame, set from RootMotionDelta."
        },
        "SkelControlTickArray": {
          "comment": "Linear Array for ticking SkelControls faster"
        },
        "SoftBodyASVPlane": {
          "comment": "Pointer to the Novodex plane-actor used when previewing the soft-body in the AnimSet Editor."
        },
        "SoftBodySceneIndex": {
          "comment": "Index of the Novodex scene the soft-body resides in."
        },
        "SoftBodySim": {
          "comment": "Pointer to the simulated NxSoftBody object."
        },
        "SoftBodyTetraIndexData": {
          "comment": "Buffer of the updated tetrahedron-indices."
        },
        "SoftBodyTetraPosData": {
          "comment": "Buffer of the updated tetrahedron-vertex positions."
        },
        "SpaceBases": {
          "comment": "Temporary array of of component-space bone matrices, update each frame and used for rendering the mesh."
        },
        "TemporarySavedAnimSets": {
          "comment": "Temporary array of AnimSets that are used as a backup target when the engine needs to temporarily modify the\n actor's animation set list. (e.g. Matinee playback)"
        },
        "ApexClothingCollisionRBChannel": {
          "comment": "Enum indicating what channel the apex clothing collision shapes should be placed in"
        },
        "ApexClothingRBChannel": {
          "comment": "Enum indicating what type of object this apex clothing should be considered for rigid body collision."
        },
        "ApexClothingRBCollideWithChannels": {
          "comment": "Types of objects that this clothing will collide with."
        },
        "bAutoFreezeApexClothingWhenNotRendered": {
          "comment": "If true, the clothing actor will stop simulating when it is not rendered"
        },
        "bLocalSpaceWind": {
          "comment": "If TRUE, WindVelocity is applied in the local space of the component, rather than world space."
        },
        "WindVelocity": {
          "comment": "The Wind Velocity applied to Apex Clothing"
        },
        "WindVelocityBlendTime": {
          "comment": "Time taken for ApexClothing to reach WindVelocity"
        },
        "bAttachClothVertsToBaseBody": {
          "comment": "If true, fixed verts of the cloth are attached in the physics to the physics body that this components actor is attached to."
        },
        "bAutoFreezeClothWhenNotRendered": {
          "comment": "If true, cloth will automatically have bClothFrozen set when it is not rendered, and have it turned off when it is seen."
        },
        "bClothAwakeOnStartup": {
          "comment": "If true, cloth will be awake when a level is started, otherwise it will be instantly put to sleep."
        },
        "bClothBaseVelClamp": {
          "comment": "It true, clamp velocity of cloth particles to be within ClothBaseVelClampRange of Base velocity."
        },
        "bClothBaseVelInterp": {
          "comment": "It true, interp velocity of cloth particles towards Base velocity, using ClothBaseVelClampRange as the interp rate (0..1)."
        },
        "bClothFrozen": {
          "comment": "If true, cloth is 'frozen' and no simulation is taking place for it, though it will keep its shape."
        },
        "bClothPositionalDampening": {
          "comment": "Whether should do positional box dampening"
        },
        "bClothUseCompartment": {
          "comment": "If TRUE, soft body uses compartment in physics scene (usually with fixed timstep for better behaviour)"
        },
        "bClothWindRelativeToOwner": {
          "comment": "Whether wind direction is relative to owner rotation or not"
        },
        "bDisableClothCollision": {
          "comment": "Turns off all cloth collision so not checks are done (improves performance)."
        },
        "bEnableClothSimulation": {
          "comment": "Whether cloth simulation should currently be used on this SkeletalMeshComponent.\n @see SetEnableClothSimulation"
        },
        "bIsClothOnStaticObject": {
          "comment": "Whether this cloth is on a non-animating static object."
        },
        "ClothAttachmentTearFactor": {
          "comment": "The cloth tear factor for this SkeletalMeshComponent, negative values take the tear factor from the SkeletalMesh.\nNote: UpdateClothParams() should be called after modification so that the changes are reflected in the simulation."
        },
        "ClothBaseVelClampRange": {
          "comment": "If bClothBaseVelClamp is TRUE, amount of variance from base's velocity the cloth is allowed.\n If bClothBaseVelInterp is TRUE, how fast cloth verts are pushed towards base velocity (0..1)"
        },
        "ClothBlendMaxDistanceFactor": {
          "comment": "Distance factor above which cloth should be fully simulated."
        },
        "ClothBlendMinDistanceFactor": {
          "comment": "Distance factor below which cloth should be fully animated. -1.0 indicates always physics."
        },
        "ClothBlendWeight": {
          "comment": "How much to blend in results from cloth simulation with results from regular skinning."
        },
        "ClothExternalForce": {
          "comment": "Constant force applied to all vertices in the cloth."
        },
        "ClothForceScale": {
          "comment": "How much force to apply to cloth, in relation to the force(from a force field) applied to rigid bodies(zero applies no force to cloth, 1 applies the same)"
        },
        "ClothImpulseScale": {
          "comment": "Amount to scale impulses applied to cloth simulation."
        },
        "ClothRBChannel": {
          "comment": "Enum indicating what type of object this cloth should be considered for rigid body collision."
        },
        "ClothRBCollideWithChannels": {
          "comment": "Types of objects that this cloth will collide with."
        },
        "ClothWind": {
          "comment": "'Wind' force applied to cloth. Force on each vertex is based on the dot product between the wind vector and the surface normal."
        },
        "MaxPosDampRange": {
          "comment": "Distance from the owner in relative frame (max == pos XYZ, min == neg XYZ)"
        },
        "MaxPosDampScale": {
          "comment": "Dampening scale applied to cloth particle velocity when approaching boundaries of *PosDampRange"
        },
        "MinDistanceForClothReset": {
          "comment": "If the distance traveled between frames exceeds this value the vertices will be reset to avoid stretching."
        },
        "MinPosDampRange": {
          "comment": "Distance from the owner in relative frame (max == pos XYZ, min == neg XYZ)"
        },
        "MinPosDampScale": {
          "comment": "Dampening scale applied to cloth particle velocity when approaching boundaries of *PosDampRange"
        },
        "AnimationLODDistanceFactor": {
          "comment": "If MaxDistanceFactor goes below this value (and it is non 0), start playing animations at a low frame rate"
        },
        "Animations<MaxPropertyDepth=3>": {
          "comment": "This is the unique instance of the AnimTree used by this SkeletalMeshComponent.\n THIS SHOULD NEVER POINT TO AN ANIMTREE IN A CONTENT PACKAGE."
        },
        "AnimRotationOnly": {
          "comment": "SkeletalMeshComponent settings for AnimRotationOnly"
        },
        "AnimSets": {
          "comment": "The set of AnimSets that will be looked in to find a particular sequence, specified by name in an AnimNodeSequence.\n Array is search from last to first element, so you can replace a particular sequence but putting a set containing the new version later in the array.\n You will need to call SetAnim again on nodes that may be affected by any changes you make to this array."
        },
        "AnimTreeTemplate": {
          "comment": "This should point to the AnimTree in a content package.\n BeginPlay on this SkeletalMeshComponent will instance (copy) the tree and assign the instance to the Animations pointer."
        },
        "bConsiderAllBodiesForBounds": {
          "comment": "If TRUE, when updating bounds from a PhysicsAsset, consider _all_ BodySetups, not just those flagged with bConsiderForBounds."
        },
        "bDisableFaceFXMaterialInstanceCreation": {
          "comment": "If true, FaceFX will not automatically create material instances."
        },
        "bForceDiscardRootMotion": {
          "comment": "force root motion to be discarded, no matter what the AnimNodeSequence(s) are set to do"
        },
        "bForceUpdateAttachmentsInTick": {
          "comment": "If true, attachments will be updated twice a frame - once in Tick and again when UpdateTransform is called.\n This can resolve some 'frame behind' issues if an attachment need to be in the correct location for it's Tick, but at a cost."
        },
        "bHasPhysicsAssetInstance": {
          "comment": "Indicates whether this SkeletalMeshComponent should have a physics engine representation of its state.\n @see SetHasPhysicsAssetInstance"
        },
        "bNoSkeletonUpdate": {
          "comment": "Skip UpdateSkelPose."
        },
        "bNotifyRootMotionProcessed": {
          "comment": "Call RootMotionProcessed notification on Owner"
        },
        "bPerBoneMotionBlur": {
          "comment": "If true, use per-bone motion blur on this skeletal mesh."
        },
        "bPerBoneVolumeEffects": {
          "comment": "If true, when this skeletal mesh overlaps a physics volume, each body of it will be tested against the volume, so only limbs\n actually in the volume will be affected. Useful when gibbing bodies."
        },
        "bSyncActorLocationToRootRigidBody": {
          "comment": "If true, will move the Actors Location to match the root rigid body location when in PHYS_RigidBody."
        },
        "bUpdateJointsFromAnimation": {
          "comment": "If we should pass joint position to joints each frame, so that they can be used by motorized joints to drive the\n ragdoll based on the animation."
        },
        "bUpdateKinematicBonesFromAnimation": {
          "comment": "If we are running physics, should we update bFixed bones based on the animation bone positions."
        },
        "bUpdateSkelWhenNotRendered": {
          "comment": "If true, update skeleton/attachments even when our Owner has not been rendered recently\n @note if this is false, bone information may not be accurate, so be careful setting this to false if bone info is relevant to gameplay\n @note you can use ForceSkelUpdate() to force an update\n @note: In the output from SHOWSKELCOMPTICKTIME you want UpdatePoseTotal to be 0 when this is FALSE for a specific component"
        },
        "FaceFXBlendMode": {
          "comment": "How FaceFX transforms should be blended with skeletal mesh"
        },
        "ForcedLodModel": {
          "comment": "If 0, auto-select LOD level. if >0, force to (ForcedLodModel-1)."
        },
        "GlobalAnimRateScale": {
          "comment": "Used to scale speed of all animations on this skeletal mesh."
        },
        "MinLodModel": {
          "comment": "This is the min LOD that this component will use. (e.g. if set to 2 then only 2+ LOD Models will be used.) This is useful to set on\n meshes which are known to be a certain distance away and still want to have better LODs when zoomed in on them."
        },
        "MorphSets": {
          "comment": "Array of MorphTargetSets that will be looked in to find a particular MorphTarget, specified by name.\n It is searched in the same way as the AnimSets array above."
        },
        "ParentAnimComponent": {
          "comment": "If set, this SkeletalMeshComponent will not use its Animations pointer to do its own animation blending, but will\n use the SpaceBases array in the ParentAnimComponent. This is used when constructing a character using multiple skeletal meshes sharing the same\n skeleton within the same Actor."
        },
        "PhysicsAsset": {
          "comment": "Physics and collision information used for this SkeletalMesh, set up in PhAT.\n This is used for per-bone hit detection, accurate bounding box calculation and ragdoll physics for example."
        },
        "PhysicsWeight": {
          "comment": "Influence of rigid body physics on the mesh's pose (0.0 == use only animation, 1.0 == use only physics)"
        },
        "RootMotionRotationMode": {
          "comment": "Apply rotation delta to actor"
        },
        "SkeletalMesh": {
          "comment": "The skeletal mesh used by this component."
        },
        "bAutoFreezeSoftBodyWhenNotRendered": {
          "comment": "If true, the soft-body will automatically have bSoftBodyFrozen set when it is not rendered, and have it turned off when it is seen."
        },
        "bEnableSoftBodySimulation": {
          "comment": "Whether soft-body simulation should currently be used on this SkeletalMeshComponent."
        },
        "bSoftBodyAwakeOnStartup": {
          "comment": "If true, the soft-body will be awake when a level is started, otherwise it will be instantly put to sleep."
        },
        "bSoftBodyFrozen": {
          "comment": "If true, the soft-body is 'frozen' and no simulation is taking place for it, though it will keep its shape."
        },
        "bSoftBodyUseCompartment": {
          "comment": "If TRUE, soft body uses compartment in physics scene (usually with fixed timstep for better behaviour)"
        },
        "SoftBodyImpulseScale": {
          "comment": "Amount to scale impulses applied to soft body simulation."
        },
        "SoftBodyRBChannel": {
          "comment": "Enum indicating what type of object this soft-body should be considered for rigid body collision."
        },
        "SoftBodyRBCollideWithChannels": {
          "comment": "Types of objects that this soft-body will collide with."
        }
      },
      "functions": {
        "AddInstanceVertexWeightBoneParented": {
          "comment": "Add a new bone to the list of instance vertex weight bones",
          "params": {
            "BoneNames": "set of bones (implicitly parented) to use for finding vertices"
          }
        },
        "AllAnimNodes": {
          "comment": "returns all AnimNodes in the animation tree that are the specfied class or a subclass",
          "params": {
            "BaseClass": "base class to return",
            "Node": "(out) the returned AnimNode for each iteration"
          }
        },
        "AttachComponentToSocket": {
          "comment": "Attach an ActorComponent to a Socket."
        },
        "AttachedComponents": {
          "comment": "returns all attached components that are of the specified class or a subclass",
          "params": {
            "BaseClass": "the base class of ActorComponent to return",
            "(out)": "OutComponent the returned ActorComponent for each iteration"
          }
        },
        "BoneIsChildOf": {
          "comment": "Tests if BoneName is child of (or equal to) ParentBoneName.\n Note - will return FALSE if ChildBoneIndex is the same as ParentBoneIndex ie. must be strictly a child."
        },
        "BreakConstraint": {
          "comment": "Break a constraint off a Gore mesh."
        },
        "CreateForceField": {
          "comment": "Called by AnimNotify_ForceField\n Looks for a socket name first then bone name",
          "params": {
            "AnimNotifyData": "The AnimNotify_ForceField which will have all of the various params on it"
          }
        },
        "DeclareFaceFXRegister": {
          "comment": "Declare a new register in the FaceFX register system. This is required"
        },
        "FindAnimNode": {
          "comment": "Find an Animation Node in the Animation Tree whose NodeName matches InNodeName.\n Warning: The search is O(n), so for large AnimTrees, cache result."
        },
        "FindAnimSequence": {
          "comment": "Find a named AnimSequence from the AnimSets array in the SkeletalMeshComponent.\n This searches array from end to start, so specific sequence can be replaced by putting a set containing a sequence with the same name later in the array.",
          "params": {
            "AnimSeqName": "Name of AnimSequence to look for."
          }
        },
        "FindBodyInstanceNamed": {
          "comment": "Find a BodyInstance by BoneName"
        },
        "FindClosestBone": {
          "comment": "finds the closest bone to the given location",
          "params": {
            "TestLocation": "the location to test against",
            "BoneLocation": "(optional, out) if specified, set to the world space location of the bone that was found, or (0,0,0) if no bone was found",
            "IgnoreScale": "(optional) if specified, only bones with scaling larger than the specified factor are considered"
          }
        },
        "FindComponentAttachedToBone": {
          "comment": "Returns component attached to specified BoneName. (returns the first entry found).",
          "params": {
            "BoneName": "Bone Name to look up."
          }
        },
        "FindInstanceVertexweightBonePair": {
          "comment": "Find an existing bone pair entry in the list of InstanceVertexWeightBones",
          "params": {
            "Bones": "pair of bones to search for"
          }
        },
        "FindMorphTarget": {
          "comment": "Find a named MorphTarget from the MorphSets array in the SkeletalMeshComponent.\n This searches the array in the same way as FindAnimSequence",
          "params": {
            "AnimSeqName": "Name of MorphTarget to look for."
          }
        },
        "ForceApexClothingTeleport": {
          "comment": "Forces apex clothing to use 'teleport' for the next update"
        },
        "ForceApexClothingTeleportAndReset": {
          "comment": "Forces apex clothing to use 'teleport and reset' for the next update"
        },
        "ForceSkelUpdate": {
          "comment": "forces an update to the mesh's skeleton/attachments, even if bUpdateSkelWhenNotRendered is false and it has not been recently rendered\n @note if bUpdateSkelWhenNotRendered is true, there is no reason to call this function (but doing so anyway will have no effect)"
        },
        "GetAnimLength": {
          "comment": "Returns the duration (in seconds) for a named AnimSequence. Returns 0.f if no animation."
        },
        "GetBoneAxis": {
          "comment": "finds a vector pointing along the given axis of the given bone",
          "params": {
            "BoneName": "the name of the bone to find",
            "Axis": "the axis of that bone to return"
          }
        },
        "GetBoneMatrix": {
          "comment": "returns the matrix of the bone at the specified index"
        },
        "GetBoneNames": {
          "comment": "fills the given array with the names of all the bones in this component's current SkeletalMesh"
        },
        "GetBonesWithinRadius": {
          "comment": "Find all bones by name within given radius"
        },
        "GetClosestCollidingBoneLocation": {
          "comment": "iterates through all bodies in our PhysicsAsset and returns the location of the closest bone associated\n with a body that blocks the specified kind of traces\n \n@note: only the collision flags on the PhysicsAsset are checked; the collision flags on the component are ignored",
          "params": {
            "TestLocation": "location to check against",
            "bCheckZeroExtent": "consider bodies that block zero extent traces",
            "bCheckNonZeroExtent": "consider bodies that block nonzero extent traces"
          }
        },
        "GetFaceFXRegister": {
          "comment": "Retrieve the value of the specified FaceFX register."
        },
        "GetParentBone": {
          "comment": "returns the name of the parent bone for the specified bone. Returns 'None' if the bone does not exist or it is the root bone"
        },
        "GetRefPosePosition": {
          "comment": "Gets the local-space position of a bone in the reference pose."
        },
        "GetSocketBoneName": {
          "comment": "Returns bone name linked to a given named socket on the skeletal mesh component.\n If you're unsure to deal with sockets or bones names, you can use this function to filter through, and always return the bone name.\n @input bone name or socket name\n @output bone name"
        },
        "GetSocketByName": {
          "comment": "Returns SkeletalMeshSocket of named socket on the skeletal mesh component.\n Returns None if not found."
        },
        "GetSocketWorldLocationAndRotation": {
          "comment": "Find the current world space location and rotation of a named socket on the skeletal mesh component.\n If the socket is not found, then it returns false and does not change the OutLocation/OutRotation variables.",
          "params": {
            "InSocketName": "the name of the socket to find",
            "OutLocation": "(out) set to the world space location of the socket",
            "OutRotation": "(out) if specified, set to the world space rotation of the socket"
          }
        },
        "GetTransformMatrix": {
          "comment": "Return Transform Matrix for SkeletalMeshComponent considering root motion setups",
          "params": {
            "SkelComp": "SkeletalMeshComponent to get transform matrix from"
          }
        },
        "HideBone": {
          "comment": "Hides the specified bone. Currently this just enforces a scale of 0 for the hidden bones.",
          "params": {
            "PhysBodyOption": "Option for physics bodies that attach to the bones to be hidden"
          }
        },
        "HideBoneByName": {
          "comment": "Hides the specified bone with name. Currently this just enforces a scale of 0 for the hidden bones.\n Compoared to HideBone By Index - This keeps track of list of bones and update when LOD changes",
          "params": {
            "BoneName": "Name of bone to hide",
            "PhysBodyOption": "Option for physics bodies that attach to the bones to be hidden"
          }
        },
        "InitMorphTargets": {
          "comment": "Initialize MorphSets look up table : MorphTargetIndexMap"
        },
        "IsBoneHidden": {
          "comment": "Determines if the specified bone is hidden."
        },
        "IsComponentAttached": {
          "comment": "Returns true if component is attached to skeletal mesh.",
          "params": {
            "Component": "ActorComponent to check for."
          }
        },
        "IsPlayingFaceFXAnim": {
          "comment": "Is playing a FaceFX animation."
        },
        "MatchRefBone": {
          "comment": "returns the bone index of the specified bone, or INDEX_NONE if it couldn't be found"
        },
        "PlayAnim": {
          "comment": "simple generic case animation player\n requires that the one and only animation node in the AnimTree is an AnimNodeSequence",
          "params": {
            "AnimName": "name of the animation to play",
            "Duration": "(optional) override duration for the animation",
            "bLoop": "(optional) whether the animation should loop",
            "bRestartIfAlreadyPlaying": "whether or not to restart the animation if the specified anim is already playing",
            "StartTime": "(optional) What time to start the animation at",
            "bPlayBackwards": "(optional) Play this animation backwards"
          }
        },
        "PlayFaceFXAnim": {
          "comment": "Play the specified FaceFX animation.\n Returns TRUE if successful.\n If animation couldn't be found, a log warning will be issued."
        },
        "PlayParticleEffect": {
          "comment": "Called by AnimNotify_PlayParticleEffect\n Looks for a socket name first then bone name",
          "params": {
            "AnimNotifyData": "The AnimNotify_PlayParticleEffect which will have all of the various params on it"
          }
        },
        "RemoveInstanceVertexWeightBoneParented": {
          "comment": "Remove a new bone to the list of instance vertex weight bones",
          "params": {
            "BoneNames": "set of bones (implicitly parented) to use for finding vertices"
          }
        },
        "ResetClothVertsToRefPose": {
          "comment": "Move all vertices in the cloth to the reference pose and zero their velocity."
        },
        "RestoreSavedAnimSets": {
          "comment": "Restores saved AnimSets to the master list of AnimSets and clears the temporary saved list of AnimSets."
        },
        "SaveAnimSets": {
          "comment": "Saves the skeletal component's current AnimSets to a temporary buffer. You can restore them later by calling\n RestoreSavedAnimSets()."
        },
        "SetAttachClothVertsToBaseBody": {
          "comment": "Attach/detach verts from physics body that this components actor is attached to."
        },
        "SetClothExternalForce": {
          "comment": "Modify the external force that is applied to the cloth. Will continue to be applied until it is changed."
        },
        "SetClothFrozen": {
          "comment": "Toggle active simulation of cloth. Cheaper than doing SetEnableClothSimulation, and keeps its shape while frozen."
        },
        "SetEnableClothingSimulation": {
          "comment": "Toggle active simulation of clothing and keeps its shape while frozen."
        },
        "SetEnableClothSimulation": {
          "comment": "Turn on and off cloth simulation for this skeletal mesh."
        },
        "SetFaceFXRegister": {
          "comment": "Set the value and operation of the specified FaceFX register."
        },
        "SetFaceFXRegisterEx": {
          "comment": "Set the value and operation of the specified FaceFX register."
        },
        "SetForceRefPose": {
          "comment": "Change whether to force mesh into ref pose (and use cheaper vertex shader)"
        },
        "SetHasPhysicsAssetInstance": {
          "comment": "Set value of bHasPhysicsAssetInstance flag.\n Will create/destroy PhysicsAssetInstance as desired."
        },
        "SetPhysicsAsset": {
          "comment": "Change the Physics Asset of the mesh"
        },
        "SetSkeletalMesh": {
          "comment": "Change the SkeletalMesh that is rendered for this Component. Will re-initialize the animation tree etc."
        },
        "SetSoftBodyFrozen": {
          "comment": "Toggle active simulation of the soft-body."
        },
        "ShowMaterialSection": {
          "comment": "Show/Hide Material - technical correct name for this is Section, but seems Material is mostly used\n This disable rendering of certain Material ID (Section)",
          "params": {
            "MaterialID": "id of the material to match a section on and to show/hide",
            "bShow": "TRUE to show the section, otherwise hide it",
            "LODIndex": "index of the lod entry since material mapping is unique to each LOD"
          }
        },
        "SkelMeshCompOnParticleSystemFinished": {
          "comment": "We so we detach the Component once we are done playing it"
        },
        "StopAnim": {
          "comment": "simple generic case animation stopper\n requires that the one and only animation node in the AnimTree is an AnimNodeSequence"
        },
        "StopFaceFXAnim": {
          "comment": "Stop any currently playing FaceFX animation."
        },
        "ToggleInstanceVertexWeights": {
          "comment": "Enabled or disable the instanced vertex weights buffer for the skeletal mesh object",
          "params": {
            "bEnable": "TRUE to enable, FALSE to disable",
            "LODIdx": "LOD to enable"
          }
        },
        "TransformFromBoneSpace": {
          "comment": "Transform a location/rotation in bone relative space to world space."
        },
        "TransformToBoneSpace": {
          "comment": "Transform a location/rotation from world space to bone relative space.\n This is handy if you know the location in world space for a bone attachment, as AttachComponent takes location/rotation in bone-relative space."
        },
        "UnHideBone": {
          "comment": "Unhides the specified bone."
        },
        "UnHideBoneByName": {
          "comment": "UnHide the specified bone with name. Currently this just enforces a scale of 0 for the hidden bones.\n Compoared to HideBone By Index - This keeps track of list of bones and update when LOD changes",
          "params": {
            "BoneName": "Name of bone to unhide"
          }
        },
        "UpdateAnimations": {
          "comment": "Force AnimTree to recache all animations.\n Call this when the AnimSets array has been changed."
        },
        "UpdateClothParams": {
          "comment": "Update params of the this components internal cloth sim from the SkeletalMesh properties."
        },
        "UpdateInstanceVertexWeightBones": {
          "comment": "Update the bones that specify which vertices will use instanced influences\n This will also trigger an update of the vertex weights.",
          "params": {
            "BonePairs": "set of bone pairs to use for finding vertices.\n A bone can be paired with None bone name to only match up a single bone."
          }
        },
        "UpdateMeshForBrokenConstraints": {
          "comment": "Looks up all bodies for broken constraints.\n Makes sure child bodies of a broken constraints are not fixed and using bone springs, and child joints not motorized."
        },
        "UpdateRBBonesFromSpaceBases": {
          "comment": "Force an update of this meshes kinematic bodies and springs."
        },
        "UpdateSoftBodyParams": {
          "comment": "Update soft-body simulation from components params."
        },
        "WakeSoftBody": {
          "comment": "Force awake any soft body simulation on this component"
        }
      },
      "structs": {
        "ActiveMorph": {
          "comment": "Struct used to indicate one active morph target that should be applied to this SkeletalMesh when rendered.",
          "properties": {
            "Target": {
              "comment": "The morph target that we want to apply."
            },
            "Weight": {
              "comment": "Strength of the morph target, between 0.0 and 1.0"
            }
          }
        },
        "BonePair": {
          "comment": "Set of bones which will be used to find vertices to switch to using instanced influence weights\n instead of the default skeletal mesh weighting."
        },
        "SkelMeshComponentLODInfo": {
          "comment": "LOD specific setup for the skeletal mesh component",
          "properties": {
            "HiddenMaterials": {
              "comment": "Material corresponds to section. To show/hide each section, use this"
            },
            "InstanceWeightIdx": {
              "comment": "Current index into the skeletal mesh VertexInfluences for the current LOD"
            },
            "InstanceWeightUsage": {
              "comment": "Whether the instance weights are used for a partial/full swap"
            }
          }
        }
      }
    },
    "SkeletalMeshSocket": {
      "properties": {
        "SocketName": {
          "comment": "Defines a named attachment location on the SkeletalMesh. \n These are set up in editor and used as a shortcut instead of specifying \n everything explicitly to AttachComponent in the SkeletalMeshComponent.\n The Outer of a SkeletalMeshSocket should always be the SkeletalMesh."
        }
      }
    },
    "SkyLightComponent": {
      "properties": {
        "LowerBrightness": {
          "comment": "The brightness for the lower hemisphere of the sky light."
        },
        "LowerColor": {
          "comment": "The color of the lower hemisphere of the sky light."
        }
      }
    },
    "SoundClass": {
      "properties": {
        "bIsChild": {
          "comment": "Whether this class is referenced by another class"
        },
        "EditorData": {
          "comment": "Editor data for all sound classes; only used in the master sound class"
        },
        "MenuID": {
          "comment": "ID used in menus in the editor"
        },
        "ChildClassNames": {
          "comment": "Array of names of child sound classes. Empty for leaf classes."
        },
        "Properties": {
          "comment": "Configurable properties like volume and priority."
        }
      },
      "structs": {
        "SoundClassProperties": {
          "comment": "Structure containing configurable properties of a sound class.",
          "properties": {
            "bAlwaysPlay": {
              "comment": "Whether to artificially prioritise the component to play"
            },
            "bApplyEffects": {
              "comment": "Sound mode voice - whether to apply audio effects"
            },
            "bCenterChannelOnly": {
              "comment": "Whether or not this sound class forces sounds to the center channel"
            },
            "bIsMusic": {
              "comment": "Whether or not this is music (propagates only if parent is TRUE)"
            },
            "bIsUISound": {
              "comment": "Whether or not this sound plays when the game is paused in the UI"
            },
            "bReverb": {
              "comment": "Whether or not this sound class has reverb applied"
            },
            "LFEBleed": {
              "comment": "The amount of a sound to bleed to the LFE channel"
            },
            "Pitch": {
              "comment": "Pitch multiplier."
            },
            "RadioFilterVolume": {
              "comment": "Volume of the radio filter effect"
            },
            "RadioFilterVolumeThreshold": {
              "comment": "Volume at which the radio filter kicks in"
            },
            "StereoBleed": {
              "comment": "The amount of stereo sounds to bleed to the rear speakers"
            },
            "VoiceCenterChannelVolume": {
              "comment": "Voice center channel volume - Not a multiplier (no propagation)"
            },
            "Volume": {
              "comment": "Volume multiplier."
            }
          }
        }
      }
    },
    "SoundCue": {
      "properties": {
        "CurrentPlayCount": {
          "comment": "Number of times this cue is currently being played."
        },
        "FaceFXAnimName": {
          "comment": "Name of the FaceFX Animation"
        },
        "FaceFXAnimSetRef": {
          "comment": "Reference to FaceFX AnimSet package the animation is in"
        },
        "FaceFXGroupName": {
          "comment": "Name of the FaceFX Group the animation is in"
        },
        "MaxConcurrentPlayCount": {
          "comment": "Maximum number of times this cue can be played concurrently."
        },
        "SoundClass": {
          "comment": "Sound group this sound cue belongs to"
        }
      }
    },
    "SoundMode": {
      "properties": {
        "bApplyEQ": {
          "comment": "Whether to apply the EQ effect"
        },
        "SoundClassEffects": {
          "comment": "Array of changes to be applied to groups"
        }
      },
      "structs": {
        "AudioEQEffect": {
          "properties": {
            "HFFrequency": {
              "comment": "High frequency filter cutoff frequency (Hz)"
            },
            "HFGain": {
              "comment": "High frequency gain"
            },
            "LFFrequency": {
              "comment": "Low frequency filter cutoff frequency (Hz)"
            },
            "LFGain": {
              "comment": "Low frequency filter gain"
            },
            "MFBandwidth": {
              "comment": "Middle frequency filter bandwidth frequency (Hz)"
            },
            "MFCutoffFrequency": {
              "comment": "Middle frequency filter cutoff frequency (Hz)"
            },
            "MFGain": {
              "comment": "Middle frequency filter gain"
            },
            "RootTime": {
              "comment": "Start time of effect"
            }
          }
        },
        "SoundClassAdjuster": {
          "comment": "Elements of data for sound group volume control"
        }
      }
    },
    "SoundNodeAmbient": {
      "comment": "Defines the parameters for an in world looping ambient sound e.g. a wind sound",
      "properties": {
        "DistanceModel": {
          "comment": "What kind of attenuation model to use"
        }
      }
    },
    "SoundNodeAmbientNonLoop": {
      "comment": "Defines the parameters for an in world non looping ambient sound e.g. a car driving by"
    },
    "SoundNodeAmbientNonLoopToggle": {
      "comment": "Defines the parameters for an in world non looping ambient sound e.g. a car driving by"
    },
    "SoundNodeAttenuation": {
      "comment": "Defines how a sounds changes volume with distance to the listener",
      "properties": {
        "DistanceAlgorithm": {
          "comment": "What kind of attenuation model to use"
        },
        "DistanceType": {
          "comment": "How to calculate the distance from the sound to the listener"
        }
      }
    },
    "SoundNodeConcatenator": {
      "comment": "A node to play sounds sequentially\n WARNING: these are not seamless",
      "properties": {
        "InputVolume": {
          "comment": "A volume for each input. Automatically sized."
        }
      }
    },
    "SoundNodeConcatenatorRadio": {
      "comment": "A node to play sounds sequentially\n WARNING: these are not seamless"
    },
    "SoundNodeDelay": {
      "comment": "Defines a delay"
    },
    "SoundNodeDistanceCrossFade": {
      "comment": "SoundNodeDistanceCrossFade\n \n This node's purpose is to play different sounds based on the distance to the listener. \n The node mixes between the N different sounds which are valid for the distance. One should\n think of a SoundNodeDistanceCrossFade as Mixer node which determines the set of nodes to\n \"mix in\" based on their distance to the sound.\n \n Example:\n You have a gun that plays a fire sound. At long distances you want a different sound than\n if you were up close. So you use a SoundNodeDistanceCrossFade which will calculate the distance\n a listener is from the sound and play either: short distance, long distance, mix of short and long sounds.\n A SoundNodeDistanceCrossFade differs from an SoundNodeAttenuation in that any sound is only going\n be played if it is within the MinRadius and MaxRadius. So if you want the short distance sound to be \n heard by people close to it, the MinRadius should probably be 0\n The volume curve for a SoundNodeDistanceCrossFade will look like this:\n Volume (of the input) \n FadeInDistance.Max --> _________________ <-- FadeOutDistance.Min\n / \\\n / \\\n / \\\n FadeInDistance.Min -->/ \\ <-- FadeOutDistance.Max",
      "properties": {
        "CrossFadeInput": {
          "comment": "Each input needs to have the correct data filled in so the SoundNodeDistanceCrossFade is able\n to determine which sounds to play"
        }
      },
      "structs": {
        "DistanceDatum": {
          "properties": {
            "FadeInDistanceStart": {
              "comment": "The FadeInDistance at which to start hearing this sound. If you want to hear the sound \n up close then setting this to 0 might be a good option."
            },
            "FadeOutDistanceStart": {
              "comment": "The FadeOutDistance is where hearing this sound will end."
            },
            "Volume": {
              "comment": "The volume for which this Input should be played"
            }
          }
        }
      }
    },
    "SoundNodeLooping": {
      "comment": "Defines how a sound loops; either indefinitely, or for a set number of times"
    },
    "SoundNodeMature": {
      "comment": "This SoundNode uses UEngine::bAllowMatureLanguage to determine whether child nodes\n that have USoundNodeWave::bMature=TRUE should be played."
    },
    "SoundNodeMixer": {
      "comment": "Defines how concurrent sounds are mixed together",
      "properties": {
        "InputVolume": {
          "comment": "A volume for each input. Automatically sized."
        }
      }
    },
    "SoundNodeModulator": {
      "comment": "Defines a random volume and pitch modification when a sound starts"
    },
    "SoundNodeModulatorContinuous": {
      "comment": "Defines a random volume and pitch modification as a sound plays"
    },
    "SoundNodeOscillator": {
      "comment": "Defines how a sound oscillates"
    },
    "SoundNodeRandom": {
      "comment": "Selects sounds from a random set",
      "properties": {
        "HasBeenUsed": {
          "comment": "Internal state of which sounds have been played. This is only used at runtime\n to keep track of which sounds have been played"
        },
        "NumRandomUsed": {
          "comment": "Counter var so we don't have to count all of the used sounds each time we choose a sound"
        },
        "bRandomizeWithoutReplacement": {
          "comment": "Determines whether or not this SoundNodeRandom should randomize with or without\n replacement. \n WithoutReplacement means that only nodes left will be valid for \n selection. So with that, you are guarenteed to have only one occurrence of the\n sound played until all of the other sounds in the set have all been played.\n WithReplacement means that a node will be chosen and then placed back into the set.\n So one could play the same sound over and over if the probabilities don't go your way :-)"
        }
      }
    },
    "SoundNodeWave": {
      "comment": "Sound node that contains sample data",
      "properties": {
        "bDynamicResource": {
          "comment": "Whether to free the resource data after it has been uploaded to the hardware"
        },
        "bProcedural": {
          "comment": "Set to true for programmatically-generated, streamed audio. Not used from the editor; you should use SoundNodeWaveStreaming.uc for this."
        },
        "ChannelOffsets": {
          "comment": "Offsets into the bulk data for the source wav data"
        },
        "ChannelSizes": {
          "comment": "Sizes of the bulk data for the source wav data"
        },
        "CompressedPCData": {
          "comment": "Cached ogg vorbis data."
        },
        "CompressedPS3Data": {
          "comment": "Cached cooked PS3 data to speed up iteration times."
        },
        "CompressedXbox360Data": {
          "comment": "Cached cooked Xbox 360 data to speed up iteration times."
        },
        "DecompressionType": {
          "comment": "Type of buffer this wave uses. Set once on load"
        },
        "RawData": {
          "comment": "Uncompressed wav data 16 bit in mono or stereo - stereo not allowed for multichannel data"
        },
        "RawPCMData": {
          "comment": "Pointer to 16 bit PCM data - used to decompress data to and preview sounds"
        },
        "RawPCMDataSize": {
          "comment": "Size of RawPCMData, or what RawPCMData would be if the sound was fully decompressed"
        },
        "ResourceData": {
          "comment": "Memory containing the data copied from the compressed bulk data"
        },
        "ResourceID": {
          "comment": "Resource index to cross reference with buffers"
        },
        "ResourceSize": {
          "comment": "Size of resource copied from the bulk data"
        },
        "VorbisDecompressor": {
          "comment": "Async worker that decompresses the vorbis data on a different thread"
        },
        "100isbestquality.>": {
          "comment": "Platform agnostic compression quality. 1..100 with 1 being best compression and 100 being best quality"
        },
        "bForceRealTimeDecompression<Tooltip=Forcesontheflysounddecompression": {
          "comment": "If set, forces wave data to be decompressed during playback instead of upfront on platforms that have a choice."
        },
        "bLoopingSound<Tooltip=Informsthecompressionroutimestoprocessthissoundtoallowittoloop.>": {
          "comment": "If set, the compressor does everything required to make this a seamlessly looping sound"
        },
        "CompressionQuality<Tooltip=1smallestsize": {
          "comment": "Platform agnostic compression quality. 1..100 with 1 being best compression and 100 being best quality"
        },
        "evenforshortdurationsounds.>": {
          "comment": "If set, forces wave data to be decompressed during playback instead of upfront on platforms that have a choice."
        },
        "Duration": {
          "comment": "Duration of sound in seconds."
        },
        "maximumis2.0-itisasimplelinearmultipliertotheSampleRate.>": {
          "comment": "Playback pitch for sound 0.4 to 2.0"
        },
        "NumChannels": {
          "comment": "Number of channels of multichannel data; 1 or 2 for regular mono and stereo files"
        },
        "Pitch<Tooltip=Minimumis0.4": {
          "comment": "Playback pitch for sound 0.4 to 2.0"
        },
        "SampleRate": {
          "comment": "Cached sample rate for displaying in the tools"
        },
        "Volume<Tooltip=Defaultis0.75.>": {
          "comment": "Playback volume of sound 0 to 1"
        },
        "SourceFilePath": {
          "comment": "Path to the resource used to construct this sound node wave"
        },
        "SourceFileTimestamp": {
          "comment": "Date/Time-stamp of the file from the last import"
        },
        "bManualWordWrap": {
          "comment": "TRUE if the subtitles have been split manually."
        },
        "bMature": {
          "comment": "TRUE if this sound is considered to contain mature content."
        },
        "Comment": {
          "comment": "Provides contextual information for the sound to the translator."
        },
        "Subtitles": {
          "comment": "Subtitle cues. If empty, use SpokenText as the subtitle. Will often be empty,\n as the contents of the subtitle is commonly identical to what is spoken."
        },
        "bUseTTS<Tooltip=UseTextToSpeechtoverbaliseSpokenText.>": {
          "comment": "Set to true to speak SpokenText using TTS"
        },
        "SpokenText": {
          "comment": "A localized version of the text that is actually spoken in the audio."
        },
        "TTSSpeaker<Tooltip=ThevoicetouseforTextToSpeech.>": {
          "comment": "Speaker to use for TTS"
        }
      }
    },
    "SoundNodeWaveParam": {
      "comment": "Sound node that takes a runtime parameter for the wave to play",
      "properties": {
        "WaveParameterName": {
          "comment": "The name of the wave parameter to use to look up the SoundNodeWave we should play"
        }
      }
    },
    "SoundNodeWaveStreaming": {
      "comment": "This class provides a simple adapter between the audio device and code that wants to produce\n an ongoing stream of audio data.\n You feed data to this class through its QueueAudio() method, and it will slowly feed it to \n the audio device as more sound data is needed for playback.",
      "properties": {
        "QueuedAudio": {
          "comment": "FIFO data to give to the audio device in GeneratePCMData()."
        }
      },
      "functions": {
        "AvailableAudioBytes": {
          "comment": "Query bytes queued for playback"
        },
        "GeneratePCMData": {
          "comment": "overridden from SoundNodeWave superclass."
        },
        "QueueAudio": {
          "comment": "Add data to the FIFO that feeds the audio device."
        },
        "ResetAudio": {
          "comment": "Remove all queued data from the FIFO. This is only necessary if you want to start over, or GeneratePCMData() isn't going to be called, since that will eventually drain it."
        }
      }
    },
    "SpeechRecognition": {
      "properties": {
        "bDirty": {
          "comment": "Whether this object has been altered"
        },
        "bInitialised": {
          "comment": "Whether the object was successfully initialised or not"
        },
        "FnxVoiceData": {
          "comment": "Cached pointers to Fonix data"
        },
        "InstanceData[4]": {
          "comment": "Cached user data - max users"
        },
        "UserData": {
          "comment": "Cached user data"
        },
        "VoiceData": {
          "comment": "Cached neural net data"
        },
        "WorkingVoiceData": {
          "comment": "Working copy of neural net data"
        },
        "ConfidenceThreshhold": {
          "comment": "Threshhold below which the recognised word will be ignored"
        },
        "Language": {
          "comment": "Language to recognise data in"
        },
        "Vocabularies": {
          "comment": "Array of vocabularies that can be swapped in and out"
        }
      },
      "structs": {
        "RecognisableWord": {
          "properties": {
            "PhoneticWord": {
              "comment": "This is the word string that is passed into the recognition. e.g. \"Loke\""
            },
            "ReferenceWord": {
              "comment": "This is the reference word, which is returned upon recognition. e.g. \"Loque\". Does not need to be unique."
            }
          }
        },
        "RecogUserData": {
          "comment": "Initialise the recogniser",
          "properties": {
            "ActiveVocabularies": {
              "comment": "Bitfield of active vocabularies"
            },
            "UserData": {
              "comment": "Workspace for recognition data"
            }
          }
        },
        "RecogVocabulary": {
          "properties": {
            "VocabData": {
              "comment": "Cached processed vocabulary data"
            },
            "VocabName": {
              "comment": "Name of vocab file"
            },
            "WhoDictionary": {
              "comment": "Arrays of words that can be recognised - note that words need an ID unique among the contents of all three arrays"
            },
            "WorkingVocabData": {
              "comment": "Working copy of vocab data"
            }
          }
        }
      }
    },
    "SpeedTree": {
      "properties": {
        "bLegacySpeedTree": {
          "comment": "If TRUE, this tree was imported with the Speedtree 4 integration."
        },
        "LightingGuid": {
          "comment": "Unique ID for this speed tree, used for caching during distributed lighting"
        },
        "SRH": {
          "comment": "Helper object to allow SpeedTree to be script exposed."
        },
        "LeafStaticShadowOpacity": {
          "comment": "The probability of a shadow ray being blocked by the leaf material."
        },
        "BillboardMaterial": {
          "comment": "Billboard material."
        },
        "Branch1Material": {
          "comment": "Branch 1 material."
        },
        "Branch2Material": {
          "comment": "Branch 2 material."
        },
        "FrondMaterial": {
          "comment": "Frond material."
        },
        "LeafCardMaterial": {
          "comment": "Leaf card material."
        },
        "LeafMeshMaterial": {
          "comment": "Leaf mesh material."
        }
      }
    },
    "SpeedTreeActorFactory": {
      "properties": {
        "SpeedTree": {
          "comment": "If the ActorFactory thinks it could create an Actor with the current settings.\n Used to determine if we should add to context menu for example.\n \n@param OutErrorMsg Receives localized error string name if returning FALSE.\n \n@param bFromAssetOnly If true, the actor factory will check that a valid asset has been assigned from selection. If the factory always requires an asset to be selected, this param does not matter"
        }
      }
    },
    "SpeedTreeComponent": {
      "properties": {
        "BillboardLightMap": {
          "comment": "The component's billboard light-map."
        },
        "BranchLightMap": {
          "comment": "The component's branch light-map."
        },
        "FrondLightMap": {
          "comment": "The component's frond light-map."
        },
        "LeafCardLightMap": {
          "comment": "The component's leaf card light-map."
        },
        "LeafMeshLightMap": {
          "comment": "The component's leaf mesh light-map."
        },
        "RotationOnlyMatrix": {
          "comment": "The component's rotation matrix (for arbitrary rotations with wind)"
        },
        "SpeedTreeIcon": {
          "comment": "Icon texture."
        },
        "StaticLights": {
          "comment": "Static lights array."
        },
        "LightmassSettings<ScriptOrder=true>": {
          "comment": "The Lightmass settings for the entire speedtree."
        },
        "BillboardMaterial": {
          "comment": "Billboard material."
        },
        "Branch1Material": {
          "comment": "Branch material."
        },
        "Branch2Material": {
          "comment": "Cap material."
        },
        "bUseBillboards": {
          "comment": "Whether billboards are drawn at the lowest LOD or not."
        },
        "bUseBranches": {
          "comment": "Whether to draw branches or not."
        },
        "bUseFronds": {
          "comment": "Whether to draw fronds or not."
        },
        "bUseLeafCards": {
          "comment": "Whether to draw leaf cards or not."
        },
        "bUseLeafMeshes": {
          "comment": "Whether to draw leaf meshes or not."
        },
        "FrondMaterial": {
          "comment": "Frond material."
        },
        "LeafCardMaterial": {
          "comment": "Leaf card material."
        },
        "LeafMeshMaterial": {
          "comment": "Leaf mesh material."
        },
        "Lod3DEnd": {
          "comment": "The distance for the lowest detail tree."
        },
        "Lod3DStart": {
          "comment": "The distance for the most detailed tree."
        },
        "LodBillboardEnd": {
          "comment": "The distance for the lowest detail tree."
        },
        "LodBillboardStart": {
          "comment": "The distance for the most detailed tree."
        },
        "LodLevelOverride": {
          "comment": "the tree will use this LOD level (0.0 - 1.0). If -1.0, the tree will calculate its LOD normally."
        },
        "SpeedTree": {
          "comment": "USpeedTree resource."
        }
      },
      "functions": {
        "GetMaterial": {
          "comment": "Returns the component's material corresponding to MeshType if it is set, otherwise returns the USpeedTree's material."
        },
        "SetMaterial": {
          "comment": "Sets the component's material override, and reattaches if necessary."
        }
      },
      "structs": {
        "SpeedTreeStaticLight": {
          "comment": "The static lighting for a single light's affect on the component."
        }
      }
    },
    "SphericalHarmonicLightComponent": {
      "properties": {
        "bRenderBeforeModShadows": {
          "comment": "If TRUE, the SH light can be combined into the base pass as an optimization. \n If FALSE, the SH light will be rendered after modulated shadows."
        },
        "WorldSpaceIncidentLighting": {
          "comment": "Colored SH coefficients for the light intensity, parameterized by the world-space incident angle."
        }
      }
    },
    "SplineActor": {
      "properties": {
        "Connections": {
          "comment": "Array of connections"
        },
        "LinksFrom": {
          "comment": "Set of SplineActors that link to this one"
        },
        "bDisableDestination": {
          "comment": "Splines connectin to this SplineActor will be marked as bSplineDisabled"
        },
        "SplineActorTangent": {
          "comment": "Tangent of spline at this actor - this is in local space"
        },
        "SplineColor": {
          "comment": "Color to use to draw the splines"
        },
        "SplineVelocityOverTime": {
          "comment": "For actors using this spline, how quickly to move along the spline over time"
        }
      },
      "functions": {
        "AddConnectionTo": {
          "comment": "Create a connection to another SplineActor"
        },
        "BreakAllConnections": {
          "comment": "Break all connections to and from this SplineActor"
        },
        "BreakAllConnectionsFrom": {
          "comment": "Break all connections from this SplineActor"
        },
        "BreakConnectionTo": {
          "comment": "Breaks a connection from this SplineActor to NextActor"
        },
        "FindSplineComponentTo": {
          "comment": "Returns the SplineComponent that connects this SplineActor to NextActor. Returns None if not connected"
        },
        "FindSplinePathTo": {
          "comment": "Find a path through network from this point to Goal, and put results into OutRoute."
        },
        "FindTargetForComponent": {
          "comment": "Returns the SplineActor that this SplineComponent connects to."
        },
        "GetAllConnectedSplineActors": {
          "comment": "Find all SplineActors connected to (and including) this one"
        },
        "GetBestConnectionInDirection": {
          "comment": "Returns a SplineActor that takes you most in the specified direction. If no connections, returns None. If bUseLinksFrom is true, the best connection TO this spline will be returned"
        },
        "GetRandomConnection": {
          "comment": "If bUseLinksFrom is false, returns a random SplineActor that is connected to from this SplineActor. Otherwise, returns a random SplineActor that connects to this SplineActor. If no connections, returns None."
        },
        "GetWorldSpaceTangent": {
          "comment": "Returns spline tangent at this actor, in world space"
        },
        "IsConnectedTo": {
          "comment": "Returns TRUE if there is a connection from this SplineActor to NextActor"
        },
        "OnToggle": {
          "comment": "Handle Toggle action for setting bDisableDestination"
        },
        "OnToggleHidden": {
          "comment": "Handler for SeqAct_ToggleHidden, just sets bHidden."
        },
        "UpdateConnectedSplineComponents": {
          "comment": "Create/destroy/update SplineComponents belonging to this SplineActor, and all SplineActors that link to this."
        },
        "UpdateSplineComponents": {
          "comment": "Create/destroy/update SplineComponents belonging to this SplineActor."
        }
      },
      "structs": {
        "SplineConnection": {
          "comment": "Struct containing information about one connection from this SplineActor to another.",
          "properties": {
            "ConnectTo": {
              "comment": "Which SplineActor this one connects to - spline is between these locations"
            },
            "SplineComponent": {
              "comment": "Component that stores actual spline points, tangents, reparam table etc"
            }
          }
        }
      }
    },
    "SplineComponent": {
      "properties": {
        "bSplineDisabled": {
          "comment": "If TRUE, this spline is for whatever reason disabled, and will be drawn in red."
        },
        "SplineArrowSize": {
          "comment": "Size of arrow on end of spline. If zero, no arrow drawn"
        },
        "SplineColor": {
          "comment": "Color of spline"
        },
        "SplineCurviness": {
          "comment": "This is how curvy this spline is. 1.0f is straight and anything below that is curvy!\n We are doing a simplistic calculate of: vsize(points) / Length Of Spline"
        },
        "SplineDrawRes": {
          "comment": "Resolution to draw spline at"
        },
        "SplineInfo": {
          "comment": "Actual data for spline. Locations and tangents are in world space."
        },
        "SplineReparamTable": {
          "comment": "Input, distance along curve, output, parameter that puts you there."
        }
      },
      "functions": {
        "GetLocationAtDistanceAlongSpline": {
          "comment": "Given a distance along the length of this spline, return the point in space where this puts you"
        },
        "GetSplineLength": {
          "comment": "Returns total length along this spline"
        },
        "GetTangentAtDistanceAlongSpline": {
          "comment": "Given a distance along the length of this spline, return the direction of the spline there. Note, result is non-unit length."
        },
        "UpdateSplineCurviness": {
          "comment": "This will update the spline curviness value"
        },
        "UpdateSplineReparamTable": {
          "comment": "Update the SplineReparamTable"
        }
      }
    },
    "SplineLoftActor": {
      "properties": {
        "SplineMeshComps": {
          "comment": "Components used to render deformed meshes along each connection spline to other nodes"
        },
        "bAcceptsLights": {
          "comment": "If TRUE, generated SplineMeshComponents will accept lights"
        },
        "bSmoothInterpRollAndScale": {
          "comment": "If TRUE, will use smooth interpolation (ease in/out) for Scale and Roll along this section of spline. If FALSE, uses linear"
        },
        "DeformMesh": {
          "comment": "Mesh to deform along spline \n This must be set to have a visual mesh viewable in the world\n @TODO: make a map check for errors for this being None"
        },
        "DeformMeshMaterials": {
          "comment": "Materials to override with for this instance"
        },
        "MeshLightEnvironment": {
          "comment": "Light environment used to light dynamically moving spline"
        },
        "MeshMaxDrawDistance": {
          "comment": "The maximum distance at which these meshes will be drawn"
        },
        "Offset": {
          "comment": "Offset in X and Y for the mesh along the spline. Note the offset is applied BEFORE scaling and roll"
        },
        "Roll": {
          "comment": "Roll around spline at this node, in degrees"
        },
        "ScaleX": {
          "comment": "Size that mesh should be along its local X axis at this node on spline."
        },
        "ScaleY": {
          "comment": "Size that mesh should be along its local Y axis at this node on spline."
        },
        "WorldXDir": {
          "comment": "Axis (in world space) used to determine the X axis for the mesh along the spline"
        }
      },
      "functions": {
        "ClearLoftMesh": {
          "comment": "Clear any static mesh assigned to this spline actor"
        },
        "UpdateSplineParams": {
          "comment": "Quick function that updates params/positions of the spline mesh components"
        }
      }
    },
    "SplineMeshComponent": {
      "properties": {
        "bSmoothInterpRollScale": {
          "comment": "If TRUE, will use smooth interpolation (ease in/out) for Scale, Roll, and Offset along this section of spline. If FALSE, uses linear"
        },
        "SplineParams": {
          "comment": "Spline that is used to deform mesh"
        },
        "SplineXDir": {
          "comment": "Axis (in component space) that is used to determine X axis for co-ordinates along spline"
        }
      },
      "structs": {
        "SplineMeshParams": {
          "comment": "Structure that holds info about spline, passed to renderer to deform StaticMesh.\n Also used by Lightmass, so be sure to update Lightmass::FSplineMeshParams and the static lighting code if this changes!",
          "properties": {
            "EndOffset": {
              "comment": "Ending offset of the mesh from the spline, in component space"
            },
            "EndPos": {
              "comment": "End location of spline, in component space"
            },
            "EndRoll": {
              "comment": "Roll around spline applied at end"
            },
            "EndScale": {
              "comment": "X and Y scale applied to mesh at end of spline"
            },
            "EndTangent": {
              "comment": "End tangent of spline, in component space"
            },
            "StartOffset": {
              "comment": "Starting offset of the mesh from the spline, in component space"
            },
            "StartPos": {
              "comment": "Start location of spline, in component space"
            },
            "StartRoll": {
              "comment": "Roll around spline applied at start"
            },
            "StartScale": {
              "comment": "X and Y scale applied to mesh at start of spline"
            },
            "StartTangent": {
              "comment": "Start tangent of spline, in component space"
            }
          }
        }
      }
    },
    "SpotLightComponent": {
      "properties": {
        "LightShaftConeAngle": {
          "comment": "Angle from the spot direction that pixels must be in to affect light shafts from this light."
        }
      }
    },
    "SpotLightToggleable": {
      "functions": {
        "ShouldSaveForCheckpoint": {
          "comment": "Returns true if the light supports being toggled off and on on-the-fly"
        }
      }
    },
    "SpriteComponent": {
      "properties": {
        "SpriteCategoryName": {
          "comment": "Sprite category that the component belongs to. Value serves as a key into the localization file."
        }
      },
      "functions": {
        "SetSprite": {
          "comment": "Change the sprite texture used by this component"
        },
        "SetSpriteAndUV": {
          "comment": "Change the sprite texture and UVs used by this component"
        },
        "SetUV": {
          "comment": "Change the UVs used by this component"
        }
      }
    },
    "StaticLightCollectionActor": {
      "properties": {
        "LightComponents": {
          "comment": "Since the components array is only serialized during make, we need to store the components we contain in a separate array."
        },
        "MaxLightComponents": {
          "comment": "The maximum number of LightComponents that can be attached to this actor. Once this number has been reached, a\n new StaticLightCollectionActor will be created."
        }
      }
    },
    "StaticMeshActor": {
      "properties": {
        "bDisableAutoBaseOnProcBuilding": {
          "comment": "If checked, this actor will not try to set its base to any proc building below it."
        }
      },
      "functions": {
        "PreBeginPlay": {
          "comment": "This function actually does the work for the GetDetailInfo and is virtual. \n It should only be called from GetDetailedInfo as GetDetailedInfo is safe to call on NULL object pointers"
        }
      }
    },
    "StaticMeshActorBasedOnExtremeContent": {
      "properties": {
        "ExtremeContent": {
          "comment": "The material to use for ExtremeContent (e.g. blood and gore!)"
        },
        "NonExtremeContent": {
          "comment": "The material to use for NonExtremeContent (e.g. blackness everywhere there used to be blood and gore)"
        }
      },
      "functions": {
        "SetMaterialBasedOnExtremeContent": {
          "comment": "This will set the material of this Actor based on the ExtremeContent setting."
        }
      },
      "structs": {
        "SMMaterialSetterDatum": {
          "comment": "This is set so the LD can map specific MaterialIndex on the target to some material"
        }
      }
    },
    "StaticMeshCollectionActor": {
      "properties": {
        "MaxStaticMeshComponents": {
          "comment": "The maximum number of StaticMeshComponents that can be attached to this actor. Once this number has been reached, a\n new StaticMeshCollectionActor will be created."
        },
        "StaticMeshComponents": {
          "comment": "Since the components array is only serialized during make, we need to store the components we contain in a separate array."
        }
      }
    },
    "StaticMeshComponent": {
      "properties": {
        "bCanHighlightSelectedSections": {
          "comment": "Whether or not we can highlight selected sections - this should really only be done in the editor"
        },
        "bForceStaticDecals": {
          "comment": "if True then decals will always use the fast path and will be treated as static wrt this mesh"
        },
        "bOverrideLightMapResolution": {
          "comment": "Deprecated. Replaced by 'bOverrideLightMapRes'."
        },
        "bUseSubDivisions": {
          "comment": "Whether to use subdivisions or just the triangle's vertices."
        },
        "LODData": {
          "comment": "Static mesh LOD data. Contains static lighting data along with instanced mesh vertex colors."
        },
        "OverriddenLightMapResolution": {
          "comment": "Deprecated. Replaced by 'OverriddenLightMapRes'."
        },
        "SubDivisionStepSize": {
          "comment": "Subdivision step size for static vertex lighting."
        },
        "VertexPositionVersionNumber": {
          "comment": "Incremented any time the position of vertices from the source mesh change, used to determine if an update from the source static mesh is required"
        },
        "LightmassSettings<ScriptOrder=true>": {
          "comment": "The Lightmass settings for this object."
        },
        "bUseSimpleLightmapModifications": {
          "comment": "Whether or not to use the optional simple lightmap modification texture"
        },
        "SimpleLightmapModificationFunction<EditCondition=bUseSimpleLightmapModifications>": {
          "comment": "The function to use when modifying the simple lightmap texture"
        },
        "SimpleLightmapModificationTexture<EditCondition=bUseSimpleLightmapModifications>": {
          "comment": "The texture to use when modifying the simple lightmap texture"
        },
        "bNeverBecomeDynamic": {
          "comment": "Never become dynamic, even if my mesh has bCanBecomeDynamic=true"
        },
        "bIgnoreInstanceForTextureStreaming": {
          "comment": "Ignore this instance of this static mesh when calculating streaming information.\n This can be useful when doing things like applying character textures to static geometry,\n to avoid them using distance-based streaming."
        },
        "bOverrideLightMapRes": {
          "comment": "Whether to override the lightmap resolution defined in the static mesh."
        },
        "ForcedLodModel": {
          "comment": "If 0, auto-select LOD level. if >0, force to (ForcedLodModel-1)."
        },
        "OverriddenLightMapRes": {
          "comment": "Light map resolution used if bOverrideLightMapRes is TRUE"
        },
        "OverriddenLODMaxRange": {
          "comment": "With the default value of 0, the LODMaxRange from the UStaticMesh will be used to control LOD transitions, otherwise this value overrides."
        }
      },
      "functions": {
        "CanBecomeDynamic": {
          "comment": "@RETURNS true if this mesh can become dynamic"
        },
        "DisableRBCollisionWithSMC": {
          "comment": "Disables physics collision between a specific pair of primitive components."
        },
        "SetForceStaticDecals": {
          "comment": "Changes the value of bForceStaticDecals.",
          "params": {
            "bInForceStaticDecals": "The value to assign to bForceStaticDecals."
          }
        },
        "SetStaticMesh": {
          "comment": "Change the StaticMesh used by this instance."
        }
      },
      "structs": {
        "StaticMeshComponentLODInfo": {
          "properties": {
            "OverrideVertexColors": {
              "comment": "Vertex colors to use for this mesh LOD"
            },
            "VertexColorPositions": {
              "comment": "Positions of the vertex colors to use for this mesh LOD, if any"
            }
          }
        }
      }
    },
    "StringsTag": {
      "comment": "Translates tags of the form via the localization system.",
      "functions": {
        "Translate": {
          "comment": "Return the translated text given the option.\n E.g. In the case of the argument is 'GBA_POI'.",
          "params": {
            "InArgument": "The text after the : in the tag."
          }
        }
      }
    },
    "SVehicle": {
      "properties": {
        "bCanFlip": {
          "comment": "true if vehicle can be uprighted by player"
        },
        "bChassisTouchingGround": {
          "comment": "OUTPUT: True if there are any contacts between the chassis of the vehicle and the ground."
        },
        "bFlipRight": {
          "comment": "Changes the direction the car gets flipped (used to prevent flipping car onto player"
        },
        "bIsInverted": {
          "comment": "OUTPUT: True if vehicle is mostly upside down."
        },
        "bIsUprighting": {
          "comment": "Internal variable. True while uprighting forces are being applied."
        },
        "bUpdateWheelShapes": {
          "comment": "set this flag to cause wheel shape parameters to be updated. Cleared after update occurs."
        },
        "bVehicleOnGround": {
          "comment": "OUTPUT: True if _any_ SVehicleWheel is currently touching the ground (ignores contacts with chassis etc)"
        },
        "bVehicleOnWater": {
          "comment": "OUTPUT: True if _any_ SVehicleWheel is currently touching water"
        },
        "bWasChassisTouchingGroundLastTick": {
          "comment": "OUTPUT: True if there were any contacts between the chassis of the vehicle and the ground last tick"
        },
        "HeavySuspensionShiftPercent": {
          "comment": "Percent the Suspension must want to move in one go for the heavy shift function to be called"
        },
        "LastCollisionSoundTime": {
          "comment": "Internal variable; prevents collision sounds from being triggered too frequently."
        },
        "RadialImpulseScaling": {
          "comment": "Hacky - used to scale hurtradius applied impulses"
        },
        "TimeOffGround": {
          "comment": "OUTPUT: Time that bVehicleOnGround has been false for."
        },
        "UprightStartTime": {
          "comment": "Internal variable. Marks the time that uprighting began."
        },
        "CollisionIntervalSecs": {
          "comment": "Minimum time passed between the triggering collision sounds; generally set to longest collision sound."
        },
        "CollisionSound": {
          "comment": "Played when the vehicle slams into things."
        },
        "EngineSound": {
          "comment": "Ambient engine-running sound. Pitch modulated based on RPMS."
        },
        "EngineStartOffsetSecs": {
          "comment": "Time delay between the engine startup sound and the engine idling sound."
        },
        "EngineStopOffsetSecs": {
          "comment": "Time delay between the engine shutdown sound and the deactivation of the engine idling sound."
        },
        "EnterVehicleSound": {
          "comment": "Engine startup sound played upon entering the vehicle."
        },
        "ExitVehicleSound": {
          "comment": "Engine switch-off sound played upon exiting the vhicle."
        },
        "LatAngleVolumeMult": {
          "comment": "multiplier for volume level of Lateral squeals relative to straight slip squeals."
        },
        "SquealLatThreshold": {
          "comment": "Lateral Slip velocity cut off below which no wheel squealing is heard"
        },
        "SquealSound": {
          "comment": "Volume-modulated wheel squeeling."
        },
        "SquealThreshold": {
          "comment": "Slip velocity cuttoff below which no wheel squealing is heard."
        },
        "COMOffset": {
          "comment": "Center of mass location of the vehicle, in local space."
        },
        "InertiaTensorMultiplier": {
          "comment": "Inertia Tensor Multipler - allows you to scale the components of the pre-calculated inertia tensor"
        },
        "MaxAngularVelocity": {
          "comment": "Vehicle angular velocity will be capped to this value"
        },
        "MaxSpeed": {
          "comment": "Vehicle total speed will be capped to this value"
        },
        "SimObj": {
          "comment": "Object containing the actual vehicle simulation paramters and code. Allows you to 'plug' different vehicle types in."
        },
        "Wheels": {
          "comment": "Data for each wheel."
        },
        "bStayUpright": {
          "comment": "Use the stay-upright world constraint"
        },
        "StayUprightDamping": {
          "comment": "Amount of dampening past the limit angles"
        },
        "StayUprightPitchResistAngle": {
          "comment": "Angle at which the vehicle will resist pitching"
        },
        "StayUprightRollResistAngle": {
          "comment": "Angle at which the vehicle will resist rolling"
        },
        "StayUprightStiffness": {
          "comment": "Amount of spring past the limit angles"
        },
        "UprightLiftStrength": {
          "comment": "Scales the lifting force applied to the vehicle during uprighting."
        },
        "UprightTime": {
          "comment": "Time in seconds to apply uprighting force/torque."
        },
        "UprightTorqueStrength": {
          "comment": "Scales the torque applied to the vehicle during uprighting."
        }
      },
      "functions": {
        "CalcCamera": {
          "comment": "Calculate camera view point, when viewing this actor.",
          "params": {
            "fDeltaTime": "delta time seconds since last update",
            "out_CamLoc": "Camera Location",
            "out_CamRot": "Camera Rotation",
            "out_FOV": "Field of View"
          }
        },
        "DisplayWheelsDebug": {
          "comment": "Special debug information for the wheels that is displayed at each wheel's location"
        },
        "GetSVehicleDebug": {
          "comment": "Retrieves important SVehicle debug information as an array of strings. That can then be dumped or displayed on HUD."
        },
        "HasWheelsOnGround": {
          "comment": "HasWheelsOnGround()\nreturns true if any of vehicles wheels are currently in contact with the ground (wheel has bWheelOnGround==true)"
        },
        "HermiteEval": {
          "comment": "Hermite spline evaluation for use with the slip curve debug display"
        },
        "InitVehicleRagdoll": {
          "comment": "Utility for switching the vehicle from a single body to an articulated ragdoll-like one given a new mesh and physics asset.\n ActorMove is an extra translation applied to Actor during the transition, which can be useful to avoid ragdoll mesh penetrating into the ground."
        },
        "PostBeginPlay": {
          "comment": "Called when gameplay begins. Used to make sure the engine sound audio component\n has the right properties set to ensure it gets restarted if it has been cut out\n due to the audio code running out of HW channels to play the sound in."
        },
        "PostInitAnimTree": {
          "comment": "Store pointer to each wheel's SkelControlWheel."
        },
        "SetWheelCollision": {
          "comment": "turns on or off a wheel's collision",
          "params": {
            "WheelNum": "the index of the wheel in the Wheels array to change",
            "bCollision": "whether to turn collision on or off"
          }
        },
        "StartEngineSound": {
          "comment": "turns on the engine sound"
        },
        "StartEngineSoundTimed": {
          "comment": "starts a timer of EngineStartOffsetSecs duration to turn on the engine sound"
        },
        "StopEngineSound": {
          "comment": "turns off the engine sound"
        },
        "StopEngineSoundTimed": {
          "comment": "starts a timer of EngineStopOffsetSecs duration to turn off the engine sound"
        },
        "SuspensionHeavyShift": {
          "comment": "called when the suspension moves a large amount, passes the delta"
        },
        "TakeRadiusDamage": {
          "comment": "Take Radius Damage\n by default scales damage based on distance from HurtOrigin to Actor's location.\n This can be overriden by the actor receiving the damage for special conditions (see KAsset.uc).",
          "params": {
            "InstigatedBy,": "instigator of the damage",
            "Base": "Damage",
            "Damage": "Radius (from Origin)",
            "DamageType": "class",
            "Momentum": "(float)",
            "HurtOrigin,": "origin of the damage radius.",
            "bFullDamage,": "if true, damage not scaled based on distance HurtOrigin",
            "DamageCauser": "the Actor that directly caused the damage (i.e. the Projectile that exploded, the Weapon that fired, etc)"
          }
        },
        "TurnOff": {
          "comment": "TurnOff()\nFreeze pawn - stop sounds, animations, physics, weapon firing"
        }
      }
    },
    "SVehicleSimBase": {
      "properties": {
        "bClampedFrictionModel": {
          "comment": "Friction model that clamps the frictional force applied by the wheels. Should be more realistic."
        }
      }
    },
    "SVehicleSimTank": {
      "properties": {
        "bTurnInPlaceOnSteer": {
          "comment": "If true, tank will turn in place when just steering is applied."
        },
        "TurnGripScaleRate": {
          "comment": "How quickly grip drops off based on difference in track speed."
        },
        "TurnMaxGripReduction": {
          "comment": "Maximum amount we will reduce lateral grip."
        }
      }
    },
    "SVehicleWheel": {
      "properties": {
        "SlipParticleParamName": {
          "comment": "parameter that should be set in WheelParticleComp to the wheel's slip velocity"
        },
        "WheelPSCClass": {
          "comment": "the class to use for WheelParticleComp"
        },
        "bCollidesPawns": {
          "comment": "If true, this wheel will collide with pawns (add RBCC_Pawn to its RBCollideWithChannels)."
        },
        "bCollidesVehicles": {
          "comment": "If true, this wheel will collide with other vehicles (add RBCC_Vehicle to its RBCollideWithChannels)."
        },
        "SteerFactor": {
          "comment": "How steering affects this wheel. 0.0 means it is not steered. 1.0 means steered fully normally. -1.0 means reversed steering."
        }
      }
    },
    "Teleporter": {
      "properties": {
        "bCanTeleportVehicles": {
          "comment": "whether this Teleporter works on vehicles"
        }
      },
      "functions": {
        "CanTeleport": {
          "comment": "returns whether this NavigationPoint is a teleporter that can teleport the given Actor"
        }
      }
    },
    "Terrain": {
      "properties": {
        "AlphaMaps": {
          "comment": "Array of the alpha maps between layers"
        },
        "bHeightmapLocked": {
          "comment": "The terrain heightmap is locked - no editing can take place on it"
        },
        "bLocked": {
          "comment": "The terrain is locked - no editing can take place on it"
        },
        "bShowingCollision": {
          "comment": "Viewing collision tessellation level"
        },
        "CachedTerrainMaterials[2]": {
          "comment": "array of cached terrain materials \n Only the first entry is ever used now that SM2 is no longer supported, \n But the member is kept as an array to make adding future material platforms easier. \n The second entry is to work around the script compile error from having an array with one element."
        },
        "Heights": {
          "comment": "Array of the terrain heights"
        },
        "InfoData": {
          "comment": "Array of the terrain information data (visible, etc.)"
        },
        "LightingGuid": {
          "comment": "Unique ID for this terrain, used for caching during distributed lighting"
        },
        "NumSectionsX": {
          "comment": "Internal values used to setup components\n The number of sections is the number of terrain components along the\n X and Y of the 'grid'."
        },
        "NumVerticesX": {
          "comment": "The number of vertices currently stored in a single row of height and alpha data.\n Updated from NumPatchesX when Allocate is called(usually from PostEditChange)."
        },
        "NumVerticesY": {
          "comment": "The number of vertices currently stored in a single column of height and alpha data.\n Updated from NumPatchesY when Allocate is called(usually from PostEditChange)."
        },
        "ReleaseResourcesFence": {
          "comment": "Command fence used to shut down properly"
        },
        "TerrainComponents": {
          "comment": "The array of terrain components that are used by the terrain"
        },
        "WeightedMaterials": {
          "comment": "INTERNAL - The weighted materials and blend maps"
        },
        "bAllowRigidBodyUnderneath": {
          "comment": "If true, this allows rigid bodies to go underneath visible areas of the terrain. This adds some physics cost."
        },
        "bBlockRigidBody": {
          "comment": "If false, primitive does not block rigid body physics.\n Property is propagated to terrain components."
        },
        "CollisionTesselationLevel": {
          "comment": "The tessellation level to utilize when performing collision checks with non-zero extents."
        },
        "bAcceptsDynamicLights": {
          "comment": "If false, primitive does not accept dynamic lights, aka lights with HasStaticShadowing() == FALSE\n Property is propagated to terrain components."
        },
        "bBilinearFilterLightmapGeneration": {
          "comment": "If true, the lightmap generation will be performed using the bilinear filtering\n that all other lightmap generation in the engine uses."
        },
        "bCastDynamicShadow": {
          "comment": "If false, primitive does not cast dynamic shadows.\n Property is propagated to terrain components ."
        },
        "bCastShadow": {
          "comment": "Whether terrain should cast shadows.\n Property is propagated to terrain components"
        },
        "bEnableSpecular": {
          "comment": "If TRUE, enable specular on this terrain."
        },
        "bForceDirectLightMap": {
          "comment": "If true, forces all static lights to use light-maps for direct lighting on the terrain, regardless of\n the light's UseDirectLightMap property.\n Property is propagated to terrain components ."
        },
        "bIsOverridingLightResolution": {
          "comment": "If true, the light/shadow map size is no longer restricted...\n The size of the light map will be (per component):\n INT LightMapSizeX = Component->SectionSizeX * StaticLightingResolution + 1;\n INT LightMapSizeY = Component->SectionSizeY * StaticLightingResolution + 1;\n So, the maximum size of a light/shadow map for a component will be:\n MaxMapSizeX = MaxComponentSize * StaticLightingResolution + 1\n MaxMapSizeY = MaxComponentSize * StaticLightingResolution + 1\n Be careful with the setting of StaticLightingResolution when this mode is enabled.\n It will be quite easy to run up a massive texture requirement on terrain!"
        },
        "StaticLightingResolution": {
          "comment": "The resolution to cache lighting at, in texels/patch.\n A separate shadow-map is used for each terrain component, which is up to\n (MaxComponentSize * StaticLightingResolution + 1) pixels on a side.\n Must be a power of two, 1 <= StaticLightingResolution <= MaxTesselationLevel."
        },
        "LightmassSettings<ScriptOrder=true>": {
          "comment": "Lightmass settings for the terrain"
        },
        "TerrainPhysMaterialOverride": {
          "comment": "PhysicalMaterial to use for entire terrain"
        },
        "bMorphingEnabled": {
          "comment": "Whether to utilize morping terrain or not"
        },
        "bMorphingGradientsEnabled": {
          "comment": "Whether to utilize morping gradients or not (bMorphingEnabled must be true for this to matter)"
        },
        "bShowWireframe": {
          "comment": "Tells the terrain to render in wireframe."
        },
        "bUseWorldOriginTextureUVs": {
          "comment": "Base UVs from world origin, to avoid layering seams in adjacent terrains"
        },
        "DecoLayers": {
          "comment": "Array of the decoration layers applied"
        },
        "EditorTessellationLevel": {
          "comment": "Editor-viewing tessellation level"
        },
        "Layers": {
          "comment": "Array of the terrain layers applied to the terrain"
        },
        "MaxComponentSize": {
          "comment": "For rendering and collision, split the terrain into components with a maximum size of\n (MaxComponentSize,MaxComponentSize) patches.\n The terrain is split up into rectangular groups of patches called terrain components for rendering.\n MaxComponentSize is the maximum number of patches in a single row/column of a terrain component.\n Generally, all components will be MaxComponentSize patches square, but on terrains with a patch\n resolution which isn't a multiple of MaxComponentSize, there will be some components along the edges\n which are smaller.\n This is limited by the MaxTesselationLevel, to prevent the vertex buffer for a fully tessellated\n component from being > 65536 vertices.\n For a MaxTesselationLevel of 16, MaxComponentSize is limited to <= 15.\n For a MaxTesselationLevel of 8, MaxComponentSize is limited to <= 31.\n PostEditChange clamps this to be >= 1."
        },
        "MaxTesselationLevel": {
          "comment": "The maximum number of quads in a single row/column of a tessellated patch.\n Must be a power of two, 1 <= MaxTesselationLevel <= 16"
        },
        "MinTessellationLevel": {
          "comment": "The minimum number of quads in a tessellated patch.\n Must be a power of two, 1 <= MaxTesselationLevel"
        },
        "NormalMapLayer": {
          "comment": "The index of the layer that supplies the normal map for the whole terrain.\n If this is -1, the terrain will compile the normal property the old way\n (all normal maps blended together).\n If this is a valid index into the layer array, it will compile the normal\n property only for the material(s) contained in said layer."
        },
        "NumPatchesX": {
          "comment": "The number of patches in a single row of the terrain's patch grid.\n PostEditChange clamps this to be >= 1.\n Note that if you make this and/or NumPatchesY smaller, it will destroy the height-map/alpha-map\n data which is no longer used by the patches.If you make the dimensions larger, it simply fills\n in the new height-map/alpha-map data with zero."
        },
        "NumPatchesY": {
          "comment": "The number of patches in a single column of the terrain's patch grid.\n PostEditChange clamps this to be >= 1."
        },
        "TesselationDistanceScale": {
          "comment": "The scale factor to apply to the distance used in determining the tessellation\n level to utilize when rendering a patch.\n TessellationLevel = SomeFunction((Patch distance to camera) * TesselationDistanceScale)"
        },
        "TessellationCheckDistance": {
          "comment": "The radius from the view origin that terrain tessellation checks should be performed.\n If less than 0, the general setting from the engine configuration will be used.\n If 0.0, every component will be checked for tessellation changes each frame."
        },
        "WireframeColor": {
          "comment": "The color to use when rendering the wireframe of the terrain."
        }
      },
      "functions": {
        "CalcLayerBounds": {
          "comment": "for each layer, calculate the rectangle encompassing all the vertices affected by it and store the result in\n the layer's MinX, MinY, MaxX, and MaxY properties"
        }
      },
      "structs": {
        "AlphaMap": {
          "comment": "A mapping used to apply a layer to the terrain.\n Full structure can be found in UnTerrain.h, FAlphaMap."
        },
        "SelectedTerrainVertex": {
          "comment": "Selected vertex structure - used for vertex editing",
          "properties": {
            "Weight": {
              "comment": "The weight of the selection."
            },
            "X": {
              "comment": "The position of the vertex."
            },
            "Y": {
              "comment": "The position of the vertex."
            }
          }
        },
        "TerrainDecoLayer": {
          "comment": "A decoration layer - used to easily apply static meshes to the terrain",
          "properties": {
            "AlphaMapIndex": {
              "comment": "INTERNAL: The index of the alpha map that represents the application of this layer."
            },
            "Decorations": {
              "comment": "The decoration(s) to apply for this layer."
            },
            "Name": {
              "comment": "The name of the DecoLayer, for UI display purposes."
            }
          }
        },
        "TerrainDecoration": {
          "comment": "A decoration source for terrain DecoLayers.",
          "properties": {
            "Density": {
              "comment": "The density to use when applying the mesh to the terrain."
            },
            "Factory": {
              "comment": "The factory used to generate the decoration mesh."
            },
            "Instances": {
              "comment": "INTERNAL: An array of instances of the decoration applied to the\n terrain."
            },
            "MaxScale": {
              "comment": "The max scale to apply to the source mesh."
            },
            "MinScale": {
              "comment": "The min scale to apply to the source mesh."
            },
            "RandSeed": {
              "comment": "The value to use to seed the random number generator."
            },
            "SlopeRotationBlend": {
              "comment": "The amount to rotate the mesh to match the slope of the terrain\n where it is being placed. If 1.0, the mesh will match the slope\n exactly."
            }
          }
        },
        "TerrainDecorationInstance": {
          "comment": "A decoration instance applied to the terrain.\n Used internally to apply DecoLayers."
        },
        "TerrainHeight": {
          "comment": "A height data entry that is stored in an array for the terrain.\n Full structure can be found in UnTerrain.h, FTerrainHeight."
        },
        "TerrainInfoData": {
          "comment": "InfoData entries for each patch in the terrain.\n This includes information such as whether the patch is visible or not (holes).\n Full structure can be found in UnTerrain.h, FTerrainInfoData."
        },
        "TerrainLayer": {
          "comment": "A layer that can be painted onto the terrain.",
          "properties": {
            "AlphaMapIndex": {
              "comment": "INTERNAL: The index of the alpha map that represents the application of this layer."
            },
            "Hidden": {
              "comment": "Whether the layer is hidden (not rendered)."
            },
            "HighlightColor": {
              "comment": "The color to highlight the layer with."
            },
            "Highlighted": {
              "comment": "Whether the layer should be highlighted when rendered."
            },
            "MaxX": {
              "comment": "Rectangle encompassing all the vertices this layer affects.\n TerrainLayerSetup::SetMaterial() uses this to avoid rebuilding\n terrain that has not changed"
            },
            "MaxY": {
              "comment": "Rectangle encompassing all the vertices this layer affects.\n TerrainLayerSetup::SetMaterial() uses this to avoid rebuilding\n terrain that has not changed"
            },
            "MinX": {
              "comment": "Rectangle encompassing all the vertices this layer affects.\n TerrainLayerSetup::SetMaterial() uses this to avoid rebuilding\n terrain that has not changed"
            },
            "MinY": {
              "comment": "Rectangle encompassing all the vertices this layer affects.\n TerrainLayerSetup::SetMaterial() uses this to avoid rebuilding\n terrain that has not changed"
            },
            "Name": {
              "comment": "The name of the layer, for UI display purposes."
            },
            "Setup": {
              "comment": "The TerrainLayerSetup, which declares the material(s) used in the layer."
            },
            "WireframeColor": {
              "comment": "The color to wireframe highlight the layer with."
            },
            "WireframeHighlighted": {
              "comment": "Whether the layer should be wireframe highlighted when rendered.\n CURRENTLY NOT IMPLEMENTED"
            }
          }
        },
        "TerrainMaterialResource": {
          "comment": "Terrain material resource - compiled terrain material used to render the terrain.\n Full structure can be found in UnTerrain.h, FTerrainMaterialResource."
        },
        "TerrainWeightedMaterial": {
          "comment": "A weighted material used on the terrain.\n Full structure can be found in UnTerrain.h, FTerrainWeightedMaterial."
        }
      }
    },
    "TerrainComponent": {
      "properties": {
        "bDisplayCollisionLevel": {
          "comment": "Indicates the the terrain collision level should be rendered."
        },
        "BVTree": {
          "comment": "Used for in-game collision tests against terrain."
        },
        "CollisionVertices": {
          "comment": "This is a low poly version of the terrain vertices in world space. The\n triangle data is created based upon Terrain->CollisionTesselationLevel"
        },
        "IrrelevantLights": {
          "comment": "INTERNAL: Array of lights that don't apply to the terrain component."
        },
        "RBHeightfield": {
          "comment": "Physics engine version of heightfield data."
        },
        "ShadowMaps": {
          "comment": "INTERNAL: Array of shadow map data applied to the terrain component."
        },
        "TrueSectionSizeX": {
          "comment": "The actual section size in vertices..."
        }
      },
      "structs": {
        "TerrainBVTree": {
          "comment": "Place holder structure that mirrors the byte size needed for a BV tree."
        }
      }
    },
    "TerrainLayerSetup": {
      "functions": {
        "PostBeginPlay": {
          "comment": "called from Terrain::PostBeginPlay() to allow the layer to initialize itself for gameplay\n @note this function will be called once for each terrain the layer is part of"
        }
      }
    },
    "TerrainMaterial": {
      "properties": {
        "DisplacementMap": {
          "comment": "Grayscale image to move vertices of the terrain along the surface normal."
        },
        "DisplacementScale": {
          "comment": "The amount to sacle the displacement texture by."
        },
        "MappingPanU": {
          "comment": "Offset to apply to the mapping along U."
        },
        "MappingPanV": {
          "comment": "Offset to apply to the mapping along V."
        },
        "MappingRotation": {
          "comment": "Rotation to apply to the mapping."
        },
        "MappingScale": {
          "comment": "Uniform scale to apply to the mapping."
        },
        "MappingType": {
          "comment": "Determines the mapping place to use on the terrain."
        },
        "Material": {
          "comment": "The Material to apply to the terrain."
        }
      }
    },
    "Texture": {
      "properties": {
        "bAsyncResourceReleaseHasBeenStarted": {
          "comment": "Whether the async resource release process has already been kicked off or not"
        },
        "bIsSourceArtUncompressed": {
          "comment": "Has uncompressed source art?"
        },
        "bNoTiling": {
          "comment": "If TRUE, the RHI texture will be created using TexCreate_NoTiling"
        },
        "bUseCinematicMipLevels": {
          "comment": "Whether to use the extra cinematic quality mip-levels, when we're forcing mip-levels to be resident."
        },
        "CachedCombinedLODBias": {
          "comment": "Cached combined group and texture LOD bias to use."
        },
        "InternalFormatLODBias": {
          "comment": "Internal LOD bias already applied by the texture format (eg TC_NormalMapUncompressed). Used to adjust MinLODMipCount and MaxLODMipCount in CalculateLODBias"
        },
        "LightingGuid": {
          "comment": "Unique ID for this material, used for caching during distributed lighting"
        },
        "Resource": {
          "comment": "The texture's resource."
        },
        "bForcePVRTC4": {
          "comment": "For DXT1 textures, setting this will cause the texture to be twice the size, but better looking, on iPhone"
        },
        "AdjustBrightness": {
          "comment": "Static texture brightness adjustment (scales HSV value.) (Non-destructive; Requires texture source art to be available.)"
        },
        "AdjustBrightnessCurve": {
          "comment": "Static texture curve adjustment (raises HSV value to the specified power.) (Non-destructive; Requires texture source art to be available.)"
        },
        "AdjustHue": {
          "comment": "Static texture hue adjustment (0 - 360) (offsets HSV hue by value in degrees.) (Non-destructive; Requires texture source art to be available.)"
        },
        "AdjustRGBCurve": {
          "comment": "Static texture RGB curve adjustment (raises linear-space RGB color to the specified power.) (Non-destructive; Requires texture source art to be available.)"
        },
        "AdjustSaturation": {
          "comment": "Static texture saturation adjustment (scales HSV saturation.) (Non-destructive; Requires texture source art to be available.)"
        },
        "AdjustVibrance": {
          "comment": "Static texture \"vibrance\" adjustment (0 - 1) (HSV saturation algorithm adjustment.) (Non-destructive; Requires texture source art to be available.)"
        },
        "bDitherMipMapAlpha": {
          "comment": "When TRUE, the alpha channel of mip-maps and the base image are dithered for smooth LOD transitions."
        },
        "bPreserveBorderR": {
          "comment": "If TRUE, the color border pixels are preserved by mipmap generation. One flag per color channel."
        },
        "Filter": {
          "comment": "The texture filtering mode to use when sampling this texture."
        },
        "LODBias": {
          "comment": "A bias to the index of the top mip level to use."
        },
        "LODGroup": {
          "comment": "Texture group this texture belongs to for LOD bias"
        },
        "MipGenSettings": {
          "comment": "Per asset specific setting to define the mip-map generation properties like sharpening and kernel size."
        },
        "NumCinematicMipLevels": {
          "comment": "Number of mip-levels to use for cinematic quality."
        }
      },
      "structs": {
        "TextureGroupContainer": {
          "comment": "Select texture group(s)"
        }
      }
    },
    "Texture2D": {
      "properties": {
        "bForceMiplevelsToBeResident": {
          "comment": "Override whether to fully stream even if texture hasn't been rendered."
        },
        "bHasBeenLoadedFromPersistentArchive": {
          "comment": "Whether the texture has been loaded from a persistent archive. We keep track of this in order to not stream \n textures that are being re-imported over as they will have a linker but won't have been serialized from disk \n and are therefore not streamable."
        },
        "bHasCancelationPending": {
          "comment": "Whether the current texture mip change request is pending cancelation."
        },
        "bIsStreamable": {
          "comment": "Whether the texture is currently streamable or not."
        },
        "CachedPVRTCMips": {
          "comment": "Cached PVRTC compressed texture data"
        },
        "FirstResourceMemMip": {
          "comment": "keep track of first mip level used for ResourceMem creation"
        },
        "ForceMipLevelsToBeResidentTimestamp": {
          "comment": "WorldInfo timestamp that tells the streamer to force all miplevels to be resident up until that time."
        },
        "Format": {
          "comment": "The format of the texture data."
        },
        "Mips": {
          "comment": "The texture's mip-map data."
        },
        "MipTailBaseIdx": {
          "comment": "Keep track of the first mip level stored in the packed miptail.\n it's set to highest mip level if no there's no packed miptail"
        },
        "OriginalSizeX": {
          "comment": "The original width of the texture source art we imported from."
        },
        "OriginalSizeY": {
          "comment": "The original height of the texture source art we imported from."
        },
        "PendingMipChangeRequestStatus": {
          "comment": "Thread-safe counter indicating the texture streaming state. The definitions below are mirrored in UnTex.h.\nenum ETextureStreamingState\n{\n// The renderer hasn't created the resource yet.\nTexState_InProgress_Initialization = -1,\n// There are no pending requests/ all requests have been fulfilled.\nTexState_ReadyFor_Requests = 0,\n// Finalization has been kicked off and is in progress.\nTexState_InProgress_Finalization = 1,\n// Initial request has completed and finalization needs to be kicked off.\nTexState_ReadyFor_Finalization = 2,\n// We're currently loading in mip data.\nTexState_InProgress_Loading = 3,\n// ...\n// States 3+N means we're currently loading in N mips\n// ...\n// Memory has been allocated and we're ready to start loading in mips.\nTexState_ReadyFor_Loading = 100,\n// We're currently allocating/preparing memory for the new mip count.\nTexState_InProgress_Allocating = 101,\n};"
        },
        "RequestedMips": {
          "comment": "Number of miplevels the texture should have resident."
        },
        "ResidentMips": {
          "comment": "Number of miplevels currently resident."
        },
        "ResourceMem": {
          "comment": "memory used for directly loading bulk mip data"
        },
        "SizeX": {
          "comment": "The width of the texture."
        },
        "SizeY": {
          "comment": "The height of the texture."
        },
        "StreamableTexturesLink": {
          "comment": "This texture's link in the global streamable texture list."
        },
        "StreamingIndex": {
          "comment": "FStreamingTexture index used by the texture streaming system."
        },
        "SystemMemoryData": {
          "comment": "Data formatted only for 1 bit textures which are CPU based and never allocate GPU Memory"
        },
        "TextureFileCacheGuid": {
          "comment": "ID generated whenever the texture is changed so that its bulk data can be updated in the TextureFileCache during cook"
        },
        "TextureFileCacheName": {
          "comment": "Name of texture file cache texture mips are stored in, NAME_None if it is not part of one."
        },
        "Timer": {
          "comment": "Used for various timing measurements, e.g. streaming latency."
        },
        "AddressX": {
          "comment": "The addressing mode to use for the X axis."
        },
        "AddressY": {
          "comment": "The addressing mode to use for the Y axis."
        },
        "bGlobalForceMipLevelsToBeResident": {
          "comment": "Global/ serialized version of ForceMiplevelsToBeResident."
        },
        "bIsCompositingSource": {
          "comment": "Allows texture to be a source for Texture2DComposite. Will NOT be available for use in rendering!"
        }
      },
      "functions": {
        "Create": {
          "comment": "creates and initializes a new Texture2D with the requested settings"
        },
        "SetForceMipLevelsToBeResident": {
          "comment": "Tells the streaming system that it should force all mip-levels to be resident for a number of seconds.",
          "params": {
            "Seconds": "Duration in seconds",
            "CinematicTextureGroups": "Bitfield indicating which texture groups that use extra high-resolution mips"
          }
        }
      },
      "structs": {
        "Texture2DMipMap": {
          "comment": "A mip-map of the texture."
        },
        "TextureLinkedListMirror": {
          "comment": "Mirror helper structure for linked list of texture objects. The linked list should NOT be traversed by the\n garbage collector, which is why Element is declared as a pointer."
        }
      }
    },
    "Texture2DComposite": {
      "properties": {
        "MaxTextureSize": {
          "comment": "Optional max texture size clamp for the composite texture. A value of 0 is ignored and \n defaults to deriving the texture size using texture LOD bias settings from the source textures"
        },
        "SourceRegions": {
          "comment": "list of source textures and UV regions for compositing"
        }
      },
      "functions": {
        "ResetSourceRegions": {
          "comment": "Utils to reset all source region info."
        },
        "SourceTexturesFullyStreamedIn": {
          "comment": "Utility that checks to see if all Texture2Ds specified in the SourceRegions array are fully streamed in."
        },
        "UpdateCompositeTexture": {
          "comment": "Regenerates this composite texture using the list of source texture regions.\n The existing mips are reallocated and the RHI resource for the texture is updated",
          "params": {
            "NumMipsToGenerate": "number of mips to generate. if 0 then all mips are created"
          }
        }
      },
      "structs": {
        "SourceTexture2DRegion": {
          "comment": "Defines a source texture and UV region in that texture"
        }
      }
    },
    "Texture2DDynamic": {
      "properties": {
        "bIsResolveTarget": {
          "comment": "Whether the texture can be used as a resolve target."
        },
        "Format": {
          "comment": "The format of the texture."
        },
        "NumMips": {
          "comment": "The number of mip-maps in the texture."
        },
        "SizeX": {
          "comment": "The width of the texture."
        },
        "SizeY": {
          "comment": "The height of the texture."
        }
      },
      "functions": {
        "Create": {
          "comment": "Creates and initializes a new Texture2DDynamic with the requested settings"
        },
        "Init": {
          "comment": "Initializes the texture with 1 mip-level and creates the render resource.",
          "params": {
            "InSizeX": "Width of the texture, in texels",
            "InSizeY": "Height of the texture, in texels",
            "InFormat": "Format of the texture, defaults to PF_A8R8G8B8",
            "InIsResolveTarget": "Whether the texture can be used as a resolve target"
          }
        }
      }
    },
    "TextureCube": {
      "properties": {
        "bIsCubemapValid": {
          "comment": "Cached information on whether the cubemap is valid, aka all faces are non NULL and match in width, height and format."
        },
        "Format": {
          "comment": "Cached format of the cubemap"
        },
        "NumMips": {
          "comment": "Cached number of mips in the cubemap"
        },
        "SizeX": {
          "comment": "Cached width of the cubemap."
        },
        "SizeY": {
          "comment": "Cached height of the cubemap."
        }
      }
    },
    "TextureFlipBook": {
      "properties": {
        "bPaused": {
          "comment": "Whether the movie is currently paused."
        },
        "bStopped": {
          "comment": "Whether the movie is currently stopped."
        },
        "CurrentColumn": {
          "comment": "The current sub-image column"
        },
        "CurrentRow": {
          "comment": "The current sub-image row"
        },
        "HorizontalScale": {
          "comment": "The horizontal scale factor"
        },
        "ReleaseResourcesFence": {
          "comment": "Command fence used to shut down properly"
        },
        "RenderOffsetU": {
          "comment": "The current sub-image row for the render-thread"
        },
        "RenderOffsetV": {
          "comment": "The current sub-image column for the render-thread"
        },
        "TimeIntoMovie": {
          "comment": "Time into the movie in seconds."
        },
        "TimeSinceLastFrame": {
          "comment": "Time that has passed since the last frame. Will be adjusted by decoder to combat drift."
        },
        "VerticalScale": {
          "comment": "The vertical scale factor"
        },
        "bAutoPlay": {
          "comment": "Whether the movie should automatically start playing when it is loaded."
        },
        "bLooping": {
          "comment": "Whether the movie should loop when it reaches the end."
        },
        "FrameRate": {
          "comment": "The time to display a single frame"
        },
        "HorizontalImages": {
          "comment": "The horizontal and vertical sub-image count"
        }
      },
      "functions": {
        "Pause": {
          "comment": "Pauses the movie."
        },
        "Play": {
          "comment": "Plays the movie and also unpauses."
        },
        "SetCurrentFrame": {
          "comment": "Sets the current frame of the 'movie'."
        },
        "Stop": {
          "comment": "Stops movie playback."
        }
      }
    },
    "TextureMovie": {
      "properties": {
        "Data": {
          "comment": "Raw compressed data as imported."
        },
        "Decoder": {
          "comment": "Instance of decoder."
        },
        "DecoderClass": {
          "comment": "Class type of Decoder that will be used to decode Data."
        },
        "Format": {
          "comment": "The format of the texture data."
        },
        "Paused": {
          "comment": "Whether the movie is currently paused."
        },
        "ReleaseCodecFence": {
          "comment": "Set in order to synchronize codec access to this movie texture resource from the render thread"
        },
        "SizeX": {
          "comment": "The width of the texture."
        },
        "SizeY": {
          "comment": "The height of the texture."
        },
        "Stopped": {
          "comment": "Whether the movie is currently stopped."
        },
        "AddressX": {
          "comment": "The addressing mode to use for the X axis."
        },
        "AddressY": {
          "comment": "The addressing mode to use for the Y axis."
        },
        "AutoPlay": {
          "comment": "Whether the movie should automatically start playing when it is loaded."
        },
        "Looping": {
          "comment": "Whether the movie should loop when it reaches the end."
        },
        "MovieStreamSource": {
          "comment": "Select streaming movie from memory or from file for playback"
        },
        "ResetOnLastFrame": {
          "comment": "Whether the movie should reset to first frame when it reaches the end."
        }
      },
      "functions": {
        "Pause": {
          "comment": "Pauses the movie."
        },
        "Play": {
          "comment": "Plays the movie and also unpauses."
        },
        "Stop": {
          "comment": "Stops movie playback."
        }
      }
    },
    "TextureRenderTarget": {
      "properties": {
        "bUpdateImmediate": {
          "comment": "If true, initialise immediately instead of allowing deferred update."
        },
        "bNeedsTwoCopies": {
          "comment": "If true, there will be two copies in memory - one for the texture and one for the render target. If false, they will share memory if possible. This is useful for scene capture textures that are used in the scene."
        },
        "bRenderOnce": {
          "comment": "If true, the render target will only be written to one time"
        },
        "TargetGamma": {
          "comment": "Will override FTextureRenderTarget2DResource::GetDisplayGamma if > 0."
        }
      }
    },
    "TextureRenderTarget2D": {
      "properties": {
        "ClearColor": {
          "comment": "the color the texture is cleared to"
        },
        "Format": {
          "comment": "The format of the texture data."
        },
        "AddressX": {
          "comment": "The addressing mode to use for the X axis."
        },
        "AddressY": {
          "comment": "The addressing mode to use for the Y axis."
        },
        "bForceLinearGamma": {
          "comment": "True to force linear gamma space for this render target"
        },
        "SizeX": {
          "comment": "The width of the texture."
        },
        "SizeY": {
          "comment": "The height of the texture."
        }
      },
      "functions": {
        "Create": {
          "comment": "creates and initializes a new TextureRenderTarget2D with the requested settings"
        }
      }
    },
    "TextureRenderTargetCube": {
      "properties": {
        "Format": {
          "comment": "The format of the texture data."
        },
        "SizeX": {
          "comment": "The width of the texture."
        }
      }
    },
    "TranslationContext": {
      "comment": "A TranslationContext is part of the system for managing translation tags in localization text.\n This system handles text with special tags. E.g.: Press to look at point of interest.\n A TranslationContext provides information that cannot be deduced from the text alone.\n In the example above player1 and player2 might have different buttons mapped to the POI action;\n a per-player context helps translate based on the player's controller setup.",
      "properties": {
        "TranslatorTags": {
          "comment": "TranslatorTags that define this TranslationContext."
        }
      },
      "functions": {
        "RegisterTranslatorTag": {
          "comment": "Add a Tag to this Context"
        }
      }
    },
    "TranslatorTag": {
      "comment": "A TranslatorTag is part of the system that translates text with embedded\n tags. E.g.: Press to look at point of interest.\n In this example, 'Controller' is a tag, and we want it to process GBA_POI.\n The Controller TranslatorTag would look up the controls for the associated player\n and return a text representation of the control.\n \n See TranslationContext for more info.",
      "properties": {
        "Tag": {
          "comment": "The Tag that this Translator handles.\n E.g. In the case of the tag is 'Controller'."
        }
      },
      "functions": {
        "Translate": {
          "comment": "Return the translated text given the option.\n E.g. In the case of the argument is 'GBA_POI'.",
          "params": {
            "InArgument": "The text after the : in the tag."
          }
        }
      }
    },
    "Trigger": {
      "properties": {
        "bRecentlyTriggered": {
          "comment": "for AI, true if we have been recently triggered (so AI doesn't try to trigger it again)"
        },
        "AITriggerDelay": {
          "comment": "how long bRecentlyTriggered should stay set after each triggering"
        },
        "CylinderComponent": {
          "comment": "Base cylinder component for collision"
        }
      },
      "functions": {
        "NotifyTriggered": {
          "comment": "called when this trigger has successfully been used to activate a Kismet event"
        }
      }
    },
    "TriggeredPath": {
      "properties": {
        "bOpen": {
          "comment": "whether the path is currently usable"
        },
        "MyTrigger": {
          "comment": "the trigger, button, etc that will make this path usable"
        }
      }
    },
    "TriggerStreamingLevel": {
      "comment": "This volume is used to control which levels are loaded/unloaded during\n gameplay.",
      "properties": {
        "Levels": {
          "comment": "Holds the list of levels to load/unload when triggered"
        }
      },
      "functions": {
        "Touch": {
          "comment": "Loads & unloads the specified streaming levels when triggered",
          "params": {
            "Other": "the actor generating the event",
            "HitLocation": "the location of the touch",
            "HitNormal": "the normal generated at the touch"
          }
        }
      },
      "structs": {
        "LevelStreamingData": {
          "comment": "Holds the various settings needed to un/load a streaming level",
          "properties": {
            "bShouldBeLoaded": {
              "comment": "Whether the level should be loaded"
            },
            "bShouldBeVisible": {
              "comment": "Whether the level should be visible if it is loaded"
            },
            "bShouldBlockOnLoad": {
              "comment": "Whether we want to force a blocking load"
            },
            "Level": {
              "comment": "The level that will be streamed in"
            }
          }
        }
      }
    },
    "Trigger_LOS": {
      "functions": {
        "Tick": {
          "comment": "Overridden to check for any players looking at this\n trigger."
        }
      }
    },
    "UberPostProcessEffect": {
      "comment": "Uber post process effect",
      "properties": {
        "PreviousLUTBlender": {
          "comment": "LUTBlender parameters used last frame."
        },
        "BloomSizeScaleLarge": {
          "comment": "Scales the large kernel size. A good number is in the range from 2 to 4.\n This property is only used if BloomWeightLarge specifies some weight."
        },
        "BloomSizeScaleMedium": {
          "comment": "Scales the medium kernel size. A good number is in the range from 0.5 to 1.5."
        },
        "BloomSizeScaleSmall": {
          "comment": "Scales the small kernel size. A good number is in the range from 0.1 to 0.5.\n This property is only used if BloomWeightSmall specifies some weight."
        },
        "BloomWeightLarge": {
          "comment": "To adjust the bloom to get an extra outer, more wide spread glow.\n 0=off\n If this feature is used, it might costs additional performance depending on the bloom radius.\n However in some cases it might get faster as the bigger radius is done in lower resolution.\n The actual weight is computed as the ratio between all bloom weights."
        },
        "BloomWeightMedium": {
          "comment": "To adjust the bloom shape to reduce the extra inner and outer weight.\n Should be bigger than 0.\n However in some cases it might get faster as the bigger radius is done in lower resolution.\n The actual weight is computed as the ratio between all bloom weights."
        },
        "BloomWeightSmall": {
          "comment": "To adjust the bloom to get an extra inner, more sharp glow.\n 0=off\n If this feature is used, it might costs additional performance depending on the bloom radius.\n However in some cases it might get faster as the bigger radius is done in lower resolution.\n The actual weight is computed as the ratio between all bloom weights."
        },
        "MotionBlurSoftEdgeKernelSize": {
          "comment": "The radius of the soft edge for motion blur. A value bigger than 0 enables the soft edge motion blur. The method improves motion blur\n by blurring the silhuette of moving objects. The method works in screen space. Therefore the performance of the method only depends\n on screen size, not on the object/vertex/triangle count."
        },
        "bScaleEffectsWithViewSize": {
          "comment": "affects BlurKernelSize, the attribute is scaled depending on the view size"
        },
        "bEnableImageGrain": {
          "comment": "Whether the image grain (noise) is enabled, to fight 8 bit quantization artifacts and to simulate film grain (scaled by SceneImageGrainScale)"
        },
        "SceneImageGrainScale": {
          "comment": "Image grain scale, only affects the darks, >=0, 0:none, 1(strong) should be less than 1"
        },
        "TonemapperRange": {
          "comment": "This tonemapper property allows to specify the HDR brightness value that is mapping to the maximum LDR value. Brighter values will be\n mapped to white (good values are in the range 2 to 16). Only affects the \"Customizable\" tonemapper."
        },
        "TonemapperScale": {
          "comment": "Scale the input for the tonemapper. Only used if a tonemapper is specified.\n >=0, 0:black, 1(default), >1 brighter"
        },
        "TonemapperToeFactor": {
          "comment": "This tonemapper property allows to adjust the mapping of the darker colors (tonemapper toe). \n As the adjustment is independent per color channel it can introduce slight shifts color and saturation changes.\n Only affects the \"Customizable\" tonemapper.\n 0=linear .. 1=crushed darks (more filmic)"
        },
        "TonemapperType": {
          "comment": "Allows to specify the tone mapper function which maps HDR colors into the LDR color range."
        }
      }
    },
    "UICharacterSummary": {
      "functions": {
        "IsProviderDisabled": {
          "comment": "Allows a resource data provider instance to indicate that it should be unselectable in subscribed lists"
        }
      }
    },
    "UIConfigFileProvider": {
      "properties": {
        "ConfigFileName": {
          "comment": "the name of the config file associated with this data provider"
        },
        "Sections": {
          "comment": "the list of sections in this config file"
        }
      }
    },
    "UIConfigSectionProvider": {
      "properties": {
        "SectionName": {
          "comment": "the name of the section associated with this provider"
        }
      }
    },
    "UIDataProvider": {
      "properties": {
        "ProviderChangedNotifies": {
          "comment": "The list of delegates to call when data exposed by this provider has been updated.\n @todo - change into a map of property name => delegate, so that when a property name is passed to NotifyPropertyChanged,\n only those delegates are called."
        },
        "WriteAccessType": {
          "comment": "Determines whether/how subscribers to this data store are allowed to publish changes to property values."
        }
      },
      "functions": {
        "AddPropertyNotificationChangeRequest": {
          "comment": "Subscribes a function for receiving notifications that a property in this data provider has changed. Intended\n only for use between data providers and their owning data stores. For external notifications, use the callbacks\n in UIDataStore instead.",
          "params": {
            "InDelegate": "the delegate to add to the notification list"
          }
        },
        "AllowPublishingToField": {
          "comment": "Callback for allowing script-only children to specify whether modification of a particular field is allowed. This callback\n will only be called if the provider's WriteAccessType is ACCESS_PerField.\n Child classes should override this function to indicate which fields can be written to, if this provider's WriteAccessType\n is set to ACCESS_PerField. Otherwise, write access will not be allowed to any fields.",
          "params": {
            "FieldName": "the name of the field [within this provider] for the field to check",
            "ArrayIndex": "optional array index for use with data collections."
          }
        },
        "GenerateFillerData": {
          "comment": "Callback to allow script-only child classes to return filler data for their own data fields.",
          "params": {
            "DataTag": "the tag corresponding to the data field that we want filler data for"
          }
        },
        "GetFieldValue": {
          "comment": "Resolves the value of the data field specified and stores it in the output parameter.",
          "params": {
            "FieldName": "the data field to resolve the value for; guaranteed to correspond to a property that this provider\n can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)",
            "out_FieldValue": "receives the resolved value for the property specified.\n \n@see ParseDataStoreReference for additional notes",
            "ArrayIndex": "optional array index for use with data collections"
          }
        },
        "GetProviderFieldType": {
          "comment": "Retrieves the field type for the specified field",
          "params": {
            "DataTag": "the tag corresponding to the data field that we want the field type for",
            "out_ProviderFieldType": "will receive the fieldtype for the data field specified; if DataTag isn't supported\n by this provider, this value will not be modified."
          }
        },
        "GetSupportedScriptFields": {
          "comment": "Callback to allow script-only child classes to add their own supported tags when GetSupportedDataFields is called.",
          "params": {
            "out_Fields": "the list of data tags supported by this data store."
          }
        },
        "IsCollectionDataType": {
          "comment": "Wrapper for determining whether the specified field type represents a collection of data."
        },
        "IsProviderDisabled": {
          "comment": "Allows a data provider instance to indicate that it should be unselectable in lists"
        },
        "NotifyPropertyChanged": {
          "comment": "Iterates over the list of subscribed delegates and fires off the event. Called whenever the value of a field\n managed by this data provider is modified.",
          "params": {
            "PropTag": "the name of the property that changed"
          }
        },
        "ParseArrayDelimiter": {
          "comment": "Parses the string specified, separating the array index portion from the data field tag.",
          "params": {
            "DataTag": "the data tag that possibly contains an array index"
          }
        },
        "ParseTagArrayDelimiter": {
          "comment": "Wrapper for ParseArrayDelimiter that takes a name parameter."
        },
        "RemovePropertyNotificationChangeRequest": {
          "comment": "Removes the delegate from the notification list",
          "params": {
            "InDelegate": "the delegate to remove from the list"
          }
        },
        "SetFieldValue": {
          "comment": "Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.\n Only called if WriteAccessType is ACCESS_WriteAll or AllowsPublishingToField returns TRUE.",
          "params": {
            "FieldName": "the data field to resolve the value for; guaranteed to correspond to a property that this provider\n can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)",
            "FieldValue": "the value to store for the property specified.",
            "ArrayIndex": "optional array index for use with data collections"
          }
        }
      },
      "structs": {
        "UIDataProviderField": {
          "comment": "Contains data about a single data field exposed by this data provider.",
          "properties": {
            "FieldProviders": {
              "comment": "The list of providers associated with this field. Only relevant if FieldType is DATATYPE_Provider or\n DATATYPE_ProviderCollection. If FieldType is DATATYPE_Provider, the list should contain only one element."
            },
            "FieldTag": {
              "comment": "the tag used to access this field"
            },
            "FieldType": {
              "comment": "the type of field this tag corresponds to"
            }
          }
        }
      }
    },
    "UIDataProvider_MenuItem": {
      "properties": {
        "bEditableCombo": {
          "comment": "Whether or not the options presented to the user are the only options they can choose from, used on PC only for setting whether combobox edit boxes are read only or not."
        },
        "bKeyboardOrMouseOption": {
          "comment": "Whether the option is a keyboard or mouse option."
        },
        "bNumericCombo": {
          "comment": "Whether or not the combobox is numeric."
        },
        "bOfflineOnly": {
          "comment": "Whether the option is a offline only option or not."
        },
        "bOnlineOnly": {
          "comment": "Whether the option is a online only option or not."
        },
        "bRemoveOn360": {
          "comment": "Options to remove certain menu items on a per platform basis."
        },
        "CustomFriendlyName": {
          "comment": "Script settable friendly name."
        },
        "DataStoreMarkup": {
          "comment": "Markup for the option"
        },
        "Description": {
          "comment": "Localized description of the option"
        },
        "DescriptionMarkup": {
          "comment": "Markup for the description for the option"
        },
        "EditBoxMaxLength": {
          "comment": "Maximum length of the editbox property."
        },
        "FriendlyName": {
          "comment": "Friendly displayable name to the player."
        },
        "IniName": {
          "comment": "the .ini file that this instance was created from, if not the class default .ini (for bSearchAllInis classes)"
        },
        "OptionSet": {
          "comment": "Name of the option set that this option belongs to."
        },
        "RangeData": {
          "comment": "Range data for the option, only used if its a slider type."
        },
        "RequiredGameMode": {
          "comment": "Game mode required for this option to appear."
        },
        "SchemaCellFields": {
          "comment": "the names of the fields to use for populating schemas for list widgets"
        },
        "bSearchAllInis": {
          "comment": "whether to search all .inis for valid resource provider instances instead of just the our specified config file\n this is used for lists that need to support additions via extra files, i.e. mods"
        }
      }
    },
    "UIDataProvider_OnlineFriendMessages": {
      "comment": "This class is responsible for retrieving the friends list from the online\n subsystem and populating the UI with that data.",
      "properties": {
        "bIsFriendInviteCol": {
          "comment": "The column name to display in the UI"
        },
        "bWasAcceptedCol": {
          "comment": "The column name to display in the UI"
        },
        "bWasDeniedCol": {
          "comment": "The column name to display in the UI"
        },
        "LastInviteFrom": {
          "comment": "The person that sent the last invite"
        },
        "MessageCol": {
          "comment": "The column name to display in the UI"
        },
        "Messages": {
          "comment": "Gets a copy of the friends messages from the online subsystem"
        },
        "SendingPlayerNameCol": {
          "comment": "The column name to display in the UI"
        }
      },
      "functions": {
        "OnFriendInviteReceived": {
          "comment": "Called when a friend invite arrives for a local player",
          "params": {
            "LocalUserNum": "the user that is receiving the invite",
            "RequestingPlayer": "the player sending the friend request",
            "RequestingNick": "the nick of the player sending the friend request",
            "Message": "the message to display to the recipient"
          }
        },
        "OnFriendMessageReceived": {
          "comment": "Handles the notification that a friend message was received",
          "params": {
            "LocalUserNum": "the user that is receiving the message",
            "SendingPlayer": "the player sending the message",
            "SendingNick": "the nick of the player sending the message",
            "Message": "the message to display to the recipient"
          }
        },
        "OnGameInviteReceived": {
          "comment": "Handles the notification that a game invite has arrived",
          "params": {
            "LocalUserNum": "the user that is receiving the invite",
            "InviterName": "the nick name of the person sending the invite"
          }
        },
        "OnLoginChange": {
          "comment": "Executes a refetching of the friends data when the login for this player\n changes",
          "params": {
            "LocalUserNum": "the player that logged in/out"
          }
        },
        "OnRegister": {
          "comment": "Binds the player to this provider. Starts the async friends list gathering",
          "params": {
            "InPlayer": "the player that we are retrieving friends for"
          }
        },
        "OnUnregister": {
          "comment": "Clears our delegate for getting login change notifications"
        },
        "ReadMessages": {
          "comment": "Copies the messages from the subsystem"
        }
      }
    },
    "UIDataProvider_OnlineFriends": {
      "comment": "This class is responsible for retrieving the friends list from the online\n subsystem and populating the UI with that data.",
      "properties": {
        "AwayText": {
          "comment": "The text to use when away"
        },
        "bHasInvitedYouCol": {
          "comment": "The column name to display in the UI"
        },
        "bHasVoiceSupportCol": {
          "comment": "The column name to display in the UI"
        },
        "bHaveInvitedCol": {
          "comment": "The column name to display in the UI"
        },
        "bIsJoinableCol": {
          "comment": "The column name to display in the UI"
        },
        "bIsOnlineCol": {
          "comment": "The column name to display in the UI"
        },
        "bIsPlayingCol": {
          "comment": "The column name to display in the UI"
        },
        "bIsPlayingThisGameCol": {
          "comment": "The column name to display in the UI"
        },
        "BusyText": {
          "comment": "The text to use when busy"
        },
        "FriendsList": {
          "comment": "Gets a copy of the friends data from the online subsystem"
        },
        "FriendStateCol": {
          "comment": "The column name to display in the UI"
        },
        "NickNameCol": {
          "comment": "The column name to display in the UI"
        },
        "OfflineText": {
          "comment": "The text to use when offline"
        },
        "OnlineText": {
          "comment": "The text to use when online"
        },
        "PresenceInfoCol": {
          "comment": "The column name to display in the UI"
        }
      },
      "functions": {
        "OnFriendsReadComplete": {
          "comment": "Handles the notification that the async read of the friends data is done",
          "params": {
            "bWasSuccessful": "whether the call completed ok or not"
          }
        },
        "OnLoginChange": {
          "comment": "Executes a refetching of the friends data when the login for this player\n changes",
          "params": {
            "LocalUserNum": "the player that logged in/out"
          }
        },
        "OnRegister": {
          "comment": "Binds the player to this provider. Starts the async friends list gathering",
          "params": {
            "InPlayer": "the player that we are retrieving friends for"
          }
        },
        "OnUnregister": {
          "comment": "Clears our delegate for getting login change notifications"
        },
        "RefreshFriendsList": {
          "comment": "Re-reads the friends list to freshen any cached data"
        }
      }
    },
    "UIDataProvider_OnlinePartyChatList": {
      "comment": "This class is responsible for retrieving the party chat member list from the online\n subsystem and populating the UI with that data.",
      "properties": {
        "IsInGameSessionCol": {
          "comment": "The column name to display in the UI"
        },
        "IsInPartyVoiceCol": {
          "comment": "The column name to display in the UI"
        },
        "IsLocalCol": {
          "comment": "The column name to display in the UI"
        },
        "IsPlayingThisGameCol": {
          "comment": "The column name to display in the UI"
        },
        "IsTalkingCol": {
          "comment": "The column name to display in the UI"
        },
        "NatTypeCol": {
          "comment": "The column name to display in the UI"
        },
        "NatTypes": {
          "comment": "The text to use for nat types"
        },
        "NickNameCol": {
          "comment": "The column name to display in the UI"
        },
        "PartyMembersList": {
          "comment": "Gets a copy of the friends data from the online subsystem"
        }
      },
      "functions": {
        "OnLoginChange": {
          "comment": "Executes a refetching of the friends data when the login for this player\n changes",
          "params": {
            "LocalUserNum": "the player that logged in/out"
          }
        },
        "OnRegister": {
          "comment": "Binds the player to this provider. Starts the async friends list gathering",
          "params": {
            "InPlayer": "the player that we are retrieving friends for"
          }
        },
        "OnUnregister": {
          "comment": "Clears our delegate for getting login change notifications"
        },
        "RefreshMembersList": {
          "comment": "Re-reads the friends list to freshen any cached data"
        }
      }
    },
    "UIDataProvider_OnlinePlayerDataBase": {
      "comment": "This class is responsible for retrieving the friends list from the online\n subsystem and populating the UI with that data.",
      "properties": {
        "PlayerControllerId": {
          "comment": "Holds the player that this provider is getting friends for"
        }
      },
      "functions": {
        "OnRegister": {
          "comment": "Binds the player to this provider",
          "params": {
            "InPlayer": "the player that is being bound to the provider"
          }
        },
        "OnUnregister": {
          "comment": "Tells the provider that the player is no longer valid"
        }
      }
    },
    "UIDataProvider_OnlinePlayerStorage": {
      "comment": "This class is responsible for mapping properties in an OnlineGameSettings\n object to something that the UI system can consume.",
      "properties": {
        "bIsExternalUIOpen": {
          "comment": "Whether the UI external to the game is open or not"
        },
        "bNeedsDeferredRefresh": {
          "comment": "Whether we need to refresh our data upon external UI closing or not"
        },
        "bWasErrorLastRead": {
          "comment": "If there was an error, it was possible the read was already in progress. This\n indicates to re-read upon a good completion"
        },
        "DeviceStorageSizeNeeded": {
          "comment": "The amount of storage needed for this game"
        },
        "PlayerStorageArrayProviders": {
          "comment": "The list of mappings from settings id to their provider"
        },
        "Profile": {
          "comment": "The storage settings that are used to load/save with the online subsystem"
        },
        "ProviderName": {
          "comment": "For displaying in the provider tree"
        }
      },
      "functions": {
        "AddReadCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "PlayerInterface": "is the OnlinePlayerInterface used",
            "LocalUserNum": "which user to watch for read complete notifications"
          }
        },
        "ArrayProviderPropertyChanged": {
          "comment": "Called when a setting or property which is bound to one of our array providers is updated.",
          "params": {
            "SourceProvider": "the data provider that generated the notification",
            "PropTag": "the property that changed"
          }
        },
        "ClearReadCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "PlayerInterface": "is the OnlinePlayerInterface used",
            "LocalUserNum": "which user to stop watching for read complete notifications"
          }
        },
        "GetData": {
          "comment": "Fetches the requested object from the online layer's cache",
          "params": {
            "PlayerInterface": "is the OnlinePlayerInterface used",
            "LocalUserNum": "the user that we are writing the data for"
          }
        },
        "OnDeviceSelectionComplete": {
          "comment": "Called once the user has selected their device",
          "params": {
            "bWasSuccessful": "true if the async action completed without error, false if there was an error"
          }
        },
        "OnExternalUIChange": {
          "comment": "Used to check for an external UI being open when attempting to show other UI. That will fail\n so this allows the code to call the show upon closing",
          "params": {
            "bIsOpening": "whether the external UI is opening or closing"
          }
        },
        "OnLoginChange": {
          "comment": "Executes a refetching of the storage data when the login for this player changes",
          "params": {
            "LocalUserNum": "the player that logged in/out"
          }
        },
        "OnReadStorageComplete": {
          "comment": "Handles the notification that the async read of the storage data is done",
          "params": {
            "bWasSuccessful": "whether the call succeeded or not"
          }
        },
        "OnRegister": {
          "comment": "Binds the player to this provider. Starts the async friends list gathering",
          "params": {
            "InPlayer": "the player that we are retrieving friends for"
          }
        },
        "OnSettingValueUpdated": {
          "comment": "Handler for the OnDataProviderPropertyChange delegate in our internal array providers. Determines which provider sent the update\n and propagates that update to this provider's own list of listeners.",
          "params": {
            "SettingName": "the name of the setting that was changed."
          }
        },
        "OnStorageDeviceChange": {
          "comment": "Verifies that the device for all of the installed DLC is still valid and reboots the game if not"
        },
        "OnUnregister": {
          "comment": "Clears our delegate for getting login change notifications"
        },
        "ReadData": {
          "comment": "Reads the data",
          "params": {
            "PlayerInterface": "is the OnlinePlayerInterface used",
            "LocalUserNum": "the user that we are reading the data for",
            "DeviceId": "device for local read of player data (-1 for no device)",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read"
          }
        },
        "RefreshStorageData": {
          "comment": "Reads this user's storage data from the online subsystem."
        },
        "ShowDeviceSelection": {
          "comment": "Shows the device selection UI if possible"
        },
        "WriteData": {
          "comment": "Writes the online data for a given local user to the online data store",
          "params": {
            "PlayerInterface": "is the OnlinePlayerInterface used",
            "LocalUserNum": "the user that we are writing the data for",
            "DeviceId": "device for local write of player data (-1 for no device)",
            "PlayerStorage": "the object that contains the list of items to write"
          }
        }
      },
      "structs": {
        "PlayerStorageArrayProvider": {
          "comment": "Keeps a list of providers for each storage settings id",
          "properties": {
            "PlayerStorageId": {
              "comment": "The storage settings id that this provider is for"
            },
            "PlayerStorageName": {
              "comment": "Cached to avoid extra look ups"
            },
            "Provider": {
              "comment": "The provider object to expose the data with"
            }
          }
        }
      }
    },
    "UIDataProvider_OnlinePlayerStorageArray": {
      "comment": "This class is responsible for exposing string settings as arrays to the ui",
      "properties": {
        "ColumnHeaderText": {
          "comment": "string to use in list column headers for this setting; assigned from the ColumnHeaderText property for the corresponding\n property or setting from the Settings object."
        },
        "PlayerStorage": {
          "comment": "Holds the storage object that will be exposed to the UI"
        },
        "PlayerStorageId": {
          "comment": "The settings id this provider is responsible for managing"
        },
        "PlayerStorageName": {
          "comment": "Cache for faster compares"
        },
        "Values": {
          "comment": "Cached set of possible values for this array"
        }
      }
    },
    "UIDataProvider_OnlineProfileSettings": {
      "comment": "This class is responsible for mapping properties in an OnlineGameSettings\n object to something that the UI system can consume.",
      "functions": {
        "AddReadCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "PlayerInterface": "is the OnlinePlayerInterface used",
            "LocalUserNum": "which user to watch for read complete notifications"
          }
        },
        "ClearReadCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "PlayerInterface": "is the OnlinePlayerInterface used",
            "LocalUserNum": "which user to stop watching for read complete notifications"
          }
        },
        "GetData": {
          "comment": "Fetches the requested object from the online layer's cache",
          "params": {
            "PlayerInterface": "is the OnlinePlayerInterface used",
            "LocalUserNum": "the user that we are writing the data for",
            "PlayerStorage": "the object that contains the list of items to write"
          }
        },
        "ReadData": {
          "comment": "Reads the data",
          "params": {
            "PlayerInterface": "is the OnlinePlayerInterface used",
            "LocalUserNum": "the user that we are reading the data for",
            "DeviceId": "device for local read of player data (-1 for no device)",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read"
          }
        },
        "RefreshStorageData": {
          "comment": "Reads this user's storage data from the online subsystem."
        },
        "WriteData": {
          "comment": "Writes the online data for a given local user to the online data store",
          "params": {
            "PlayerInterface": "is the OnlinePlayerInterface used",
            "LocalUserNum": "the user that we are writing the data for",
            "DeviceId": "device for local write of player data (-1 for no device)",
            "PlayerStorage": "the object that contains the list of items to write"
          }
        }
      }
    },
    "UIDataProvider_PlayerAchievements": {
      "functions": {
        "GetAchievementDetails": {
          "comment": "Gets achievement details based on achievement id",
          "params": {
            "AchievementId": "EGearAchievement for which to find details",
            "OutAchievementDetails": "AchievementDetails struct to be populated"
          }
        },
        "GetAchievementIconPathName": {
          "comment": "Wrapper for retrieving the path name of an achievement's icon."
        },
        "GetMaxTotalGamerScore": {
          "comment": "Returns the number of gamer points that can be acquired in this game across all achievements"
        },
        "GetTotalGamerScore": {
          "comment": "Returns the number of gamer points this profile has accumulated across all achievements"
        },
        "OnLoginChange": {
          "comment": "Handlers for the player's login changed delegate. Refreshes the list of achievements.",
          "params": {
            "LocalUserNum": "the player that logged in/out"
          }
        },
        "OnPlayerAchievementsChanged": {
          "comment": "Called when the async achievements read has completed",
          "params": {
            "TitleId": "the title id that the read was for (0 means current title)"
          }
        },
        "OnPlayerAchievementUnlocked": {
          "comment": "Handler for online service's callback for the player unlocking an achievement."
        },
        "OnRegister": {
          "comment": "Binds the player to this provider. Starts the async friends list gathering",
          "params": {
            "InPlayer": "the player that we are retrieving friends for"
          }
        },
        "OnUnregister": {
          "comment": "Clears our delegate for getting login change notifications"
        },
        "PopulateAchievementIcons": {
          "comment": "Loads the achievement icons from the .ini and applies them to the list of achievements."
        },
        "UpdateAchievements": {
          "comment": "Queries the online service for the player's list of achievements."
        }
      }
    },
    "UIDataProvider_Settings": {
      "comment": "This class is responsible for mapping properties in an Settings\n object to something that the UI system can consume.",
      "properties": {
        "bIsAListRow": {
          "comment": "Whether this provider is a row in a list (removes array handling)"
        },
        "Settings": {
          "comment": "Holds the settings object that will be exposed to the UI"
        },
        "SettingsArrayProviders": {
          "comment": "The list of mappings from settings id to their provider"
        }
      },
      "functions": {
        "ArrayProviderPropertyChanged": {
          "comment": "Called when a setting or property which is bound to one of our array providers is updated.",
          "params": {
            "SourceProvider": "the data provider that generated the notification",
            "PropTag": "the property that changed"
          }
        },
        "OnSettingValueUpdated": {
          "comment": "Handler for the OnDataProviderPropertyChange delegate in our internal array providers. Determines which provider sent the update\n and propagates that update to this provider's own list of listeners.",
          "params": {
            "SettingName": "the name of the setting that was changed."
          }
        }
      },
      "structs": {
        "SettingsArrayProvider": {
          "comment": "Keeps a list of providers for each settings id",
          "properties": {
            "Provider": {
              "comment": "The provider object to expose the data with"
            },
            "SettingsId": {
              "comment": "The settings id that this provider is for"
            },
            "SettingsName": {
              "comment": "Cached to avoid extra look ups"
            }
          }
        }
      }
    },
    "UIDataProvider_SettingsArray": {
      "comment": "This class is responsible for exposing string settings as arrays to the ui",
      "properties": {
        "ColumnHeaderText": {
          "comment": "string to use in list column headers for this setting; assigned from the ColumnHeaderText property for the corresponding\n property or setting from the Settings object."
        },
        "Settings": {
          "comment": "Holds the settings object that will be exposed to the UI"
        },
        "SettingsId": {
          "comment": "The settings id this provider is responsible for managing"
        },
        "SettingsName": {
          "comment": "Cache for faster compares"
        },
        "Values": {
          "comment": "Cached set of possible values for this array"
        }
      }
    },
    "UIDataStore": {
      "properties": {
        "RefreshSubscriberNotifies": {
          "comment": "the list of delegates to call when data exposed by this data store has been updated"
        },
        "Tag": {
          "comment": "The name used to access this datastore"
        }
      },
      "functions": {
        "GetDataStoreClient": {
          "comment": "Returns a reference to the global data store client, if it exists."
        },
        "NotifyGameSessionEnded": {
          "comment": "Called when the current map is being unloaded. Cleans up any references which would prevent garbage collection."
        },
        "OnCommit": {
          "comment": "Notifies the data store that all values bound to this data store in the current scene have been saved. Provides data stores which\n perform buffered or batched data transactions with a way to determine when the UI system has finished writing data to the data store.\n @note: for now, this lives in UIDataStore, but it might make sense to move it up to UIDataProvider later on."
        },
        "RefreshSubscribers": {
          "comment": "Loops through the subscriber notify list and calls the delegate letting the subscriber know to refresh their value.",
          "params": {
            "PropertyTag": "the tag associated with the data field that was updated.",
            "SourceProvider": "for data stores which contain nested providers, the provider that contains the data which changed.",
            "ArrayIndex": "for collection fields, indicates which element was changed. value of INDEX_NONE indicates not an array\n or that the entire array was updated."
          }
        },
        "Registered": {
          "comment": "Called when this data store is added to the data store manager's list of active data stores.",
          "params": {
            "PlayerOwner": "the player that will be associated with this DataStore. Only relevant if this data store is\n associated with a particular player; NULL if this is a global data store."
          }
        },
        "SubscriberAttached": {
          "comment": "Notification that a subscriber is using a value from this data store. Adds the subscriber's RefreshSubscriberValue method\n to this data store's list of refresh notifies so that the subscriber can refresh its value when the data store's value changes.",
          "params": {
            "Subscriber": "the subscriber that attached to the data store."
          }
        },
        "SubscriberDetached": {
          "comment": "Notification that a subscriber is no longer using any values from this data store. Removes the subscriber's RefreshSubscriberValue method\n from this data store's list of refresh notifies so that the subscriber no longer refreshes its value when the data store's value changes.",
          "params": {
            "Subscriber": "the subscriber that detached from the data store."
          }
        },
        "Unregistered": {
          "comment": "Called when this data store is removed from the data store manager's list of active data stores.",
          "params": {
            "PlayerOwner": "the player that will be associated with this DataStore. Only relevant if this data store is\n associated with a particular player; NULL if this is a global data store."
          }
        }
      }
    },
    "UIDataStorePublisher": {
      "functions": {
        "SaveSubscriberValue": {
          "comment": "Resolves this subscriber's data store binding and publishes this subscriber's value to the appropriate data store.",
          "params": {
            "out_BoundDataStores": "contains the array of data stores that widgets have saved values to. Each widget that\n implements this method should add its resolved data store to this array after data values have been\n published. Once SaveSubscriberValue has been called on all widgets in a scene, OnCommit will be called\n on all data stores in this array.",
            "BindingIndex": "optional parameter for indicating which data store binding is being requested for those\n objects which have multiple data store bindings. How this parameter is used is up to the\n class which implements this interface, but typically the \"primary\" data store will be index 0."
          }
        }
      }
    },
    "UIDataStoreSubscriber": {
      "functions": {
        "ClearBoundDataStores": {
          "comment": "Notifies this subscriber to unbind itself from all bound data stores"
        },
        "GetBoundDataStores": {
          "comment": "Retrieves the list of data stores bound by this subscriber.",
          "params": {
            "out_BoundDataStores": "receives the array of data stores that subscriber is bound to."
          }
        },
        "NotifyDataStoreValueUpdated": {
          "comment": "Handler for the UIDataStore.OnDataStoreValueUpdated delegate. Used by data stores to indicate that some data provided by the data\n has changed. Subscribers should use this function to refresh any data store values being displayed with the updated value.\n notify subscribers when they should refresh their values from this data store.",
          "params": {
            "SourceDataStore": "the data store that generated the refresh notification; useful for subscribers with multiple data store\n bindings, to tell which data store sent the notification.",
            "bValuesInvalidated": "TRUE if the data values were completely invalidated; suggest a full refresh rather than an update (i.e. in lists)",
            "PropertyTag": "the tag associated with the data field that was updated; Subscribers can use this tag to determine whether\n there is any need to refresh their data values.",
            "SourceProvider": "for data stores which contain nested providers, the provider that contains the data which changed.",
            "ArrayIndex": "for collection fields, indicates which element was changed. value of INDEX_NONE indicates not an array\n or that the entire array was updated."
          }
        },
        "RefreshSubscriberValue": {
          "comment": "Resolves this subscriber's data store binding and updates the subscriber with the current value from the data store.",
          "params": {
            "BindingIndex": "optional parameter for indicating which data store binding is being requested for those\n objects which have multiple data store bindings. How this parameter is used is up to the\n class which implements this interface, but typically the \"primary\" data store will be index 0."
          }
        }
      }
    },
    "UIDataStore_DynamicResource": {
      "properties": {
        "ProfileProvider": {
          "comment": "Provides access to the player's profile data"
        },
        "ResourceProviderDefinitions": {
          "comment": "the list of data providers supported by this data store that correspond to list element data"
        },
        "ResourceProviders": {
          "comment": "collection of list element provider instances that are associated with each ElementProviderType"
        }
      },
      "functions": {
        "FindProviderIndexByFieldValue": {
          "comment": "Searches for resource provider instance that has a field with a value that matches the value specified.",
          "params": {
            "ProviderTag": "the name of the provider type; should match the ProviderTag value of an element in the ElementProviderTypes array.",
            "SearchField": "the name of the field within the provider type to compare the value to; should be one of the elements retrieved from a call\n to GetResourceProviderFields.",
            "ValueToSearchFor": "the field value to search for."
          }
        },
        "FindProviderTypeIndex": {
          "comment": "Finds the index for the GameResourceDataProvider with a tag matching ProviderTag."
        },
        "GenerateProviderAccessTag": {
          "comment": "Generates a tag containing the provider type with the name of an instance of that provider as the array delimiter.",
          "params": {
            "ProviderIndex": "the index into the ElementProviderTypes array for the provider's type",
            "InstanceIndex": "the index into that type's list of providers for the target instance"
          }
        },
        "GetProviderCount": {
          "comment": "Get the number of UIResourceDataProvider instances associated with the specified tag.",
          "params": {
            "ProviderTag": "the tag to find instances for; should match the ProviderTag value of an element in the ElementProviderTypes array."
          }
        },
        "GetProviderFieldValue": {
          "comment": "Get the value of a single field in a specific resource provider instance. Example: GetProviderFieldValue('GameTypes', ClassName, 2, FieldValue)",
          "params": {
            "ProviderTag": "the name of the provider type; should match the ProviderTag value of an element in the ElementProviderTypes array.",
            "SearchField": "the name of the field within the provider type to get the value for; should be one of the elements retrieved from a call\n to GetResourceProviderFields.",
            "ProviderIndex": "the index [into the array of providers associated with the specified tag] of the instance to get the value from;\n should be one of the elements retrieved by calling GetResourceProviders().",
            "out_FieldValue": "receives the value of the field"
          }
        },
        "GetResourceProviderFields": {
          "comment": "Get the list of fields supported by the provider type specified.",
          "params": {
            "ProviderTag": "the name of the provider type to get fields for; should match the ProviderTag value of an element in the ElementProviderTypes array.\n If the provider type is expanded (bExpandProviders=true), this tag should also contain the array index of the provider instance\n to use for retrieving the fields (this can usually be automated by calling GenerateProviderAccessTag)",
            "ProviderFieldTags": "receives the list of tags supported by the provider specified."
          }
        },
        "GetResourceProviders": {
          "comment": "Get the UIResourceDataProvider instances associated with the tag.",
          "params": {
            "ProviderTag": "the tag to find instances for; should match the ProviderTag value of an element in the ElementProviderTypes array.",
            "out_Providers": "receives the list of provider instances. this array is always emptied first."
          }
        },
        "OnLoginChange": {
          "comment": "Re-initializes all dynamic providers.",
          "params": {
            "LocalUserNum": "the player that had a login change"
          }
        },
        "Registered": {
          "comment": "Called when this data store is added to the data store manager's list of active data stores.",
          "params": {
            "PlayerOwner": "the player that will be associated with this DataStore. Only relevant if this data store is\n associated with a particular player; NULL if this is a global data store."
          }
        },
        "Unregistered": {
          "comment": "Called when this data store is removed from the data store manager's list of active data stores.",
          "params": {
            "PlayerOwner": "the player that will be associated with this DataStore. Only relevant if this data store is\n associated with a particular player; NULL if this is a global data store."
          }
        }
      },
      "structs": {
        "DynamicResourceProviderDefinition": {
          "properties": {
            "ProviderClass": {
              "comment": "the UIDataProvider class that exposes the data for this data field tag"
            },
            "ProviderClassName": {
              "comment": "the name of the class associated with this data provider"
            },
            "ProviderTag": {
              "comment": "the tag that is used to access this provider, i.e. Players, Teams, etc.; should be the same value as the ProviderTag for the\n static resource this provider type is associated with."
            }
          }
        }
      }
    },
    "UIDataStore_GameResource": {
      "properties": {
        "ElementProviderTypes": {
          "comment": "the list of data providers supported by this data store that correspond to list element data"
        },
        "ListElementProviders": {
          "comment": "collection of list element provider instances that are associated with each ElementProviderType"
        }
      },
      "functions": {
        "FindProviderIndexByFieldValue": {
          "comment": "Searches for resource provider instance that has a field with a value that matches the value specified.",
          "params": {
            "ProviderTag": "the name of the provider type; should match the ProviderTag value of an element in the ElementProviderTypes array.",
            "SearchField": "the name of the field within the provider type to compare the value to; should be one of the elements retrieved from a call\n to GetResourceProviderFields.",
            "ValueToSearchFor": "the field value to search for."
          }
        },
        "FindProviderTypeIndex": {
          "comment": "Finds the index for the GameResourceDataProvider with a tag matching ProviderTag."
        },
        "GenerateProviderAccessTag": {
          "comment": "Generates a tag containing the provider type with the name of an instance of that provider as the array delimiter.",
          "params": {
            "ProviderIndex": "the index into the ElementProviderTypes array for the provider's type",
            "InstanceIndex": "the index into that type's list of providers for the target instance"
          }
        },
        "GetProviderCount": {
          "comment": "Get the number of UIResourceDataProvider instances associated with the specified tag.",
          "params": {
            "ProviderTag": "the tag to find instances for; should match the ProviderTag value of an element in the ElementProviderTypes array."
          }
        },
        "GetProviderFieldValue": {
          "comment": "Get the value of a single field in a specific resource provider instance. Example: GetProviderFieldValue('GameTypes', ClassName, 2, FieldValue)",
          "params": {
            "ProviderTag": "the name of the provider type; should match the ProviderTag value of an element in the ElementProviderTypes array.",
            "SearchField": "the name of the field within the provider type to get the value for; should be one of the elements retrieved from a call\n to GetResourceProviderFields.",
            "ProviderIndex": "the index [into the array of providers associated with the specified tag] of the instance to get the value from;\n should be one of the elements retrieved by calling GetResourceProviders().",
            "out_FieldValue": "receives the value of the field"
          }
        },
        "GetResourceProviderFields": {
          "comment": "Get the list of fields supported by the provider type specified.",
          "params": {
            "ProviderTag": "the name of the provider type to get fields for; should match the ProviderTag value of an element in the ElementProviderTypes array.\n If the provider type is expanded (bExpandProviders=true), this tag should also contain the array index of the provider instance\n to use for retrieving the fields (this can usually be automated by calling GenerateProviderAccessTag)",
            "ProviderFieldTags": "receives the list of tags supported by the provider specified."
          }
        },
        "GetResourceProviders": {
          "comment": "Get the UIResourceDataProvider instances associated with the tag.",
          "params": {
            "ProviderTag": "the tag to find instances for; should match the ProviderTag value of an element in the ElementProviderTypes array.",
            "out_Providers": "receives the list of provider instances. this array is always emptied first."
          }
        }
      },
      "structs": {
        "GameResourceDataProvider": {
          "properties": {
            "bExpandProviders": {
              "comment": "indicates that each provider instance should be displayed as an element in the list of tags, rather than\n displaying the ProviderTag itself"
            },
            "ProviderClass": {
              "comment": "the UIDataProvider class that exposes the data for this data field tag"
            },
            "ProviderClassName": {
              "comment": "the name of the class associated with this data provider"
            },
            "ProviderTag": {
              "comment": "the tag that is used to access this provider, i.e. Players, Teams, etc."
            }
          }
        }
      }
    },
    "UIDataStore_GameState": {
      "comment": "Tracks all data about the current game state, such as players, objectives, time remaining, current scores, etc. Game data stores\n can be nested, in that a GameState data store can contain references to other game state data stores. This is useful for\n isolating the weapon data store associated with a particular player, for example.\n Game data stores are further divided into two components:",
      "functions": {
        "NotifyGameSessionEnded": {
          "comment": "Called when the current map is being unloaded. Cleans up any references which would prevent garbage collection."
        }
      }
    },
    "UIDataStore_InputAlias": {
      "properties": {
        "InputAliases": {
          "comment": "Defines the list of supported aliases and their associated input keys."
        },
        "InputAliasLookupMap": {
          "comment": "Mapping of input alias name => index into the InputAliases array for the UIDataStoreInputAlias associated with that\n input alias. Provides a way to quickly access the input key data for an input alias without linear searching.\n Generated when the data store is registered."
        }
      },
      "functions": {
        "FindInputAliasIndex": {
          "comment": "Finds the location [in the InputAliases array] for an input alias.",
          "params": {
            "DesiredAlias": "the name of the alias (i.e. Accept) to find"
          }
        },
        "GetAliasFontMarkup": {
          "comment": "Retrieves the button icon font markup string for an input alias",
          "params": {
            "DesiredAlias": "the name of the alias (i.e. Accept) to get the markup string for",
            "OverridePlatform": "specifies which platform's markup string is desired; if not specified, uses the current\n platform, taking into account whether the player is using a gamepad (PC) or a keyboard (console)."
          }
        },
        "GetAliasFontMarkupByIndex": {
          "comment": "Retrieves the button icon font markup string for an input alias",
          "params": {
            "AliasIndex": "the index [into the InputAliases array] for the alias to get the markup string for.",
            "OverridePlatform": "specifies which platform's markup string is desired; if not specified, uses the current\n platform, taking into account whether the player is using a gamepad (PC) or a keyboard (console)."
          }
        },
        "GetAliasInputKeyData": {
          "comment": "Retrieves both the input key name and modifier keys for an input alias",
          "params": {
            "DesiredAlias": "the name of the alias (i.e. Accept) to get the input key data for",
            "OverridePlatform": "specifies which platform's markup string is desired; if not specified, uses the current\n platform, taking into account whether the player is using a gamepad (PC) or a keyboard (console)."
          }
        },
        "GetAliasInputKeyDataByIndex": {
          "comment": "Retrieves both the input key name and modifier keys for an input alias",
          "params": {
            "AliasIndex": "the index [into the InputAliases array] for the alias to get the input key data for.",
            "OverridePlatform": "specifies which platform's markup string is desired; if not specified, uses the current\n platform, taking into account whether the player is using a gamepad (PC) or a keyboard (console)."
          }
        },
        "GetAliasInputKeyName": {
          "comment": "Retrieves the associated input key name for an input alias",
          "params": {
            "AliasIndex": "the index [into the InputAliases array] for the alias to get the input key for.",
            "OverridePlatform": "specifies which platform's input key is desired; if not specified, uses the current\n platform, taking into account whether the player is using a gamepad (PC) or a keyboard (console)."
          }
        },
        "GetAliasInputKeyNameByIndex": {
          "comment": "Retrieves the associated input key name for an input alias",
          "params": {
            "AliasIndex": "the index [into the InputAliases array] for the alias to get the input key for.",
            "OverridePlatform": "specifies which platform's markup string is desired; if not specified, uses the current\n platform, taking into account whether the player is using a gamepad (PC) or a keyboard (console)."
          }
        },
        "HasAliasMappingForPlatform": {
          "comment": "Determines whether an input alias is supported on a particular platform.",
          "params": {
            "DesiredAlias": "the name of the alias (i.e. Accept) to check",
            "DesiredPlatform": "the platform to check for an input key"
          }
        }
      },
      "structs": {
        "UIDataStoreInputAlias": {
          "comment": "Defines a single input alias (i.e. Accept) along with the raw input keys for each platform which should activate that alias.",
          "properties": {
            "AliasName": {
              "comment": "The name of the alias which will be referenced by the game (i.e. Accept, Cancel, ShiftUp, etc.)."
            },
            "PlatformInputKeys[EInputPlatformType.IPT_MAX]": {
              "comment": "Input keys associated with this alias, per platform."
            }
          }
        },
        "UIInputKeyData": {
          "comment": "Stores an input key name (and optional modifier keys) and a button icon markup string."
        }
      }
    },
    "UIDataStore_MenuItems": {
      "properties": {
        "CurrentGameSettingsTag": {
          "comment": "the tag used to retrieve the menu items for the gametype options of the OnlineGameSettings datastore's selected game configuration."
        },
        "DynamicProviders": {
          "comment": "Array of dynamically created providers."
        },
        "OptionProviders": {
          "comment": "collection of providers per part type."
        }
      },
      "functions": {
        "AppendToSet": {
          "comment": "Appends N amount of providers to the specified set.",
          "params": {
            "SetName": "Set to append to",
            "NumOptions": "Number of options to append"
          }
        },
        "ClearSet": {
          "comment": "Clears all options in the specified set.",
          "params": {
            "SetName": "Set to clear"
          }
        },
        "GetSet": {
          "comment": "Retrieves a set of option providers.",
          "params": {
            "SetName": "Set to retrieve",
            "OutProviders": "Storage array for resulting providers."
          }
        },
        "OnGameSettingsChanged": {
          "comment": "Handler for the OnlineGameSettings data store's OnDataProviderPropertyChange delegate. When the selected gametype is\n changed, updates the current game option set.",
          "params": {
            "SourceProvider": "the data provider that generated the notification",
            "PropTag": "the property that changed"
          }
        },
        "Registered": {
          "comment": "Called when this data store is added to the data store manager's list of active data stores.",
          "params": {
            "PlayerOwner": "the player that will be associated with this DataStore. Only relevant if this data store is\n associated with a particular player; NULL if this is a global data store."
          }
        },
        "Unregistered": {
          "comment": "Called when this data store is removed from the data store manager's list of active data stores.",
          "params": {
            "PlayerOwner": "the player that will be associated with this DataStore. Only relevant if this data store is\n associated with a particular player; NULL if this is a global data store."
          }
        }
      }
    },
    "UIDataStore_OnlineGameSearch": {
      "comment": "This class is responsible for mapping properties in an OnlineGameSearch\n object to something that the UI system can consume. It exposes two things\n DesiredSettings and SearchResults. DesiredSettings is just publishes the\n properties/string settings of an online game settings and SearchResults is\n the set of games found by the search.\n NOTE: Each game needs to derive at least one class from this one in\n order to expose the game's specific search class(es)",
      "properties": {
        "ActiveSearchIndex": {
          "comment": "the index into the set of providers/searches for the query that is currently active"
        },
        "GameInterface": {
          "comment": "Cached game interface pointer"
        },
        "GameSearchCfgList": {
          "comment": "The set of game searches and results"
        },
        "OnlineSub": {
          "comment": "Cached online subsystem pointer"
        },
        "SearchResultsName": {
          "comment": "Cached FName for faster compares"
        },
        "SelectedIndex": {
          "comment": "The index into the set of providers/searches for the query that the user most recently requested"
        }
      },
      "functions": {
        "BuildSearchResults": {
          "comment": "Tells this provider to rebuild it's array data"
        },
        "ClearAllSearchResults": {
          "comment": "Attempts to clear the server query results for all gametypes"
        },
        "FindSearchConfigurationIndex": {
          "comment": "Find the index of the search configuration element which has the specified tag.",
          "params": {
            "SearchTag": "the name of the search configuration to find"
          }
        },
        "GetActiveGameSearch": {
          "comment": "returns the game search object that last submitted a server query"
        },
        "GetCurrentGameSearch": {
          "comment": "Returns the game search object that is currently selected"
        },
        "GetSearchResultFromIndex": {
          "comment": "Returns the search result for the list index specified",
          "params": {
            "ListIndex": "the index to find the result for"
          }
        },
        "Init": {
          "comment": "Registers the delegate with the online subsystem"
        },
        "InvalidateCurrentSearchResults": {
          "comment": "Attempts to free the results from the last search that was submitted."
        },
        "MoveToNext": {
          "comment": "Moves to the next item in the list",
          "params": {
            "bInvalidateExistingSearchResults": "specify FALSE to keep previous searches (i.e. for other gametypes) in memory; default\n behavior is to clear all search results when switching to a different item in the game search list"
          }
        },
        "MoveToPrevious": {
          "comment": "Moves to the previous item in the list",
          "params": {
            "bInvalidateExistingSearchResults": "specify FALSE to keep previous searches (i.e. for other gametypes) in memory; default\n behavior is to clear all search results when switching to a different item in the game search list"
          }
        },
        "OnSearchComplete": {
          "comment": "Called by the online subsystem when the game search has completed",
          "params": {
            "bWasSuccessful": "true if the async action completed without error, false if there was an error"
          }
        },
        "OverrideQuerySubmission": {
          "comment": "Worker for SubmitGameSeach; allows child classes to perform additional work before the query is submitted.",
          "params": {
            "ControllerId": "the index of the controller for the player to perform the search for.",
            "Search": "the search object that will be used to generate the query."
          }
        },
        "SetCurrentByIndex": {
          "comment": "Sets the index into the list of game search to use",
          "params": {
            "NewIndex": "the new index to use",
            "bInvalidateExistingSearchResults": "specify FALSE to keep previous searches (i.e. for other gametypes) in memory; default\n behavior is to clear all search results when switching to a different item in the game search list"
          }
        },
        "SetCurrentByName": {
          "comment": "Sets the index into the list of game settings to use",
          "params": {
            "SearchName": "the name of the search to find",
            "bInvalidateExistingSearchResults": "specify FALSE to keep previous searches (i.e. for other gametypes) in memory; default\n behavior is to clear all search results when switching to a different item in the game search list"
          }
        },
        "ShowHostGamercard": {
          "comment": "Displays the gamercard for the specified host",
          "params": {
            "ControllerIndex": "the ControllerId for the player displaying the gamercard",
            "ListIndex": "the item in the list to display the gamercard for"
          }
        },
        "SubmitGameSearch": {
          "comment": "Called to kick off an online game search and set up all of the delegates needed",
          "params": {
            "ControllerIndex": "the ControllerId for the player to perform the search for",
            "bInvalidateExistingSearchResults": "specify FALSE to keep previous searches (i.e. for other gametypes) in memory; default\n behavior is to clear all search results when switching to a different item in the game search list"
          }
        }
      },
      "structs": {
        "GameSearchCfg": {
          "comment": "Holds the items needed for keeping a list of game searches around",
          "properties": {
            "DefaultGameSettingsClass": {
              "comment": "The OnlineGameSettings derived class to use as the default data"
            },
            "DesiredSettingsProvider": {
              "comment": "Publishes the desired settings from the game search object"
            },
            "GameSearchClass": {
              "comment": "The OnlineGameSeach derived class to load and populate the UI with"
            },
            "Search": {
              "comment": "OnlineGameSearch object that will be exposed to the UI"
            },
            "SearchName": {
              "comment": "For finding via name"
            },
            "SearchResults": {
              "comment": "Array of providers that handle the search results"
            },
            "SearchResultsProviderClass": {
              "comment": "The data provider to use for each search result that is returned. Useful when\n a game wishes to create \"meta\" properties from search results."
            }
          }
        }
      }
    },
    "UIDataStore_OnlineGameSettings": {
      "comment": "This class is responsible for mapping properties in an OnlineGameSettings\n object to something that the UI system can consume.\n NOTE: Each game needs to derive at least one class from this one in\n order to expose the game's specific settings class(es)",
      "properties": {
        "GameSettingsCfgList": {
          "comment": "The list of settings that this data store is exposing"
        },
        "SelectedIndex": {
          "comment": "The index into the list that is currently being exposed"
        },
        "SettingsProviderClass": {
          "comment": "the class to use for creating the data provider for each game settings object"
        }
      },
      "functions": {
        "CreateGame": {
          "comment": "Called to kick create an online game based upon the settings",
          "params": {
            "WorldInfo": "the world info object. useful for actor iterators",
            "ControllerIndex": "the ControllerId for the player to create the game for"
          }
        },
        "GetCurrentGameSettings": {
          "comment": "Returns the game settings object that is currently selected"
        },
        "GetCurrentProvider": {
          "comment": "Returns the provider object that is currently selected"
        },
        "MoveToNext": {
          "comment": "Moves to the next item in the list"
        },
        "MoveToPrevious": {
          "comment": "Moves to the previous item in the list"
        },
        "OnSettingProviderChanged": {
          "comment": "Handler for this data store internal settings data providers OnDataProviderPropertyChange delegate. When the setting associated with that\n provider is updated, issues a refresh notification which causes e.g. widgets to refresh their values.",
          "params": {
            "SourceProvider": "the data provider that generated the notification",
            "SettingsName": "the name of the setting that changed"
          }
        },
        "Registered": {
          "comment": "Called when this data store is added to the data store manager's list of active data stores.",
          "params": {
            "PlayerOwner": "the player that will be associated with this DataStore. Only relevant if this data store is\n associated with a particular player; NULL if this is a global data store."
          }
        },
        "SetCurrentByIndex": {
          "comment": "Sets the index into the list of game settings to use",
          "params": {
            "NewIndex": "the new index to use"
          }
        },
        "SetCurrentByName": {
          "comment": "Sets the index into the list of game settings to use",
          "params": {
            "SettingsName": "the name of the setting to find"
          }
        },
        "Unregistered": {
          "comment": "Called when this data store is removed from the data store manager's list of active data stores.",
          "params": {
            "PlayerOwner": "the player that will be associated with this DataStore. Only relevant if this data store is\n associated with a particular player; NULL if this is a global data store."
          }
        }
      },
      "structs": {
        "GameSettingsCfg": {
          "comment": "Holds the information used to expose 1 or more game settings providers",
          "properties": {
            "GameSettings": {
              "comment": "The object we are exposing to the UI"
            },
            "GameSettingsClass": {
              "comment": "The OnlineGameSettings derived class to create and expose"
            },
            "Provider": {
              "comment": "The provider that was created to process the specified game settings object"
            },
            "SettingsName": {
              "comment": "Used to set/select by name"
            }
          }
        }
      }
    },
    "UIDataStore_OnlinePlayerData": {
      "comment": "This class is responsible for retrieving the friends list from the online\n subsystem and populating the UI with that data.",
      "properties": {
        "AchievementsProvider": {
          "comment": "Provides access to the list of achievements for this player"
        },
        "AchievementsProviderClass": {
          "comment": "The class that should be created when a player is bound to this data store for providing achievements data to the UI"
        },
        "AchievementsProviderClassName": {
          "comment": "The name of the data provider class to use as the default for enumerating achievements"
        },
        "FriendMessagesProvider": {
          "comment": "Provides access to any friend messages"
        },
        "FriendMessagesProviderClass": {
          "comment": "The class that should be created when a player is bound to this data store"
        },
        "FriendMessagesProviderClassName": {
          "comment": "The name of the data provider class to use as the default for messages"
        },
        "FriendsProvider": {
          "comment": "Provides access to the player's online friends list"
        },
        "FriendsProviderClass": {
          "comment": "The class that should be created when a player is bound to this data store"
        },
        "FriendsProviderClassName": {
          "comment": "The name of the data provider class to use as the default for friends"
        },
        "PartyChatProvider": {
          "comment": "The provider instance for the party chat data"
        },
        "PartyChatProviderClass": {
          "comment": "The class that should be created when a player is bound to this data store"
        },
        "PartyChatProviderClassName": {
          "comment": "The name of the data provider class to use as the default for party chat members"
        },
        "PlayerControllerId": {
          "comment": "Holds the player controller that this data store is associated with"
        },
        "PlayerNick": {
          "comment": "The online nick name for the player"
        },
        "PlayerStorageClass": {
          "comment": "The class that should be created when a player is bound to this data store"
        },
        "PlayerStorageClassName": {
          "comment": "The name of the OnlinePlayerStorage class to use as the default"
        },
        "ProfileProvider": {
          "comment": "Provides access to the player's profile data"
        },
        "ProfileProviderClass": {
          "comment": "The class that should be created when a player is bound to this data store"
        },
        "ProfileProviderClassName": {
          "comment": "The name of the data provider class to use as the default for player storage data"
        },
        "ProfileSettingsClass": {
          "comment": "The class that should be created when a player is bound to this data store"
        },
        "ProfileSettingsClassName": {
          "comment": "The name of the OnlineProfileSettings class to use as the default"
        },
        "StorageProvider": {
          "comment": "Provides access to the player's storage data"
        },
        "StorageProviderClass": {
          "comment": "The class that should be created when a player is bound to this data store"
        },
        "StorageProviderClassName": {
          "comment": "The name of the data provider class to use as the default for player storage data"
        }
      },
      "functions": {
        "GetCachedPlayerProfile": {
          "comment": "Retrieves a player profile which has been cached by the online subsystem.",
          "params": {
            "ControllerId": "the controller ID for the player to retrieve the profile for."
          }
        },
        "GetCachedPlayerStorage": {
          "comment": "Retrieves a player storage which has been cached by the online subsystem.",
          "params": {
            "ControllerId": "the controller ID for the player to retrieve the profile for."
          }
        },
        "OnLoginChange": {
          "comment": "Refetches the player's nick name from the online subsystem",
          "params": {
            "LocalUserNum": "the player that logged in/out"
          }
        },
        "OnPlayerDataChange": {
          "comment": "Refetches the player's nick name from the online subsystem"
        },
        "OnRegister": {
          "comment": "Binds the player to this provider. Starts the async friends list gathering",
          "params": {
            "InPlayer": "the player that we are retrieving friends for"
          }
        },
        "OnSettingProviderChanged": {
          "comment": "Handler for this data store internal settings data providers OnDataProviderPropertyChange delegate. When the setting associated with that\n provider is updated, issues a refresh notification which causes e.g. widgets to refresh their values.",
          "params": {
            "SourceProvider": "the data provider that generated the notification",
            "SettingsName": "the name of the setting that changed"
          }
        },
        "OnUnregister": {
          "comment": "Clears our delegate for getting login change notifications"
        },
        "RegisterDelegates": {
          "comment": "Registers the delegates with the providers so we can know when async data changes"
        }
      }
    },
    "UIDataStore_OnlineStats": {
      "comment": "This class is responsible for mapping properties in an OnlineStatsRead\n class to the UI. It maintains a set of different read objects that are\n switched between at run time. This allows you to show leaderboards by\n age (one week, month, year, etc.) from the same UI by having this\n data store just use different query objects\n NOTE: Each game needs to derive at least one class from this one in\n order to expose the game's specific stats class(es)",
      "properties": {
        "CurrentReadType": {
          "comment": "The current type to read"
        },
        "PlayerInterface": {
          "comment": "The player interface to use for performing player specific functions"
        },
        "RankNameMetaData": {
          "comment": "Cached FName for faster compares"
        },
        "StatsInterface": {
          "comment": "The stats interface to use for reading stats data"
        },
        "StatsRead": {
          "comment": "The OnlineStatsRead object that will be exposed to the UI. One of the objects\n from the array above. The game specific version of this class needs to change\n the current setting based on its rules"
        },
        "StatsReadClasses": {
          "comment": "The OnlineStatsRead derived classes to load and populate the UI with"
        },
        "StatsReadName": {
          "comment": "Cached FName for faster compares"
        },
        "StatsReadObjects": {
          "comment": "The set of stats read objects that will be used for display purposes"
        },
        "TotalRowsName": {
          "comment": "Cached FName for faster compares"
        }
      },
      "functions": {
        "Init": {
          "comment": "Grabs the interface pointers and sets the read delegate"
        },
        "OnReadComplete": {
          "comment": "Called by the online subsystem when the stats read has completed",
          "params": {
            "bWasSuccessful": "whether the stats read was successful or not"
          }
        },
        "RefreshStats": {
          "comment": "Tells the online subsystem to re-read the stats data using the current read\n mode and the current object to add the results to"
        },
        "SetStatsReadInfo": {
          "comment": "This function should be overloaded with a game specific version. It is used\n to determine which search class to use and in which mode"
        },
        "ShowGamercard": {
          "comment": "Displays the gamercard for the specified list index",
          "params": {
            "ConrollerIndex": "the ControllerId for the player displaying the gamercard",
            "ListIndex": "the item in the list to display the gamercard for"
          }
        },
        "SortResultsByRank": {
          "comment": "Sorts the returned results by their rank (lowest to highest)"
        }
      },
      "structs": {
        "PlayerNickMetaData": {
          "properties": {
            "PlayerNickColumnName": {
              "comment": "The name displayed in column headings in the UI"
            },
            "PlayerNickName": {
              "comment": "Cached FName for faster compares"
            }
          }
        },
        "RankMetaData": {
          "properties": {
            "RankColumnName": {
              "comment": "The name displayed in column headings in the UI"
            },
            "RankName": {
              "comment": "Cached FName for faster compares"
            }
          }
        }
      }
    },
    "UIDataStore_Registry": {
      "properties": {
        "RegistryDataProvider": {
          "comment": "The data provider that contains the data fields which have been added to this data store."
        }
      }
    },
    "UIDataStore_StringAliasMap": {
      "properties": {
        "MenuInputMapArray": {
          "comment": "Array of input string mappings for use in the front end."
        },
        "MenuInputSets": {
          "comment": "collection of list element provider instances that are associated with each ElementProviderType"
        },
        "PlayerIndex": {
          "comment": "The index [into the Engine.GamePlayers array] for the player that this data store provides settings for."
        }
      },
      "functions": {
        "FindMappingWithFieldName": {
          "comment": "Attempts to find a mapping index given a field name.",
          "params": {
            "FieldName": "Fieldname to search for."
          }
        },
        "GetPlayerOwner": {
          "comment": "Returns a reference to the ULocalPlayer that this PlayerSettingsProvdier provider settings data for"
        },
        "GetStringWithFieldName": {
          "comment": "Set MappedString to be the localized string using the FieldName as a key\n Returns the index into the mapped string array of where it was found."
        }
      },
      "structs": {
        "UIMenuInputMap": {
          "comment": "Struct to store the field values and how they map to localized strings",
          "properties": {
            "FieldName": {
              "comment": "the name of the input alias; i.e. Accept, Cancel, Conditional1, etc."
            },
            "MappedText": {
              "comment": "The actual markup string corresponding to this alias's letter in [usually] a button font"
            },
            "Set": {
              "comment": "Name of the platform type this mapping is associated with. Valid values are PC, 360, and PS3."
            }
          }
        }
      }
    },
    "UIDataStore_Strings": {
      "properties": {
        "LocFileProviders": {
          "comment": "list of data providers for each loc file"
        }
      }
    },
    "UIDynamicDataProvider": {
      "properties": {
        "DataClass": {
          "comment": "The metaclass for this data provider. Each instance of this class (including instances of child classes) will have\n a data provider that tells the UI which properties to provide for this class. Classes indicate which properties are\n available for use by dynamic data stores by marking the property with a keyword."
        },
        "DataSource": {
          "comment": "The object that this data provider is presenting data for. Set by calling BindProviderInstance."
        }
      },
      "functions": {
        "BindProviderInstance": {
          "comment": "Associates this data provider with the specified instance.",
          "params": {
            "DataSourceInstance": "a pointer to the object instance that this data provider should present data for. DataSourceInstance\n must be of type DataClass."
          }
        },
        "CleanupDataProvider": {
          "comment": "Allows the data provider to clear any references that would interfere with garbage collection."
        },
        "GetDataSource": {
          "comment": "Returns a reference to the data source associated with this data provider."
        },
        "IsValidDataSourceClass": {
          "comment": "Script hook for preventing a particular child of DataClass from being represented by this dynamic data provider.",
          "params": {
            "PotentialDataSourceClass": "a child class of DataClass that is being considered as a candidate for binding by this provider."
          }
        },
        "ProviderInstanceBound": {
          "comment": "Called once BindProviderInstance has successfully verified that DataSourceInstance is of the correct type. Child classes\n can override this function to handle storing the reference, for example."
        },
        "ProviderInstanceUnbound": {
          "comment": "Called immediately after this data provider's DataSource is disassociated from this data provider."
        },
        "UnbindProviderInstance": {
          "comment": "Clears the instance associated with this data provider."
        }
      }
    },
    "UIDynamicFieldProvider": {
      "properties": {
        "PersistentCollectionData": {
          "comment": "Contains the source data for all DATATYPE_Collection data fields which have their values stored in the PersistentDataFields array."
        },
        "RuntimeCollectionData": {
          "comment": "Contains the source data for all DATATYPE_Collection data fields which have their values stored in the PersistentDataFields array."
        },
        "PersistentDataFields": {
          "comment": "The list of data fields and values which were added to this data provider in the UI editor. These fields are copied into\n the RuntimeDataFields array when the provider is initialized."
        },
        "RuntimeDataFields": {
          "comment": "The list of data fields currently supported by this data provider. When fields are added and removed during the game,\n those operations always occur using this array. Is never modified in the editor."
        }
      },
      "functions": {
        "AddField": {
          "comment": "Adds a new data field to the list of supported fields.",
          "params": {
            "FieldName": "the name to give the new field",
            "FieldType": "the type of data field being added",
            "bPersistent": "specify TRUE to add the field to the PersistentDataFields array as well.",
            "out_InsertPosition": "allows the caller to find out where the element was inserted"
          }
        },
        "ClearCollectionValueArray": {
          "comment": "Removes all data values for a single collection data field.",
          "params": {
            "FieldName": "the name of the data field associated with the data source collection being manipulated.",
            "bPersistent": "specify TRUE to ensure that the PersistentCollectionData is used, even if it otherwise\n wouldn't be.",
            "CellTag": "optional name of a subfield within the list of values for FieldName. if not specified, FieldName is used."
          }
        },
        "ClearFields": {
          "comment": "Removes all data fields from this data provider.",
          "params": {
            "bReinitializeRuntimeFields": "specify TRUE to reset the elements of the RuntimeDataFields array to match the elements\n in the PersistentDataFields array. Ignored in the editor."
          }
        },
        "FindCollectionValueIndex": {
          "comment": "Finds the index [into the array of values for FieldName] for a specific value.",
          "params": {
            "FieldName": "the name of the data field associated with the data source collection being manipulated.",
            "ValueToFind": "the value that should be found.",
            "bPersistent": "specify TRUE to ensure that the PersistentCollectionData is used, even if it otherwise wouldn't be.",
            "CellTag": "optional name of a subfield within the list of values for FieldName. if not specified, FieldName is used."
          }
        },
        "FindFieldIndex": {
          "comment": "Finds the index into the DataFields array for the data field specified.",
          "params": {
            "FieldName": "the name of the data field to search for",
            "bSearchPersistentFields": "if TRUE, searches the PersistentDataFields array for the specified field; otherwise,\n searches the RuntimeDataFields array",
            "the": "index into the DataFields array for the data field specified, or INDEX_NONE if it isn't in the array."
          }
        },
        "GetCollectionValue": {
          "comment": "Retrieves the value of an element in a collection data source array.",
          "params": {
            "FieldName": "the name of the data field associated with the data source collection being manipulated.",
            "ValueIndex": "the index [into the array of values for FieldName] of the value that should be retrieved.",
            "out_Value": "receives the value of the collection data source element",
            "bPersistent": "specify TRUE to ensure that the PersistentCollectionData is used, even if it otherwise\n wouldn't be.",
            "CellTag": "optional name of a subfield within the list of values for FieldName. if not specified, FieldName is used."
          }
        },
        "GetCollectionValueArray": {
          "comment": "Gets the data value source array for the specified data field.",
          "params": {
            "FieldName": "the name of the data field the source data should be associated with.",
            "out_DataValueArray": "receives the array of data values available for FieldName.",
            "bPersistent": "specify TRUE to ensure that the PersistentCollectionData is used, even if it otherwise\n wouldn't be.",
            "CellTag": "optional name of a subfield within the list of values for FieldName. if not specified, FieldName is used."
          }
        },
        "GetCollectionValueSchema": {
          "comment": "Gets the list of schema tags set for the data value source array stored for FieldName",
          "params": {
            "FieldName": "the name of the data field the source data should be associated with.",
            "out_CellTagArray": "the list of unique tags stored in the source array data for the specified data field name.",
            "bPersistent": "specify TRUE to ensure that the PersistentCollectionData is used, even if it otherwise\n wouldn't be."
          }
        },
        "GetField": {
          "comment": "Gets the value of the data field specified.",
          "params": {
            "FieldName": "the name of the data field to retrieve the value for",
            "out_Field": "receives the value of the data field specified"
          }
        },
        "InitializeRuntimeFields": {
          "comment": "Copies the elements from the PersistentDataFields array into the RuntimeDataFields array. Should only be called once when the provider\n is initialized."
        },
        "InsertCollectionValue": {
          "comment": "Inserts a new string into the list of values for the specified collection data field.",
          "params": {
            "FieldName": "the name of the data field associated with the data source collection being manipulated.",
            "NewValue": "the value to insert",
            "InsertIndex": "the index [into the array of values for FieldName] to insert the new value, or INDEX_NONE to\n append the value to the end of the list.",
            "bPersistent": "specify TRUE to ensure that the PersistentCollectionData is used, even if it otherwise\n wouldn't be.",
            "bAllowDuplicateValues": "controls whether multiple elements containing the same value should be allowed in the data source\n collection. If FALSE is specified, and NewValue already exists in the collection source array, method\n return TRUE but it does not modify the array. If TRUE is specified, NewValue will be added anyway,\n resulting in multiple copies of NewValue existing in the array.",
            "CellTag": "optional name of a subfield within the list of values for FieldName. if not specified, FieldName is used."
          }
        },
        "RemoveCollectionValue": {
          "comment": "Removes a value from the collection data source specified by FieldName.",
          "params": {
            "FieldName": "the name of the data field associated with the data source collection being manipulated.",
            "ValueToRemove": "the value that should be removed",
            "bPersistent": "specify TRUE to ensure that the PersistentCollectionData is used, even if it otherwise\n wouldn't be.",
            "CellTag": "optional name of a subfield within the list of values for FieldName. if not specified, FieldName is used."
          }
        },
        "RemoveCollectionValueByIndex": {
          "comment": "Removes the value from the collection data source specified by FieldName located at ValueIndex.",
          "params": {
            "FieldName": "the name of the data field associated with the data source collection being manipulated.",
            "ValueIndex": "the index [into the array of values for FieldName] of the value that should be removed.",
            "bPersistent": "specify TRUE to ensure that the PersistentCollectionData is used, even if it otherwise\n wouldn't be.",
            "CellTag": "optional name of a subfield within the list of values for FieldName. if not specified, FieldName is used."
          }
        },
        "RemoveField": {
          "comment": "Removes the data field that has the specified tag.",
          "params": {
            "FieldName": "the name of the data field to remove from this data provider."
          }
        },
        "ReplaceCollectionValue": {
          "comment": "Replaces the value in a collection data source with a different value.",
          "params": {
            "FieldName": "the name of the data field associated with the data source collection being manipulated.",
            "CurrentValue": "the value that will be replaced.",
            "NewValue": "the value that will replace CurrentValue",
            "bPersistent": "specify TRUE to ensure that the PersistentCollectionData is used, even if it otherwise\n wouldn't be.",
            "CellTag": "optional name of a subfield within the list of values for FieldName. if not specified, FieldName is used."
          }
        },
        "ReplaceCollectionValueByIndex": {
          "comment": "Replaces the value located at ValueIndex in a collection data source with a different value",
          "params": {
            "FieldName": "the name of the data field associated with the data source collection being manipulated.",
            "ValueIndex": "the index [into the array of values for FieldName] of the value that should be replaced.",
            "NewValue": "the value that should replace the old value.",
            "bPersistent": "specify TRUE to ensure that the PersistentCollectionData is used, even if it otherwise\n wouldn't be.",
            "CellTag": "optional name of a subfield within the list of values for FieldName. if not specified, FieldName is used."
          }
        },
        "SavePersistentProviderData": {
          "comment": "Copies the values of all fields which exist in the PersistentDataFields array from the RuntimeDataFields array into the PersistentDataFields array and\n saves everything to the .ini."
        },
        "SetCollectionValueArray": {
          "comment": "Sets the source data for a collection data field to the values specified. It is not necessary to add the field first\n (via AddField) in order to set the collection values.",
          "params": {
            "FieldName": "the name of the data field the source data should be associated with.",
            "CollectionValues": "the actual values that will be associated with FieldName.",
            "bClearExisting": "specify TRUE to clear the existing collection data before adding the new values",
            "InsertIndex": "the position to insert the new values (only relevant if bClearExisting is FALSE)",
            "bPersistent": "specify TRUE to ensure that the values will be added to PersistentCollectionData, even\n if they otherwise wouldn't be.",
            "CellTag": "optional name of a subfield within the list of values for FieldName. if not specified, FieldName is used."
          }
        },
        "SetField": {
          "comment": "Sets the value for the data field specified.",
          "params": {
            "FieldName": "the name of the data field to retrieve the value for",
            "FieldValue": "the value to assign to the specified data field",
            "bChangeExistingOnly": "controls what happens if there is no data field with the specified name in this data provider's list\n of fields; TRUE indicates that we should only set the value if the field already exists in the list;\n FALSE indicates that we should add a new element to the list if there are no existing fields with this name."
          }
        }
      }
    },
    "UIGameInfoSummary": {
      "properties": {
        "GameSettingsClassName": {
          "comment": "the pathname for the OnlineGameSettings subclass associated with this gametype"
        }
      },
      "functions": {
        "IsProviderDisabled": {
          "comment": "Allows a resource data provider instance to indicate that it should be unselectable in subscribed lists"
        }
      }
    },
    "UIInteraction": {
      "properties": {
        "AxisEmulationDefinitions": {
          "comment": "Runtime mapping of the axis button-press emulation configurations. Built in UIInteraction::InitializeAxisInputEmulations() based\n on the values retrieved from ConfiguredAxisEmulationDefinitions."
        },
        "AxisInputEmulation[MAX_SUPPORTED_GAMEPADS]": {
          "comment": "Tracks the axis key-press emulation data for all players in the game."
        },
        "AxisRepeatDelay": {
          "comment": "The amount of time (in seconds) to wait between generating simulated button presses from axis input."
        },
        "bProcessInput": {
          "comment": "Indicates whether there are any active scenes capable of processing input. Set in UpdateInputProcessingStatus, based\n on whether there are any active scenes which are capable of processing input."
        },
        "ConfiguredAxisEmulationDefinitions": {
          "comment": "Default button press emulation definitions for gamepad and joystick axis input keys."
        },
        "DataStoreManager": {
          "comment": "Manages all persistent global data stores. Created when UIInteraction is initialized using the value of\n GEngine.DataStoreClientClass."
        },
        "DoubleClickPixelTolerance": {
          "comment": "The maximum number of pixels to allow between the current mouse position and the last click's mouse position for a double-click\n event to be triggered"
        },
        "DoubleClickTriggerSeconds": {
          "comment": "The maximum amount of time (in seconds) that can pass between a key press and key release in order to trigger a double-click event"
        },
        "MouseButtonRepeatDelay": {
          "comment": "The amount of time (in seconds) to wait between generating repeat events for mouse buttons (which are not handled by windows)."
        },
        "MouseButtonRepeatInfo": {
          "comment": "Tracks the mouse button that is currently being held down for simulating repeat input events."
        },
        "SceneClient": {
          "comment": "Acts as the interface between the UIInteraction and the active scenes."
        },
        "SceneClientClass": {
          "comment": "the class to use for the scene client"
        },
        "SupportedDoubleClickKeys": {
          "comment": "list of keys that can trigger double-click events"
        },
        "UIAxisMultiplier": {
          "comment": "Mouse & joystick axis input will be multiplied by this amount in the UI system. Higher values make the cursor move faster."
        },
        "UIJoystickDeadZone": {
          "comment": "The amount of movement required before the UI will process a joystick's axis input."
        },
        "UIManager": {
          "comment": "The UI Manager - Acts as the interface between the UIInteraction and the active scenes"
        },
        "UIManagerClass": {
          "comment": "The class of UIManager to instantiate"
        }
      },
      "functions": {
        "GetConnectedGamepadCount": {
          "params": {
            "ControllerConnectionStatusOverrides": "array indicating the connection status of each gamepad; should always contain\n MAX_SUPPORTED_GAMEPADS elements; useful when executing code as a result of a controller\n insertion/removal notification, as IsControllerConnected isn't reliable in that case."
          }
        },
        "GetDataStoreClient": {
          "comment": "Returns a reference to the global data store client, if it exists."
        },
        "GetLocalPlayer": {
          "comment": "Wrapper for retrieving a LocalPlayer reference for one of the players in the GamePlayers array.",
          "params": {
            "PlayerIndex": "the index of the player reference to retrieve."
          }
        },
        "GetNATType": {
          "comment": "Wrapper for getting the NAT type"
        },
        "GetNumGuestsLoggedIn": {
          "comment": "Returns the number of guests logged in"
        },
        "GetPlayerControllerId": {
          "comment": "Retrieves the ControllerId for the player specified.",
          "params": {
            "PlayerIndex": "the index [into the Engine.GamePlayers array] for the player to retrieve the ControllerId for"
          }
        },
        "GetPlayerCount": {
          "comment": "Returns the number of players currently active."
        },
        "GetPlayerIndex": {
          "comment": "Retrieves the index (into the Engine.GamePlayers array) for the player which has the ControllerId specified",
          "params": {
            "ControllerId": "the gamepad index of the player to search for"
          }
        },
        "IsGamepadConnected": {
          "comment": "Check whether a gamepad is connected and turned on.",
          "params": {
            "ControllerId": "the id of the gamepad to check"
          }
        },
        "NotifyGameSessionEnded": {
          "comment": "Called when the current map is being unloaded. Cleans up any references which would prevent garbage collection."
        },
        "NotifyPlayerAdded": {
          "comment": "Called when a new player has been added to the list of active players (i.e. split-screen join)",
          "params": {
            "PlayerIndex": "the index [into the GamePlayers array] where the player was inserted",
            "AddedPlayer": "the player that was added"
          }
        },
        "NotifyPlayerRemoved": {
          "comment": "Called when a player has been removed from the list of active players (i.e. split-screen players)",
          "params": {
            "PlayerIndex": "the index [into the GamePlayers array] where the player was located",
            "RemovedPlayer": "the player that was removed"
          }
        }
      },
      "structs": {
        "UIAxisEmulationData": {
          "comment": "Contains parameters for emulating button presses using axis input.",
          "properties": {
            "bEnabled": {
              "comment": "Determines whether to emulate button presses."
            }
          }
        },
        "UIKeyRepeatData": {
          "comment": "Tracks information relevant to simulating IE_Repeat input events.",
          "properties": {
            "CurrentRepeatKey": {
              "comment": "The name of the axis input key that is currently being held. Used to determine which type of input event\n to simulate (i.e. IE_Pressed, IE_Released, IE_Repeat)"
            },
            "NextRepeatTime": {
              "comment": "The time (in seconds since the process started) when the next simulated input event will be generated."
            }
          }
        }
      }
    },
    "UIManager": {
      "functions": {
        "CanUnpauseInternalUI": {
          "comment": "Callback which allows the UI to prevent unpausing if scenes which require pausing are still active.\n @see PlayerController.SetPause"
        },
        "GetUIManager": {
          "comment": "Returns the game's UI Manager."
        },
        "NotifyPlayerAdded": {
          "comment": "Called when a new player has been added to the list of active players (i.e. split-screen join)",
          "params": {
            "PlayerIndex": "the index [into the GamePlayers array] where the player was inserted",
            "AddedPlayer": "the player that was added"
          }
        },
        "NotifyPlayerRemoved": {
          "comment": "Called when a player has been removed from the list of active players (i.e. split-screen players)",
          "params": {
            "PlayerIndex": "the index [into the GamePlayers array] where the player was located",
            "RemovedPlayer": "the player that was removed"
          }
        },
        "PauseGame": {
          "comment": "Wrapper for pausing the game.",
          "params": {
            "bDesiredPauseState": "TRUE indicates that the game should be paused.",
            "PlayerIndex": "the index [into Engine GamePlayers array] for the player that should be used for pausing the game; can\n affect whether the game is actually paused or not (i.e. if the player is an admin in a multi-player match,\n for example)."
          }
        }
      }
    },
    "UIPropertyDataProvider": {
      "properties": {
        "ComplexPropertyTypes": {
          "comment": "the list of property classes for which values cannot be automatically derived; if your script-only child class has a member\n var of one of these types, you'll need to provide the value yourself via the GetCustomPropertyValue event"
        }
      },
      "functions": {
        "GetCustomPropertyValue": {
          "comment": "Gets the value for the property specified. Child classes only need to override this function if it contains data fields\n which do not correspond to a member property in the class, or if the data corresponds to a complex data type, such as struct,\n array, etc.",
          "params": {
            "PropertyValue": "[in] the name of the property to get the value for.\n [out] should be filled with the value for the specified property tag.",
            "ArrayIndex": "optional array index for use with data collections"
          }
        }
      }
    },
    "UIResourceCombinationProvider": {
      "properties": {
        "ProfileProvider": {
          "comment": "The data provider which provides access to a player's profile data."
        },
        "StaticDataProvider": {
          "comment": "Each combo provider is linked to a single static resource data provider. The name of the combo provider should match the name of the\n static resource it's associated with, as the dynamic resource data store will match combo providers to the static provider with the same name."
        }
      },
      "functions": {
        "ClearProviderReferences": {
          "comment": "Clears all references in this data provider. Called when the owning data store is unregistered."
        },
        "GetCellFieldType": {
          "comment": "Retrieves the field type for the specified cell.",
          "params": {
            "FieldName": "the name of the field the desired cell tags are associated with. Used for cases where a single data provider\n instance provides element cells for multiple collection data fields.",
            "CellTag": "the tag for the element cell to get the field type for",
            "out_CellFieldType": "receives the field type for the specified cell; should be a EUIDataProviderFieldType value."
          }
        },
        "GetCellFieldValue": {
          "comment": "Resolves the value of the cell specified by CellTag and stores it in the output parameter.",
          "params": {
            "FieldName": "the name of the field the desired cell tags are associated with. Used for cases where a single data provider\n instance provides element cells for multiple collection data fields.",
            "CellTag": "the tag for the element cell to resolve the value for",
            "ListIndex": "the UIList's item index for the element that contains this cell. Useful for data providers which\n do not provide unique UIListElement objects for each element.",
            "out_FieldValue": "receives the resolved value for the property specified.\n \n@see GetDataStoreValue for additional notes",
            "ArrayIndex": "optional array index for use with cell tags that represent data collections. Corresponds to the\n ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond\n to a data collection."
          }
        },
        "GetElementCellSchemaProvider": {
          "comment": "Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.\n Used by the UI editor to know which cells are available for binding to individual list cells.",
          "params": {
            "FieldName": "the tag of the list element data field that we want the schema for."
          }
        },
        "GetElementCellTags": {
          "comment": "Retrieves the list of tags that can be bound to individual cells in a single list element.",
          "params": {
            "FieldName": "the name of the field the desired cell tags are associated with. Used for cases where a single data provider\n instance provides element cells for multiple collection data fields.",
            "out_CellTags": "receives the list of tag/column headers that can be bound to element cells for the specified property."
          }
        },
        "GetElementCellValueProvider": {
          "comment": "Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells\n of the list element indicated by CellValueProvider.DataSourceIndex",
          "params": {
            "FieldName": "the tag of the list element data field that we want the values for",
            "ListIndex": "the list index for the element to get values for"
          }
        },
        "GetElementCount": {
          "comment": "Returns the number of list elements associated with the data tag specified.",
          "params": {
            "FieldName": "the name of the property to get the element count for. guaranteed to be one of the values returned\n from GetElementProviderTags."
          }
        },
        "GetElementProviderTags": {
          "comment": "Retrieves the list of all data tags contained by this element provider which correspond to list element data."
        },
        "GetListElements": {
          "comment": "Retrieves the list elements associated with the data tag specified.",
          "params": {
            "FieldName": "the name of the property to get the element count for. guaranteed to be one of the values returned\n from GetElementProviderTags.",
            "out_Elements": "will be filled with the elements associated with the data specified by DataTag."
          }
        },
        "InitializeProvider": {
          "comment": "Provides the data provider with the chance to perform initialization, including preloading any content that will be needed by the provider.",
          "params": {
            "bIsEditor": "TRUE if the editor is running; FALSE if running in the game.",
            "InStaticResourceProvider": "the data provider that provides the static resource data for this combo provider.",
            "InProfileProvider": "the data provider that provides profile data for the player associated with the owning data store."
          }
        },
        "IsElementEnabled": {
          "comment": "Determines whether a member of a collection should be considered \"enabled\" by subscribed lists. Disabled elements will still be displayed in the list\n but will be drawn using the disabled state.",
          "params": {
            "FieldName": "the name of the collection data field that CollectionIndex indexes into.",
            "CollectionIndex": "the index into the data field collection indicated by FieldName to check"
          }
        },
        "ReplaceProviderCollection": {
          "comment": "Utility function for replacing the value of a data field's provider collection with a different set of providers.",
          "params": {
            "out_Fields": "the list of fields containing the data field to replace the value for",
            "TargetFieldTag": "the tag for the field whose value should be replaced.",
            "ReplacementProviders": "the collection of provider to set as the new value for the field being changed"
          }
        },
        "ReplaceProviderValue": {
          "comment": "Utility function for replacing the value of a data field's provider reference with a different value.",
          "params": {
            "out_Fields": "the list of fields containing the data field to replace the value for",
            "TargetFieldTag": "the tag for the field whose value should be replaced.",
            "ReplacementProvider": "the provider to set as the new value for the field being changed"
          }
        }
      }
    },
    "UIResourceDataProvider": {
      "properties": {
        "bDataBindingPropertiesOnly": {
          "comment": "Controls which properties this data provider will expose as data fields. Specify TRUE to only allow properties marked\n with the 'databinding' keyword to be exposed.\n Child classes may override or ignore this flag by using different logic in GetSupportedDataFields()."
        },
        "bSkipDuringEnumeration": {
          "comment": "Controls whether the object should be used or not. This is the only way to remove a per object config from the list"
        }
      },
      "functions": {
        "InitializeProvider": {
          "comment": "Provides the data provider with the chance to perform initialization, including preloading any content that will be needed by the provider.",
          "params": {
            "bIsEditor": "TRUE if the editor is running; FALSE if running in the game."
          }
        }
      }
    },
    "UIRoot": {
      "functions": {
        "GetCurrentUIController": {
          "comment": "Returns the UIInteraction instance currently controlling the UI system, which is valid in game."
        },
        "GetDataStoreFieldValue": {
          "comment": "Gets the field value struct of the datastore entry specified.",
          "params": {
            "InDataStoreMarkup": "Markup to find the field we want to retrieve the value of.",
            "OutFieldValue": "Variable to store the result field value in.",
            "OwnerScene": "Owner scene for the datastore, used when dealing with scene specific datastores.",
            "OwnerPlayer": "Owner player for the datastore, used when dealing with player datastores."
          }
        },
        "GetDataStoreStringValue": {
          "comment": "Gets the string value of the datastore entry specified.",
          "params": {
            "InDataStoreMarkup": "Markup to find the field we want to retrieve the value of.",
            "OutStringValue": "Variable to store the result string in.",
            "OwnerScene": "Owner scene for the datastore, used when dealing with scene specific datastores.",
            "OwnerPlayer": "Owner player for the datastore, used when dealing with player datastores."
          }
        },
        "GetInputPlatformType": {
          "comment": "Returns the platform type for the current input device. This is not necessarily the platform the game is actually running\n on; for example, if the game is running on a PC, but the player is using an Xbox controller, the current InputPlatformType\n would be IPT_360.",
          "params": {
            "OwningPlayer": "if specified, the returned InputPlatformType will reflect the actual input device the player\n is using. Otherwise, the returned InputPlatformType is always the platform the game is running on."
          }
        },
        "GetOnlineGameInterface": {
          "comment": "Wrapper for getting a reference to the online subsystem's game interface."
        },
        "GetOnlinePlayerInterface": {
          "comment": "Wrapper for getting a reference to the online subsystem's player interface."
        },
        "GetOnlinePlayerInterfaceEx": {
          "comment": "Wrapper for getting a reference to the extended online player interface"
        },
        "GetSceneClient": {
          "comment": "Returns the game's scene client."
        },
        "SetDataStoreFieldValue": {
          "comment": "Sets the string value of the datastore entry specified.",
          "params": {
            "InDataStoreMarkup": "Markup to find the field we want to set the value of.",
            "InFieldValue": "Value to set the datafield's value to.",
            "OwnerScene": "Owner scene for the datastore, used when dealing with scene specific datastores.",
            "OwnerPlayer": "Owner player for the datastore, used when dealing with player datastores."
          }
        },
        "SetDataStoreStringValue": {
          "comment": "Sets the string value of the datastore entry specified.",
          "params": {
            "InDataStoreMarkup": "Markup to find the field we want to set the value of.",
            "InStringValue": "Value to set the datafield's string value to.",
            "OwnerScene": "Owner scene for the datastore, used when dealing with scene specific datastores.",
            "OwnerPlayer": "Owner player for the datastore, used when dealing with player datastores."
          }
        }
      },
      "structs": {
        "InputEventParameters": {
          "comment": "This struct contains all data used by the various UI input processing methods.",
          "properties": {
            "bAltPressed": {
              "comment": "For PC input events, tracks whether the corresponding modifier keys are pressed."
            },
            "bCtrlPressed": {
              "comment": "For PC input events, tracks whether the corresponding modifier keys are pressed."
            },
            "bShiftPressed": {
              "comment": "For PC input events, tracks whether the corresponding modifier keys are pressed."
            },
            "ControllerId": {
              "comment": "The ControllerId that generated this event. Not guaranteed to be a ControllerId associated with a valid player."
            },
            "DeltaTime": {
              "comment": "For input axis events, represents the amount of time that has passed since the last update."
            },
            "EventType": {
              "comment": "The type of input event generated (i.e. IE_Released, IE_Pressed, IE_Axis, etc.)"
            },
            "InputDelta": {
              "comment": "For input key events generated by analog buttons, represents the amount the button was depressed.\n For input axis events (i.e. joystick, mouse), represents the distance the axis has traveled since the last update."
            },
            "InputKeyName": {
              "comment": "Name of the input key that was generated, such as KEY_Left, KEY_Enter, etc."
            },
            "PlayerIndex": {
              "comment": "Index [into the Engine.GamePlayers array] for the player that generated this input event. If PlayerIndex is not\n a valid index for the GamePlayers array, it indicates that this input event was generated by a gamepad that is not\n currently associated with an active player"
            }
          }
        },
        "InputKeyAction": {
          "comment": "Associates a UIAction with input key name.",
          "properties": {
            "InputKeyName": {
              "comment": "the input key name that will activate the action"
            },
            "InputKeyState": {
              "comment": "the state (pressed, released, etc.) that will activate the action"
            },
            "TriggeredOps": {
              "comment": "The sequence operations to activate when the input key is received"
            }
          }
        },
        "RawInputKeyEventData": {
          "properties": {
            "InputKeyName": {
              "comment": "the name of the key (i.e. 'Left' [KEY_Left], 'LeftMouseButton' [KEY_LeftMouseButton], etc.)"
            },
            "ModifierKeyFlags": {
              "comment": "a bitmask of values indicating which modifier keys are associated with this input key event, or which modifier\n keys are excluded. Bit values are:\n 0: Alt active (or required)\n 1: Ctrl active (or required)\n 2: Shift active (or required)\n 3: Alt excluded\n 4: Ctrl excluded\n 5: Shift excluded\n (key states)\n 6: Pressed\n 7: Released"
            }
          }
        },
        "SubscribedInputEventParameters": {
          "comment": "Contains additional data for an input event which a widget has registered for (via UUIComp_Event::RegisterInputEvents).is\n in the correct state capable of processing is registered to handle.the data for a Stores the UIInputAlias name translated from a combination of input key, input event type, and modifier keys.",
          "properties": {
            "InputAliasName": {
              "comment": "Name of the UI input alias determined from the current input key, event type, and active modifiers."
            }
          }
        },
        "TextureCoordinates": {
          "comment": "Coordinates for mapping an individual texture of a texture atlas"
        },
        "UIAxisEmulationDefinition": {
          "comment": "Contains information for simulating a button press input event in response to axis input.",
          "properties": {
            "AdjacentAxisInputKey": {
              "comment": "The axis input key name that represents the other axis of the joystick associated with this axis input.\n e.g. if AxisInputKey is MouseX, AdjacentAxisInputKey would be MouseY."
            },
            "AxisInputKey": {
              "comment": "The axis input key name that this definition represents."
            },
            "bEmulateButtonPress": {
              "comment": "Indicates whether button press/release events should be generated for this axis key"
            },
            "InputKeyToEmulate[2]": {
              "comment": "The button input key that this axis input should emulate. The first element corresponds to the input key\n that should be emulated when the axis value is positive; the second element corresponds to the input key\n that should be emulated when the axis value is negative."
            }
          }
        },
        "UIDataStoreBinding": {
          "comment": "Contains information about a UI data store binding, including the markup text used to reference the data store and\n the resolved value of the markup text.\n @NOTE: if you move this struct declaration to another class, make sure to update UUIObject::GetDataBindingProperties()",
          "properties": {
            "BindingIndex": {
              "comment": "Used to differentiate multiple data store properties in a single class."
            },
            "DataStoreField": {
              "comment": "the name of the field resolved from MarkupString; must be a field supported by ResolvedDataStore"
            },
            "DataStoreName": {
              "comment": "the name of the data store resolved from MarkupString"
            },
            "MarkupString": {
              "comment": "A datastore markup string which resolves to a property/data type exposed by a UI data store.\n @note: cannot be editconst until we have full editor support for manipulating markup strings (e.g. inserting embedded\n markup, etc.)"
            },
            "RequiredFieldType": {
              "comment": "Indicates which type of data fields can be used in this data store binding"
            },
            "ResolvedDataStore": {
              "comment": "a pointer to the data store resolved from MarkupString"
            },
            "Subscriber": {
              "comment": "The UIDataStoreSubscriber that contains this UIDataStoreBinding"
            }
          }
        },
        "UIProviderFieldValue": {
          "comment": "This extension of UIProviderScriptFieldValue is used when resolving values for markup text found in UIStrings. This struct\n allows data stores to provide the UIStringNode that should be used when rendering the value for the data field represented\n this struct.",
          "properties": {
            "CustomStringNode": {
              "comment": "Only used by native code; allows the data store to create and initialize string nodes manually, rather than allowing\n the calling code to create a UIStringNode based on the value of StringValue or ImageValue"
            }
          }
        },
        "UIProviderScriptFieldValue": {
          "comment": "Contains the value for a property, as either text or an image. Used for allowing script-only data provider classes to\n resolve data fields parsed from UIStrings.",
          "properties": {
            "ArrayValue": {
              "comment": "If PropertyTag corresponds to data that should be represented as a list of untyped data, contains the value of the selected elements"
            },
            "AtlasCoordinates": {
              "comment": "Specifies the coordinates for ImageValue if it corresponds to a texture atlas"
            },
            "ImageValue": {
              "comment": "If PropertyTag correspondsd to data that should be represented as an image, contains the value for this resource"
            },
            "NetIdValue": {
              "comment": "If PropertyTag corresponds to data that should be represented as a UniqueNetId, contains the value."
            },
            "PropertyTag": {
              "comment": "the name of this resource; set natively after the list of available tags are retrieved from script"
            },
            "PropertyType": {
              "comment": "the type of field this tag corresponds to"
            },
            "RangeValue": {
              "comment": "If PropertyTag corresponds to data that should be represented as value within a specific range, contains the value for this resource"
            },
            "StringValue": {
              "comment": "If PropertyTag corresponds to data that should be represented as text, contains the value for this resource"
            }
          }
        },
        "UIRangeData": {
          "comment": "Contains information about a data value that must be within a specific range.",
          "properties": {
            "bIntRange": {
              "comment": "Indicates whether the values in this UIRange should be treated as ints."
            },
            "CurrentValue": {
              "comment": "the current value of this UIRange"
            },
            "MaxValue": {
              "comment": "The maximum value for this UIRange. The value of this UIRange must be less than or equal to this value."
            },
            "MinValue": {
              "comment": "The minimum value for this UIRange. The value of this UIRange must be greater than or equal to this value."
            },
            "NudgeValue": {
              "comment": "Controls the amount to increment or decrement this UIRange's value when used by widgets that support \"nudging\".\n If NudgeValue is zero, reported NudgeValue will be 1% of MaxValue - MinValue."
            }
          }
        }
      }
    },
    "UISceneClient": {
      "properties": {
        "bEnablePostProcess": {
          "comment": "if TRUE then post processing is enabled using the UIScenePostProcess"
        },
        "CanvasToScreen": {
          "comment": "Stores the 3D projection matrix being used to render the UI."
        },
        "DataStoreManager": {
          "comment": "Manager all persistent global data stores. Set by the object that creates the scene client."
        },
        "MousePosition": {
          "comment": "the location of the mouse\n @fixme splitscreen"
        },
        "RenderViewport": {
          "comment": "the viewport to use for rendering scenes"
        },
        "UIScenePostProcess": {
          "comment": "Post process chain to be applied when rendering UI Scenes"
        }
      },
      "functions": {
        "GetCanvasToScreen": {
          "comment": "Returns the current canvas to screen projection matrix.",
          "params": {
            "Widget": "if specified, the returned matrix will include the widget's tranformation matrix as well."
          }
        },
        "GetInverseCanvasToScreen": {
          "comment": "Returns the inverse of the local to world screen projection matrix.",
          "params": {
            "Widget": "if specified, the returned matrix will include the widget's tranformation matrix as well."
          }
        },
        "InitializeSceneClient": {
          "comment": "Called when the scene client is first initialized."
        },
        "IsUIActive": {
          "comment": "Returns true if there is an unhidden fullscreen UI active",
          "params": {
            "Flags": "a bitmask of values which alter the result of this method; the bits are derived from the ESceneFilterTypes\n enum (which is native-only); script callers must pass these values literally"
          }
        }
      }
    },
    "UISoundTheme": {
      "properties": {
        "SoundEventBindings": {
          "comment": "List of the event bindings for this sound theme. Usually, these will be specified by a designer in an archetype in the editor, or in the defaultproperties"
        }
      },
      "functions": {
        "ProcessSoundEvent": {
          "comment": "Called when an event (focus change, click, etc) is fired from the UI"
        }
      },
      "structs": {
        "SoundEventMapping": {
          "comment": "Maps an event name to a sound. When an event comes in to the UISceneTheme, if it can be found in the bindings array, then the corresponding SoundCue will be played",
          "properties": {
            "SoundEventName": {
              "comment": "Name of the event that corresponds to the sound cue below."
            },
            "SoundToPlay": {
              "comment": "Sound cue to play when the the above event is received."
            }
          }
        }
      }
    },
    "UIWeaponSummary": {
      "functions": {
        "IsProviderDisabled": {
          "comment": "Allows a resource data provider instance to indicate that it should be unselectable in subscribed lists"
        }
      }
    },
    "Vehicle": {
      "properties": {
        "bAttachDriver": {
          "comment": "If true, attach the driver to the vehicle when he starts using it."
        },
        "bAvoidReversing": {
          "comment": "if set, AI avoids going in reverse unless it has to"
        },
        "bDoExtraNetRelevancyTraces": {
          "comment": "If true, do extra traces to vehicle extremities for net relevancy checks"
        },
        "bDriverIsVisible": {
          "comment": "whether to render driver seated in vehicle"
        },
        "bDriving": {
          "comment": "true if vehicle is being driven."
        },
        "bRetryPathfindingWithDriver": {
          "comment": "if set and pathfinding fails, retry with vehicle driver - ContinueOnFoot() will be called when AI can't go any further in vehicle"
        },
        "bTurnInPlace": {
          "comment": "AI control"
        },
        "Driver": {
          "comment": "Pawn driving this vehicle."
        },
        "DriverDamageMult": {
          "comment": "damage to the driver is multiplied by this value"
        },
        "ExitOffset": {
          "comment": "Offset from center for Exit test circle."
        },
        "ExitRadius": {
          "comment": "Radius for automatic exit positions."
        },
        "ForceCrushPenetration": {
          "comment": "If this vehicle penetrates more than this, even if going less than MinCrushSpeed, crush the pawn."
        },
        "MinCrushSpeed": {
          "comment": "If going less than this speed, don't crush the pawn."
        },
        "OldSteering": {
          "comment": "steering value used last tick"
        },
        "OldThrottle": {
          "comment": "Used by AI during three point turns, to make sure it doesn't get into a state where the throttle is reversed every tick"
        },
        "OnlySteeringStartTime": {
          "comment": "when AI started using only steering (so it doesn't get stuck doing that when it isn't working)"
        },
        "StuckTime": {
          "comment": "last time at which throttle was 0 (used by AI)"
        },
        "TargetLocationAdjustment": {
          "comment": "Adjust position that NPCs should aim at when firing at this vehicle"
        },
        "bIgnoreStallZ": {
          "comment": "TRUE for vehicle to ignore the StallZ value, FALSE to respect it normally"
        },
        "ExitPositions": {
          "comment": "Positions (relative to vehicle) to try putting the player when exiting. Optional -"
        },
        "MomentumMult": {
          "comment": "damage momentum multiplied by this value before being applied to vehicle"
        }
      },
      "functions": {
        "AnySeatAvailable": {
          "comment": "SeatAvailable()\nreturns true if a seat is available for a pawn"
        },
        "AttachDriver": {
          "comment": "Attach driver to vehicle.\n Sets up the Pawn to drive the vehicle (rendering, physics, collision..).\n Called only if bAttachDriver is true.\n Network : ALL"
        },
        "CanEnterVehicle": {
          "comment": "CanEnterVehicle()\nreturn true if Pawn P is allowed to enter this vehicle"
        },
        "ContinueOnFoot": {
          "comment": "ContinueOnFoot() - used by AI\nCalled from route finding if route can only be continued on foot."
        },
        "CrushedBy": {
          "comment": "CrushedBy()\nCalled for pawns that have bCanBeBaseForPawns=false when another pawn becomes based on them"
        },
        "DetachDriver": {
          "comment": "Detach Driver from vehicle.\n Network : ALL"
        },
        "DisplayDebug": {
          "comment": "@See Actor::DisplayDebug"
        },
        "DriverEnter": {
          "comment": "DriverEnter()\n Make Pawn P the new driver of this vehicle\n Changes controller ownership across pawns"
        },
        "DriverRadiusDamage": {
          "comment": "DriverRadiusDamage()\ndetermine if radius damage that hit the vehicle should damage the driver"
        },
        "EncroachedBy": {
          "comment": "Vehicles dont get telefragged."
        },
        "EncroachingOn": {
          "comment": "called when this Actor is encroaching on Other and we couldn't find an appropriate place to push Other to"
        },
        "FaceRotation": {
          "comment": "Vehicles ignore 'face rotation'."
        },
        "FindAutoExit": {
          "comment": "FindAutoExit(Pawn ExitingDriver)\nTries to find exit position on either side of vehicle, in back, or in front"
        },
        "GetMaxRiseForce": {
          "comment": "@RETURNS max rise force for this vehicle (used by AI)"
        },
        "NotifyDriverTakeHit": {
          "comment": "called when the driver of this vehicle takes damage"
        },
        "NotifyTeamChanged": {
          "comment": "NotifyTeamChanged()\nCalled when PlayerReplicationInfo is replicated to this pawn, or PlayerReplicationInfo team property changes.\nNetwork: client"
        },
        "PancakeOther": {
          "comment": "Crush the pawn vehicle is encroaching"
        },
        "PlaceExitingDriver": {
          "comment": "PlaceExitingDriver()\nFind an acceptable position to place the exiting driver pawn, and move it there.\nReturns true if pawn was successfully placed."
        },
        "TakeRadiusDamage": {
          "comment": "Take Radius Damage\n by default scales damage based on distance from HurtOrigin to Actor's location.\n This can be overriden by the actor receiving the damage for special conditions (see KAsset.uc).",
          "params": {
            "InstigatedBy,": "instigator of the damage",
            "Base": "Damage",
            "Damage": "Radius (from Origin)",
            "DamageType": "class",
            "Momentum": "(float)",
            "HurtOrigin,": "origin of the damage radius.",
            "DamageCauser": "the Actor that directly caused the damage (i.e. the Projectile that exploded, the Weapon that fired, etc)"
          }
        },
        "TryToDrive": {
          "comment": "TryToDrive()\nreturns true if Pawn P successfully became driver of this vehicle"
        }
      }
    },
    "Volume": {
      "properties": {
        "AssociatedActor": {
          "comment": "this actor gets touch() and untouch notifications as the volume is entered or left."
        },
        "bForcePawnWalk": {
          "comment": "Should pawns be forced to walk when inside this volume?"
        },
        "bProcessAllActors": {
          "comment": "Should process all actors within this volume"
        }
      },
      "functions": {
        "DisplayDebug": {
          "comment": "list important Volume variables on canvas. HUD will call DisplayDebug() on the current ViewTarget when\n the ShowDebug exec is used",
          "params": {
            "HUD": "HUD with canvas to draw on\n \n@input out_YL - Height of the current font\n \n@input out_YPos - Y position on Canvas. out_YPos += out_YL, gives position to draw text for next debug line."
          }
        },
        "Encompasses": {
          "comment": "Function that gets called from within Map_Check to allow this actor to check itself\n for any potential errors and register them with map check dialog."
        },
        "OnToggle": {
          "comment": "Handling Toggle event from Kismet."
        }
      }
    },
    "VolumePathNode": {
      "properties": {
        "StartingHeight": {
          "comment": "when path building, the cylinder starts at this size and does traces/point checks to refine\n to a size that isn't embedded in world geometry\n can be modified by LDs to adjust building behavior"
        },
        "StartingRadius": {
          "comment": "when path building, the cylinder starts at this size and does traces/point checks to refine\n to a size that isn't embedded in world geometry\n can be modified by LDs to adjust building behavior"
        }
      }
    },
    "WaterVolume": {
      "comment": "Games should create placeable subclasses of WaterVolume for use in game levels.",
      "properties": {
        "EntryActor": {
          "comment": "Effect spawned when touched by an actor that can splash"
        },
        "EntrySound": {
          "comment": "Sound played when touched by an actor that can splash"
        },
        "ExitActor": {
          "comment": "Effect spawned when untouched by an actor that can splash"
        },
        "ExitSound": {
          "comment": "Sound played when untouched by an actor that can splash"
        }
      }
    },
    "WaveFormBase": {
      "properties": {
        "TheWaveForm": {
          "comment": "This is the waveform data"
        }
      }
    },
    "Weapon": {
      "properties": {
        "AIController": {
          "comment": "Current AI controlling this weapon"
        },
        "bCanThrow": {
          "comment": "Can player toss his weapon out? Typically false for default inventory."
        },
        "bWasDoNotActivate": {
          "comment": "Set from ClientWeaponSet() when it has to go through PendingClientWeaponSet, to preserve those variables."
        },
        "bWasOptionalSet": {
          "comment": "Set from ClientWeaponSet() when it has to go through PendingClientWeaponSet, to preserve those variables."
        },
        "bWeaponPutDown": {
          "comment": "Set to put weapon down at the end of a state. Typically used to change weapons on state changes (weapon up, stopped firing...)"
        },
        "CachedMaxRange": {
          "comment": "Cache MaxRange of weapon"
        },
        "CurrentFireMode": {
          "comment": "Current FireMode"
        },
        "FiringStatesArray": {
          "comment": "Array of firing states defining available firemodes"
        },
        "InstantHitDamageTypes": {
          "comment": "DamageTypes for Instant Hit Weapons"
        },
        "Priority": {
          "comment": "Configurable weapon priority. Ties (mod weapons) are broken by GroupWeight"
        },
        "WeaponFireTypes": {
          "comment": "Defines the type of fire (see Enum above) for each mode"
        },
        "WeaponProjectiles": {
          "comment": "The Class of Projectile to spawn"
        },
        "DefaultAnimSpeed": {
          "comment": "When no duration is specified, speed to play anims."
        },
        "EquipTime": {
          "comment": "How long does it take to Equip this weapon"
        },
        "FireInterval": {
          "comment": "Holds the amount of time a single shot takes"
        },
        "FireOffset": {
          "comment": "Holds an offest for spawning protectile effects."
        },
        "InstantHitDamage": {
          "comment": "How much damage does a given instanthit shot do"
        },
        "InstantHitMomentum": {
          "comment": "momentum transfer scaling for instant hit damage"
        },
        "Mesh": {
          "comment": "Weapon Mesh"
        },
        "PutDownTime": {
          "comment": "How long does it take to put this weapon down"
        },
        "Spread": {
          "comment": "How much of a spread between shots"
        },
        "WeaponRange": {
          "comment": "Range of Weapon, used for Traces (InstantFire, ProjectileFire, AdjustAim...)"
        }
      },
      "functions": {
        "Activate": {
          "comment": "Activate() ignored since already becoming active"
        },
        "AddAmmo": {
          "comment": "Add ammo to weapon",
          "params": {
            "Amount": "to add."
          }
        },
        "AddSpread": {
          "comment": "Adds any fire spread offset to the passed in rotator",
          "params": {
            "Aim": "the base aim direction"
          }
        },
        "AttachWeaponTo": {
          "comment": "AttachWeaponTo is called when it's time to attach the weapon's mesh to a location.\n it should be subclassed."
        },
        "BeginFire": {
          "comment": "Override BeginFire so that it will enter the firing state right away."
        },
        "BeginState": {
          "comment": "Time the process and clear the Firing flags"
        },
        "CalcWeaponFire": {
          "comment": "CalcWeaponFire: Simulate an instant hit shot.\n This doesn't deal any damage nor trigger any effect. It just simulates a shot and returns\n the hit information, to be post-processed later.\n ImpactList returns a list of ImpactInfo containing all listed impacts during the simulation.\n CalcWeaponFire however returns one impact (return variable) being the first geometry impact\n straight, with no direction change. If you were to do refraction, reflection, bullet penetration\n or something like that, this would return exactly when the crosshair sees:\n The first 'real geometry' impact, skipping invisible triggers and volumes.",
          "params": {
            "StartTrace": "world location to start trace from",
            "EndTrace": "world location to end trace at",
            "Extent": "extent of trace performed\n \n@output ImpactList list of all impacts that occured during simulation"
          }
        },
        "CanThrow": {
          "comment": "Returns true if this item can be thrown out."
        },
        "ClearFlashCount": {
          "comment": "Clear flashCount variable on Pawn. and call WeaponStoppedFiring event.\n Call this on the server and local player.\n Network: Server or Local Player"
        },
        "ClearFlashLocation": {
          "comment": "Reset flash location variable. and call stop firing.\n Network: Server only"
        },
        "ClientGivenTo": {
          "comment": "Pawn/Controller/View functions"
        },
        "ClientWeaponSet": {
          "comment": "is called by the server to tell the client about potential weapon changes after the player runs over\n a weapon (the client decides whether to actually switch weapons or not.\n Network: LocalPlayer",
          "params": {
            "bOptionalSet.": "Set to true if the switch is optional. (simple weapon pickup and weight against current weapon).",
            "bDoNotActivate.": "Override, do not activate this weapon. It's just been received in the inventory."
          }
        },
        "ClientWeaponThrown": {
          "comment": "This function is called when the client needs to discard the weapon"
        },
        "ConsumeAmmo": {
          "comment": "Consumes ammunition when firing a shot.\n Subclass me to define weapon ammunition consumption."
        },
        "CustomFire": {
          "comment": "If the weapon isn't an instant hit, or a simple projectile, it should use the tyoe EWFT_Custom. In those cases\n this function will be called. It should be subclassed by the custom weapon."
        },
        "DenyClientWeaponSet": {
          "comment": "Returns true if this weapon wants to deny a ClientWeaponSwitch call"
        },
        "DenyPickupQuery": {
          "comment": "When you pickup an weapon, the inventory system has a chance to restrict the pickup."
        },
        "Destroyed": {
          "comment": "Event called when weapon actor is destroyed"
        },
        "DetachWeapon": {
          "comment": "Detach weapon components from instigator. Perform any clean up.\n Should be subclassed."
        },
        "DisplayDebug": {
          "comment": "list important Weapon variables on canvas. HUD will call DisplayDebug() on the current ViewTarget when\n the ShowDebug exec is used",
          "params": {
            "HUD": "HUD with canvas to draw on\n \n@input out_YL - Height of the current font\n \n@input out_YPos - Y position on Canvas. out_YPos += out_YL, gives position to draw text for next debug line."
          }
        },
        "DoOverrideNextWeapon": {
          "comment": "hook to override Next weapon call.\n For example the physics gun uses it to have mouse wheel change the distance of the held object.\n Warning: only use in firing state, otherwise it breaks weapon switching"
        },
        "DoOverridePrevWeapon": {
          "comment": "hook to override Previous weapon call."
        },
        "DropFrom": {
          "comment": "Drop this weapon out in to the world",
          "params": {
            "StartLocation": "The World Location to drop this item from",
            "StartVelocity": "The initial velocity for the item when dropped"
          }
        },
        "EndFire": {
          "comment": "Like BeginFire, this function puts a client and the server in sync and shuts down the\n firing sequence on both.\n Network: LocalPlayer and Server"
        },
        "EndState": {
          "comment": "Event called when weapon leaves this state"
        },
        "FireAmmunition": {
          "comment": "FireAmmunition: Perform all logic associated with firing a shot\n - Fires ammunition (instant hit or spawn projectile)\n - Consumes ammunition\n - Plays any associated effects (fire sound and whatnot)\n Network: LocalPlayer and Server"
        },
        "FireModeUpdated": {
          "comment": "Event called when Pawn.FiringMode has been changed.\n bViaReplication indicates if this was the result of a replication call."
        },
        "ForceEndFire": {
          "comment": "Clear all pending fires.\n This is non replicated flag."
        },
        "GetAdjustedAim": {
          "comment": "GetAdjustedAim begins a chain of function class that allows the weapon, the pawn and the controller to make\n on the fly adjustments to where this weapon is pointing."
        },
        "GetAIRating": {
          "comment": "AI interface"
        },
        "GetFireInterval": {
          "comment": "Returns interval in seconds between each shot, for the firing state of FireModeNum firing mode.",
          "params": {
            "FireModeNum": "fire mode"
          }
        },
        "GetMuzzleLoc": {
          "comment": "This function returns the world location for spawning the visual effects"
        },
        "GetPendingFireLength": {
          "comment": "Pending Fire / Inv Manager"
        },
        "GetPhysicalFireStartLoc": {
          "comment": "This function returns the world location for spawning the projectile, pulled in to the Pawn's collision along the AimDir direction."
        },
        "GetProjectileClass": {
          "comment": "Returns the type of projectile to spawn. We use a function so subclasses can\n override it if needed (case in point, homing rockets)."
        },
        "GetTargetDistance": {
          "comment": "Compute the approximate Screen distance from the camera to whatever is at the center of the viewport.\n Useful for stereoizing the crosshair to reduce eyestrain.\n NOTE: The dotproduct at the end is currently unnecessary, but if you were to use a different value for\n TargetLoc that was not at center of screen, it'd become necessary to do the way screen projection works."
        },
        "GetTraceRange": {
          "comment": "Range of weapon\n Used for Traces (CalcWeaponFire, InstantFire, ProjectileFire, AdjustAim...)\n State scoped accessor function. Override in proper state"
        },
        "GetWeaponAnimNodeSeq": {
          "comment": "Returns the AnimNodeSequence the weapon is using to play animations."
        },
        "GetWeaponDebug": {
          "comment": "Retrieves important weapon debug information as an array of strings. That can then be dumped or displayed on HUD."
        },
        "GetWeaponRating": {
          "comment": "Returns a weight reflecting the desire to use the\n given weapon, used for AI and player best weapon\n selection."
        },
        "HasAmmo": {
          "comment": "This function checks to see if the weapon has any ammo available for a given fire mode.",
          "params": {
            "FireModeNum": "The Fire Mode to Test For",
            "Amount": "[Optional] Check to see if this amount is available."
          }
        },
        "HasAnyAmmo": {
          "comment": "returns true if this weapon has any ammo left, regardless of the actual firing mode."
        },
        "HolderDied": {
          "comment": "Pawn holding this weapon as active weapon just died."
        },
        "IncrementFlashCount": {
          "comment": "Increment Pawn's FlashCount variable.\n This is used to play weapon fire effects on remote clients.\n Call this on the server and local player.\n Network: Server and Local Player"
        },
        "InstantFire": {
          "comment": "Performs an 'Instant Hit' shot.\n Also, sets up replication for remote clients,\n and processes all the impacts to deal proper damage and play effects.\n Network: Local Player and Server"
        },
        "IsFiring": {
          "comment": "Returns true if the weapon is firing, used by AI"
        },
        "ItemRemovedFromInvManager": {
          "comment": "A notification call when this weapon is removed from the Inventory of a pawn\n @see Inventory::ItemRemovedFromInvManager"
        },
        "MaxRange": {
          "comment": "Returns the Maximum Range for this weapon"
        },
        "NotifyWeaponFinishedFiring": {
          "comment": "AI function to handle a firing sequence (ie burst/melee strike/etc) being finished"
        },
        "NotifyWeaponFired": {
          "comment": "AI function to handle a single shot being fired"
        },
        "PassThroughDamage": {
          "comment": "returns true if should pass trace through this hitactor"
        },
        "PlayFireEffects": {
          "comment": "PlayFireEffects\n Main function to play Weapon fire effects.\n This is called from Pawn::WeaponFired in the base implementation."
        },
        "PlayWeaponAnimation": {
          "comment": "Play an animation on the weapon mesh\n Network: Local Player and clients",
          "params": {
            "Anim": "Sequence to play on weapon skeletal mesh",
            "desired": "duration, in seconds, animation should be played"
          }
        },
        "ProcessInstantHit": {
          "comment": "Processes a successful 'Instant Hit' trace and eventually spawns any effects.\n Network: LocalPlayer and Server",
          "params": {
            "FiringMode:": "index of firing mode being used",
            "Impact:": "hit information",
            "NumHits": "(opt): number of hits to apply using this impact\n this is useful for handling multiple nearby impacts of multihit weapons (e.g. shotguns)\n without having to execute the entire damage code path for each one\n an omitted or <= 0 value indicates a single hit"
          }
        },
        "ProjectileFire": {
          "comment": "Fires a projectile.\n Spawns the projectile, but also increment the flash count for remote client effects.\n Network: Local Player and Server"
        },
        "PutDownWeapon": {
          "comment": "This function is called to put a weapon down"
        },
        "ReadyToFire": {
          "comment": "ReadyToFire() called by NPC firing weapon. bFinished should only be true if called from the Finished() function"
        },
        "RefireCheckTimer": {
          "comment": "Timer event, call is set up in Weapon::TimeWeaponFiring().\n The weapon is given a chance to evaluate if another shot should be fired.\n This event defines the weapon's rate of fire."
        },
        "SendToFiringState": {
          "comment": "Send weapon to proper firing state\n Also sets the CurrentFireMode.\n Network: LocalPlayer and Server",
          "params": {
            "FireModeNum": "Fire Mode."
          }
        },
        "ServerStartFire": {
          "comment": "When StartFire() is called on a client, it replicates the start by calling ServerStartFire. This\n begins the event on server. Server side actors (such as bots) should not call ServerStartFire directly and should\n instead call StartFire().\n Network: Dedicated Server only, or Listen Server for remote clients."
        },
        "ServerStopFire": {
          "comment": "When StopFire is called on a client, ServerStopFire is used to initiate the sequence on the server.\n Network: Dedicated Server only, or Listen Server for remote clients."
        },
        "SetCurrentFireMode": {
          "comment": "Set current firing mode.\n Network: Local Player and Server."
        },
        "SetFlashLocation": {
          "comment": "This function sets up the Location of a hit to be replicated to all remote clients.\n Network: Server only"
        },
        "ShouldRefire": {
          "comment": "Check if current fire mode can/should keep on firing.\n This is called from a firing state after each shot is fired\n to decide if the weapon should fire again, or stop and go to the active state.\n The default behavior, implemented here, is keep on firing while player presses fire\n and there is enough ammo. (Auto Fire)."
        },
        "StartFire": {
          "comment": "do not allow firing in the inactive state"
        },
        "StillFiring": {
          "comment": "This function returns true if the weapon is still firing in a given mode"
        },
        "StopFire": {
          "comment": "This initiates the shutdown of a weapon that is firing.\n Network: Local Player"
        },
        "StopFireEffects": {
          "comment": "StopFireEffects\n Main function to stop any active effects\n This is called from Pawn::WeaponStoppedFiring"
        },
        "StopWeaponAnimation": {
          "comment": "Stops an animation on the weapon mesh\n Network: Local Player and clients"
        },
        "TimeWeaponEquipping": {
          "comment": "Sets the timing for equipping a weapon.\n The WeaponEquipped event is trigged when expired"
        },
        "TimeWeaponFiring": {
          "comment": "Sets the timing for the firing state on server and local client.\n By default, a constant looping Rate Of Fire (ROF) is set up.\n When the delay has expired, the RefireCheckTimer event is triggered.\n Network: LocalPlayer and Server",
          "params": {
            "FireModeNum": "Fire Mode."
          }
        },
        "TimeWeaponPutDown": {
          "comment": "Sets the timing for putting a weapon down. The WeaponIsDown event is trigged when expired"
        },
        "TryPutDown": {
          "comment": "can't put down an inactive weapon"
        },
        "WeaponEmpty": {
          "comment": "Called when the weapon runs out of ammo during firing"
        },
        "WeaponIsDown": {
          "comment": "We are done putting the weapon away, remove the mesh/etc."
        }
      }
    },
    "WorldInfo": {
      "properties": {
        "bAllowHostMigration": {
          "comment": "Config if TRUE then host migration is allowed to occur"
        },
        "bHaveActiveCrowd": {
          "comment": "Set if any CrowdAgents are currently spawned in this world - needs to be set when agent is spawned"
        },
        "bHighPriorityLoading": {
          "comment": "when this flag is set, more time is allocated to background loading (replicated)"
        },
        "bHighPriorityLoadingLocal": {
          "comment": "copy of bHighPriorityLoading that is not replicated, for clientside-only loading operations"
        },
        "bIsMenuLevel": {
          "comment": "That map is default map or not"
        },
        "bMapHasDLEsOutsideOfImportanceVolume": {
          "comment": "This is a bool on the world which is set when it is detected that a DLE is outside of any\n of the importance volumes used for lighting. This is then checked in CheckMap."
        },
        "bMapHasMultipleDominantLightsAffectingOnePrimitive": {
          "comment": "Set to true when one or primitives are affected by multiple dominant lights."
        },
        "bMapHasPathingErrors": {
          "comment": "This is a bool on the level which is set when the AI detects that paths are either not set up correctly\n or need to be rebuilt. If set the HUD will display a warning message on the screen."
        },
        "bMapNeedsLightingFullyRebuilt": {
          "comment": "This is a bool on the level which is set when a light that needs to have lighting rebuilt\n is moved. This is then checked in CheckMap for errors to let you know that this level should\n have lighting rebuilt."
        },
        "bRequestedBlockOnAsyncLoading": {
          "comment": "Whether it was requested that the engine bring up a loading screen and block on async loading."
        },
        "bUseConsoleInput": {
          "comment": "Bool that indicates that 'console' input is desired. This flag is mis named as it is used for a lot of gameplay related things\n (e.g. increasing collision size, changing vehicle turning behavior, modifying put down/up weapon speed, bot behavior)\n currently set when you are running a console build (implicitly or explicitly via ?param on the commandline)"
        },
        "ClientDestroyedActorContent": {
          "comment": "list of objects referenced by Actors that will be destroyed by the client on load (because they have bStatic and bNoDelete == false)\n this is so that they will persist in memory on the client in case the server needs to replicate them\n (generated at editor time so that server and client memory usage is more consistent)"
        },
        "CurrentMusicTrack": {
          "comment": "Param information for the currently playing MusicComp"
        },
        "DecalManagerClassPath": {
          "comment": "decal pool and lifetime manager"
        },
        "DeferredExecs": {
          "comment": "This is the array of string which will be called after a tick has occurred. This allows\n functions which GC and/or delete objects to be executed from .uc land!"
        },
        "EmitterPoolClassPath": {
          "comment": "particle emitter pool for gameplay effects that are spawned independent of their owning Actor"
        },
        "EmitterVertical": {
          "comment": "Verticals"
        },
        "EnvironmentVolumes": {
          "comment": "An array of environment volumes"
        },
        "FracturedMeshWeaponDamage": {
          "comment": "How much damage weapons do to fractured static meshes."
        },
        "FractureManagerClassPath": {
          "comment": "fractured mesh manager"
        },
        "HighestPriorityPostProcessVolume": {
          "comment": "Linked list of post processing volumes, sorted in descending order of priority."
        },
        "HighestPriorityReverbVolume": {
          "comment": "Linked list of reverb volumes, sorted in descending order of priority."
        },
        "HostMigrationTimeout": {
          "comment": "Started as soon as a client peer disconnects. If migration does succeed within this time then fall back to server disconnect failure"
        },
        "LastTimeUnbuiltLightingWasEncountered": {
          "comment": "Time in appSeconds unbuilt time was last encountered. 0 means not yet."
        },
        "LMLevelSettings": {
          "comment": "The Lightmass-related settings for this level"
        },
        "MassiveLODOverrideVolumes": {
          "comment": "Array of AMassiveLODOverrideVolume's in the world."
        },
        "MaxPhysicsSubsteps": {
          "comment": "The maximum number of substeps allowed in any physics scene/partition."
        },
        "MaxTrianglesPerLeaf<FixedIncrement=4|ClampMin=4|Multiple=4>": {
          "comment": "The number of triangles per leaf of the kdop tree in lightmass"
        },
        "MusicComp": {
          "comment": "Audio component used for playing music tracks via SeqAct_PlayMusicTrack"
        },
        "NextTravelType": {
          "comment": "The type of travel to perform next when doing a server travel"
        },
        "NumFacturedChunksSpawnedThisFrame": {
          "comment": "Number of chunks already spawned this frame"
        },
        "ParticleEventManagerClassPath": {
          "comment": "Particle event manager"
        },
        "PeerHostMigration": {
          "comment": "Info relevant to migrating a client peer to new host"
        },
        "PopulationManager": {
          "comment": "Population manager being used by this level"
        },
        "PortalVolumes": {
          "comment": "A array of portal volumes"
        },
        "PreparingLevelNames": {
          "comment": "array of levels that were loaded into this map via PrepareMapChange() / CommitMapChange() (to inform newly joining clients)"
        },
        "PriorityScreenMessages": {
          "comment": "A collection of messages to display on-screen."
        },
        "ReplicatedMusicTrack": {
          "comment": "Version of a new music track request replicated to clients"
        },
        "ReplicationViewers": {
          "comment": "valid only during replication - information about the player(s) being replicated to\n (there could be more than one in the case of a splitscreen client)"
        },
        "ScreenMessages": {
          "comment": "A collection of messages to display on-screen."
        },
        "bEnableChanceOfPhysicsChunkOverride": {
          "comment": "If TRUE, uses ChanceOfPhysicsChunkOverride instead of that set in the FracturedStaticMesh."
        },
        "bLimitDamageChunkSize": {
          "comment": "If TRUE, limit the max dimension of the bounding box of a fracture chunk due to weapon damage to bLimitDamageChunkSize"
        },
        "bLimitExplosionChunkSize": {
          "comment": "If TRUE, limit the max dimension of the bounding box of a fracture chunk due to explosion to MaxExplosionChunkSize"
        },
        "ChanceOfPhysicsChunkOverride": {
          "comment": "Allows global override of the ChanceOfPhysicsChunk setting."
        },
        "FractureExplosionVelScale": {
          "comment": "Scaling for chunk thrown out during explosion on a fractured mesh"
        },
        "MaxDamageChunkSize": {
          "comment": "Max dimension of the bounding box of a fracture chunk due to weapon damage."
        },
        "MaxExplosionChunkSize": {
          "comment": "Max dimension of the bounding box of a fracture chunk due to explosion."
        },
        "MaxNumFacturedChunksToSpawnInAFrame": {
          "comment": "Max number of Fractured Chunks to Spawn in a frame."
        },
        "bAllowLightEnvSphericalHarmonicLights": {
          "comment": "Whether to allow spherical harmonic lights on light environments. If FALSE, a cheaper skylight will be used instead."
        },
        "CharacterLightingContrastFactor<UIMin=1.0|UIMax=2.0|ClampMin=0.5|ClampMax=5.0>": {
          "comment": "Increases the contrast of light environment lighting on characters by scaling up the brightest directions and scaling down the rest by this factor. \n Note that this setting only affects light environments completely in shadow from all dominant lights."
        },
        "CharacterLitIndirectBrightness<UIMin=0.1|UIMax=1.0|ClampMin=0.0|ClampMax=5.0>": {
          "comment": "Brightness applied to the indirect lighting of character light environments that are lit by any dominant light."
        },
        "CharacterLitIndirectContrastFactor<UIMin=1.0|UIMax=2.0|ClampMin=0.5|ClampMax=5.0>": {
          "comment": "Contrast factor applied to the indirect lighting of character light environments that are lit by any dominant light."
        },
        "CharacterShadowedIndirectBrightness<UIMin=0.1|UIMax=1.0|ClampMin=0.0|ClampMax=5.0>": {
          "comment": "Brightness applied to the indirect lighting of character light environments that are shadowed by all dominant lights."
        },
        "CharacterShadowedIndirectContrastFactor<UIMin=1.0|UIMax=2.0|ClampMin=0.5|ClampMax=5.0>": {
          "comment": "Contrast factor applied to the indirect lighting of character light environments that are shadowed by all dominant lights."
        },
        "bForceNoPrecomputedLighting": {
          "comment": "Whether to force lightmaps and other precomputed lighting to not be created even when the engine thinks they are needed.\n This is useful for improving iteration in levels with fully dynamic lighting and shadowing.\n Note that any lighting and shadowing interactions that are usually precomputed will be lost if this is enabled."
        },
        "bSimpleLightmapsStoredInLinearSpace": {
          "comment": "Enables keeping 'simple' light maps in linear space for enhanced performance on mobile platforms"
        },
        "bUseGlobalIllumination": {
          "comment": "Whether this level should be using fully-featured global illumination. If not, it will use old-style direct lightmaps."
        },
        "bPhysicsIgnoreDeltaTime": {
          "comment": "If TRUE, physics simulation will ignore time elapsed between frames, and use (0.033 * TimeDilation)"
        },
        "ApexLODResourceBudget": {
          "comment": "Global APEX resource budget override. If negative the INI setting will be used instead."
        },
        "bSupportDoubleBufferedPhysics": {
          "comment": "Double buffered physics compartments enabled"
        },
        "CompartmentRunFrames": {
          "comment": "Which compartments run on which frames (list is cyclic). An empty list means all compartments run on all frames."
        },
        "DefaultSkinWidth": {
          "comment": "Default skin width"
        },
        "MaxPhysicsDeltaTime": {
          "comment": "The maximum frame time allowed for physics calculations"
        },
        "PhysicsProperties": {
          "comment": "Timing parameters for the scene, primary and compartments."
        },
        "VerticalProperties": {
          "comment": "Vertical parameters."
        },
        "bPlaceCellsOnSurfaces": {
          "comment": "Whether to place visibility cells on shadow casting surfaces only, or everywhere inside Precomputed Visibility Volumes. \n Placing cells everywhere in the volumes is useful for games where the camera is not restrained to an area around the ground,\n But generates a lot more cells than just placing on surfaces, so build times and memory usage will increase."
        },
        "bPrecomputeVisibility": {
          "comment": "Whether to place visibility cells inside Precomputed Visibility Volumes and along camera tracks in this level. \n Precomputing visibility reduces rendering thread time at the cost of some runtime memory and somewhat increased lighting build times."
        },
        "VisibilityAggressiveness": {
          "comment": "Determines how aggressive precomputed visibility should be. \n More aggressive settings cull more objects but also cause more visibility errors like popping."
        },
        "VisibilityCellSize": {
          "comment": "World space size of precomputed visibility cells in x and y.\n Smaller sizes produce more effective occlusion culling at the cost of increased runtime memory usage and lighting build times."
        },
        "bUseProcBuildingRulesetOverride": {
          "comment": "Overriding is useful for doing perf testing / load testing / being able to overcome memory issues in other tools until they are fixed\n withOUT compromising the RuleSet creation process and the application of the rulesets in the level"
        },
        "bAllowModulateBetterShadows": {
          "comment": "Whether to allow modulate-better shadows. If FALSE, all modulate-better shadows will be rendered as cheaper modulated shadows."
        },
        "bAllowTemporalAA": {
          "comment": "Whether to allow temporal AA."
        },
        "bIncreaseFogNearPrecision": {
          "comment": "Whether to increase precision close to the camera at the cost of distant precision"
        },
        "ImageReflectionEnvironmentColor<bShowOnlyWhenTrue=bShowD3D11Properties>": {
          "comment": "Color to be multiplied against ImageReflectionEnvironmentTexture. Alpha controls brightness."
        },
        "ImageReflectionEnvironmentRotation<bShowOnlyWhenTrue=bShowD3D11Properties>": {
          "comment": "Angle to rotate the environment texture around the world Z axis, in degrees."
        },
        "ImageReflectionEnvironmentTexture<bShowOnlyWhenTrue=bShowD3D11Properties>": {
          "comment": "Panoramic environment texture for image reflections. \n The texture should be laid out so that the horizon is along the bottom (v = 0) and straight up in world space is along the top (v = 1).\n The u direction of the texture then corresponds to rotation around the Z world axis."
        },
        "bNoDefaultInventoryForPlayer": {
          "comment": "if true, do not grant player with default inventory (presumably, the LD's will be setting it manually)"
        },
        "bNoPathWarnings": {
          "comment": "If true, don't add \"no paths from\" warnings to map error list in editor. Useful for maps that don't need AI support, but still have a few NavigationPoint actors in them."
        },
        "bPersistPostProcessToNextLevel": {
          "comment": "Whether or not post process effects should persist when this level is unloaded"
        },
        "DefaultAmbientZoneSettings": {
          "comment": "Default interior settings used by reverb volumes."
        },
        "DefaultColorScale": {
          "comment": "Default color scale for the level"
        },
        "DefaultPostProcessSettings": {
          "comment": "Default post process settings used by post processing volumes."
        },
        "DefaultReverbSettings": {
          "comment": "Default reverb settings used by reverb volumes."
        },
        "GameTypeForPIE": {
          "comment": "This is the gametype that should be used when starting the map in PIE."
        },
        "GameTypesSupportedOnThisMap": {
          "comment": "This is the list of GameTypes which this map can support. This is used for SeekFree loading\n code so the map has a reference to the game type it will be played with so it can cook\n all of the specific assets"
        },
        "LevelLightingQuality": {
          "comment": "The lighting quality the level was last built with"
        },
        "MyMapInfo": {
          "comment": "game specific map information - access through GetMapInfo()/SetMapInfo()"
        },
        "PackedLightAndShadowMapTextureSize": {
          "comment": "Maximum size of textures for packed light and shadow maps"
        },
        "SquintModeKernelSize": {
          "comment": "Squint mode kernel size (same as DOF)."
        },
        "StreamingLevels": {
          "comment": "Level collection. ULevels are referenced by FName (Package name) to avoid serialized references. Also contains offsets in world units"
        },
        "Title": {
          "comment": "title of the map displayed in the UI"
        },
        "WorldPostProcessChain": {
          "comment": "The post process chain for the entire world"
        }
      },
      "functions": {
        "AddOnScreenDebugMessage": {
          "comment": "Add a string to the On-screen debug message system"
        },
        "AllControllers": {
          "comment": "returns all Controllers in the ControllerList that are of the specified class or a subclass\n \n@note this function is only useful on the server; if you need the local player on a client, use Actor::LocalPlayerControllers()",
          "params": {
            "BaseClass": "the base class of Controller to return",
            "(out)": "C the returned Controller for each iteration"
          }
        },
        "AllNavigationPoints": {
          "comment": "returns all NavigationPoints in the NavigationPointList that are of the specified class or a subclass\n \n@note this function cannot be used during level startup because the NavigationPointList is created in C++ ANavigationPoint::PreBeginPlay()",
          "params": {
            "BaseClass": "the base class of NavigationPoint to return",
            "(out)": "N the returned NavigationPoint for each iteration"
          }
        },
        "AllPawns": {
          "comment": "returns all Pawns in the PawnList that are of the specified class or a subclass\n \n@note: useful on both client and server; pawns are added/removed from pawnlist in PostBeginPlay (on clients, only relevant pawns will be available)",
          "params": {
            "BaseClass": "the base class of Pawn to return",
            "(out)": "P the returned Pawn for each iteration",
            "(optional)": "TestRadius is the radius checked against\n using TestLocation, skipping any pawns not within that\n value"
          }
        },
        "BeginHostMigration": {
          "comment": "Try to start the process of host migration. This is called when server disconnect is detected.\n If host migration can't be started then fall back to the normal disconnect process.\n Also notify peers through peer net driver RPC that server connection has been lost."
        },
        "CanBeginHostMigration": {
          "comment": "Verifies that all players can be part of host migration"
        },
        "CancelPendingMapChange": {
          "comment": "cancels pending map change (@note: we can't cancel pending async loads, so this won't immediately free the memory)"
        },
        "ClearObjectPools": {
          "comment": "Tells the world to compact the current Physics instance pools to return memory to general availability"
        },
        "CommitMapChange": {
          "comment": "actually performs the map transition prepared by PrepareMapChange()\n it happens in the next tick to avoid GC issues\n if a map change is being prepared but isn't ready yet, the transition code will block until it is\n wait until IsMapChangeReady() returns true if this is undesired behavior"
        },
        "DoMemoryTracking": {
          "comment": "This function will do what ever memory tracking we have enabled. Basically there are a myriad of memory tracking/leak detection\n methods and this function abstracts all of that."
        },
        "FindEnvironmentVolume": {
          "comment": "Returns an Environment Volume if one is found at given location. If many are overlapping, only the first one found will be returned."
        },
        "GetAllRootSequences": {
          "comment": "Go over all loaded levels and get each root sequence"
        },
        "GetDemoFrameInfo": {
          "comment": "if playing back a demo, returns the frame information for that demo",
          "params": {
            "CurrentFrame": "(optional, out) - current frame the demo playback is on",
            "TotalFrames": "(optional, out) - total number of frames in the demo"
          }
        },
        "GetGameSequence": {
          "comment": "Grabs the default game sequence and returns it."
        },
        "GetGravityZ": {
          "comment": "Returns the Z component of the current world gravity and initializes it to the default\n gravity if called for the first time."
        },
        "GetMapName": {
          "comment": "@Returns the name of the current map"
        },
        "GetNavMeshPathConstraintFromCache": {
          "comment": "Will search for an existing free constraint from the cache, and return it if one is found\n otherwise it will add a new instance to the cache and return that",
          "params": {
            "ConstraintClass": "the class of the constraint to grab from the cache",
            "Requestor": "the handle that needs this constraint"
          }
        },
        "GetNavMeshPathGoalEvaluatorFromCache": {
          "comment": "Will search for an existing free Evaluator from the cache, and return it if one is found\n otherwise it will add a new instance to the cache and return that",
          "params": {
            "GoalEvalClass": "the class of the evaluator to grab from the cache",
            "Requestor": "the handle that needs this constraint"
          }
        },
        "GetWorldFractureSettings": {
          "comment": "Get the current fracture settings for the loaded world - handles streaming correctly."
        },
        "IsConsoleBuild": {
          "comment": "Returns whether we are running on a console platform or on the PC.",
          "params": {
            "ConsoleType": "if specified, only returns true if we're running on the specified platform"
          }
        },
        "IsMapChangeReady": {
          "comment": "if there is a map change being prepared, returns whether that change is ready to be committed\n (if no change is pending, always returns false)"
        },
        "IsMenuLevel": {
          "comment": "Determines whether a map is the default local map.",
          "params": {
            "MapName": "if specified, checks whether MapName is the default local map; otherwise, checks the currently loaded map."
          }
        },
        "IsPlayInEditor": {
          "comment": "Returns whether script is executing within the editor."
        },
        "IsPlayInPreview": {
          "comment": "Returns whether script is executing within a preview window"
        },
        "IsPreparingMapChange": {
          "comment": "returns whether there's a map change currently in progress"
        },
        "NavigationPointCheck": {
          "comment": "returns a list of NavigationPoints and ReachSpecs that intersect with the given point and extent",
          "params": {
            "Point": "point to check",
            "Extent": "box extent to check",
            "(optional,": "out) Specs list of ReachSpecs that intersect"
          }
        },
        "NotifyHostMigrationStateChanged": {
          "comment": "Notification when host migration state has changed",
          "params": {
            "NewState": "current host migration state",
            "OldState": "previous host migration state"
          }
        },
        "NotifyMatchStarted": {
          "comment": "Called by GameInfo.StartMatch, used to notify native classes of match startup (such as Kismet)."
        },
        "PrepareMapChange": {
          "comment": "asynchronously loads the given levels in preparation for a streaming map transition.\n This codepath is designed for worlds that heavily use level streaming and gametypes where the game state should\n be preserved through a transition.",
          "params": {
            "LevelNames": "the names of the level packages to load. LevelNames[0] will be the new persistent (primary) level"
          }
        },
        "RadiusNavigationPoints": {
          "comment": "returns all NavigationPoints whose cylinder intersects with a sphere of the specified radius at the specified point\n this function uses the navigation octree and is therefore fast for reasonably small radii\n \n@note this function cannot be used during level startup because the navigation octree is populated in C++ ANavigationPoint::PreBeginPlay()",
          "params": {
            "BaseClass": "the base class of NavigationPoint to return",
            "(out)": "N the returned NavigationPoint for each iteration",
            "Radius": "the radius to search in"
          }
        },
        "ReleaseCachedConstraintsAndEvaluators": {
          "comment": "will go through all the pools for each constraint/evaluator class that has been added so far and reset\n the instance index to 0 (call this after the search is complete to indicate you're done\n with the constraints from the pool)"
        },
        "Reset": {
          "comment": "Reset actor to initial state - used when restarting level without reloading."
        },
        "SeamlessTravel": {
          "comment": "seamlessly travels to the given URL by first loading the entry level in the background,\n switching to it, and then loading the specified level. Does not disrupt network communication or disconnet clients.\n You may need to implement GameInfo::GetSeamlessTravelActorList(), PlayerController::GetSeamlessTravelActorList(),\n GameInfo::PostSeamlessTravel(), and/or GameInfo::HandleSeamlessTravelPlayer() to handle preserving any information\n that should be maintained (player teams, etc)\n This codepath is designed for worlds that use little or no level streaming and gametypes where the game state\n is reset/reloaded when transitioning. (like UT)",
          "params": {
            "URL": "the URL to travel to; must be on the same server as the current URL",
            "bAbsolute": "(opt) - if true, URL is absolute, otherwise relative",
            "MapPackageGuid": "(opt) - the GUID of the map package to travel to - this is used to find the file when it has been autodownloaded,\n so it is only needed for clients"
          }
        },
        "ServerTravel": {
          "comment": "Jumps the server to new level. If bAbsolute is true and we are using seemless traveling, we\n will do an absolute travel (URL will be flushed).",
          "params": {
            "URL": "the URL that we are traveling to",
            "bAbsolute": "whether we are using relative or absolute travel",
            "bShouldSkipGameNotify": "whether to notify the clients/game or not"
          }
        },
        "SetMapInfo": {
          "comment": "sets the current MapInfo to the passed in one"
        },
        "SetSeamlessTravelMidpointPause": {
          "comment": "this function allows pausing the seamless travel in the middle,\n right before it starts loading the destination (i.e. while in the transition level)\n this gives the opportunity to perform any other loading tasks before the final transition\n this function has no effect if we have already started loading the destination (you will get a log warning if this is the case)",
          "params": {
            "bNowPaused": "whether the transition should now be paused"
          }
        },
        "ToggleHostMigration": {
          "comment": "Enable or disable host migration.",
          "params": {
            "bEnabled": "TRUE if host migration should be enabled."
          }
        }
      },
      "structs": {
        "ApexModuleDestructibleSettings": {
          "comment": "APEX",
          "properties": {
            "bOverrideMaxChunkSeparationLOD": {
              "comment": "If set, override the INI setting with Max Chunk Separation LOD in the WorldInfo properties."
            },
            "MaxChunkIslandCount": {
              "comment": "The maximum number of active PhysX actors which represent dynamic groups of chunks (islands). If a \nfracturing event would cause more islands to be created, then oldest islands are released and the chunks"
            },
            "MaxChunkSeparationLOD<ClampMin=0.0|ClampMax=1.0>": {
              "comment": "Every destructible asset defines a min and max lifetime, and maximum separation distance for its chunks.\nChunk islands are destroyed after this time or separation from their origins. This parameter sets the"
            },
            "MaxRrbActorCount": {
              "comment": "Reserved for future use."
            }
          }
        },
        "CompartmentRunList": {
          "comment": "For specifying which compartments should run on a given frame",
          "properties": {
            "Cloth": {
              "comment": "The cloth compartment will run on this frame"
            },
            "Fluid": {
              "comment": "The fluid compartment will run on this frame"
            },
            "RigidBody": {
              "comment": "The rigid body compartment will run on this frame"
            },
            "SoftBody": {
              "comment": "The soft body compartment will run on this frame"
            }
          }
        },
        "HostMigrationState": {
          "comment": "State of host migration",
          "properties": {
            "bHostMigrationEnabled": {
              "comment": "if TRUE then host migration is currently enabled"
            },
            "HostMigrationElapsedTime": {
              "comment": "Elapsed time since host migration has started. Ie. transitioned from HostMigration_None"
            },
            "HostMigrationProgress": {
              "comment": "Current progress of host migration process for client peers"
            },
            "HostMigrationTravelCountdown": {
              "comment": "Countdown begins ticking once new host has been selected. When it hits 0 then the new host will travel"
            },
            "HostMigrationTravelURL": {
              "comment": "URL to be used by the newly selected host to travel"
            }
          }
        },
        "LightmassWorldInfoSettings": {
          "properties": {
            "bCompressShadowmap": {
              "comment": "If TRUE, compress shadowmap with DXT1."
            },
            "bEnableImageReflectionShadowing": {
              "comment": "If TRUE, Lightmass will generate static shadowing information for image reflections."
            },
            "bUseAmbientOcclusion": {
              "comment": "If TRUE, AmbientOcclusion will be enabled."
            },
            "bUseNormalMapsForSimpleLightMaps": {
              "comment": "Enables normal map sampling when Lightmass is generating 'simple' light maps. This increases lighting build time, but may improve quality when normal maps are used to represent curvature over a large surface area. When this setting is disabled, 'simple' light maps will not take normal maps into account."
            },
            "bVisualizeAmbientOcclusion": {
              "comment": "If TRUE, override normal direct and indirect lighting with just the AO term."
            },
            "bVisualizeMaterialDiffuse": {
              "comment": "If TRUE, override normal direct and indirect lighting with just the exported diffuse term."
            },
            "DiffuseBoost": {
              "comment": "Scales the diffuse contribution of all materials in the scene."
            },
            "DirectIlluminationOcclusionFraction": {
              "comment": "How much of the AO to apply to direct lighting."
            },
            "EmissiveBoost": {
              "comment": "Scales the emissive contribution of all materials in the scene."
            },
            "EnvironmentColor": {
              "comment": "Color that rays which miss the scene will pick up. \n This is effectively a light surrounding the entire level that is shadowed, but doesn't emit indirect lighting."
            },
            "EnvironmentIntensity": {
              "comment": "Scales EnvironmentColor to allow independent color and brightness controls."
            },
            "FullyOccludedSamplesFraction": {
              "comment": "Fraction of samples taken that must be occluded in order to reach full occlusion."
            },
            "IndirectIlluminationOcclusionFraction": {
              "comment": "How much of the AO to apply to indirect lighting."
            },
            "IndirectNormalInfluenceBoost": {
              "comment": "Lerp factor that controls the influence of normal maps with directional lightmaps on indirect lighting.\n A value of 0 gives a physically correct distribution of light, which may result in little normal influence in areas only lit by indirect lighting, but less lightmap compression artifacts.\n A value of .8 results in 80% of the lighting being redistributed in the dominant incident lighting direction, which effectively increases the per-pixel normal's influence,\n But causes more severe lightmap compression artifacts."
            },
            "MaxOcclusionDistance": {
              "comment": "Maximum distance for an object to cause occlusion on another object."
            },
            "NumIndirectLightingBounces": {
              "comment": "Number of times light is allowed to bounce off of surfaces, starting from the light source. \n 0 is direct lighting only, 1 is one bounce, etc. \n Bounce 1 takes the most time to calculate and contributes the most to visual quality, followed by bounce 2. \n Successive bounces are nearly free, but have a much lower impact."
            },
            "OcclusionExponent": {
              "comment": "Higher exponents increase contrast."
            },
            "SpecularBoost": {
              "comment": "Scales the specular contribution of all materials in the scene."
            },
            "StaticLightingLevelScale": {
              "comment": "Scale of the level relative to Gears of War 2 levels. \n All scale-dependent Lightmass setting defaults have been tweaked to work well in Gears 2 levels, \n Any levels with a different scale should use this scale to compensate."
            }
          }
        },
        "NavMeshPathGoalEvaluatorCacheDatum": {
          "comment": "Path Goal evaluator pool"
        },
        "NetViewer": {
          "comment": "stores information on a viewer that actors need to be checked against for relevancy"
        },
        "PhysXEmitterVerticalProperties": {
          "comment": "Parameters for emitter vertical",
          "properties": {
            "bApplyCylindricalPacketCulling": {
              "comment": "Selects either cylindrical or spherical packet range culling."
            },
            "PacketsPerPhysXParticleSystemMax": {
              "comment": "Limit for packets per PhysXParticleSystem. Caped to 900."
            },
            "ParticlesLodMax": {
              "comment": "Max value for particle LOD range."
            },
            "ParticlesLodMin": {
              "comment": "Min value for particle LOD range."
            },
            "SpawnLodVsFifoBias": {
              "comment": "Parameter for scaling spawn lod impact. 1.0: As much as possible lod through\nemitter spawn rate/lifetime control. 0.0: Lod constraint handled only through\nfifo control."
            }
          }
        },
        "PhysXSceneProperties": {
          "comment": "Timings for primary and compartments.",
          "properties": {
            "CompartmentCloth": {
              "comment": "Timing settings for the PhysX cloth compartment"
            },
            "CompartmentFluid": {
              "comment": "Timing settings for the PhysX fluid compartment"
            },
            "CompartmentRigidBody": {
              "comment": "Timing settings for the PhysX rigid body compartment"
            },
            "CompartmentSoftBody": {
              "comment": "Timing settings for the PhysX soft body compartment"
            },
            "PrimaryScene": {
              "comment": "Timing settings for the PhysX primary scene"
            }
          }
        },
        "PhysXSimulationProperties": {
          "comment": "Parameters used for a PhysX primary scene or compartment",
          "properties": {
            "bFixedTimeStep": {
              "comment": "If true, substep sizes are fixed equal to TimeStep.\nIf false, substep sizes are varied to fit an integer number of times into the frame time."
            },
            "bUseHardware": {
              "comment": "Whether or not to put the scene (or compartment) in PhysX hardware, if available."
            },
            "MaxSubSteps": {
              "comment": "The maximum number of substeps allowed per frame."
            },
            "TimeStep": {
              "comment": "The fixed or maximum substep size, depending on the value of bFixedTimeStep."
            }
          }
        },
        "PhysXVerticalProperties": {
          "properties": {
            "Emitters": {
              "comment": "Parameters for Emitter Vertical"
            }
          }
        },
        "ScreenMessageString": {
          "comment": "Helper struct for tracking on screen messages.",
          "properties": {
            "CurrentTimeDisplayed": {
              "comment": "The number of frames it has been displayed so far."
            },
            "DisplayColor": {
              "comment": "The color to display the message in."
            },
            "Key": {
              "comment": "The 'key' for this message."
            },
            "ScreenMessage": {
              "comment": "The message to display."
            },
            "TimeToDisplay": {
              "comment": "The number of frames to display it."
            }
          }
        },
        "WorldFractureSettings": {
          "comment": "Struct used for passing back results from GetWorldFractureSettings"
        }
      }
    }
  },
  "GameFramework": {
    "DynamicGameCrowdDestination": {
      "comment": "Moveable version of GameCrowdDestination"
    },
    "DynamicSpriteComponent": {
      "properties": {
        "AnimatedColor": {
          "comment": "Animated color + alpha"
        },
        "AnimatedPosition": {
          "comment": "Animated 2D position (screen space). Relative to StartPosition."
        },
        "AnimatedScale": {
          "comment": "Animated Scale. Relative to DrawScale."
        },
        "LocationOffset": {
          "comment": "3D world space offset from Location"
        },
        "LoopCount": {
          "comment": "How many times to loop (-1 = infinite)"
        }
      }
    },
    "FrameworkGame": {
      "properties": {
        "RequiredMobileInputConfigs": {
          "comment": "Holds a list of MobileInputZones to load"
        }
      }
    },
    "GameAICmd_Hover_MoveToGoal": {
      "properties": {
        "GoalDistance": {
          "comment": "how close to get to the enemy (only valid of bCompleteMove is TRUE)"
        },
        "MoveVectDest": {
          "comment": "current vector destination"
        }
      },
      "functions": {
        "IsEnemyBasedOnInterpActor": {
          "comment": "Allows subclasses to determine if our enemy is based on an interp actor or not"
        },
        "MoveToGoal": {
          "comment": "Simple constructor that pushes a new instance of the command for the AI"
        }
      }
    },
    "GameAICmd_Hover_MoveToGoal_Mesh": {
      "properties": {
        "bFinalApproach": {
          "comment": "is this AI on 'final approach' ( i.e. moving directly to it's end-goal destination )"
        },
        "GoalDistance": {
          "comment": "how close to get to the enemy (only valid of bCompleteMove is TRUE)"
        },
        "InitialFinalDestination": {
          "comment": "storage of initial desired move location"
        },
        "IntermediatePoint": {
          "comment": "current vector destination"
        },
        "LastMoveTargetPathLocation": {
          "comment": "location of MoveToActor last time we did pathfinding"
        }
      },
      "functions": {
        "HoverToGoal": {
          "comment": "Simple constructor that pushes a new instance of the command for the AI"
        }
      }
    },
    "GameAICommand": {
      "properties": {
        "bAborted": {
          "comment": "Command has been aborted and should be popped next frame"
        },
        "bAllowNewSameClassInstance": {
          "comment": "if this is FALSE and we're trying to push a new instance of a given class, but the top of the stack is already an instance of that class ignore the attempted push"
        },
        "bPendingPop": {
          "comment": "this command is about to be popped, and shouldn't have resumed called on it when children are popped"
        },
        "bReplaceActiveSameClassInstance": {
          "comment": "if this is TRUE, when we try to push a new instance of a command who has the same class as the command on the top of the stack, pop the one on the stack, and push the new one"
        },
        "ChildCommand": {
          "comment": "Current child node executing on top of this command"
        },
        "ChildStatus": {
          "comment": "Exiting status of the last child command to execute"
        },
        "GameAIOwner": {
          "comment": "Extra reference to the AI this command is being used by"
        },
        "Status": {
          "comment": "Exiting status of this command"
        }
      },
      "functions": {
        "GetDebugOverheadText": {
          "comment": "Used to get text from the AICmds"
        },
        "InitCommand": {
          "comment": "Simple constructor that pushes a new instance of the command for the AI"
        },
        "InitCommandUserActor": {
          "comment": "Simple constructor that takes one extra userdata param"
        },
        "InternalPaused": {
          "comment": "Called when another command is pushed on top of this one"
        },
        "InternalPopped": {
          "comment": "Called when command popped to perform any necessary cleanup, independent of the individual command implementations - @see Popped() instead"
        },
        "InternalPrePushed": {
          "comment": "called to set up internal pointers to the owning AI, before Pushed is called"
        },
        "InternalPushed": {
          "comment": "Called when command pushed to perform any necessary work, independent of the individual command implementations - @see Pushed() instead"
        },
        "InternalResumed": {
          "comment": "Called when the command that was on top of this one in the stack is popped"
        },
        "Popped": {
          "comment": "Notification when this command has popped"
        },
        "PostPopped": {
          "comment": "called just before popped.. useful for cleaning up things before the popped chain gets called"
        },
        "PrePushed": {
          "comment": "called to set up internal pointers to the owning AI, before Pushed is called"
        },
        "Pushed": {
          "comment": "Notification called when this command has pushed"
        },
        "Tick": {
          "comment": "== OVERRIDABLE INTERFACE =="
        }
      }
    },
    "GameAIController": {
      "properties": {
        "AILogFile": {
          "comment": "Debug log file, @see: AILog"
        },
        "bHasRunawayCommandList": {
          "comment": "Whether this AI has a runaway loop or not. If it does we are going to do AbortCommand( CommandList ) at the end of Tick()."
        },
        "AILogFilter": {
          "comment": "List of categories to filter"
        },
        "AITree": {
          "comment": "This should point to the AITree in a content package."
        },
        "CommandList": {
          "comment": "Current command stack, with the last element being the currently active (ticked) one"
        }
      },
      "functions": {
        "AbortCommand": {
          "comment": "AbortCommand\n Aborts a command (and all of its children)",
          "params": {
            "AbortCmd": "the command to abort (can be NULL, in which case AbortClass will be used to determine which command to abort",
            "AbortClass": "not used unless AbortCmd is NULL, in which case the first command int he stack of class 'AbortClass' will be aborted (and all its children)"
          }
        },
        "AllCommands": {
          "comment": "returns all AI Commands in the CommandList that are of the specified class or a subclass\n \n@note this function is only useful on the server",
          "params": {
            "BaseClass": "the base class of GameAICommand to return",
            "(out)": "Cmd the returned GameAICommand for each iteration"
          }
        },
        "CheckCommandCount": {
          "comment": "checks the command stack for too many commands and/or infinite recursion"
        },
        "Destroyed": {
          "comment": "=====\n DEBUG\n ====="
        },
        "FindCommandOfClass": {
          "comment": "finds and returns the lowest command of the specified class on the stack (will return subclasses of the specified class)"
        },
        "GetAICommandInStack": {
          "comment": "This will search the CommandList for the passed in command class."
        },
        "GetDestinationOffset": {
          "comment": "return desired offset to move position... used for MoveTo/MoveToward"
        },
        "PopCommand": {
          "comment": "PopCommand\n will pop the passed command (and everything above it in the stack)",
          "params": {
            "ToBePoppedCommand": "the command to pop"
          }
        },
        "PushCommand": {
          "comment": "PushCommand\n pushes a new AI command on top of the command stack",
          "params": {
            "NewCommand": "command to place on top of stack"
          }
        },
        "SetDesiredRotation": {
          "comment": "SetDesiredRotation\n Calls Pawn's SetDesiredRotation: Simple interface to Pawn"
        }
      }
    },
    "GameCameraBase": {
      "properties": {
        "bResetCameraInterpolation": {
          "comment": "resets camera interpolation. Set on first frame and teleports to prevent long distance or wrong camera interpolations."
        }
      },
      "functions": {
        "OnBecomeActive": {
          "comment": "Called when the camera becomes active"
        },
        "OnBecomeInActive": {
          "comment": "Called when the camera becomes inactive"
        },
        "ResetInterpolation": {
          "comment": "Called to indicate that the next update should skip interpolation and snap to desired values."
        },
        "UpdateCamera": {
          "comment": "Expected to fill in OutVT with new camera pos/loc/fov."
        }
      }
    },
    "GameCrowdAgent": {
      "properties": {
        "AmbientSoundComponent": {
          "comment": "Ambient sound being played"
        },
        "bBadHitNormal": {
          "comment": "flags set for debugging (set each tick)"
        },
        "BeaconColor": {
          "comment": "Beacon background color"
        },
        "BeaconMaxDist": {
          "comment": "Max distance to draw debug beacon"
        },
        "BeaconOffset": {
          "comment": "Debug beacon offset from Location"
        },
        "BeaconTexture": {
          "comment": "Background texture for debug beacon"
        },
        "BehaviorDestination": {
          "comment": "Last destination where performed Kismet/Behavior. Cleared when have new destination. Used to keep from looping kismet/behavior at destination."
        },
        "bHasNotifiedSpawner": {
          "comment": "True if already notified spawner about destruction"
        },
        "bHitObstacle": {
          "comment": "flags set for debugging (set each tick)"
        },
        "bIsInSpawnPool": {
          "comment": "true if agent is currently sitting in pop mgr's agent pool"
        },
        "bIsPanicked": {
          "comment": "only used for animation now. Need to replace with more appropriately named property"
        },
        "bPotentialEncounter": {
          "comment": "Set when updating dynamics if agent is potential encounter for updating agent - only valid in HandlePotentialAgentEncounter() event."
        },
        "bSimulateThisTick": {
          "comment": "Whether to perform crowd simulation this tick on this agent ( updated using ShouldPerformCrowdSimulation() )"
        },
        "bUniformScale": {
          "comment": "Whether to use same scale variation in all axes"
        },
        "bWantsGroupIdle": {
          "comment": "Whether should idle and wait for other group members"
        },
        "bWantsSeePlayerNotification": {
          "comment": "Note currently only checks if see player when being rendered"
        },
        "ConformTraceFrameCount": {
          "comment": "Used to count how many frames since the last conform trace."
        },
        "CurrentBehavior": {
          "comment": "Current applied behavior instance"
        },
        "CurrentConformTraceInterval": {
          "comment": "Current conform interval"
        },
        "CurrentDestination": {
          "comment": "Current destination"
        },
        "DesiredGroupRadiusSq": {
          "comment": "Keep square of DesiredGroupRadius for faster testing"
        },
        "EyeZOffset": {
          "comment": "Eye Z offset from location"
        },
        "ForceUpdateTime": {
          "comment": "World time when agent was spawned or last rendered"
        },
        "InitialLastRenderTime": {
          "comment": "Initial setting of LastRenderTime (used to see if agent was ever actually rendered)"
        },
        "IntermediatePoint": {
          "comment": "Current movement destination intermediate to reaching CurrentDestination"
        },
        "InterpZTranslation": {
          "comment": "If conforming to ground, this is how much to move the agent each frame between line-trace updates."
        },
        "LastGroundZ": {
          "comment": "TEMP for debugging - last ground conform hit normal Z"
        },
        "LastKnownGoodPosition": {
          "comment": "Last position validated by collision trace"
        },
        "LastPathingAttempt": {
          "comment": "Last time pathing was attempted for this agent"
        },
        "LastUpdateTime": {
          "comment": "Used to limit update frequency of agents that are not visible"
        },
        "LightEnvironment": {
          "comment": "Pointer to LightEnvironment"
        },
        "MaxLOSLifeDistanceSq": {
          "comment": "Max distance to keep agents around if they haven't been rendered in NotVisibleLifeSpan, but are still in player's potential line of sight"
        },
        "MaxSeePlayerDistSq": {
          "comment": "Calculated from behaviors in SeePlayerList"
        },
        "MaxSpeed": {
          "comment": "Current max speed"
        },
        "MyArchetype": {
          "comment": "Archetype used to spawn this agent"
        },
        "MyGroup": {
          "comment": "Agent group this agent is part of"
        },
        "MySpawner": {
          "comment": "Actor with GameCrowdSpawnerInterface which spawned this agent"
        },
        "NavigationHandleClass": {
          "comment": "Navigation Handle used by agents requesting pathing"
        },
        "NearbyDynamics": {
          "comment": "Nearby pawns and agents. Updated periodically using main Octree"
        },
        "PendingVelocity": {
          "comment": "Velocity we will take next physics tick"
        },
        "PreferredVelocity": {
          "comment": "Velocity in the absence of other agent interactions"
        },
        "PreviousDestination": {
          "comment": "where agent is coming from"
        },
        "ReachThreshold": {
          "comment": "Random variation in how closely agent must reach destination (0.5 to 1.0)"
        },
        "SearchExtent": {
          "comment": "bounding box to use for pathing queries"
        },
        "SpawnOffset": {
          "comment": "Used for keeping groups spawned together"
        },
        "WalkableFloorZ": {
          "comment": "Used for accessing potential obstacles - not an obstacle if hitnormal.Z > WalkableFloorZ"
        },
        "DeadBodyDuration": {
          "comment": "How long dead body stays around"
        },
        "DesiredGroupRadius": {
          "comment": "Try to keep Members this close together - probably will be obsolete when have formations"
        },
        "EncounterAgentBehaviors": {
          "comment": "Behaviors to choose from when encounter another agent (only if no current behavior)"
        },
        "GroupWaitingBehaviors": {
          "comment": "Behaviors to choose from when waiting for other group members."
        },
        "RandomBehaviorInterval": {
          "comment": "Average time between random behavior attempt (only if visible to player and no current behavior)"
        },
        "RandomBehaviors": {
          "comment": "Behaviors to choose from randomly at RandomBehaviorInterval."
        },
        "SeePlayerBehaviors": {
          "comment": "Behaviors to choose from when see player (only if no current behavior)"
        },
        "SeePlayerInterval": {
          "comment": "How often see player event can be triggered. If 0, never retriggers"
        },
        "SpawnBehaviors": {
          "comment": "Behaviors to choose from when agent spawns."
        },
        "TakeDamageBehaviors": {
          "comment": "Behaviors to choose from when the agent takes damage."
        },
        "UneasyBehaviors": {
          "comment": "Behaviors to choose from when agent panicks."
        },
        "AmbientSoundCue": {
          "comment": "Ambient Sound cue played by this agent"
        },
        "bPreferVisibleDestination": {
          "comment": "If true, agent will prefer destinations with line of sight to player if starting from non-L.O.S. destination"
        },
        "bPreferVisibleDestinationOnSpawn": {
          "comment": "If true, prefer visible destination only for first destination chosen after spawn"
        },
        "Health": {
          "comment": "Current health of agent"
        },
        "NotVisibleLifeSpan": {
          "comment": "how long to wait before killing this agent when it isn't visible"
        },
        "ProximityLODDist": {
          "comment": "Distance to LOD out proximity checks for non-visible agents"
        },
        "VisibleProximityLODDist": {
          "comment": "Distance to LOD out proximity checks for visible agents"
        },
        "ConformTraceDist": {
          "comment": "How far to trace to conform agent to the bsp/world."
        },
        "ConformTraceInterval": {
          "comment": "Every how many frames the ground conforming line check is done."
        },
        "ConformType": {
          "comment": "How agent conforms to surfaces"
        },
        "MaxRunningSpeed": {
          "comment": "Max running speed (if not using root motion velocity)"
        },
        "MaxWalkingSpeed": {
          "comment": "Max walking speed (if not using root motion velocity)"
        },
        "MaxYawRate": {
          "comment": "Crowd agents rotate to face the direction they are travelling. This value limits how quickly they turn to do this, to avoid them spinning too quickly"
        },
        "RotateToTargetSpeed": {
          "comment": "When a 'target' action occurs, agent will rotate to face the CrowdAttractor. This controls how fast that turn happens"
        },
        "AvoidOtherRadius": {
          "comment": "The radius used to check overlap between agents (basically how big an agent is)."
        },
        "AwareRadius": {
          "comment": "Controls how far around an agent the system looks when finding the average speed."
        },
        "bCheckForObstacles": {
          "comment": "Whether to have obstacle mesh block agents"
        },
        "bUseNavMeshPathing": {
          "comment": "If TRUE, use navmesh for pathing"
        },
        "GroundOffset": {
          "comment": "Distance from ground to agent center (used to adjust foot positioning)"
        },
        "MeshMaxScale3D": {
          "comment": "Max 3D drawscale to apply to the agent mesh"
        },
        "MeshMinScale3D": {
          "comment": "Min 3D drawscale to apply to the agent mesh"
        }
      },
      "functions": {
        "ActivateBehavior": {
          "comment": "Activate the passed in NewBehaviorArchetype as the new current behavior for this agent\n FIXMESTEVE - currently kills old behavior - instead, should have stack of behaviors"
        },
        "ActivateInstancedBehavior": {
          "comment": "Activate a new behavior that has already been instantiated"
        },
        "CalcCamera": {
          "comment": "Calculate camera view point, when viewing this actor.",
          "params": {
            "fDeltaTime": "delta time seconds since last update",
            "out_CamLoc": "Camera Location",
            "out_CamRot": "Camera Rotation",
            "out_FOV": "Field of View"
          }
        },
        "FellOutOfWorld": {
          "comment": "called when the actor falls out of the world 'safely' (below KillZ and such)"
        },
        "FireDeathEvent": {
          "comment": "Death event is script class, so need to call from script"
        },
        "GeneratePathToActor": {
          "comment": "Generate a path to Goal on behalf of the QueryingAgent"
        },
        "GetBehaviorString": {
          "comment": "Get debug string about agent behavior"
        },
        "GetCollisionExtent": {
          "comment": "This function actually does the work for the GetDetailInfo and is virtual. \n It should only be called from GetDetailedInfo as GetDetailedInfo is safe to call on NULL object pointers"
        },
        "GetDestString": {
          "comment": "Get debug string about agent destination and movement status"
        },
        "HandlePotentialAgentEncounter": {
          "comment": "Called when agent encounters another agent\n NearbyDynamics list has been updated with agents, and potential encounters have their bPotentialEncounter set to true"
        },
        "InitializeAgent": {
          "comment": "Initialize agent archetype, group, destination, and behavior"
        },
        "InitNavigationHandle": {
          "comment": "spawn and init Navigation Handle"
        },
        "IsIdle": {
          "comment": "@RETURNS true if CurrentBehavior and CurrentBehavior.bIdleBehavior is true"
        },
        "IsPanicked": {
          "comment": "@RETURNS whether this agent is panicked (true if agent has a CurrentBehavior and CurrentBehavior.bIsPanicked==true"
        },
        "KillAgent": {
          "comment": "Kill this agent or add it to population manager's spawn pool"
        },
        "NotifySeePlayer": {
          "comment": "Called when see PC's pawn where PC is a local playercontroller,\n Notification only occurs if bHasSeePlayerKismet=true"
        },
        "OverlappedActorEvent": {
          "comment": "Called when crowd agent overlaps something in the ReportOverlapsWithClass list"
        },
        "PickBehaviorFrom": {
          "comment": "Pick a behavior from the BehaviorList, for a camera at BestCameraLoc,\n and activate this behavior\n Caller is responsible for setting bHasBeenUsed on picked behavior entry.\n @RETURNS true if new behavior was activated"
        },
        "PlayDeath": {
          "comment": "Stop agent moving and pay death anim"
        },
        "PlayIdleAnimation": {
          "comment": "Play a looping idle animation"
        },
        "PlaySpawnBehavior": {
          "comment": "Called when agent spawns and has SpawnBehaviors set"
        },
        "PostRenderFor": {
          "comment": "PostRenderFor()\nHook to allow agents to render HUD overlays for themselves.\nCalled only if the agent was rendered this tick.\nAssumes that appropriate font has already been set"
        },
        "ResetPooledAgent": {
          "comment": "Agent is coming out of pool, so rev him up"
        },
        "SetCurrentBehavior": {
          "comment": "Instantiate a new behavior using BehaviorArchetype, and set it to be the current behavior."
        },
        "SetLighting": {
          "comment": "Set agent lighting\n @PARAM bEnableLightEnvironment controls whether light environment is enabled\n @PARAM AgentLightingChannel is the lighting channel to use (GameCrowdAgentSkeletal only)\n @PARAM bCastShadows controls whether agent casts shadows (GameCrowdAgentSkeletal only)"
        },
        "SetMaxSpeed": {
          "comment": "Set maximum movement speed"
        },
        "TryRandomBehavior": {
          "comment": "Called when random behavior timer expires\n If not currently in behavior AND player can see me, do a random behavior."
        },
        "UpdateIntermediatePoint": {
          "comment": "Update current intermediate destination point for agent in route to DestinationActor"
        },
        "WaitForGroupMembers": {
          "comment": "Too far ahead of group, pick waiting behavior"
        }
      },
      "structs": {
        "BehaviorEntry": {
          "comment": "Describes a behavior type and its frequency",
          "properties": {
            "bCanBeUsed": {
              "comment": "Temp Cache whether this behavior can be used"
            },
            "BehaviorArchetype": {
              "comment": "Archetype based on a GameCrowdAgentBehavior class"
            },
            "BehaviorFrequency": {
              "comment": "How often this behavior is picked = BehaviorFrequency/(sum of BehaviorFrequencies)"
            },
            "bHasBeenUsed": {
              "comment": "Whether this behavior has been used by this agent"
            },
            "bNeverRepeat": {
              "comment": "If true, agent will never repeat this behavior"
            },
            "LookAtActor": {
              "comment": "Optional actor to look at when performing this behavior"
            }
          }
        }
      }
    },
    "GameCrowdAgentBehavior": {
      "properties": {
        "ActionTarget": {
          "comment": "actor to aim at during actions"
        },
        "MyAgent": {
          "comment": "Agent currently implementing this behavior instance"
        },
        "TimeToStopPropagatingViralBehavior": {
          "comment": "This is the time we will stop propagating the bIsViralBehavior flag"
        },
        "bFaceActionTargetFirst": {
          "comment": "If true, must face action target before starting behavior"
        },
        "bIdleBehavior": {
          "comment": "If true, agent should idle (not move between destinations)/"
        },
        "bIsViralBehavior": {
          "comment": "If true, pass on to agents encountered"
        },
        "bPassOnIsViralBehaviorFlag": {
          "comment": "So for some behaviors we only want the original agents to be able to pass on the bViralBehavior flag.\n You will want to check for this flag in your specific behavior's event PropagateViralBehaviorTo. \n NOTE: Currently, there is no default implementation of that that we are are all calling super. to utilize that functionality"
        },
        "DurationOfBehavior": {
          "comment": "If non-zero, how long before behavior auto terminates"
        },
        "DurationOfViralBehaviorPropagation": {
          "comment": "How long we should propagate the viral behavior. Basically, you can get into situations where the the behavior will never go away as it\n keeps getting propagated to others over and over and the various timers get started again."
        },
        "MaxPlayerDistance": {
          "comment": "Agent must be within this distance of the player to perform this behavior"
        }
      },
      "functions": {
        "ActivatedBy": {
          "comment": "Called if agent wants to provide an action target to its behavior."
        },
        "AllowBehaviorAt": {
          "comment": "return true if get kismet or new behavior from this destination"
        },
        "AllowThisDestination": {
          "comment": "Return true if agent is allowed to go to destination while performing this behavior"
        },
        "CanBeUsedBy": {
          "comment": "This function is called on an archetype - do not modify any properties here!"
        },
        "ChangingDestination": {
          "comment": "Notification that MyAgent is changing destinations"
        },
        "FinishedTargetRotation": {
          "comment": "Event when agent is facing action target, called if bFaceActionTarget=true"
        },
        "GetBehaviorString": {
          "comment": "Get debug string about agent behavior"
        },
        "GetDestinationActor": {
          "comment": "Returns action agent wants behavior to be moving toward."
        },
        "HandleMovement": {
          "comment": "Handles movement destination updating for agent.\n @RETURNS true if destination updating was handled"
        },
        "InitBehavior": {
          "comment": "Called when Agent activates this behavior"
        },
        "OnAnimEnd": {
          "comment": "Anim end notification called by GameCrowdAgent.OnAnimEnd()."
        },
        "PropagateViralBehaviorTo": {
          "comment": "When two agents encounter each other, and one has a viral behavior and the other doesn't,\n the viral behavior is called to have a chance to propagate itself to the uninfected OtherAgent."
        },
        "ShouldEndIdle": {
          "comment": "Called every tick when agent is currently idle (because bIdleBehavior is true)\n @RETURN true if should end idle (bIdleBehavior should also become false)"
        },
        "StopBehavior": {
          "comment": "Called when Agent stops this behavior"
        },
        "Tick": {
          "comment": "Agent's current behavior gets ticked"
        },
        "TriggerCrowdBehavior": {
          "comment": "if duration < 0 it is instant\n if duration == 0 it is eternal\n if duration > 0 it has a lifespan"
        }
      }
    },
    "GameCrowdAgentSkeletal": {
      "properties": {
        "ActionSeqNode": {
          "comment": "Cached pointer to action animation player"
        },
        "AgentTree": {
          "comment": "Cached pointer to AnimTree instance (SkeletalMeshComponent.Animations)"
        },
        "bAnimateThisTick": {
          "comment": "Whether to perform animation updates this tick on this agent ( updated using ShouldPerformCrowdSimulation() )"
        },
        "bIsPlayingDeathAnimation": {
          "comment": "true if currently playing death animation"
        },
        "bIsPlayingIdleAnimation": {
          "comment": "true if currently playing idle animation"
        },
        "FullBodySlot": {
          "comment": "Cached pointer to action blend node"
        },
        "MaxAnimationDistanceSq": {
          "comment": "Keep square of MaxAnimationDistance for faster testing"
        },
        "RunSeqNode": {
          "comment": "Cached pointer to running animation player"
        },
        "SpeedBlendNode": {
          "comment": "Cached pointer to speed blend node"
        },
        "WalkSeqNode": {
          "comment": "Cached pointer to walking animation player"
        },
        "DeathAnimNames": {
          "comment": "Set of possible animation names to play when agent dies"
        },
        "MaxTargetAcquireTime": {
          "comment": "Maximum time to try to rotate toward a target before playing animation"
        },
        "MaxAnimationDistance": {
          "comment": "Maximum distance from camera at which this agent should be animated"
        },
        "Attachments": {
          "comment": "List of sets of meshes to attach to agent."
        },
        "bUseRootMotionVelocity": {
          "comment": "If true, clamp velocity based on root motion in movement animations"
        },
        "IdleAnimNames": {
          "comment": "The name of the animations to use when not moving (and not playing a custom animation)"
        },
        "RunAnimNames": {
          "comment": "The name of the animations to use when moving more quickly"
        },
        "SkeletalMeshComponent": {
          "comment": "SkeletalMeshComponent used for crowd member mesh"
        },
        "WalkAnimNames": {
          "comment": "The names of the animation loops to use when moving slowly"
        },
        "AnimVelRate": {
          "comment": "This controls how the animation playback rate changes based on the speed of the agent (if not using root motion)"
        },
        "MaxSpeedBlendChangeSpeed": {
          "comment": "Limits how quickly blending between running and walking can happen. (if not using root motion)"
        },
        "MoveSyncGroupName": {
          "comment": "Name of sync group for movement, whose rate is scaled (if not using root motion)"
        },
        "SpeedBlendEnd": {
          "comment": "Above this speed, the running animation is used. Between this and SpeedBlendStart the animations are blended (if the AnimTree has a SpeedBlendNode, and not using root motion)"
        },
        "SpeedBlendStart": {
          "comment": "Below this speed, the walking animation is used (if the AnimTree has a SpeedBlendNode, and not using root motion)"
        }
      },
      "functions": {
        "CreateAttachments": {
          "comment": "Create any attachments"
        },
        "OnPlayAgentAnimation": {
          "comment": "Animation request from kismet"
        },
        "PlayDeath": {
          "comment": "Stop agent moving and play death anim"
        },
        "PlayIdleAnimation": {
          "comment": "Play a looping idle animation"
        },
        "SetRootMotion": {
          "comment": "Enable or disable root motion for this agent"
        }
      },
      "structs": {
        "GameCrowdAttachmentInfo": {
          "comment": "Info about mesh we might want to use as an attachment.",
          "properties": {
            "Chance": {
              "comment": "Chance of choosing this attachment."
            },
            "Scale3D": {
              "comment": "Scaling applied to mesh when attached"
            },
            "StaticMesh": {
              "comment": "Pointer to mesh to attach"
            }
          }
        },
        "GameCrowdAttachmentList": {
          "comment": "Info about things you can attach to one socket.",
          "properties": {
            "List": {
              "comment": "List of possible meshes to attach to this socket."
            },
            "SocketName": {
              "comment": "Name of socket to attach mesh to"
            }
          }
        }
      }
    },
    "GameCrowdBehaviorPoint": {
      "properties": {
        "DurationOfBehaviorEvent": {
          "comment": "Duration of how long this event will last"
        },
        "RadiusOfBehaviorEvent": {
          "comment": "Raius of this event"
        },
        "EventType": {
          "comment": "Event type to pass to crowd within radius"
        }
      }
    },
    "GameCrowdBehavior_PlayAnimation": {
      "properties": {
        "AnimationIndex": {
          "comment": "Index into animationlist of current animation action"
        },
        "AnimSequence": {
          "comment": "Kismet AnimSequence that spawned this behavior (optional)"
        },
        "CustomActionTarget": {
          "comment": "Used by kismet PlayAgentAnimation"
        },
        "AnimationList": {
          "comment": "List of animations to play"
        },
        "bBlendBetweenAnims": {
          "comment": "Whether should blend between animations in the list. Set True if they don't match at start/end"
        },
        "BlendInTime": {
          "comment": "Time to blend into next animation."
        },
        "BlendOutTime": {
          "comment": "Time to blend out of animation."
        },
        "bLookAtPlayer": {
          "comment": "If true, face player before starting animation."
        },
        "bLooping": {
          "comment": "If true, loop the animation in the list specified by LoopIndex."
        },
        "bUseRootMotion": {
          "comment": "Whether to use root motion."
        },
        "LoopIndex": {
          "comment": "Which animation to loop in AnimationList if bLooping == TRUE"
        },
        "LoopTime": {
          "comment": "How long to loop the animation if bLooping == TRUE, -1.f == infinite"
        }
      },
      "functions": {
        "FinishedTargetRotation": {
          "comment": "Facing target, so play animation"
        },
        "GetBehaviorString": {
          "comment": "Get debug string about agent behavior"
        },
        "OnAnimEnd": {
          "comment": "When an animation ends, play the next animation in the list. \n If done with list, if associated with a sequence, trigger its output."
        },
        "PlayAgentAnimationNow": {
          "comment": "Play the requested animation"
        },
        "SetSequenceOutput": {
          "comment": "Set the \"Out Agent\" output of the current sequence to be MyAgent."
        }
      }
    },
    "GameCrowdBehavior_RunFromPanic": {
      "properties": {
        "PanicFocus": {
          "comment": "Actor who caused panic - if set, flee this actor"
        }
      },
      "functions": {
        "AllowBehaviorAt": {
          "comment": "return true if get kismet or new behavior from this destination"
        },
        "AllowThisDestination": {
          "comment": "Return true if agent is allowed to go to destination while panicked"
        }
      }
    },
    "GameCrowdBehavior_WaitForGroup": {
      "functions": {
        "GetBehaviorString": {
          "comment": "Get debug string about agent behavior"
        },
        "ShouldEndIdle": {
          "comment": "Called every tick when agent is currently idle (because bIdleBehavior is true)\n @RETURN true if should end idle (bIdleBehavior should also become false)"
        }
      }
    },
    "GameCrowdBehavior_WaitInQueue": {
      "properties": {
        "bStoppingBehavior": {
          "comment": "Keep from re-entering StopBehavior during queue clean up"
        },
        "QueuePosition": {
          "comment": "Current Queue position (associated with CurrentDestination"
        }
      },
      "functions": {
        "ChangingDestination": {
          "comment": "Notification that MyAgent is changing destinations"
        },
        "HandleMovement": {
          "comment": "Handles movement destination updating for agent.\n @RETURNS true if destination updating was handled"
        }
      }
    },
    "GameCrowdDestination": {
      "comment": "Where crowd agent is going. Destinations can kill agents that reach them or route them to another destination",
      "properties": {
        "AgentEnRoute": {
          "comment": "Agent currently coming to this destination. Not guaranteed to be correct/exhaustive. Used to allow agents to trade places with nearer agent for destinations with queueing"
        },
        "bAdjacentToVisibleNode": {
          "comment": "Cache that node is currently adjacent to a visible node"
        },
        "bCanSpawnHereNow": {
          "comment": "This destination is currently available for spawning"
        },
        "bHasNavigationMesh": {
          "comment": "Whether there is a valid NavigationMesh around this destination"
        },
        "bHasRestrictions": {
          "comment": "True if has supported class/archetype restrictions"
        },
        "bIsBeyondSpawnDistance": {
          "comment": "This destination is beyond the maximum spawn distance"
        },
        "bIsVisible": {
          "comment": "True if currently in line of sight of a player (may not be within view frustrum)"
        },
        "bWillBeVisible": {
          "comment": "True if will become visible shortly based on player's current velocity"
        },
        "CustomerCount": {
          "comment": "Current number of agents using this destination"
        },
        "LastSpawnTime": {
          "comment": "Most recent time at which agent was spawned at this destination"
        },
        "MyPopMgr": {
          "comment": "Population manager with which this destination is associated"
        },
        "Priority": {
          "comment": "Priority for spawning agents at this destination"
        },
        "bAvoidWhenPanicked": {
          "comment": "Don't go to this destination if panicked"
        },
        "bFleeDestination": {
          "comment": "Always run toward this destination"
        },
        "bKillWhenReached": {
          "comment": "If TRUE, kill crowd members when they reach this destination."
        },
        "bMustReachExactly": {
          "comment": "Must reach this destination exactly - will force movement when close"
        },
        "bSkipBehaviorIfPanicked": {
          "comment": "Don't perform kismet or custom behavior at this destination if panicked"
        },
        "bSoftPerimeter": {
          "comment": "Whether agent should stop on reach edge of destination radius (if not reach exactly), or have a \"soft\" perimeter"
        },
        "Capacity": {
          "comment": "How many agents can simultaneously have this as a destination"
        },
        "Frequency": {
          "comment": "Adjusts the likelihood of agents to select this destination from list at previous destination"
        },
        "InteractionDelay": {
          "comment": "Time before an agent is allowed to attempt this sort of interaction again"
        },
        "InteractionTag": {
          "comment": "Type of interaction"
        },
        "QueueHead": {
          "comment": "queue point to use if this destination is at capacity"
        },
        "ReachedBehaviors": {
          "comment": "Agents reaching this destination will pick a behavior from this list"
        },
        "RestrictedAgentClasses": {
          "comment": "if set, agents of this class cannot use this destination"
        },
        "RestrictedArchetypes": {
          "comment": "if set, agents from this archetype cannot use this destination"
        },
        "SupportedAgentClasses": {
          "comment": "if set, only agents of this class can use this destination"
        },
        "SupportedArchetypes": {
          "comment": "if set, agents from this archetype can use this destination"
        },
        "bAllowsSpawning": {
          "comment": "True if spawning permitted at this node"
        },
        "bLineSpawner": {
          "comment": "Spawn in a line rather than in a circle."
        },
        "bSpawnAtEdge": {
          "comment": "Whether to spawn agents only at the edge of the circle, or at any point within the circle."
        }
      },
      "functions": {
        "AllowableDestinationFor": {
          "comment": "Returns true if this destination is valid for Agent"
        },
        "DecrementCustomerCount": {
          "comment": "Decrement customer count. Update Queue if have one\n Be sure to decrement customer count from old destination before setting a new one!\n FIXMESTEVE - should probably wrap decrement old customercount into GameCrowdAgent.SetDestination()"
        },
        "IncrementCustomerCount": {
          "comment": "Increment customer count, or add agent to queue if needed"
        },
        "PickNewDestinationFor": {
          "comment": "Pick a new destination from this one for agent."
        },
        "ReachedByAgent": {
          "comment": "@PARAM Agent is the agent being checked\n@PARAM Testposition is the position to be tested\n@PARAM bTestExactly if true and GameCrowdDestination.bMustReachExactly is true means ReachedByAgent() only returns true if right on the destination\n @RETURNS TRUE if Agent has reached this destination"
        },
        "ReachedDestination": {
          "comment": "Called after Agent reaches this destination\n Will be called every tick as long as ReachedByAgent() is true and agent is not idle, so should change\n Agent to avoid this (change current destination, make agent idle, or kill agent) )\n \n @PARAM Agent is the crowd agent that just reached this destination\n @PARAM bIgnoreKismet skips generating Kismet event if true."
        }
      }
    },
    "GameCrowdDestinationQueuePoint": {
      "comment": "Where crowd agent is going. Destinations can kill agents that reach them or route them to another destination",
      "properties": {
        "bClearingQueue": {
          "comment": "Prevent ClearQueue() reentry"
        },
        "bPendingAdvance": {
          "comment": "True if queued agent is still at this position, but about to advance"
        },
        "PreviousQueuePosition": {
          "comment": "Position before this one in line"
        },
        "QueueBehaviorClass": {
          "comment": "Queue behavior used by this queue point"
        },
        "QueuedAgent": {
          "comment": "Agent currently occupying this queue position"
        },
        "QueueDestination": {
          "comment": "Which destination this queue is part of the line for. Used only for queue validation during error checking."
        },
        "AverageReactionTime": {
          "comment": "Average pause time before agent reacts to queue movement"
        },
        "NextQueuePosition": {
          "comment": "Position behind this one in line"
        }
      },
      "functions": {
        "ActuallyAdvance": {
          "comment": "Actually advance the customer now"
        },
        "AddCustomer": {
          "comment": "Add customer to queue"
        },
        "AdvanceCustomerTo": {
          "comment": "Advance customer to next position in line, with a reaction time delay"
        },
        "ClearQueue": {
          "comment": "Clear OldCustomer from this queue position\n Advance any customers in line"
        },
        "HasSpace": {
          "comment": "Returns true if this queue has space"
        },
        "QueueReachedBy": {
          "comment": "Returns true if agent at TestPosition is considered to have reached this queue point"
        },
        "ReachedDestination": {
          "comment": "Called after Agent reaches this queue position\n \n @PARAM Agent is the crowd agent that just reached this queue position"
        }
      }
    },
    "GameCrowdInfoVolume": {
      "properties": {
        "PotentialSpawnPoints": {
          "comment": "List of all GameCrowdDestinations that are PotentialSpawnPoints"
        }
      }
    },
    "GameCrowdInteractionDestination": {
      "comment": "Convenience subclass, with typical settings for interaction points"
    },
    "GameCrowdInteractionPoint": {
      "properties": {
        "bIsEnabled": {
          "comment": "If this interactionpoint is currently enabled"
        },
        "CylinderComponent": {
          "comment": "Cylinder component"
        }
      }
    },
    "GameCrowdPopulationManager": {
      "comment": "Manages adding appropriate crowd population around player\n Agents will be spawned/recycled at any available active GameCrowdDestination",
      "properties": {
        "HeadVisibilityOffset": {
          "comment": "Offset used to validate spawn by checking above spawn location to see if head/torso would be visible"
        },
        "NavigationHandleClass": {
          "comment": "Navigation Handle used by agents requesting pathing"
        },
        "PlayerPositionPredictionTime": {
          "comment": "How far ahead to compute predicted player position for spawn prioritization"
        },
        "QueryingAgent": {
          "comment": "Agent requesting navigation handle use"
        },
        "SplitScreenNumReduction": {
          "comment": "How much to reduce number by in splitscreen"
        }
      },
      "functions": {
        "AddPrioritizedSpawnPoint": {
          "comment": "Prioritize passed in GameCrowdDestination and insert it into ordered PrioritizedSpawnPoints list, offset from current starting point"
        },
        "CreateNewAgent": {
          "comment": "Create new GameCrowdAgent and initialize it"
        },
        "DisplayDebug": {
          "comment": "Use 'GameDebug' console command to show this debug info\n Useful to show general debug info not tied to a particular concrete actor."
        },
        "FlushAgents": {
          "comment": "Instantly destroy all active agents controlled by this manager. Useful for debugging."
        },
        "IsSpawningActive": {
          "comment": "returns whether we want spawning to currently be active"
        },
        "PickSpawnPoint": {
          "comment": "@RETURN best spawn point to spawn next crowd agent"
        },
        "PostBeginPlay": {
          "comment": "Interface_NavigationHandle implementation to grab search params"
        },
        "PrioritizeSpawnPoints": {
          "comment": "Prioritize GameCrowdDestinations as potential spawn points"
        },
        "SpawnAgentByIdx": {
          "comment": "Actually create a new CrowdAgent actor, and initialise it"
        },
        "Tick": {
          "comment": "FIXMESTEVE - Nativize?"
        },
        "ValidateSpawnAt": {
          "comment": "Determine whether candidate spawn point is currently valid"
        }
      }
    },
    "GameCrowdReplicationActor": {
      "properties": {
        "bSpawningActive": {
          "comment": "If crowd spawning is active."
        },
        "DestroyAllCount": {
          "comment": "Use to replicate when we want to destroy all crowd agents."
        },
        "Spawner": {
          "comment": "Pointer to crowd spawning action we are replicating."
        }
      }
    },
    "GameCrowdSpawnerInterface": {
      "comment": "Used by classes which spawn crowd agents and want to be notified when they are destroyed."
    },
    "GameCrowdSpawnInterface": {
      "comment": "Used by actor classes which want to customize chosing the spawn position of agents spawned at their location."
    },
    "GameCrowd_ListOfAgents": {
      "properties": {
        "ListOfAgents": {
          "comment": "List of archetypes of agents to spawn when a population manager or crowd spawner is using this list."
        }
      }
    },
    "GameExplosion": {
      "properties": {
        "ActorToIgnoreForDamage": {
          "comment": "Optional actor that does not receive any radial damage, to be specified at runtime"
        },
        "bFullDamageToAttachee": {
          "comment": "Unused? Option to force full damage to the attachee actor."
        },
        "bIgnoreInstigator": {
          "comment": "If set, ignore instigator when doing damage/effects. Can be set in addition to above"
        },
        "HitActor": {
          "comment": "Track if we've hit an actor, used to handle cases such as kidnapper protected from hostage damage"
        },
        "HitLocation": {
          "comment": "We need the hit location and hit normal so we can trace down to the actor to apply the decal (e.g. hitting wall or floor)"
        },
        "ActorClassToIgnoreForDamage": {
          "comment": "The actor class to ignore for damage from this explosion"
        },
        "ActorClassToIgnoreForKnockdownsAndCringes": {
          "comment": "The actor class to ignore for knockdowns and cringes from this explosion"
        },
        "bAllowPerMaterialFX": {
          "comment": "If true, attempt to get effect information from the physical material system. If false or a physicalmaterial is unavailable, just use the information above."
        },
        "bAllowTeammateCringes": {
          "comment": "True to allow teammates to cringe, regardless of friendly fire setting."
        },
        "bAttachExplosionEmitterToAttachee": {
          "comment": "Whether or not we should attach something to the attachee"
        },
        "bAutoControllerVibration": {
          "comment": "TRUE to attempt to automatically do force feedback to match the camera shake"
        },
        "bCausesFracture": {
          "comment": "Controls if this explosion will cause fracturing"
        },
        "bDirectionalExplosion": {
          "comment": "If TRUE, this will be a \"directional\" explosion, meaning that all radial effects will be applied only\n within DirectionalExplosionAngleDeg degrees of the blast's facing direction (which should be supplied via Explode())."
        },
        "bOrientCameraShakeTowardsEpicenter": {
          "comment": "TRUE to rotate CamShake to play radially relative to the explosion. Left/Right/Rear will be ignored."
        },
        "bParticleSystemIsBeingOverriddenDontUsePhysMatVersion": {
          "comment": "So for tagged grenades we need override the particle system but still want material based decals and such."
        },
        "bPerformRadialBlurRelevanceCheck": {
          "comment": "If true, will perform an EffectIsRelevant check before spawning the radial blur"
        },
        "bSkipDefaultPhysMatParticleSystem": {
          "comment": "If true, the PhysMat's default particle system will not override the one already set in the explosion"
        },
        "bUseMapSpecificValues": {
          "comment": "This tells the explosion to look in the Map's MapSpecific info"
        },
        "CameraLensEffect": {
          "comment": "Play this CameraLensEffect when ever damage of this type is given. This will primarily be used by explosions. But could be used for other impacts too!"
        },
        "CameraLensEffectRadius": {
          "comment": "This is the radius to play the camera effect on"
        },
        "CamShake": {
          "comment": "Shake to play when source is in front of the camera, or when directional variants are unspecified."
        },
        "CamShakeFalloff": {
          "comment": "Exponent for intensity falloff between inner and outer radii."
        },
        "CamShakeInnerRadius": {
          "comment": "Radius within which to play full-powered camera shake (will be scaled within radius)"
        },
        "CamShakeOuterRadius": {
          "comment": "Between inner and outer radii, scale shake from full to zero"
        },
        "CamShake_Left": {
          "comment": "Anim to play when the source event is to the left of the camera. If None, CamShake will be used instead."
        },
        "CamShake_Rear": {
          "comment": "Anim to play when the source event is behind of the camera. If None, CamShake will be used instead."
        },
        "CamShake_Right": {
          "comment": "Anim to play when the source event is to the right of the camera. If None, CamShake will be used instead."
        },
        "CringeDuration": {
          "comment": "duration of the cringe. X=duration at epicenter, Y=duration at CringeRadius. Values <0 mean use default cringe."
        },
        "CringeRadius": {
          "comment": "radius at which people will cringe from the explosion"
        },
        "Damage": {
          "comment": "Amount of damage done at the epicenter."
        },
        "DamageDelay": {
          "comment": "Delay before applying damage after spawning FX, 0.f == no delay"
        },
        "DamageFalloffExponent": {
          "comment": "Defines how damage falls off. High numbers cause faster falloff, lower (closer to zero) cause slower falloff. 1 is linear."
        },
        "DamageRadius": {
          "comment": "Damage range."
        },
        "DirectionalExplosionAngleDeg": {
          "comment": "Half-angle, in degrees, of the cone that defines the effective area of a directional explosion."
        },
        "ExploLight": {
          "comment": "Defines the dynamic light cast by the explosion"
        },
        "ExploLightFadeOutTime": {
          "comment": "Dynamic Light fade out time, in seconds"
        },
        "ExploRadialBlur": {
          "comment": "Defines the blurred region for the explosion"
        },
        "ExploRadialBlurFadeOutTime": {
          "comment": "Radial blur fade out time, in seconds"
        },
        "ExploRadialBlurMaxBlur": {
          "comment": "Radial blur max blur amount"
        },
        "ExplosionEmitterScale": {
          "comment": "Scalar for increasing/decreasing explosion effect size."
        },
        "ExplosionSound": {
          "comment": "Audio to play at explosion time."
        },
        "ExplosionSoundHurtSomeone": {
          "comment": "Audio to play at explosion time if at least one pawn got hurt. Does not work for delayed damage. As we typically don't want to delay the explosion sound."
        },
        "FractureMeshRadius": {
          "comment": "How far away from explosion we break bits off"
        },
        "FracturePartVel": {
          "comment": "How hard to throw broken off pieces"
        },
        "KnockDownRadius": {
          "comment": "radius at which people will be knocked down/ragdolled by the projectile's explosion"
        },
        "KnockDownStrength": {
          "comment": "@fixme, base this on MomentumTransferScale?"
        },
        "MomentumTransferScale": {
          "comment": "Percentage of damagetype's momentum to apply."
        },
        "MyDamageType<AllowAbstract>": {
          "comment": "What damagetype to use"
        },
        "ParticleEmitterTemplate": {
          "comment": "Which particle effect to play."
        }
      }
    },
    "GameExplosionActor": {
      "properties": {
        "Attachee": {
          "comment": "Are we attached to something? Used to attach FX for stuff like the smoke grenade."
        },
        "bDrawDebug": {
          "comment": "Toggles debug explosion rendering."
        },
        "bHasExploded": {
          "comment": "True if explosion has occurred."
        },
        "bTrackExplosionParticleSystemLifespan": {
          "comment": "If TRUE, take the Explosion ParticleSystem lifespan into account when determining\n the lifespan of the GameExplosionActor. This is useful in cases where the GEA\n needs to do further processing while the particle system is active.\n For example, in the case of a smoke grenade, you would want to ensure that the\n explosion actor stayed around long enough to properly trigger coughing, etc. when\n a pawn enters/exits the smoke area."
        },
        "DirectionalExplosionMinDot": {
          "comment": "Minimum dot product for explosion to be able to affect a point. Used as an optimization for directional explosions."
        },
        "ExplosionDirection": {
          "comment": "Forward dir for directional explosions."
        },
        "ExplosionLight": {
          "comment": "The actual light used for the explosion."
        },
        "ExplosionRadialBlur": {
          "comment": "Temp data for radial blur fading."
        },
        "ExplosionTemplate": {
          "comment": "Temp reference to the explosion template, used for delayed damage"
        },
        "HitActorFromPhysMaterialTrace": {
          "comment": "This the saved off hit actor and location from the GetPhysicalMaterial trace so we can see if it is a FluidSurfaceActor and then apply some forces to it"
        },
        "InstigatorController": {
          "comment": "player responsible for damage"
        },
        "LightFadeTime": {
          "comment": "Temp data for light fading."
        },
        "RadialImpulseComponent": {
          "comment": "Used to push physics when explosion goes off."
        },
        "bExplodeMoreThanOnce": {
          "comment": "True if this actor can explode more than once and doesn't die after an explosion.\n Used by placable actors whose explosions are triggered via matinee"
        }
      },
      "functions": {
        "BoxDistanceToPoint": {
          "comment": "Returns distance from bounding box to point"
        },
        "ChooseCameraShake": {
          "comment": "Internal. When using directional camera shakes, used to determine which anim to use.\n @todo: nativise for speed?"
        },
        "DoExplosionDamage": {
          "comment": "Does damage modeling and application for explosions\n @PARAM bCauseDamage if true cause damage to actors within damage radius\n @PARAM bCauseEffects if true apply other affects to actors within appropriate radii\n @RETURN TRUE if at least one Pawn victim got hurt. (This is only valid if bCauseDamage == TRUE)"
        },
        "Explode": {
          "comment": "@todo break this up into the same methods that NanoWeapon uses (SpawnImpactEffects, SpawnImpactSounds, SpawnImpactDecal) as they are all\n orthogonal and so indiv subclasses can choose to have base functionality or override",
          "params": {
            "Direction": "For bDirectionalExplosion=true explosions, this is the forward direction of the blast."
          }
        },
        "GetEffectCheckRadius": {
          "comment": "Return the desired radius to check for actors which get effects from explosion"
        },
        "GetPhysicalMaterial": {
          "comment": "Internal. Tries to find a physical material for the surface the explosion occurred upon.\n @note: It sucks doing an extra trace here. We could conceivably pass the physical material info around\n by changing the lower level physics code (e.g. processHitWall), but that's a big engine-level change."
        },
        "SpawnCameraLensEffects": {
          "comment": "Spawns the camera lens effect(s) if needed by this explosion"
        },
        "SpecialCringeEffectsFor": {
          "comment": "Handle applying cringe to non-pawn actors",
          "params": {
            "Victim": "the actor hit",
            "VictimDist": "the distance the victim was from the blast"
          }
        },
        "SpecialPawnEffectsFor": {
          "comment": "Handle making pawns cringe or fall down from nearby explosions. Server only."
        },
        "UpdateExplosionTemplateWithPerMaterialFX": {
          "comment": "Internal. Extract what data we can from the physical material-based effects system\n and stuff it into the ExplosionTemplate.\n Data in the physical material will take precedence.\n We are also going to be checking for relevance here as when any of these params are \"none\" / invalid we do not\n play those effects in Explode(). So this way we avoid any work on looking things up in the physmaterial"
        }
      }
    },
    "GameExplosionContent": {
      "comment": "This is a content only archetype object to allow artists to update explosion\n content without programmer intervention",
      "properties": {
        "ExplosionSound": {
          "comment": "Audio to play at explosion time."
        },
        "ExploRadialBlur": {
          "comment": "Defines the blurred region for the explosion"
        },
        "ExploRadialBlurFadeOutTime": {
          "comment": "Radial blur fade out time, in seconds"
        },
        "ExploRadialBlurMaxBlur": {
          "comment": "Radial blur max blur amount"
        },
        "bOrientCameraShakeTowardsEpicenter": {
          "comment": "TRUE to rotate CamShake to play radially relative to the explosion. Left/Right/Rear will be ignored."
        },
        "CameraLensEffect": {
          "comment": "Play this CameraLensEffect when ever damage of this type is given. This will primarily be used by explosions. But could be used for other impacts too!"
        },
        "CameraLensEffectRadius": {
          "comment": "This is the radius to play the camera effect on"
        },
        "CamShake": {
          "comment": "Shake to play when source is in front of the camera, or when directional variants are unspecified."
        },
        "CamShakeFalloff": {
          "comment": "Exponent for intensity falloff between inner and outer radii."
        },
        "CamShakeInnerRadius": {
          "comment": "Radius within which to play full-powered camera shake (will be scaled within radius) const"
        },
        "CamShakeOuterRadius": {
          "comment": "Between inner and outer radii, scale shake from full to zero"
        },
        "CamShake_Left": {
          "comment": "Anim to play when the source event is to the left of the camera. If None, CamShake will be used instead."
        },
        "CamShake_Rear": {
          "comment": "Anim to play when the source event is behind of the camera. If None, CamShake will be used instead."
        },
        "CamShake_Right": {
          "comment": "Anim to play when the source event is to the right of the camera. If None, CamShake will be used instead."
        },
        "FogVolumeArchetype": {
          "comment": "The archetype that the artists set up that will be spawned with this explosion"
        },
        "bAutoControllerVibration": {
          "comment": "TRUE to attempt to automatically do force feedback to match the camera shake"
        },
        "ExploLight": {
          "comment": "Defines the dynamic light cast by the explosion"
        },
        "ExploLightFadeOutTime": {
          "comment": "Dynamic Light fade out time, in seconds"
        },
        "ParticleEmitterTemplate": {
          "comment": "Which particle effect to play."
        }
      }
    },
    "GameFixedCamera": {
      "properties": {
        "DefaultFOV": {
          "comment": "FOV to fall back to if we can't get one from somewhere else."
        }
      },
      "functions": {
        "OnBecomeActive": {
          "comment": "Called when Camera mode becomes active"
        }
      }
    },
    "GamePawn": {
      "properties": {
        "bLastHitWasHeadShot": {
          "comment": "Was the last hit considered a head shot? Used to see if we need to pop off helmet/head"
        },
        "bRespondToExplosions": {
          "comment": "Whether pawn responds to explosions or not (ie knocked down from explosions)"
        }
      },
      "functions": {
        "ReattachMesh": {
          "comment": "reattaches the mesh component"
        },
        "ReattachMeshWithoutBeingSeen": {
          "comment": "reattaches the mesh component without being seen"
        },
        "UpdateShadowSettings": {
          "comment": "This will update the shadow settings for this pawn's mesh"
        }
      }
    },
    "GamePlayerCamera": {
      "properties": {
        "bResetInterp": {
          "comment": "Indicates if we should reset interpolation on whichever active camera processes next."
        },
        "bUseForcedCamFOV": {
          "comment": "Should the FOV be overridden?"
        },
        "ForcedCamFOV": {
          "comment": "If bUseForcedCamFOV is true, use this angle"
        },
        "CurrentCamera": {
          "comment": "Which camera is currently active."
        },
        "FixedCam": {
          "comment": "Implements fixed camera, used for viewing through pre-placed camera actors."
        },
        "FixedCameraClass": {
          "comment": "Class to use for third person camera."
        },
        "ThirdPersonCam": {
          "comment": "Implements typical third person camera."
        },
        "ThirdPersonCameraClass": {
          "comment": "Class to use for third person camera."
        },
        "SplitScreenShakeScale": {
          "comment": "Scalar applied to all screen shakes in splitscreen. Normally used to dampen, since shakes feel more intense in a smaller viewport."
        }
      },
      "functions": {
        "AdjustFOVForViewport": {
          "comment": "Given a horizontal FOV that assumes a 16:9 viewport, return an appropriately\n adjusted FOV for the viewport of the target pawn.\n Used to correct for splitscreen."
        },
        "CreateCamera": {
          "comment": "Internal. Creates and initializes a new camera of the specified class, returns the object ref."
        },
        "FindBestCameraType": {
          "comment": "Internal. Polls game state to determine best camera to use."
        },
        "ProcessViewRotation": {
          "comment": "Give cameras a chance to influence player view rotation."
        },
        "ResetInterpolation": {
          "comment": "Stop interpolation for this frame and just let everything go to where it's supposed to be."
        },
        "SetColorScale": {
          "comment": "Sets the new color scale"
        },
        "ShouldConstrainAspectRatio": {
          "comment": "Available for overriding."
        },
        "UpdateCameraLensEffects": {
          "comment": "Update any attached camera lens effects (e.g. blood)"
        },
        "UpdateViewTarget": {
          "comment": "Query ViewTarget and outputs Point Of View.",
          "params": {
            "OutVT": "ViewTarget to use.",
            "DeltaTime": "Delta Time since last camera update (in seconds)."
          }
        }
      }
    },
    "GamePlayerController": {
      "properties": {
        "AgentAwareRadius": {
          "comment": "Controls how far around a player to warn agents."
        },
        "bIsWarmupPaused": {
          "comment": "If true we are in 'warmup paused' state to allow textures to stream in, and should not allow unpausing."
        },
        "bWarnCrowdMembers": {
          "comment": "If true, warn GameCrowdAgents to avoid pawn controlled by this player. Used when player will move through crowds"
        },
        "CurrentSoundMode": {
          "comment": "Name of the current sound mode that is active for the audio system"
        },
        "bDebugCrowdAwareness": {
          "comment": "If TRUE, draw debug info for crowd awareness checks"
        }
      },
      "functions": {
        "CallMemLeakCheck": {
          "comment": "Worker function for DoMemLeakChecking"
        },
        "CanUnpauseWarmup": {
          "comment": "Delegate used to control whether we can unpause during warmup. We never allow this."
        },
        "ClientPlayMovie": {
          "comment": "starts playing the specified movie"
        },
        "ClientStopMovie": {
          "comment": "Stops the currently playing movie",
          "params": {
            "DelayInSeconds": "number of seconds to delay before stopping the movie.",
            "bAllowMovieToFinish": "indicates whether the movie should be stopped immediately or wait until it's finished.",
            "bForceStopNonSkippable": "indicates whether a movie marked as non-skippable should be stopped anyway; only relevant if the specified\n movie is marked non-skippable (like startup movies).",
            "bForceStopLoadingMovie": "If false then don't stop the movie if it's the loading movie."
          }
        },
        "DoForceFeedbackForScreenShake": {
          "comment": "Play forcefeedback to match the given screenshake."
        },
        "DoMemLeakChecking": {
          "comment": "This will set a timer to call \"MemLeakCheck\" every N seconds",
          "params": {
            "float": "InTimeBetweenMemLeakChecks Time between checks"
          }
        },
        "GetCurrentMovie": {
          "comment": "returns the name of the currently playing movie, or an empty string if no movie is currently playing\n @todo: add an out param for current time in playback for synchronizing clients that join in the middle"
        },
        "KeepPlayingLoadingMovie": {
          "comment": "Keep playing the loading movie if it's currently playing and abort any StopMovie calls that may be pending through the FDelayedUnpauser."
        },
        "NotifyCrowdAgentInRadius": {
          "comment": "Hook to let player know crowd member is in range"
        },
        "NotifyCrowdAgentRefresh": {
          "comment": "Hook to let player know a refresh of crowd agent info is coming"
        },
        "SetSoundMode": {
          "comment": "Set the sound mode of the audio system for special EQing"
        },
        "ShowLoadingMovie": {
          "comment": "Starts/stops the loading movie",
          "params": {
            "bShowMovie": "true to show the movie, false to stop it",
            "bPauseAfterHide": "(optional) If TRUE, this will pause the game/delay movie stop to let textures stream in",
            "PauseDuration": "(optional) allows overriding the default pause duration specified in .ini (only used if bPauseAfterHide is true)",
            "KeepPlayingDuration": "(optional) keeps playing the movie for a specified more seconds after it's supposed to stop",
            "bOverridePreviousDelays": "(optional) whether to cancel previous delayed StopMovie or not (defaults to FALSE)"
          }
        },
        "StopMemLeakChecking": {
          "comment": "This will stop the periodic MemLeakCheck that was started via DoMemLeakChecking"
        },
        "WarmupPause": {
          "comment": "Function used by loading code to pause and unpause the game during texture-streaming warm-up."
        }
      }
    },
    "GameSkelCtrl_Recoil": {
      "comment": "Weapon recoil bone controller.\n Add a small recoil to a bone (similar to camera shakes).",
      "properties": {
        "bApplyControl": {
          "comment": "Internal, evaluates recoil is doing an effect and needs to be applied"
        },
        "bBoneSpaceRecoil": {
          "comment": "If TRUE, Aim is ignored, and recoil is just applied in the local bone space."
        },
        "bPlayRecoil": {
          "comment": "variable to play recoil"
        },
        "Recoil": {
          "comment": "Recoil Information"
        }
      },
      "structs": {
        "RecoilDef": {
          "comment": "Recoil definition",
          "properties": {
            "LocAmplitude": {
              "comment": "Loc offset amplitude"
            },
            "LocFrequency": {
              "comment": "Loc offset frequency"
            },
            "LocOffset": {
              "comment": "Internal, Location offset for this frame."
            },
            "LocParams": {
              "comment": "Loc parameters"
            },
            "LocSinOffset": {
              "comment": "Loc offset Sine offset"
            },
            "RotAmplitude": {
              "comment": "Rotation amplitude"
            },
            "RotFrequency": {
              "comment": "Rotation frequency"
            },
            "RotOffset": {
              "comment": "Internal, Rotation offset for this frame."
            },
            "RotParams": {
              "comment": "Rotation parameters"
            },
            "RotSinOffset": {
              "comment": "Rotation Sine offset"
            },
            "TimeDuration": {
              "comment": "Duration in seconds of current recoil shake"
            },
            "TimeToGo": {
              "comment": "Time in seconds to go until current recoil finished"
            }
          }
        },
        "RecoilParams": {
          "comment": "Recoil params"
        }
      }
    },
    "GameSpecialMove": {
      "properties": {
        "bForcePrecisePosition": {
          "comment": "PrecisePosition will not be enforced on non-owning instance unless this flag is set"
        },
        "bLastCanDoSpecialMove": {
          "comment": "Can we do the current special move?"
        },
        "bReachedPreciseDestination": {
          "comment": "Flag set when Pawn reached precise location"
        },
        "bReachedPreciseRotation": {
          "comment": "Flag set when pawn reached precise rotation"
        },
        "bReachPreciseDestination": {
          "comment": "Flag used when moving Pawn to a precise location"
        },
        "bReachPreciseRotation": {
          "comment": "Flag used when rotating pawn to a precise rotation"
        },
        "Handle": {
          "comment": "Named handle of this special move"
        },
        "LastCanDoSpecialMoveTime": {
          "comment": "Last time CanDoSpecialMove was called."
        },
        "PawnOwner": {
          "comment": "Owner of this special move"
        },
        "PreciseDestination": {
          "comment": "World location to reach"
        },
        "PreciseRotation": {
          "comment": "World rotation to face"
        },
        "PreciseRotationInterpolationTime": {
          "comment": "Time to interpolate Pawn's rotation"
        }
      },
      "functions": {
        "CanChainMove": {
          "comment": "Can the special move be chained after the current one finishes?"
        },
        "CanDoSpecialMove": {
          "comment": "Public accessor to see if this special move can be done, handles caching the results for a single frame.",
          "params": {
            "bForceCheck": "Allows you to skip the single frame condition (which will be incorrect on clients since LastCanDoSpecialMoveTime isn't replicated)"
          }
        },
        "CanOverrideMoveWith": {
          "comment": "Can a new special move override this one before it is finished?\n This is only if CanDoSpecialMove() == TRUE && !bForce when starting it."
        },
        "CanOverrideSpecialMove": {
          "comment": "Can this special move override InMove if it is currently playing?"
        },
        "ExtractSpecialMoveFlags": {
          "comment": "Give special move a chance to pull info out of flags"
        },
        "ForcePawnRotation": {
          "comment": "Forces Pawn's rotation to a given Rotator"
        },
        "InitSpecialMoveFlags": {
          "comment": "Give special move a chance to set info flags"
        },
        "InternalCanDoSpecialMove": {
          "comment": "Checks to see if this Special Move can be done."
        },
        "MessageEvent": {
          "comment": "Generic function to send message events to SpecialMoves.\n Returns TRUE if message has been processed correctly."
        },
        "ReachedPrecisePosition": {
          "comment": "Event sent when Pawn has reached precise position.\n PreciseRotation or PreciseLocation, or Both.\n When both Rotation and Location are set, the event is fired just once,\n after the Pawn has reached both."
        },
        "ResetFacePreciseRotation": {
          "comment": "Reset FacePreciseRotation related vars\n Otherwise, these vars will be carried over to next action\n vars are const in script - so need native interface"
        },
        "SetFacePreciseRotation": {
          "comment": "Force Pawn to face a specific rotation.",
          "params": {
            "RotationToFace": "Rotation for Pawn to face.",
            "InterpolationTime": "Time it takes for Pawn to face given rotation."
          }
        },
        "SetReachPreciseDestination": {
          "comment": "Send Pawn to reach a precise destination.\n ReachedPrecisePosition() event will be called when Pawn reaches destination.\n This tries to get the Pawn as close as possible from DestinationToReach in 2D space (so Z is ignored).\n This doesn't use the path network, so PawnOwner should be already fairly close to destination.\n A TimeOut should be used to prevent the Pawn from being stuck.",
          "params": {
            "DestinationToReach": "point in world space to reach. (Z ignored).",
            "bCancel": "if TRUE, this will cancel any current PreciseDestination movement."
          }
        },
        "ShouldReplicate": {
          "comment": "Should this special move be replicated to non-owning clients?"
        },
        "SpecialMoveEnded": {
          "comment": "Event called when Special Move is finished."
        },
        "SpecialMoveFlagsUpdated": {
          "comment": "called when DoSpecialMove() is called again with this special move, but the special move flags have changed"
        },
        "SpecialMoveStarted": {
          "comment": "Event called when Special Move is started."
        },
        "Tick": {
          "comment": "Script Tick function."
        },
        "WorldToRelativeOffset": {
          "comment": "Turn a World Space location into an Actor Space relative location."
        }
      }
    },
    "GameStateObject": {
      "comment": "Keeps track of current state as a game stats stream is parsed",
      "properties": {
        "bIsMatchStarted": {
          "comment": "Has the stream passed a match started event"
        },
        "bIsRoundStarted": {
          "comment": "True if between round started and ended events"
        },
        "MaxRoundNumber": {
          "comment": "Maximum round number reported during the match"
        },
        "PlayerStates": {
          "comment": "All players present in the game over the course of the stream"
        },
        "RoundNumber": {
          "comment": "Current round number reported by the last round started event"
        },
        "SessionType": {
          "comment": "Type of game session we are parsing"
        },
        "TeamStates": {
          "comment": "All teams present in the game over the course of the stream"
        }
      },
      "functions": {
        "PreProcessStream": {
          "comment": "A chance to do something before the stream starts"
        },
        "Reset": {
          "comment": "Completely reset the game state object"
        }
      },
      "structs": {
        "PlayerState": {
          "comment": "Contains the notion of player state while parsing the stats stream",
          "properties": {
            "CurrentTeamIndex": {
              "comment": "Current team index (changes with TEAM_CHANGE event)"
            },
            "PlayerIndex": {
              "comment": "Player index related to player metadata array"
            },
            "TimeAliveSinceLastDeath": {
              "comment": "If non-zero represents the time between a spawn and death event"
            },
            "TimeSpawned": {
              "comment": "Last time player spawned"
            }
          }
        },
        "TeamState": {
          "comment": "State variables related to a game team",
          "properties": {
            "PlayerIndices": {
              "comment": "Array of player indices that were ever on a given team"
            },
            "TeamIndex": {
              "comment": "Team Index related to team metadata array"
            }
          }
        }
      }
    },
    "GameStatsAggregator": {
      "comment": "Aggregates data from a game session stored on disk",
      "properties": {
        "AggregateEvents": {
          "comment": "The set of aggregate events that the aggregation supports"
        },
        "AggregateEventsMapping": {
          "comment": "Mapping of event ID to its aggregate equivalents (created at runtime)"
        },
        "AggregatesList": {
          "comment": "Array of all aggregates that require mappings when making an aggregate run"
        },
        "AllDamageEvents": {
          "comment": "Aggregates of all recorded damage events"
        },
        "AllGameEvents": {
          "comment": "Aggregates of all recorded events"
        },
        "AllPawnEvents": {
          "comment": "Aggregates of all recorded pawn events"
        },
        "AllPlayerEvents": {
          "comment": "Aggregates of all recorded player events"
        },
        "AllProjectileEvents": {
          "comment": "Aggregates of all recorded projectile events"
        },
        "AllTeamEvents": {
          "comment": "Aggregates of all recorded team events"
        },
        "AllWeaponEvents": {
          "comment": "Aggregates of all recorded weapon events"
        },
        "GameState": {
          "comment": "Current game state as the game stream is parsed"
        }
      },
      "functions": {
        "PostProcessStream": {
          "comment": "A chance to do something after the stream ends"
        },
        "PreProcessStream": {
          "comment": "A chance to do something before the stream starts"
        },
        "Reset": {
          "comment": "Cleanup/reset all data related to this aggregation"
        }
      },
      "structs": {
        "AggregateEventMapping": {
          "comment": "Clear out the contents",
          "properties": {
            "AggregateID": {
              "comment": "Mapping to the main aggregate event"
            },
            "EventID": {
              "comment": "Recorded event ID"
            },
            "TargetAggregateID": {
              "comment": "Mapping to the aggregate event for the target if applicable"
            }
          }
        },
        "DamageEvents": {
          "comment": "Container for all damage events\n Stores totals across all damage plus individually by recorded damage class metadata"
        },
        "EventsBase": {
          "comment": "Base class for event storage"
        },
        "GameEvent": {
          "comment": "Base container for a single stat aggregated over multiple time periods"
        },
        "GameEvents": {
          "comment": "Container for game event stats stored by event ID"
        },
        "PawnEvents": {
          "comment": "Container for all pawn events\n Stores totals across all pawn plus individually by recorded pawn class metadata"
        },
        "PlayerEvents": {
          "comment": "Container for all player events\n Stores totals across a single player plus all sub container types"
        },
        "ProjectileEvents": {
          "comment": "Container for all projectile events\n Stores totals across all projectiles plus individually by recorded projectile class metadata"
        },
        "TeamEvents": {
          "comment": "Container for all team events\n Stores totals across a single team plus all sub container types"
        },
        "WeaponEvents": {
          "comment": "Container for all weapon events\n Stores totals across all weapons plus individually by recorded weapon class metadata"
        }
      }
    },
    "GameThirdPersonCamera": {
      "properties": {
        "bDoSeamlessPivotTransition": {
          "comment": "Set to TRUE when the Pivot makes a big jump if you want to keep the camera in place across that transition."
        },
        "bFocusPointSet": {
          "comment": "do we have a focus point set?"
        },
        "bFocusPointSuccessful": {
          "comment": "Internal. TRUE if the focus point was good and the camera looked at it, FALSE otherwise (e.g. failed the trace)."
        },
        "DirectLookYaw": {
          "comment": "direct look vars"
        },
        "LastActualCameraOrigin": {
          "comment": "Last actual camera origin position, for lazy cam interpolation. It's only applied to player's origin, not view offsets, for faster/smoother response"
        },
        "LastActualCameraOriginRot": {
          "comment": "Last actual camera origin rotation, for lazy cam interpolation. It's only applied to player's origin, not view offsets, for faster/smoother response"
        },
        "LastActualOriginOffset": {
          "comment": "Last pawn relative offset, for slow offsets interpolation.\n This is because this offset is relative to the Pawn's rotation, which can change abruptly (when snapping to cover).\n Used to adjust the camera origin (evade, lean, pop up, blind fire, reload..)"
        },
        "LastCamFOV": {
          "comment": "last CamFOV for war cam interpolation"
        },
        "LastFocusChangeTime": {
          "comment": "Last time focus point changed (location)"
        },
        "LastFocusPointLoc": {
          "comment": "Last focus point location"
        },
        "LastHeightAdjustment": {
          "comment": "last offset adjustment, for smooth blend out"
        },
        "LastIdealCameraOrigin": {
          "comment": "Cached ideal pivot loc"
        },
        "LastIdealCameraOriginRot": {
          "comment": "Cached ideal pivot rot"
        },
        "LastOffsetAdjustment": {
          "comment": "Offset adjustment from last tick, used for interpolation."
        },
        "LastPitchAdjustment": {
          "comment": "last adjusted pitch, for smooth blend out"
        },
        "LastPostCamTurnYaw": {
          "comment": "Saved data for camera turn \"align when finished\" functionality"
        },
        "LastPreModifierCameraLoc": {
          "comment": "Last location and rotation of the camera, cached before camera modifiers are applied."
        },
        "LastViewOffset": {
          "comment": "View relative offset. This offset is relative to Controller's rotation, mainly used for Pitch positioning."
        },
        "LastYawAdjustment": {
          "comment": "last adjusted Yaw, for smooth blend out"
        },
        "LeftoverPitchAdjustment": {
          "comment": "pitch adjustment when keeping target is done in 2 parts. this is the amount to pitch in part 2 (post view offset application)"
        },
        "PenetrationBlockedPct": {
          "comment": "Percentage of distance blocked by collision. From worst location, to desired location."
        },
        "TurnCurTime": {
          "comment": "Vars for code-driven camera turns"
        },
        "WorstLocBlockedPct": {
          "comment": "obstruction pct from origin to worstloc origin"
        },
        "bDebugChangedCameraMode": {
          "comment": "Change in camera mode happened this frame - reset on first call to PlayerUpdateCamera"
        },
        "FocusPoint": {
          "comment": "current focus point"
        },
        "Focus_BackOffStrength": {
          "comment": "move back pct based on move up"
        },
        "Focus_FastAdjustKickInTime": {
          "comment": "time it takes for fast interpolation speed to kick in"
        },
        "Focus_MaxTries": {
          "comment": "number of tries to have focus in view"
        },
        "Focus_StepHeightAdjustment": {
          "comment": "Z offset step for every try"
        },
        "bDrawDebug": {
          "comment": "toggles debug mode"
        },
        "CurrentCamMode": {
          "comment": "Current GearCam Mode"
        },
        "OriginOffsetInterpSpeed": {
          "comment": "origin offset interpolation speed"
        },
        "PenetrationBlendInTime": {
          "comment": "Time to transition from ideal location to blocked position, after camera collision with geometry. (used only by predictive feelers)"
        },
        "PenetrationBlendOutTime": {
          "comment": "Time to transition from blocked location to ideal position, after camera collision with geometry."
        },
        "PenetrationExtentScale": {
          "comment": "camera extent scale to use when calculating penetration for this segment"
        },
        "ThirdPersonCamDefault": {
          "comment": "Base camera position when walking"
        },
        "WorstLocPenetrationExtentScale": {
          "comment": "camera extent scale to use when calculating penetration for this segment"
        }
      },
      "functions": {
        "AdjustFocusPointInterpolation": {
          "comment": "Use this if you keep the same focus point, but move the camera basis around underneath it \n e.g. you want the camera to hold steady focus, but the camera target is rotating"
        },
        "AdjustTurn": {
          "comment": "Adjusts a camera rotation. Useful for situations where the basis of the rotation\n changes.",
          "params": {
            "AngleOffset": "Yaw adjustment to apply (in Rotator units)"
          }
        },
        "BeginTurn": {
          "comment": "Initiates a forced camera rotation.",
          "params": {
            "StartAngle": "Starting Yaw offset (in Rotator units)",
            "EndAngle": "Finishing Yaw offset (in Rotator units)",
            "TimeSec": "How long the rotation should take",
            "DelaySec": "How long to wait before starting the rotation"
          }
        },
        "ClearFocusPoint": {
          "comment": "Clear focus point"
        },
        "CreateCameraMode": {
          "comment": "Internal."
        },
        "EndTurn": {
          "comment": "Stops a camera rotation."
        },
        "FindBestCameraMode": {
          "comment": "Evaluates the game state and returns the proper camera mode."
        },
        "GetActualFocusLocation": {
          "comment": "Internal. Returns the world space position of the current focus point."
        },
        "GetDesiredFOV": {
          "comment": "returns camera mode desired FOV"
        },
        "GetFocusActor": {
          "comment": "Returns ref to the actor currently being used as a focus point, if any."
        },
        "OnBecomeActive": {
          "comment": "Called when Camera mode becomes active"
        },
        "PlayerUpdateCamera": {
          "comment": "Internal camera updating code"
        },
        "ProcessViewRotation": {
          "comment": "Gives cameras a chance to change player view rotation"
        },
        "SetFocusOnActor": {
          "comment": "Tells camera to focus on the given actor."
        },
        "SetFocusOnLoc": {
          "comment": "Tells camera to focus on the given world position."
        },
        "UpdateCamera": {
          "comment": "Player Update Camera code"
        },
        "UpdateCameraMode": {
          "comment": "Update current camera modes. Pick Best, handle transitions, etc."
        },
        "UpdateFocusPoint": {
          "comment": "Per-tick focus point processing, for polling gamestate and adjusting as desired.\n Override if you want other systems or criteria to set focus points."
        }
      },
      "structs": {
        "CamFocusPointParams": {
          "comment": "Camera focus point definition",
          "properties": {
            "bAdjustCamera": {
              "comment": "If TRUE, camera adjusts to keep player in view, if FALSE the camera remains fixed and just rotates in place"
            },
            "bAlwaysFocus": {
              "comment": "If FALSE, focus only if point roughly in view; if TRUE, focus no matter where player is looking"
            },
            "bIgnoreTrace": {
              "comment": "If TRUE, ignore world trace to find a good spot"
            },
            "CameraFOV": {
              "comment": "If >0, FOV to force upon camera while looking at this point (degrees)"
            },
            "FocusActor": {
              "comment": "Actor to focus on."
            },
            "FocusBoneName": {
              "comment": "Bone name to focus on. Ignored if FocusActor is None or has no SkeletalMeshComponent"
            },
            "FocusPitchOffsetDeg": {
              "comment": "Offsets the pitch. e.g. 20 will look 20 degrees above the target"
            },
            "FocusWorldLoc": {
              "comment": "Focus point location in world space. Ignored if FocusActor is not None."
            },
            "InFocusFOV": {
              "comment": "FOV where target is considered in focus, no correction is made. X is yaw tolerance, Y is pitch tolerance."
            },
            "InterpSpeedRange": {
              "comment": "Interpolation speed (X=slow/focus loc moving, Y=fast/focus loc steady/blending out)"
            }
          }
        },
        "PenetrationAvoidanceFeeler": {
          "comment": "Struct defining a feeler ray used for camera penetration avoidance.",
          "properties": {
            "AdjustmentRot": {
              "comment": "rotator describing deviance from main ray"
            },
            "Extent": {
              "comment": "extent to use for collision when firing this ray"
            },
            "FramesUntilNextTrace": {
              "comment": "number of frames since this feeler was used"
            },
            "PawnWeight": {
              "comment": "how much this feeler affects the final position if it hits a Pawn (setting to 0 will not attempt to collide with pawns at all)"
            },
            "TraceInterval": {
              "comment": "minimum frame interval between traces with this feeler if nothing was hit last frame"
            },
            "WorldWeight": {
              "comment": "how much this feeler affects the final position if it hits the world"
            }
          }
        }
      }
    },
    "GameThirdPersonCameraMode": {
      "properties": {
        "bNoFOVPostProcess": {
          "comment": "Whether camera anims and other post processing should change the FOV"
        },
        "CurrentViewportType": {
          "comment": "Keep track of the current viewport type as computed by GetViewOffset()"
        },
        "LastRunOffset": {
          "comment": "Run offset last tick, used for interpolation."
        },
        "LastStrafeOffset": {
          "comment": "Strafe offset last tick, used for interpolation."
        },
        "ThirdPersonCam": {
          "comment": "Ref to the camera object that owns this mode object."
        },
        "ViewOffsetInterp": {
          "comment": "Keep track of our ViewOffset Interpolation factor"
        },
        "bAdjustDOF": {
          "comment": "Optional parameters for DOF adjustments."
        },
        "DOF_RadiusFalloff": {
          "comment": "Maps out how the DOF inner radius changes over distance."
        },
        "bApplyDeltaViewOffset": {
          "comment": "whether delta or actual view offset should be applied to the camera location"
        },
        "bDirectLook": {
          "comment": "True if, while in this mode, looking around should be directly mapped to stick position\n as opposed to relative to previous camera positions."
        },
        "bDoPredictiveAvoidance": {
          "comment": "True to turn do predictive camera avoidance, false otherwise"
        },
        "bFollowTarget": {
          "comment": "True if, while in this mode, the camera should interpolate towards a following position\n in relation to the target and it's motion. Ignored if bLockedToViewTarget is set to true."
        },
        "bInterpLocation": {
          "comment": "True means camera will attempt to smoothly interpolate to its new position. False will snap it to it's new position."
        },
        "bInterpRotation": {
          "comment": "True means camera will attempt to smoothly interpolate to its new rotation. False will snap it to it's new rotation."
        },
        "bInterpViewOffsetOnlyForCamTransition": {
          "comment": "If TRUE ViewOffset will only be interpolated between camera mode transitions, and then be instantaneous"
        },
        "BlendTime": {
          "comment": "Blend Time to and from this view mode"
        },
        "bLockedToViewTarget": {
          "comment": "True if, while in this mode, the camera should be tied to the viewtarget rotation.\n This is typical for the normal walking-around camera, since the controls rotate the controller\n and the camera follows. This can be false if you want free control of the camera, independent\n of the viewtarget's orient -- we use this for vehicles. Note that if this is false,"
        },
        "bRotInterpSpeedConstant": {
          "comment": "Whether rotation interpolation happens at constant speed or not"
        },
        "bSkipCameraCollision": {
          "comment": "If TRUE, all camera collision is disabled"
        },
        "bSmoothViewOffsetPitchChanges": {
          "comment": "TRUE to smooth the interp between high/mid/low, false to blend linearly between high <-> mid <-> low"
        },
        "bUsePerAxisOriginLocInterp": {
          "comment": "This is a special case of origin location interpolation. If true, interpolaton will be done on each axis independently, with the specified speeds.\n Ignored if bInterpLocation is false."
        },
        "bValidateWorstLoc": {
          "comment": "TRUE to do a raytrace from camera base loc to worst loc, just to be sure it's cool. False to skip it"
        },
        "FollowingCameraVelThreshold": {
          "comment": "Actual following interp speed gets scaled from FollowingInterpSpeed to zero between velocities of this value and zero."
        },
        "FOVAngle": {
          "comment": "FOV for camera to use"
        },
        "OffsetAdjustmentInterpSpeed": {
          "comment": "We optionally interpolate the results of AdjustViewOffset() to prevent pops when a cameramode changes its adjustment suddenly."
        },
        "OriginLocInterpSpeed": {
          "comment": "Controls interpolation speed of location for camera origin. Ignored if bInterpLocation is false."
        },
        "OriginRotInterpSpeed": {
          "comment": "Controls interpolation speed of rotation for the camera origin. Ignored if bInterpRotation is false."
        },
        "RunBackAdjustment": {
          "comment": "Adjustment vector to apply to camera view offset when target is moving backward"
        },
        "RunFwdAdjustment": {
          "comment": "Adjustment vector to apply to camera view offset when target is moving forward"
        },
        "RunOffsetInterpSpeedIn": {
          "comment": "Interpolation speed for interpolating to a NONZERO offset. Higher is faster/tighter interpolation."
        },
        "RunOffsetInterpSpeedOut": {
          "comment": "Interpolation speed for interpolating to a ZERO offset. Higher is faster/tighter interpolation."
        },
        "RunOffsetScalingThreshold": {
          "comment": "Velocity at (and above) which the full adjustment should be applied."
        },
        "StrafeLeftAdjustment": {
          "comment": "Adjustment vector to apply to camera view offset when target is strafing to the left"
        },
        "StrafeOffsetInterpSpeedIn": {
          "comment": "Interpolation speed for interpolating to a NONZERO strafe offsets. Higher is faster/tighter interpolation."
        },
        "StrafeOffsetInterpSpeedOut": {
          "comment": "Interpolation speed for interpolating to a ZERO strafe offset. Higher is faster/tighter interpolation."
        },
        "StrafeOffsetScalingThreshold": {
          "comment": "Velocity at (and above) which the full adjustment should be applied."
        },
        "StrafeRightAdjustment": {
          "comment": "Adjustment vector to apply to camera view offset when target is strafing to the right"
        },
        "TargetRelativeCameraOriginOffset": {
          "comment": "Offset, in the camera target's local space, from the camera target to the camera's origin."
        },
        "ViewOffset": {
          "comment": "contains offsets from camera target to camera loc"
        },
        "ViewOffset_ViewportAdjustments[ECameraViewportTypes.EnumCount]": {
          "comment": "viewoffset adjustment vectors for each possible viewport type, so the game looks close to the same in each"
        },
        "WorstLocOffset": {
          "comment": "An offset from the location of the viewtarget, in the viewtarget's local space.\n Used to calculate the \"worst case\" camera location, which is where the camera should retreat to\n if tightly obstructed."
        }
      },
      "functions": {
        "AdjustViewOffset": {
          "comment": "Allows mode to make any final situational adjustments to the base view offset."
        },
        "DOFTrace": {
          "comment": "Modeled after CalcWeaponFire to avoid triggers. Consider moving to native code and using a single line check call?"
        },
        "GetCameraWorstCaseLoc": {
          "comment": "Returns the \"worst case\" camera location for this camera mode.\n This is the position that the camera penetration avoidance is based off of,\n so it should be a guaranteed safe place to put the camera.",
          "params": {
            "TargetPawn": "Pawn being viewed.",
            "CurrentViewTarget": "current desired camera POV. Minus penetration checks."
          }
        },
        "GetDesiredFOV": {
          "comment": "Returns FOV that this camera mode desires."
        },
        "Init": {
          "comment": "Called when this mode is initially created/new'd"
        },
        "OnBecomeActive": {
          "comment": "Called when Camera mode becomes active"
        },
        "OnBecomeInActive": {
          "comment": "Called when camera mode becomes inactive"
        },
        "SetFocusPoint": {
          "comment": "Camera mode has a chance to set a focus point, if it so chooses.\n Return true if setting one, false if not."
        },
        "UpdatePostProcess": {
          "comment": "Gives mode a chance to adjust/override postprocess as desired."
        }
      },
      "structs": {
        "ViewOffsetData": {
          "properties": {
            "OffsetHigh": {
              "comment": "View point offset for high player view pitch"
            },
            "OffsetLow": {
              "comment": "View point offset for low player view pitch"
            },
            "OffsetMid": {
              "comment": "View point offset for medium (horizon) player view pitch"
            }
          }
        }
      }
    },
    "GameThirdPersonCameraMode_Default": {
      "properties": {
        "WorstLocAimingZOffset": {
          "comment": "Z adjustment to camera worst location if target pawn is in aiming stance"
        }
      }
    },
    "GameTypes": {
      "structs": {
        "AgentArchetypeInfo": {
          "properties": {
            "FrequencyModifier": {
              "comment": "added to selection rate."
            },
            "GroupMembers": {
              "comment": "additional agents to spawn with this one as part of group"
            },
            "MaxAllowed": {
              "comment": "No matter the frequency, we want to limit the number of this type of crowd agent. Another knob to easily set. \n Basically, we often want to adjust the number of crowds members / density but don't want a certain Archetype to also grow/shrink\n Due to native struct properties not being properly updated in already existing instanced objects we say MaxAllowed of 0 means infi guys"
            }
          }
        },
        "CrowdSpawnInfoItem": {
          "properties": {
            "ActiveAgents": {
              "comment": "List of currently active agents"
            },
            "AgentArchetypes": {
              "comment": "Archetypes of agents spawned by this crowd spawner"
            },
            "AgentFrequencySum": {
              "comment": "Sum of agent types + frequency modifiers"
            },
            "AgentLightingChannel": {
              "comment": "Lighting channels to put the agents in."
            },
            "AgentWarmupTime": {
              "comment": "Average time to \"warm up\" spawned agents before letting them sleep if not rendered"
            },
            "bCastShadows": {
              "comment": "Whether agents from this spawner should cast shadows"
            },
            "bEnableCrowdLightEnvironment": {
              "comment": "Whether to enable the light environment on crowd members."
            },
            "bForceNavMeshPathing": {
              "comment": "If true, force nav mesh navigation for all agents from this spawner"
            },
            "bForceObstacleChecking": {
              "comment": "If true, force obstacle checking for all agents from this spawner"
            },
            "bSpawningActive": {
              "comment": "Controls whether we are actively spawning agents."
            },
            "MaxSpawnDist": {
              "comment": "Max distance allowed for spawns"
            },
            "MinBehindSpawnDist": {
              "comment": "Square of min distance allowed for in line of sight but out of view frustrum agent spawns"
            },
            "PlayerPositionPredictionTime": {
              "comment": "How far ahead to compute predicted player position for spawn prioritization"
            },
            "PotentialSpawnPoints": {
              "comment": "List of all GameCrowdDestinations that are PotentialSpawnPoints"
            },
            "PrioritizationIndex": {
              "comment": "Index into prioritization array for picking spawn points, incremented as agents are spawned at each point"
            },
            "PrioritizationUpdateIndex": {
              "comment": "Index into prioritization array for updating prioritization"
            },
            "PrioritizedSpawnPoints": {
              "comment": "Ordered array of prioritized spawn GameCrowdDestinations"
            },
            "Remainder": {
              "comment": "Used by spawning code to accumulate partial spawning"
            },
            "SpawnNum": {
              "comment": "The maximum number of agents alive at one time. If agents are destroyed, more will spawn to meet this number."
            },
            "SpawnPrioritizationInterval": {
              "comment": "How frequently to reprioritize GameCrowdDestinations as potential spawn points"
            },
            "SpawnRate": {
              "comment": "How many agents per second will be spawned at the target actor(s)."
            }
          }
        },
        "GameSpecialMoveInfo": {
          "comment": "Struct to map specialmove label/class and allow overrides via the same label key",
          "properties": {
            "SpecialMoveInstance": {
              "comment": "Instance of the special move class"
            }
          }
        },
        "ScreenShakeAnimStruct": {
          "comment": "DEPRECATED. Defines a camera-animation-driven screenshake.",
          "properties": {
            "bRandomSegment": {
              "comment": "If TRUE, play a random snippet of the animation of length RandomSegmentDuration. Implies bLoop and bRandomStartTime = TRUE.\n If FALSE, play the full anim once, non-looped."
            },
            "bSingleInstance": {
              "comment": "TRUE to only allow a single instance of the specified anim to play at any given time."
            },
            "bUseDirectionalAnimVariants": {
              "comment": "If TRUE, code will choose which anim to play based on relative location to the player. Anim is treated as \"front\" in this case."
            }
          }
        },
        "ScreenShakeStruct": {
          "comment": "DEPRECATED. Defines a code-driven (sinusoidal) screenshake",
          "properties": {
            "bOverrideTargetingDampening": {
              "comment": "True to use TargetingDampening multiplier while player is targeted, False to use global defaults (see TargetingAlpha)."
            },
            "FOVAmplitude": {
              "comment": "FOV amplitude"
            },
            "FOVFrequency": {
              "comment": "FOV frequency"
            },
            "FOVParam": {
              "comment": "FOV parameters"
            },
            "FOVSinOffset": {
              "comment": "FOV Sine offset"
            },
            "LocAmplitude": {
              "comment": "view offset amplitude"
            },
            "LocFrequency": {
              "comment": "view offset frequency"
            },
            "LocParam": {
              "comment": "location parameters"
            },
            "LocSinOffset": {
              "comment": "view offset Sine offset"
            },
            "RotAmplitude": {
              "comment": "view rotation amplitude"
            },
            "RotFrequency": {
              "comment": "view rotation frequency"
            },
            "RotParam": {
              "comment": "rotation parameters"
            },
            "RotSinOffset": {
              "comment": "view rotation Sine offset"
            },
            "ShakeName": {
              "comment": "Unique name for this shake. Only 1 instance of a shake with a particular\n name can be playing at once. Subsequent calls to add the shake will simply\n restart the existing shake with new parameters. This is useful for animating\n shake parameters."
            },
            "TargetingDampening": {
              "comment": "Amplitude multiplier to apply while player is targeting. Ignored if bOverrideTargetingDampening == FALSE"
            },
            "TimeDuration": {
              "comment": "Duration in seconds of current screen shake"
            },
            "TimeToGo": {
              "comment": "Time in seconds to go until current screen shake is finished"
            }
          }
        },
        "ShakeParams": {
          "comment": "DEPRECATED. Shake vector params"
        },
        "SpecialMoveStruct": {
          "comment": "Container for all special move properties",
          "properties": {
            "Flags": {
              "comment": "Additional Replicated Flags"
            },
            "InteractionActor": {
              "comment": "Optional Interaction Actor"
            },
            "InteractionPawn": {
              "comment": "Interaction Pawn"
            },
            "SpecialMoveName": {
              "comment": "Special Move being performed."
            }
          }
        },
        "TakeHitInfo": {
          "comment": "replicated information on a hit we've taken",
          "properties": {
            "Damage": {
              "comment": "how much damage was delivered"
            },
            "DamageType": {
              "comment": "the damage type we were hit with"
            },
            "HitBoneIndex": {
              "comment": "the bone that was hit on our Mesh (if any)"
            },
            "HitLocation": {
              "comment": "the location of the hit"
            },
            "InstigatedBy": {
              "comment": "the weapon that shot us"
            },
            "Momentum": {
              "comment": "how much momentum was imparted"
            },
            "PhysicalMaterial": {
              "comment": "the physical material that was hit on our Mesh (if any)"
            },
            "RadialDamageOrigin": {
              "comment": "For radial damage, this is the point of origin. If damage was not radial, will be the same as HitLocation."
            }
          }
        }
      }
    },
    "GameWaveForms": {
      "properties": {
        "CameraShakeBigLong": {
          "comment": "The forcefeedback waveform to play with a particular camera shakes"
        },
        "CameraShakeBigShort": {
          "comment": "The forcefeedback waveform to play with a particular camera shakes"
        },
        "CameraShakeMediumLong": {
          "comment": "The forcefeedback waveform to play with a particular camera shakes"
        },
        "CameraShakeMediumShort": {
          "comment": "The forcefeedback waveform to play with a particular camera shakes"
        }
      }
    },
    "MobileHUD": {
      "properties": {
        "bDebugTouches": {
          "comment": "If true, display debug information regarding the touches"
        },
        "bDebugZonePresses": {
          "comment": "If true, debug info about a mobile input zone will be displayed, but only on presses"
        },
        "bDebugZones": {
          "comment": "If true, debug info about the various mobile input zones will be displayed"
        },
        "bForceMobileHUD": {
          "comment": "Allow for enabling/disabling the Mobile HUD stuff on non-mobile platforms"
        },
        "bShowGameHud": {
          "comment": "If true, we want to display the normal hud. We need a third variable to support hiding the hud completly yet still supporting the ShowHud command"
        },
        "bShowMobileHud": {
          "comment": "If true, we want to display the mobile hud (ie: Input zones. etc)"
        },
        "bShowMobileTilt": {
          "comment": "If true, this hud will display the device tilt"
        },
        "bShowMotionDebug": {
          "comment": "If this is true, we will display debug information regarding motion data"
        },
        "JoystickBackground": {
          "comment": "Texture to fill the zones with"
        },
        "MobileTiltSize": {
          "comment": "Hold the position data for displaying the tilt"
        },
        "MobileTiltX": {
          "comment": "Hold the position data for displaying the tilt"
        },
        "MobileTiltY": {
          "comment": "Hold the position data for displaying the tilt"
        }
      },
      "functions": {
        "AddKismetRenderEvent": {
          "comment": "Adds a listen to the mobile handler list.",
          "params": {
            "Handler": "the MobileMotion sequence event to add to the handler list"
          }
        },
        "DrawInputZoneOverlays": {
          "comment": "Draws the input zones on top of everything else"
        },
        "PostBeginPlay": {
          "comment": "Create a list of actors needing post renders for. Also Create the Hud Scene"
        },
        "PostRender": {
          "comment": "The start of the rendering chain."
        },
        "RefreshKismetLinks": {
          "comment": "The SeqEvent's from the level's kismet will have their RegisterEvent function called before the inputzones are\n configured. So just this once, have all of them try again."
        },
        "RenderKismetHud": {
          "comment": "Give all Kismet Render events a chance to render to the hud"
        },
        "RenderMobileMenu": {
          "comment": "Draw the Mobile hud"
        }
      }
    },
    "MobileInputZone": {
      "properties": {
        "AnimatingFadeOpacity": {
          "comment": "Fade opacity, used for certain transient effects"
        },
        "bIsDoubleTapAndHold": {
          "comment": "This will be true if this tap was a double tap. It's required in order to make sure we release the DoubleTapInputKey if it was a tap and hold"
        },
        "CurrentCenter": {
          "comment": "For Joystick, this is the center of the analog zone to calculate the analog values from"
        },
        "CurrentLocation": {
          "comment": "For Joystick and Trackball, this is where in the zone the user is currently holding down"
        },
        "EscapeVelocity": {
          "comment": "For Trackball, how much escape velocity is left to apply"
        },
        "InitialCenter": {
          "comment": "For Joystick, the initial center position (used only when resetting the joystick back to it's center)"
        },
        "InitialLocation": {
          "comment": "Holds the Initialize location where the zone was touched"
        },
        "InputOwner": {
          "comment": "A Reference back to the Player Input that controls this array Input zone"
        },
        "LastAxisValues": {
          "comment": "Holds cached versions of the last axis values"
        },
        "LastTouchTime": {
          "comment": "Used to calculate a double tap on this zone"
        },
        "LastWentActiveTime": {
          "comment": "Holds the time this zone last went active"
        },
        "MobileSeqEventHandlers": {
          "comment": "holds an list of MobileZone Sequence events associated with this zone"
        },
        "OverrideTexture1Name": {
          "comment": "Ini-controlled string that will be looked up at runtime and hooked up to OverrideTexture1"
        },
        "OverrideTexture2Name": {
          "comment": "Ini-controlled string that will be looked up at runtime and hooked up to OverrideTexture2"
        },
        "PreviousLocationCount": {
          "comment": "For Joystick and Trackball, how many previous locations we're currently storing"
        },
        "PreviousLocations[6]": {
          "comment": "For Joystick and Trackball, array of previous locations so that we can smooth input over frames"
        },
        "PreviousMoveDeltaTimes[6]": {
          "comment": "For Joystick and Trackball, array of previous movement time deltas so that we can smooth input over frames"
        },
        "State": {
          "comment": "State of the zone"
        },
        "TimeSinceLastTapRepeat": {
          "comment": "How long since we last repeated a tap"
        },
        "TotalActiveTime": {
          "comment": "Used to track the amount of time a zone is active"
        },
        "TransitionTime": {
          "comment": "Holds the current transition time"
        },
        "bAllowFirstDeltaForTrackballZone": {
          "comment": "Unless enabled, the first movement delta for a trackball zone will be ignored. This is useful for devices with inconsistent 'dead zones' for initial touch deltas, however this will reduce responsiveness of trackball drags slightly."
        },
        "ActiveSizeX": {
          "comment": "Size of active Zone. Note if it's set to 0, then SizeX/SizeY will be copied here. \nThis setting is used when you have a zone that has bCenterOnEvent set and defines the size of"
        },
        "ActiveSizeY": {
          "comment": "Size of active Zone. Note if it's set to 0, then SizeX/SizeY will be copied here. \nThis setting is used when you have a zone that has bCenterOnEvent set and defines the size of"
        },
        "AuthoredGlobalScale": {
          "comment": "This is the scale factor you are authoring for. 2.0 is useful for Retina display resolution (960x640), 1.0 for iPads and older iPhones"
        },
        "bActiveSizeYFromX": {
          "comment": "If this is true, then ActiveSizeY is relative to ActiveSizeX"
        },
        "bCenterX": {
          "comment": "if true, then this zone will be centered around the original X value. NOTE: X will be updated to reflect it's actual position"
        },
        "bCenterY": {
          "comment": "if true, then this zone will be centered around the original Y value. NOTE: Y will be updated to reflect it's actual position"
        },
        "Border": {
          "comment": "Border is an invisible region around the zone. The border is included in hit determination."
        },
        "bRelativeX": {
          "comment": "If any of the bReleative vars are true, then the corresponding X/Y/SizeX/SizeY will be consider a percentage of the viewport"
        },
        "bSizeYFromSizeX": {
          "comment": "If this is true, then SizeX is relative to SizeY"
        },
        "SizeX": {
          "comment": "Size of the zone"
        },
        "SizeY": {
          "comment": "Size of the zone"
        },
        "X": {
          "comment": "Top left corner"
        },
        "Y": {
          "comment": "Top left corner"
        },
        "Acceleration": {
          "comment": "How much acceleration to apply to Trackball or Joystick movement (0.0 for none, no upper bounds)"
        },
        "bScalePawnMovement": {
          "comment": "If true, this control will use it's \"strength\" to scale the movement of the pawn"
        },
        "DoubleTapInputKey": {
          "comment": "Input to send from a double tap"
        },
        "EscapeVelocityStrength": {
          "comment": "How much escape velocity to use for Trackball movement (0.0 for none, 1.0 for max)"
        },
        "HorizMultiplier": {
          "comment": "Multiplier to scale the analog horizontal input by"
        },
        "HorizontalInputKey": {
          "comment": "Input to send for horizontal analog input (can be NAME_None)"
        },
        "InputKey": {
          "comment": "Input to send to input subsystem on event (vertical input for analog, can be NAME_None)"
        },
        "Smoothing": {
          "comment": "How much input smoothing to apply to Trackball or Joystick movement (0.0 for none, 1.0 for max)"
        },
        "TapInputKey": {
          "comment": "Input to send for tap input (e.g. for tap-to-fire)"
        },
        "VertMultiplier": {
          "comment": "Multiplier to scale the analog vertical input by"
        },
        "bCenterOnEvent": {
          "comment": "If true, this zone will have it's \"center\" set when you touch it, otherwise the center will be set to the center of the zone"
        },
        "bFloatingTiltZone": {
          "comment": "If true, the tilt zone will float within the SizeX/SizeY"
        },
        "bIsInvisible": {
          "comment": "Do we draw anything on screen for this zone?"
        },
        "bQuickDoubleTap": {
          "comment": "If true, then this double tap will be considered a quick press/release, other wise it's tap and hold"
        },
        "ResetCenterAfterInactivityTime": {
          "comment": "If bCenterOnEvent is enabled and this is non zero, the center position will be reset to it's initial center after this period of inactivity"
        },
        "SlideType": {
          "comment": "Determines what type of slide it is"
        },
        "bRenderGuides": {
          "comment": "If true, the zone will render little guide lines for debugging"
        },
        "CaptionXAdjustment": {
          "comment": "This is a fixed adjustment that will be added to the zone's caption's X. It's used to align fonts correctly"
        },
        "CaptionYAdjustment": {
          "comment": "This is a fixed adjustment that will be added to the zone's caption's Y. It's used to align fonts correctly"
        },
        "InactiveAlpha": {
          "comment": "Holds the alpha value to use if the zone is inactive"
        },
        "OverrideTexture1": {
          "comment": "Override texture (for buttons, this is the texture when not clicked; for joystick/trackball, it's the background; for sliders, it's the slider)"
        },
        "OverrideTexture2": {
          "comment": "Override texture (for buttons, this is the texture when clicked; for joystick/trackball, it's the 'hat'; for sliders, it's unused)"
        },
        "OverrideUVs1": {
          "comment": "UVs for override texture 1 (in texel units)"
        },
        "OverrideUVs2": {
          "comment": "UVs for override texture 2 (in texel units)"
        },
        "RenderColor": {
          "comment": "Holds the color to use when drawing images"
        },
        "ActivateTime": {
          "comment": "How fast should a zone for from active to inactive"
        },
        "bUseGentleTransitions": {
          "comment": "If true, the zone will gracefully transition from Inactive to Active and vice-versus. NOTE: transitions are strickly visual. A"
        },
        "DeactivateTime": {
          "comment": "How fast a zone should go from inactive to active"
        },
        "Caption": {
          "comment": "For button zones, the Caption property will be displayed in the center of the button"
        },
        "TouchpadIndex": {
          "comment": "Which touchpad this zone will respond to"
        },
        "Type": {
          "comment": "What type of zone is this."
        }
      },
      "functions": {
        "ActivateZone": {
          "comment": "Called to activate a zone."
        },
        "AddKismetEventHandler": {
          "comment": "Adds a new MobileInput Sequence Event to the handler list",
          "params": {
            "NewHandler": "The handler to add"
          }
        },
        "DeactivateZone": {
          "comment": "Called to deactivate a zone"
        }
      },
      "structs": {
        "TextureUVs": {
          "comment": "Structure to allow easy storage of UVs for a rendered image"
        }
      }
    },
    "MobileMenuButton": {
      "properties": {
        "Caption": {
          "comment": "Localizable caption for the button"
        },
        "CaptionColor": {
          "comment": "Holds the color for the caption"
        },
        "ImageColor": {
          "comment": "Holds the color override for the image"
        },
        "ImagesUVs[2]": {
          "comment": "The UV Coordinates for the images. [0] = the untouched, [1] = touched"
        },
        "Images[2]": {
          "comment": "The 2 images that make up the button. [0] = the untouched, [1] = touched"
        }
      },
      "functions": {
        "RenderCaption": {
          "comment": "Render the optional caption on top of the widget",
          "params": {
            "Canvas": "the canvas object for drawing"
          }
        },
        "RenderObject": {
          "comment": "Render the widget",
          "params": {
            "Canvas": "the canvas object for drawing"
          }
        }
      }
    },
    "MobileMenuGame": {
      "functions": {
        "PostLogin": {
          "comment": "We override PostLogin and display the scene directly after the login process is finished."
        },
        "RestartPlayer": {
          "comment": "Never restart a player in the menus"
        },
        "StartMatch": {
          "comment": "Never start a match in the menus"
        }
      }
    },
    "MobileMenuImage": {
      "properties": {
        "Image": {
          "comment": "Holds the texture to display"
        },
        "ImageColor": {
          "comment": "Holds the color override for the image"
        },
        "ImageUVs": {
          "comment": "Holds the texture UVs. Note, after InitMenuObject(), these will hold the values to use regardless of the bUseCustomUVs flag"
        }
      },
      "functions": {
        "RenderObject": {
          "comment": "Render the widget",
          "params": {
            "Canvas": "the canvas object for drawing"
          }
        }
      }
    },
    "MobileMenuLabel": {
      "properties": {
        "bAutoSize": {
          "comment": "If true, we will calculate the actual render bounds,etc upon draw"
        },
        "Caption": {
          "comment": "Holds the caption for this label"
        },
        "TextColor": {
          "comment": "Hold the color that the font will be displayed in"
        },
        "TextFont": {
          "comment": "Holds the font that will be used to draw the text"
        },
        "TextXScale": {
          "comment": "Holds the X scaling factor for the label"
        },
        "TextYScale": {
          "comment": "Holds the Y scaling factor for the label"
        },
        "TouchedColor": {
          "comment": "Holds the color of the font when pressed"
        }
      },
      "functions": {
        "RenderObject": {
          "comment": "Render the widget",
          "params": {
            "Canvas": "the canvas object for drawing"
          }
        }
      }
    },
    "MobileMenuObject": {
      "properties": {
        "bApplyGlobalScaleLeft": {
          "comment": "If any of these are set, then the Global scsale will be applied"
        },
        "bHasBeenInitialized": {
          "comment": "If true, the object has been initialized to the screen size (note, it will not work if the screen size changes)"
        },
        "bIsActive": {
          "comment": "If true, this control is considered to be active and accepts taps"
        },
        "bIsHidden": {
          "comment": "If true, this control is hidden and will not be rendered"
        },
        "bIsHighlighted": {
          "comment": "If true, this control is highlighted (like a radio button)"
        },
        "bIsTouched": {
          "comment": "If true, this control is being touched/pressed"
        },
        "bRelativeLeft": {
          "comment": "If any of the bRelativeXXXX vars are set, then the value will be considered a percentage of the viewport"
        },
        "bXOffsetIsActual": {
          "comment": "Unlike Left/Top/Width/Height the XOffset and YOffsets are assumed to be a percentage of the bounds. If you"
        },
        "Height": {
          "comment": "The height of the menu"
        },
        "InputOwner": {
          "comment": "A reference to the input owner"
        },
        "Left": {
          "comment": "The left position of the menu."
        },
        "Opacity": {
          "comment": "Holds the opacity of an object"
        },
        "OwnerScene": {
          "comment": "The scene this object is in"
        },
        "Tag": {
          "comment": "Holds the tag of this widget"
        },
        "Top": {
          "comment": "The top position of the menu."
        },
        "TopLeeway": {
          "comment": "The Leeway values all you to subtle adjust the hitbox for an object."
        },
        "Width": {
          "comment": "The width of the menu."
        },
        "XOffset": {
          "comment": "The XOffset and YOffset can be used to shift the position of the widget within it's bounds."
        },
        "AuthoredGlobalScale": {
          "comment": "This is the scale factor you are authoring for. 2.0 is useful for Retina display resolution (960x640), 1.0 for iPads and older iPhones"
        }
      },
      "functions": {
        "InitMenuObject": {
          "comment": "InitMenuObject - Perform any initialization here",
          "params": {
            "PlayerInput": "A pointer to the MobilePlayerInput object that owns the UI system",
            "Scene": "The scene this object is in",
            "ScreenWidth": "The Width of the Screen",
            "ScreenHeight": "The Height of the Screen"
          }
        },
        "RenderObject": {
          "comment": "Render the widget",
          "params": {
            "Canvas": "the canvas object for drawing"
          }
        }
      },
      "structs": {
        "UVCoords": {
          "properties": {
            "U": {
              "comment": "The UV coords."
            }
          }
        }
      }
    },
    "MobileMenuScene": {
      "properties": {
        "AuthoredGlobalScale": {
          "comment": "This is the scale factor you are authoring for. 2.0 is useful for Retina display resolution (960x640), 1.0 for iPads and older iPhones"
        },
        "Opacity": {
          "comment": "The general opacity of the scene"
        },
        "Left": {
          "comment": "Positions and sizing"
        },
        "UITouchSound": {
          "comment": "Holds a reference to the sound to play when a touch occurs in the mobile menu system"
        },
        "UIUnTouchSound": {
          "comment": "Holds a reference to the sound to play when a touch occurs in the mobile menu system"
        },
        "InputOwner": {
          "comment": "A reference to the input owner"
        },
        "SceneCaptionFont": {
          "comment": "Allows for a single font for all buttons in a scene"
        },
        "TouchpadIndex": {
          "comment": "Which touchpad this menu will respond to"
        }
      },
      "functions": {
        "Closed": {
          "comment": "Closed will be called when the closing process is done and the scene has been removed from the stack"
        },
        "Closing": {
          "comment": "Closing will be called before the closing process really begins. Return false if\n you wish to override the closing process."
        },
        "FindMenuObject": {
          "comment": "Search the menu stack for a object",
          "params": {
            "Tag": "The name of the object to find."
          }
        },
        "GetGlobalScaleX": {
          "comment": "Native functions to get the global scale to apply to UI elements that desire such"
        },
        "InitMenuScene": {
          "comment": "Script events that allows for menu setup. It's called at the beginning of the native InitMenuScene. Nothing is set at this point and\n allows the scene to override default settings",
          "params": {
            "PlayerInput": "A pointer to the MobilePlayerInput object that owns the UI scene",
            "ScreenWidth": "The Width of the Screen",
            "ScreenHeight": "The Height of the Screen"
          }
        },
        "MadeTopMenu": {
          "comment": "Called when this menu is the topmost menu (ie, when opened or when one of top was closed)"
        },
        "MobileMenuCommand": {
          "comment": "Allows menus to handle exec commands \n \n@Param Command - The command to handle"
        },
        "OnSceneTouch": {
          "comment": "Allows the scene to manage touches that aren't sent to any given control"
        },
        "OnTouch": {
          "comment": "This event is called when a \"touch is detected on an object.",
          "params": {
            "Sender": "The Object that swallowed the touch",
            "TouchX": "The X location of the touch event",
            "TouchY": "The Y location of the touch event",
            "bCancel-": "If TRUE, the touch was canceled"
          }
        },
        "Opened": {
          "comment": "Opened will be called after the scene is opened and initialized.",
          "params": {
            "Mode": "Optional string to pass to the scene for however it wants to use it"
          }
        },
        "RenderScene": {
          "comment": "Render the scene",
          "params": {
            "Canvas": "the canvas object for drawing"
          }
        }
      }
    },
    "MobilePlayerInput": {
      "properties": {
        "InteractiveObject": {
          "comment": "The object that the user is currently interacting with.\n e.g. When a user presses on the button, this button is the\n interactive object until the user raises her finger and causes\n an UnTouch event."
        },
        "MobileInputZoneClasses": {
          "comment": "Classes that inherit from MobileInputZone - filled in by NativeInitializeInputSystem()"
        },
        "MobileRawInputSeqEventHandlers": {
          "comment": "Holds a list of handlers looking to listen in on raw touch events"
        },
        "MobileSeqEventHandlers": {
          "comment": "Holds a list of handlers looking to listen in on Motion events"
        },
        "bFakeMobileTouches": {
          "comment": "This will be set in NativeInitializeInputZones if -SimMobile is on the command line."
        },
        "NativeDebugString": {
          "comment": "Used for debugging native code"
        },
        "bAllowTouchesInCinematic": {
          "comment": "If true, we want to allow input to occur during a cinematic"
        },
        "bDisableTouchInput": {
          "comment": "If set to true, then touches will be ignored"
        },
        "bSupportsAccelerometer": {
          "comment": "If True, this mobile input system support an accelerometer"
        },
        "CurrentMobileGroup": {
          "comment": "Holds the index of the current group"
        },
        "MobileDoubleTapTime": {
          "comment": "Used to determine if a touch is a double tap"
        },
        "MobileInputGroups": {
          "comment": "Holds a list of available groups"
        },
        "MobileInputZones": {
          "comment": "Holds a list of mobile input zones."
        },
        "MobileMinHoldForTap": {
          "comment": "You have to hold down a tap at least this long to register it as a tap"
        },
        "MobilePitch": {
          "comment": "Holds the current Tilt value for mobile devices"
        },
        "MobilePitchCenter": {
          "comment": "Holds the center value for the pitch."
        },
        "MobilePitchDeadzoneSize": {
          "comment": "How much of a dead zone should the pitch have"
        },
        "MobilePitchMultiplier": {
          "comment": "Pitch sensitivity"
        },
        "MobileTapRepeatTime": {
          "comment": "Used to determine how quickly to send repeat events for touch+held"
        },
        "MobileYaw": {
          "comment": "Holds the current Yaw value for mobile devices"
        },
        "MobileYawCenter": {
          "comment": "Holds the center value for the Yaw."
        },
        "MobileYawDeadzoneSize": {
          "comment": "How much of a dead zone should the yaw have"
        },
        "MobileYawMultiplier": {
          "comment": "Pitch sensitivity"
        },
        "ZoneTimeout": {
          "comment": "Holds the amount of time that a zone can go without input before being consider timed out"
        },
        "MobileMenuStack": {
          "comment": "This is the menu stack."
        },
        "bDeviceHasAccelerometer": {
          "comment": "This will be true if the underlying device has an accelerometer"
        },
        "bDeviceHasGyroscope": {
          "comment": "This will be true if the underlying device has a Gyroscope"
        },
        "DeviceAccelerometerRawData": {
          "comment": "this is only valid if bDeviceHasAccelerometer is true"
        },
        "DeviceGyroRawData": {
          "comment": "this is only valid if bDeviceHasGyroscope is true"
        },
        "DeviceMotionAttitude": {
          "comment": "Note: We use a vector to describe the attitude of the device. X = Roll, Y=Pitch, Z=Yaw"
        },
        "DeviceMotionRotationRate": {
          "comment": "Note: We use a vector to describe the rotation rate of the device. X = Roll, Y=Pitch, Z=Yaw"
        }
      },
      "functions": {
        "AddKismetEventHandler": {
          "comment": "Adds a listen to the mobile handler list.",
          "params": {
            "Handler": "the MobileMotion sequence event to add to the handler list"
          }
        },
        "AddKismetRawInputEventHandler": {
          "comment": "Adds a raw listen to the mobile handler list.",
          "params": {
            "Handler": "the MobileMotion sequence event to add to the handler list"
          }
        },
        "ClientInitInputSystem": {
          "comment": "When the client inits the input system, initialize it's touch system"
        },
        "CloseAllMenus": {
          "comment": "Call this function to close all menus, used to \"restart\" the stack"
        },
        "CloseMenuScene": {
          "comment": "Call this function to close a menu scene. Remove it from the stack and notify the scene/etc.",
          "params": {
            "SceneToClose": "The actual scene to close."
          }
        },
        "FindorAddZone": {
          "comment": "Searchings the zone array for a zone and returns it if found. Otherwise add it and return the new zone",
          "params": {
            "ZoneName": "The name of the Mobile Input Zone we are looking for"
          }
        },
        "FindZone": {
          "comment": "Search for zone in the list and return it if found",
          "params": {
            "ZoneName": "The name of the Mobile Input Zone we are looking for"
          }
        },
        "InitializeInputZones": {
          "comment": "Initializes the input zones"
        },
        "InitInputSystem": {
          "comment": "The player controller will call this function directly after creating the input system"
        },
        "NativeInitializeInputSystem": {
          "comment": "Perform any native initialization of the subsystem"
        },
        "NativeInitializeInputZones": {
          "comment": "Iterates over the zones and pre-calculates the actual bounds based on the current device resolution"
        },
        "OpenMenuScene": {
          "comment": "Call this function to open a menu scene.",
          "params": {
            "SceneClass": "The class of the menu scene to open.",
            "Mode": "Optional string that lets the opener pass extra information to the scene"
          }
        },
        "OpenMobileMenu": {
          "comment": "Opens a menu by class\n @Param MenuClassName - the name of the class to open"
        },
        "OpenMobileMenuMode": {
          "comment": "Opens a menu by class and passes extra info to the scene\n @Param MenuClassName - the name of the class to open - REQUIRES QUOTES!\n @Param Mode - the extra mode information to pass to the scene (two strings in OpenMobileMenu above breaks a.b for class names!)"
        },
        "PreClientTravel": {
          "comment": "We need a PreClientTravel to clean up the menu system."
        },
        "RefreshKismetLinks": {
          "comment": "The SeqEvent's from the level's kismet will have their RegisterEvent function called before the inputzones are\n configured. So just this once, have all of them try again."
        },
        "RenderMenus": {
          "comment": "Start the rendering chain for the UI Scenes",
          "params": {
            "Canvas": "The canvas for drawing"
          }
        },
        "SendInputAxis": {
          "comment": "Allows the game to send an InputAxis event through the viewport",
          "params": {
            "Key": "the key we are sending",
            "Delta": "the movement delta for the axis",
            "DeltaTime": "the time (in seconds) since the last axis update."
          }
        },
        "SendInputKey": {
          "comment": "Allows the game to send a InputKey event though the viewport.",
          "params": {
            "Key": "the new of the key we are sending",
            "Event": "the Type of event",
            "AmountDepressed": "the strength of the event"
          }
        },
        "SetMobileInputConfig": {
          "comment": "Switch to the input config with the specified group name"
        }
      },
      "structs": {
        "MobileInputGroup": {
          "comment": "Defines a mobile input group",
          "properties": {
            "AssociatedZones": {
              "comment": "The List of zones associated with this group"
            },
            "GroupName": {
              "comment": "The name of this group"
            }
          }
        },
        "MobileInputZoneClassMap": {
          "comment": "Record of each MobileInputZone class (and subclasses) instances"
        },
        "TouchData": {
          "comment": "the MPI keeps track of all touches coming from a device. When the status of a touch changes, it tracks it and then passes it along to\n the associated MobileInputZone.",
          "properties": {
            "bInUse": {
              "comment": "If true, this touch entry is in use, otherwise feel free to use it for touches"
            },
            "Events": {
              "comment": "Events queued up for this touch. Because we may receive several touch movement events per tick,"
            },
            "Handle": {
              "comment": "Holds the ID of the current touch"
            },
            "InitialDeviceTime": {
              "comment": "Holds the device timestamp of when the original touch occurred"
            },
            "LastActiveTime": {
              "comment": "Holds the last active time (via TimeSeconds()) that will be used to timeout a zone"
            },
            "Location": {
              "comment": "Holds the current location of the touch"
            },
            "MoveDeltaTime": {
              "comment": "Time delta between the movement events the last time this touch moved"
            },
            "MoveEventDeviceTime": {
              "comment": "Device timestamp of most recent event"
            },
            "State": {
              "comment": "Holds the current state of the touch"
            },
            "TotalMoveDistance": {
              "comment": "Total distance that the finger moved since it initially touched down"
            },
            "TouchDuration": {
              "comment": "How long this touch has been active"
            },
            "TouchpadIndex": {
              "comment": "What touchpad this came from"
            },
            "Zone": {
              "comment": "Holds the zone that is currently processing this touch"
            }
          }
        },
        "TouchDataEvent": {
          "comment": "This structure contains data for individual touch events queued for a specific touch handle",
          "properties": {
            "DeviceTime": {
              "comment": "Holds the device timestamp of when this event occurred"
            },
            "EventType": {
              "comment": "Holds the type of event"
            },
            "Location": {
              "comment": "Holds the current location of the touch"
            },
            "TouchpadIndex": {
              "comment": "What touchpad this came from"
            }
          }
        }
      }
    },
    "NavMeshGoal_OutOfViewFrom": {
      "properties": {
        "bShowDebug": {
          "comment": "show debug lines"
        }
      }
    },
    "NavMeshPath_BiasAgainstPolysWithinDistanceOfLocations": {
      "properties": {
        "DistanceToCheck": {
          "comment": "How far we want to spawn away from a previous spawn."
        },
        "Location": {
          "comment": "Location to compare from"
        },
        "LocationsToCheck": {
          "comment": "Set of places we have spawned before"
        }
      }
    },
    "PlayerCollectorGame": {
      "properties": {
        "NumberOfClientsToWaitFor": {
          "comment": "The number of clients that are expected to join before we seamless travel"
        },
        "URLToLoad": {
          "comment": "URL of the actual game to travel to when all clients join"
        }
      }
    },
    "SeqAct_ControlGameMovie": {
      "properties": {
        "EndOfRenderingMovieFrame": {
          "comment": "When the fading from audio and video to just audio should occur"
        },
        "MovieName": {
          "comment": "Which movie to play"
        },
        "StartOfRenderingMovieFrame": {
          "comment": "When the fading in from just audio to audio and video should occur"
        }
      }
    },
    "SeqAct_Deproject": {
      "properties": {
        "HitLocation": {
          "comment": "The location where the hit occured"
        },
        "HitNormal": {
          "comment": "The hit normal"
        },
        "HitObject": {
          "comment": "The object that was hit"
        },
        "ScreenX": {
          "comment": "The X location you wish to trace out from"
        },
        "ScreenY": {
          "comment": "The Y location you wish to trace out from"
        },
        "TraceDistance": {
          "comment": "How far out should we trace"
        }
      }
    },
    "SeqAct_GameCrowdPopulationManagerToggle": {
      "properties": {
        "AgentLightingChannel": {
          "comment": "Lighting channels to put the agents in."
        },
        "AgentWarmupTime": {
          "comment": "Average time to \"warm up\" spawned agents before letting them sleep if not rendered"
        },
        "bForceObstacleChecking": {
          "comment": "If true, force obstacle checking for all agents from this spawner"
        },
        "MinBehindSpawnDist": {
          "comment": "Square of min distance allowed for in line of sight but out of view frustrum agent spawns"
        },
        "PotentialSpawnPoints": {
          "comment": "List of all GameCrowdDestinations that are PotentialSpawnPoints"
        },
        "bCastShadows": {
          "comment": "Whether agents from this spawner should cast shadows"
        },
        "bClearOldArchetypes": {
          "comment": "If true, clear old population manager archetype list rather than adding to it with this toggle action's CrowdAgentList."
        },
        "bEnableCrowdLightEnvironment": {
          "comment": "Whether to enable the light environment on crowd members."
        },
        "bForceNavMeshPathing": {
          "comment": "If true, force nav mesh navigation for all agents from this spawner"
        },
        "CrowdAgentList": {
          "comment": "List of Archetypes of agents for pop manager to spawn when this is toggled on"
        },
        "MaxAgents": {
          "comment": "The maximum number of agents alive at one time."
        },
        "MaxSpawnDist": {
          "comment": "Max distance allowed for spawns"
        },
        "SpawnRate": {
          "comment": "How many agents per second will be spawned at the target actor(s)."
        },
        "WarmupPopulationPct": {
          "comment": "Percentage of max population to immediately spawn when the population manager is toggled on (without respecting visibility checks). Range is 0.0 to 1.0"
        }
      },
      "functions": {
        "GetMaxSpawnDist": {
          "comment": "GameCrowdSpawnerInterface"
        }
      }
    },
    "SeqAct_MobileAddInputZones": {
      "properties": {
        "NewZone": {
          "comment": "All the details needed to set up a zone"
        },
        "ZoneName": {
          "comment": "Name for this zone, it will be used in Kismet zone input events"
        }
      }
    },
    "SeqAct_MobileSaveLoadValue": {
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqAct_ModifyProperty": {
      "properties": {
        "Properties": {
          "comment": "List of properties that can be modified"
        }
      },
      "structs": {
        "PropertyInfo": {
          "comment": "Struct used to figure out which properties to modify.",
          "properties": {
            "bModifyProperty": {
              "comment": "Should this property be modified?"
            },
            "PropertyName": {
              "comment": "Name of the property to modify"
            },
            "PropertyValue": {
              "comment": "New value to apply to the property"
            }
          }
        }
      }
    },
    "SeqAct_PlayAgentAnimation": {
      "properties": {
        "ActionTarget": {
          "comment": "Optional other actor that actions should point at, instead of at the actual destination location."
        },
        "AnimationList": {
          "comment": "List of animations to play while at this node"
        },
        "bBlendBetweenAnims": {
          "comment": "Whether should blend between animations in the list. Set True if they don't match at start/end"
        },
        "bFaceActionTargetFirst": {
          "comment": "If true, face action target before starting animation"
        },
        "bLooping": {
          "comment": "If true, loop the last animation in the list forever"
        },
        "LoopIndex": {
          "comment": "Which animation to loop in AnimationList if bLooping == TRUE"
        },
        "LoopTime": {
          "comment": "How long to loop the animation if bLooping == TRUE, -1.f == infinite"
        }
      }
    },
    "SeqEvent_HudRender": {
      "comment": "This is the base class of all Mobile sequence events.",
      "properties": {
        "AuthoredGlobalScale": {
          "comment": "This is the scale factor you are authoring for. 2.0 is useful for Retina display resolution (960x640), 1.0 for iPads and older iPhones"
        },
        "Targets": {
          "comment": "List of objects to call the handler function on"
        }
      },
      "functions": {
        "RegisterEvent": {
          "comment": "Whenever a SeqEvent_MobileBase sequence is created, it needs to find the PlayerInput that is assoicated with it and \n add it'self to the list of Kismet sequences looking for input"
        },
        "Render": {
          "comment": "Perform the actual rendering"
        }
      }
    },
    "SeqEvent_HudRenderImage": {
      "comment": "This is the base class of all Mobile sequence events.",
      "properties": {
        "DisplayColor": {
          "comment": "The color to modulate the text by"
        },
        "DisplayLocation": {
          "comment": "The Location to display the text at"
        },
        "DisplayTexture": {
          "comment": "The texture to display"
        },
        "U": {
          "comment": "The UVs"
        },
        "UL": {
          "comment": "The UVs"
        },
        "V": {
          "comment": "The UVs"
        },
        "VL": {
          "comment": "The UVs"
        },
        "XL": {
          "comment": "The Size of the image to display"
        },
        "YL": {
          "comment": "The Size of the image to display"
        }
      },
      "functions": {
        "Render": {
          "comment": "Perform the actual rendering"
        }
      }
    },
    "SeqEvent_HudRenderText": {
      "comment": "This is the base class of all Mobile sequence events.",
      "properties": {
        "DisplayColor": {
          "comment": "The Color to draw the text in"
        },
        "DisplayFont": {
          "comment": "The Font to draw"
        },
        "DisplayLocation": {
          "comment": "The Location to display the text at"
        },
        "DisplayText": {
          "comment": "The text to draw. NOTE: You can set this via the variable link"
        },
        "TextDrawMethod": {
          "comment": "Whether the text should be centered at the display location"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        },
        "Render": {
          "comment": "Perform the actual rendering"
        }
      }
    },
    "SeqEvent_MobileBase": {
      "comment": "This is the base class of all Mobile sequence events.",
      "functions": {
        "AddToMobileInput": {
          "comment": "Tell the MPI to attach itself to it's list of events"
        },
        "RegisterEvent": {
          "comment": "Whenever a SeqEvent_MobileBase sequence is created, it needs to find the PlayerInput that is assoicated with it and \n add it'self to the list of Kismet sequences looking for input"
        }
      }
    },
    "SeqEvent_MobileButton": {
      "properties": {
        "bWasActiveLastFrame": {
          "comment": "TRUE if the zone was active last frame (for tracking edges)"
        },
        "bSendPressedOnlyOnTouchDown": {
          "comment": "If TRUE, the Input Pressed output will only trigger when a touch first happens, not every frame"
        },
        "bSendPressedOnlyOnTouchUp": {
          "comment": "If TRUE, the Input Pressed output will only trigger when a touch ends, not every frame. MAKE SURE RETRIGGER DELAY IS 0!!!"
        }
      }
    },
    "SeqEvent_MobileInput": {
      "properties": {
        "XAxisValue": {
          "comment": "Holds the current axis values for the device"
        }
      }
    },
    "SeqEvent_MobileLook": {
      "properties": {
        "Yaw": {
          "comment": "Holds the current axis values for the device"
        }
      }
    },
    "SeqEvent_MobileMotion": {
      "properties": {
        "Roll": {
          "comment": "Called each frame. \n \n@param Originator is a reference to the PC that caused the input\n \n@param OriginatorInput is a reference to the mobile player input assoicated with this object"
        }
      },
      "functions": {
        "GetObjClassVersion": {
          "comment": "Return the version number for this class. Child classes should increment this method by calling Super then adding\n a individual class version to the result. When a class is first created, the number should be 0; each time one of the\n link arrays is modified (VariableLinks, OutputLinks, InputLinks, etc.), the number that is added to the result of\n Super.GetObjClassVersion() should be incremented by 1."
        }
      }
    },
    "SeqEvent_MobileObjectPicker": {
      "properties": {
        "bCheckonTouch": {
          "comment": "Should we check on touch/move as well"
        },
        "TraceDistance": {
          "comment": "How far should this object track out to hit something"
        },
        "Targets": {
          "comment": "List of objects that we are looking for touches on"
        }
      }
    },
    "SeqEvent_MobileRawInput": {
      "properties": {
        "TouchIndex": {
          "comment": "Holds the index in to the multi-touch array that we wish to manage."
        }
      },
      "functions": {
        "RegisterEvent": {
          "comment": "Whenever a SeqEvent_MobileBase sequence is created, it needs to find the PlayerInput that is assoicated with it and \n add it'self to the list of Kismet sequences looking for input"
        }
      }
    },
    "SeqEvent_MobileSwipe": {
      "properties": {
        "TraceDistance": {
          "comment": "How far should this object track out to hit something"
        },
        "TouchedActors": {
          "comment": "A list of actors that were passed over when the swipe occured"
        },
        "MinDistance": {
          "comment": "How far does the touch need to travel in order to be consider a swipe"
        },
        "Tolerance": {
          "comment": "How much tolerance should we give the weak axis in order to consider it a swipe"
        }
      }
    },
    "SeqEvent_MobileZoneBase": {
      "comment": "This is the base class for all mobile sequence events that require access to a specific zone.",
      "properties": {
        "TargetZoneName": {
          "comment": "Holds the name of the zone we want to be assoicated with"
        }
      },
      "functions": {
        "AddToMobileInput": {
          "comment": "Try to find the mobile input zone this is assocated with and add it"
        }
      }
    }
  },
  "GFxUI": {
    "GFxAction_OpenMovie": {
      "properties": {
        "bEnableGammaCorrection": {
          "comment": "Whether to gamma correct this movie before writing to the destination surface."
        },
        "bCaptureInput": {
          "comment": "if true, capture input"
        },
        "bDisplayWithHudOff": {
          "comment": "Whether to display the movie even if the HUD is turned off"
        },
        "bStartPaused": {
          "comment": "if true, start paused"
        },
        "bTakeFocus": {
          "comment": "if true, focus on load"
        },
        "Movie": {
          "comment": "Swf Movie data to use"
        },
        "MoviePlayerClass": {
          "comment": "Type of movie player to use"
        },
        "RenderTexture": {
          "comment": "If set, movie will be played on this RenderTexture"
        },
        "RenderTextureMode": {
          "comment": "Use RTM_Alpha with BLEND_Translucent, doesn't support add. Use RTM_AlphaComposite with BLEND_AlphaComposite."
        }
      }
    },
    "GFxClikWidget": {
      "functions": {
        "AddEventListener": {
          "comment": "Adds an event listener to the EventDispatcher for events on CLIK widgets. To add an event, pass in the name of the CLIK event, prefaced with \"CLIK_\" (e.g. 'CLIK_press')\n For a full list of valid CLIK events, see EventTypes.as in the CLIK widget source."
        },
        "GetEventStringFromTypename": {
          "comment": "Checks for a \"CLIK_\" prefix to the name (to avoid name collisions), and returns the string equivalent with the prefix removed. If prefix isn't found, errors and returns a null string"
        }
      }
    },
    "GFxDataStoreSubscriber": {
      "functions": {
        "ClearBoundDataStores": {
          "comment": "Notifies this subscriber to unbind itself from all bound data stores"
        },
        "GetBoundDataStores": {
          "comment": "Retrieves the list of data stores bound by this subscriber.",
          "params": {
            "out_BoundDataStores": "receives the array of data stores that subscriber is bound to."
          }
        },
        "NotifyDataStoreValueUpdated": {
          "comment": "Handler for the UIDataStore.OnDataStoreValueUpdated delegate. Used by data stores to indicate that some data provided by the data\n has changed. Subscribers should use this function to refresh any data store values being displayed with the updated value.\n notify subscribers when they should refresh their values from this data store.",
          "params": {
            "SourceDataStore": "the data store that generated the refresh notification; useful for subscribers with multiple data store\n bindings, to tell which data store sent the notification.",
            "PropertyTag": "the tag associated with the data field that was updated; Subscribers can use this tag to determine whether\n there is any need to refresh their data values.",
            "SourceProvider": "for data stores which contain nested providers, the provider that contains the data which changed.",
            "ArrayIndex": "for collection fields, indicates which element was changed. value of INDEX_NONE indicates not an array\n or that the entire array was updated."
          }
        },
        "RefreshSubscriberValue": {
          "comment": "Resolves this subscriber's data store binding and updates the subscriber with the current value from the data store."
        },
        "SaveSubscriberValue": {
          "comment": "Resolves this subscriber's data store binding and publishes this subscriber's value to the appropriate data store.",
          "params": {
            "out_BoundDataStores": "contains the array of data stores that widgets have saved values to. Each widget that\n implements this method should add its resolved data store to this array after data values have been\n published. Once SaveSubscriberValue has been called on all widgets in a scene, OnCommit will be called\n on all data stores in this array.",
            "BindingIndex": "optional parameter for indicating which data store binding is being requested for those\n objects which have multiple data store bindings. How this parameter is used is up to the\n class which implements this interface, but typically the \"primary\" data store will be index 0."
          }
        }
      }
    },
    "GFxEngine": {
      "properties": {
        "GCReferences": {
          "comment": "adding buffer for storing texture references created by ui renderer"
        }
      }
    },
    "GFxEvent_FSCommand": {
      "properties": {
        "Handler": {
          "comment": "Command handler to route events through"
        },
        "Movie": {
          "comment": "Swf Movie data to use."
        }
      }
    },
    "GFxFSCmdHandler": {
      "comment": "GFxFSCmdHandler handles fscommand() calls from ActionScript, calling the",
      "functions": {
        "FSCommand": {
          "comment": "Called when receive an fscommand() call from ActionScript\n @PARAM movie: The movie which generated the fscommand().\n @PARAM cmd: The command\n @PARAM Arg: The arguments"
        }
      }
    },
    "GFxInteraction": {
      "functions": {
        "GetFocusMovie": {
          "comment": "Set focus movie and input capture mode"
        }
      }
    },
    "GFxMoviePlayer": {
      "properties": {
        "bAllowFocus": {
          "comment": "If TRUE, this movie player will be allowed to accept focus events. Defaults to TRUE"
        },
        "bAllowInput": {
          "comment": "If TRUE, this movie player will be allowed to accept input events. Defaults to TRUE"
        },
        "bAutoPlay": {
          "comment": "If TRUE, MovieToLoad will be played immediately after loading"
        },
        "bBlurLesserMovies": {
          "comment": "if true, this movie will try and blur out movies with a lower priority"
        },
        "bCaptureInput": {
          "comment": "If TRUE, this movie player will capture input"
        },
        "bCloseOnLevelChange": {
          "comment": "If TRUE, the movie will be closed on a level change \n NOTE: ONLY TIMINGMODE TM_REAL movies can stay open during level change"
        },
        "bDiscardNonOwnerInput": {
          "comment": "If TRUE, any input received from a LocalPlayer that is not the owner of this movieplayer will be discarded and not acted upon \n This should be used in conjunction with bOnlyOwnerFocusable to make movieplayers that only respond to one player, but consume all input from the other players"
        },
        "bDisplayWithHudOff": {
          "comment": "If TRUE, this movie player will render even if bShowHud is FALSE. Usually set to TRUE for menus, and FALSE for HUDs"
        },
        "bEnableGammaCorrection": {
          "comment": "Whether to gamma correct this movie before writing to the destination surface."
        },
        "bHideLesserMovies": {
          "comment": "If ture, this movie will try and hide movies with a lower priority"
        },
        "bIgnoreBlurEffect": {
          "comment": "If this is true, this movie will ignore any attempts to apply a blur effect to it through the priority system"
        },
        "bIgnoreMouseInput": {
          "comment": "IF TRUE, this movie player will ignore mouse input"
        },
        "bIgnoreVisibilityEffect": {
          "comment": "If this is true, this movie will ignore any attempts to apply a visibility effect to it through the priority system"
        },
        "bIsPriorityBlurred": {
          "comment": "This will be TRUE if the movie is currently blurred via a higher priority movie"
        },
        "bIsPriorityHidden": {
          "comment": "This will be TRUE if the movie is currently hidden via a higher priority movie"
        },
        "bLogUnhandedWidgetInitializations": {
          "comment": "If TRUE, widgets that have an initialization callback that are NOT handled by WidgetInitialized() will log out a notification for debugging"
        },
        "bMovieIsOpen": {
          "comment": "TRUE after Start() is called, FALSE after Close() is called."
        },
        "bOnlyOwnerFocusable": {
          "comment": "If TRUE, only the LocalPlayerOwner's input can be directed here"
        },
        "bPauseGameWhileActive": {
          "comment": "If TRUE, the game will pause while this scene is up"
        },
        "bWidgetsInitializedThisFrame": {
          "comment": "If TRUE, a widget within this movie player was initialized this frame. This will cause the PostWidgetInit event to be fired after the Advance() of the movie is complete"
        },
        "CaptureKeys": {
          "comment": "List of keys that this movie player is listening for, and will capture (i.e. not send on to the game)"
        },
        "ExternalInterface": {
          "comment": "Object that should receive ExternalInterface calls from ActionScript. If unspecified, all ExternalInterface calls will be routed through the movie player itself"
        },
        "ExternalTextures": {
          "comment": "Array of ExternalTexture bindings that will automatically replaced when the movie player loads a new movie"
        },
        "FocusIgnoreKeys": {
          "comment": "If this is a focus movie, all input will be sent to the movie EXCEPT these keys"
        },
        "LocalPlayerOwnerIndex": {
          "comment": "Index into the GamePlayers array for the LocalPlayer who owns this movie"
        },
        "MovieInfo": {
          "comment": "Reference to the movie currently being played"
        },
        "ObjectValues": {
          "comment": "All GFxObjects created during the lifetime of GFxMoviePlayer"
        },
        "pMovie": {
          "comment": "GFx Internals"
        },
        "Priority": {
          "comment": "The priority of this movie player. Used to determine render and focus order when multiple movie players are open simultaneously"
        },
        "WidgetPathBindings": {
          "comment": "Stores bindings for forwarding WidgetInitialized() calls on to a specific GFxObject instance for widgets within a certain movie object path. Entries can be added / removed from\n the widget binding mapping using SetWidgetPathBinding()"
        },
        "RenderTexture": {
          "comment": "Texture that the movie should be rendered to. If NULL, the movie will be rendered to the frame buffer."
        },
        "SoundThemes": {
          "comment": "Stores an array of bindings between sound theme names and actual UISoundThemes"
        }
      },
      "functions": {
        "ActionScriptVoid": {
          "comment": "ActionScript function call wrappers\n \n These functions, when called from within a UnrealScript function, invoke an ActionScript function with the specified method name, with the parameters of the wrapping UnrealScript \n function. This is the preferred method for calling ActionScript functions from UnrealScript, as it is faster than Invoke, with less overhead.\n \n Example: To call the following ActionScript function from UnrealScript -\n \n function MyActionScriptFunction(Param1:String, Param2:Number, Param3:Object):Void;\n \n Use the following UnrealScript code -\n \n function CallMyActionScriptFunction(string Param1, float Param2, GFxObject Param3)\n {\n ActionScriptVoid(\"_root.MyActionScriptFunction\");\n }"
        },
        "AddCaptureKey": {
          "comment": "Adds a key to the list of keys that get eaten by the movie being played, and not passed down to the game"
        },
        "AddFocusIgnoreKey": {
          "comment": "Adds a key to the FocusIgnore list, which prevents key presses from being sent to the movie if this is the focus movie"
        },
        "Advance": {
          "comment": "Advances the movie by the specified time. After the movie is started via Start(), Advance(0.f) can be called to initialize all the objects on the first frame without actually advancing the movie"
        },
        "ApplyPriorityBlurEffect": {
          "comment": "Applies the priority blur effect to this movie.\n @bRemoveEffect - will be true if we want to remove the effect"
        },
        "ApplyPriorityEffect": {
          "comment": "Apply any depth effects based on the priority of the scene just opened.\n @bRequestedBlurState - What should the blur state for this scene be\n @bRequestedHiddenState - What should the visibility for this scene be"
        },
        "ApplyPriorityVisibilityEffect": {
          "comment": "Applies the priority visibility effect to this movie.\n @bRemoveEffect - will be true if we want to remove the effect"
        },
        "Close": {
          "comment": "Close the movie"
        },
        "ConditionalClearPause": {
          "comment": "See whether we need to attempt to unpause the game when the scene closes"
        },
        "ConsoleCommand": {
          "comment": "Routes a console command through the player's PlayerController",
          "params": {
            "Command": "The console command to run"
          }
        },
        "CreateObject": {
          "comment": "Used to create a new object of a specific ActionScript class. Note that the ASClass specified must be available in the movie you are trying to create it in!"
        },
        "FilterButtonInput": {
          "comment": "Can be overridden to filter input to this movie. Return TRUE to trap the input, FALSE to let it pass through to Gfx"
        },
        "FlushPlayerInput": {
          "comment": "Clears out all pressed keys from the player's input"
        },
        "GetLP": {
          "comment": "Helper function to get the owning local player for this movie"
        },
        "GetPC": {
          "comment": "Helper function to get the owning player controller for this movie"
        },
        "GetVariable": {
          "comment": "Accessors for ActionScript / GFx Objects\n \n If you know the type of the variable or object you're accessing, it is best to use one of the type specific accessor functions, as they are significantly faster.\n Avoid using the slower ASValue functions if possible."
        },
        "GetVariableArray": {
          "comment": "Array accessor functions\n \n As with the normal member accessor functions, it is always best to use the accessor for the specific type, rather than the generic ASValue implementations"
        },
        "GetVariableObject": {
          "comment": "Returns a GFxObject for the specified path. If the type parameter is specified, the returned object will be of the specified class. Note the return value is\n not coerced though, so if you specify a type, you must manually cast the result"
        },
        "Init": {
          "comment": "This should be called when a new GFxMoviePlayer is initialized. Handles the setting up of the LocalPlayerIndex, as well as automatically starting / advancing the movie if desired",
          "params": {
            "LocPla": "The LocalPlayer that owns this movie"
          }
        },
        "Invoke": {
          "comment": "Calls an ActionScript function on the movie, with the values from the args array as its parameters. This is slower than creating a wrapper function to call the ActionScript method\n using one of the ActionScript*() methods below, but does not require a subclass to implement. Use this for one-off functions, or functions with variable length arguments"
        },
        "OnCleanup": {
          "comment": "Called when the movie is done and removed from the all movie list. So final clean up can be done"
        },
        "OnClose": {
          "comment": "Called when a movie is closed to allow cleanup and handling"
        },
        "OnFocusGained": {
          "comment": "Event triggered when focus is given to this MoviePlayer for a given LocalPlayer",
          "params": {
            "LocalPlayerIndex": "The index of the local player that is now focusing on this MoviePlayer"
          }
        },
        "OnFocusLost": {
          "comment": "Event triggered when focus is removed from this MoviePlayer for a given LocalPlayer",
          "params": {
            "LocalPlayerIndex": "The index of the local player that is no longer focusing on this MoviePlayer"
          }
        },
        "PlaySoundFromTheme": {
          "comment": "Plays a sound associated with an event from the specified sound theme.\n Can be used to manually fire off sounds from UnrealScript when it is inconvenient to fire them off from ActionScript",
          "params": {
            "EventName": "name of the sound event to play",
            "SoundThemeName": "name of the theme to play the sound from. Defaults to 'default'"
          }
        },
        "PostAdvance": {
          "comment": "Called after the movie is advanced, and handles things like calling OnPostAdvance(), if specified",
          "params": {
            "DeltaTime": "Time that the movie was advanced"
          }
        },
        "PostWidgetInit": {
          "comment": "Callback when at least one CLIK widget with enableInitCallback set to TRUE has been initialized in a frame"
        },
        "SetExternalInterface": {
          "comment": "Set a handler for ActionScript ExternalInterface calls for the movie being played. If no handler is specified, calls will be processed by this GFxMoviePlayer"
        },
        "SetExternalTexture": {
          "comment": "Specifies a resource (linkage identifier in the movie) to be replaced by the specified texture"
        },
        "SetMovieCanReceiveFocus": {
          "comment": "Sets whether or not a movie is allowed to receive focus. Defaults to true"
        },
        "SetMovieCanReceiveInput": {
          "comment": "Sets whether or not a movie is allowed to receive input. Defaults to true"
        },
        "SetMovieInfo": {
          "comment": "Set movie to play (for script-created objects)"
        },
        "SetPause": {
          "comment": "Pauses / unpauses the movie playback"
        },
        "SetTimingMode": {
          "comment": "Sets the timing mode of the movie to either advance with game time (respecting game pause and time dilation), or real time (disregards game pause and time dilation)"
        },
        "SetView3D": {
          "comment": "3D View functions"
        },
        "SetViewport": {
          "comment": "Sets the viewport location and size for the movie being played"
        },
        "SetWidgetPathBinding": {
          "comment": "Sets a widget to handle WidgetInitialized() callbacks for a given widget path. Used when you want a specific widget within the movie to handle WidgetInitialized() calls\n for its own children. The most derived path handler will be called for any given widget \n \n Example: For WidgetInitialized() on the widget with the path _level0.a.b.c.d, if a path binding was set for _level0.a and _level0.a.b, the widget bound to path _level0.a.b\n would receive the call\n \n Passing in None for WidgetToBind will remove a Widget from being bound to that path"
        },
        "Start": {
          "comment": "Start playing the movie. Returns false if there were load errors. Can be overridden to perform other setup, but be sure to call Super.Start() first."
        },
        "WidgetInitialized": {
          "comment": "Callback when a CLIK widget with enableInitCallback set to TRUE is initialized. Returns TRUE if the widget was handled, FALSE if not."
        },
        "WidgetUnloaded": {
          "comment": "Callback when a CLIK widget with enableInitCallback set to TRUE is unloaded. Returns TRUE if the widget was handled, FALSE if not."
        }
      },
      "structs": {
        "ASValue": {
          "comment": "Generic struct used for passing generic data to and from ActionScript. Should be used as little as possible because of overhead, except in cases where it is unavoidable"
        },
        "ExternalTexture": {
          "comment": "Stores a mapping between a movie's image resource (\"Linkage\" identifier on an image resource in the movie) and an Unreal texture resource. This allows\n runtime remapping of the images used by the movie. Any texture with a linkage identifier can be replaced at runtime using SetExternalTexture()"
        },
        "GFxWidgetBinding": {
          "comment": "Widget class binding: To associate a CLIK widget instance in a movie with a particular UnrealScript subclass of GFxObject, add the widget's Flash name here, and specify the class.\n This will cause the GFxObject parameter of WidgetInitialized() to be created as the appropriate subclass."
        },
        "SoundThemeBinding": {
          "comment": "Structure that binds a sound theme name to an actual UISoundTheme to handle sound events from objects in this movie. Sound events can be fired by\n CLIK widgets or manually by the artist. Each event contains a theme name, and an event to play. This mapping binds the theme names specified\n by the artist to a UISoundTheme asset, which then binds event names to various sound cues or actions.",
          "properties": {
            "Theme": {
              "comment": "Corresponding sound theme to handle sound events for this ThemeName"
            },
            "ThemeName": {
              "comment": "Name of the sound theme, specified by the artist in the movie"
            }
          }
        }
      }
    },
    "GFxObject": {
      "comment": "GFxObject is GFxValue in Scaleform code",
      "properties": {
        "SubWidgetBindings": {
          "comment": "Array of WidgetBindings for widgets that are forwarded to this widget for their WidgetInitialized() callback. See GFxMoviePlayer's WidgetBindings for details"
        },
        "Value[12]": {
          "comment": "Stores reference information for the GFx-side GFxValue that this GFxObject refers to"
        }
      },
      "functions": {
        "ActionScriptVoid": {
          "comment": "ActionScript function call wrappers\n \n These functions, when called from within a UnrealScript function, invoke an ActionScript function with the specified method name, with the parameters of the wrapping UnrealScript \n function. This is the preferred method for calling ActionScript functions from UnrealScript, as it is faster than Invoke, with less overhead.\n \n Example: To call the following ActionScript function from UnrealScript -\n \n function MyActionScriptFunction(Param1:String, Param2:Number, Param3:Object):Void;\n \n Use the following UnrealScript code -\n \n function CallMyActionScriptFunction(string Param1, float Param2, GFxObject Param3)\n {\n ActionScriptVoid(\"MyActionScriptFunction\");\n }"
        },
        "AttachMovie": {
          "comment": "Attaches a symbol to specified movie instance. If no instance is found in this object's scope with the InstanceName, a new instance is created and returned"
        },
        "CreateEmptyMovieClip": {
          "comment": "Creates an empty MovieClip in the movie. This can then be manipulated like any other MovieClip using the above functions"
        },
        "Get": {
          "comment": "Accessors for ActionScript / GFx Objects\n \n If you know the type of the variable or object you're accessing, it is best to use one of the type specific accessor functions, as they are significantly faster.\n Avoid using the slower ASValue functions if possible."
        },
        "GetDisplayInfo": {
          "comment": "Complex Object Interface functions\n \n These functions are the preferred way modify the parameters of display objects (i.e. widgets). When possible, use these functions to view and change the display parameters of widgets\n over setting the parameters individually via Set() functions"
        },
        "GetElement": {
          "comment": "Array accessor functions\n \n As with the normal member accessor functions, it is always preferable to use the accessor for the specific type, rather than the generic GetElement() / SetElement()\n functions."
        },
        "GetElementDisplayInfo": {
          "comment": "Array accessors for display objects"
        },
        "GetElementMember": {
          "comment": "Array accessors for general element types"
        },
        "GetObject": {
          "comment": "Returns a GFxObject for the specified member. If the type parameter is specified, the returned object will be of the specified class. Note the return value is\n not coerced though, so if you specify a type, you must manually cast the result"
        },
        "GetText": {
          "comment": "Text field accessor functions"
        },
        "GotoAndPlay": {
          "comment": "Movie flow control functions\n \n These functions are used for controlling movie playback and skipping around on the timeline. The string functions take a (case-sensitive) frame label to jump to,\n while the integer functions jump to a frame number. If the label or frame isn't found, a warning will be sent to the DevGFxUI logging channel, but the movie can still\n potentially jump frames (usually to the end of the timeline for the object)"
        },
        "Invoke": {
          "comment": "Calls an ActionScript function on this GFxObject, with the values from the args array as its parameters. This is slower than creating a wrapper function to call the ActionScript method\n using one of the ActionScript*() methods below, but does not require a subclass of GFxObject to implement. Use this for one-off functions, or functions with variable length arguments"
        },
        "SetString": {
          "comment": "Set the field specified by 'member' on this object.",
          "params": {
            "Member": "The member of set object to set; e.g. \"text\" or \"htmlText\" or \"foo\"",
            "s": "Value of the string that is to be assigned to the member",
            "InContext": "The TranslationContext to use when resolving any tags enocuntered in the text."
          }
        },
        "SetText": {
          "comment": "Set the text field on this object.",
          "params": {
            "text": "The text to set.",
            "InContext": "The TranslationContext to use when resolving any tags enocuntered in the text."
          }
        },
        "SetVisible": {
          "comment": "Toggles visibility of this object, if it is a display object"
        },
        "TranslateString": {
          "comment": "Translate a string for handling markup",
          "params": {
            "StringToTranslate": "The text to set.",
            "TranslationContext": "The TranslationContext to use when resolving any tags enocountered in the text."
          }
        },
        "WidgetInitialized": {
          "comment": "Callback when a child widget is initialized within the path bound to this widget via GFxMoviePlayer::SetWidgetPathBinding(). Allows for GFxObject subclasses that encapsulate\n functionality to handle their own initialization for child widgets, instead of the GFxMoviePlayer. Returns TRUE if the widget was handled, FALSE if not."
        },
        "WidgetUnloaded": {
          "comment": "Callback when a child widget with enableInitCallback set to TRUE is unloaded within the path bound to this widget via GFxMoviePlayer::SetWidgetPathBinding(). \n Returns TRUE if the widget was handled, FALSE if not."
        }
      },
      "structs": {
        "ASColorTransform": {
          "comment": "Struct for storing color transformation information for manipulation using the Complex Object Interface"
        },
        "ASDisplayInfo": {
          "comment": "Struct for storing properties of display objects for easy and quick manipulation at runtime using the Complex Object Interface"
        }
      }
    },
    "GFxRawData": {
      "properties": {
        "ReferencedSwfs": {
          "comment": "A list of weak references to Swfs needed by this SwfMovie"
        }
      }
    },
    "SwfMovie": {
      "properties": {
        "ImportTimeStamp": {
          "comment": "Time stamp set upon import (or re-import) of this Swf movie. Used to force GFx to ignore already-loaded content and use the re-imported data within a single editor session."
        },
        "SourceFileTimestamp": {
          "comment": "Date/Time-stamp of the file from the last import"
        },
        "bUsesFontlib": {
          "comment": "Set sRGB = OFF on all referenced Texture2Ds"
        }
      }
    }
  },
  "IpDrv": {
    "ClientBeaconAddressResolver": {
      "comment": "Allows a client to register and resolve the address for a host that it wants to connect to.\n The platform specific implementation for this resolver will handle the specifics of generating \n a secure key to allow for a connection.",
      "properties": {
        "BeaconName": {
          "comment": "The name to use when logging (helps debugging)"
        },
        "BeaconPort": {
          "comment": "The port that the beacon will listen on"
        }
      }
    },
    "MCPBase": {
      "comment": "Provides a base class for commonly needed MCP functions"
    },
    "MeshBeacon": {
      "comment": "This class is the base class for the client/host mesh beacon classes.",
      "properties": {
        "BeaconName": {
          "comment": "The name to use when logging (helps debugging)"
        },
        "bIsInTick": {
          "comment": "Used to determine whether to use deferred destruction or not"
        },
        "bShouldTick": {
          "comment": "Whether to the socket(s) or not (not during travel)"
        },
        "bWantsDeferredDestroy": {
          "comment": "True if the beacon should be destroyed at the end of the tick"
        },
        "ElapsedHeartbeatTime": {
          "comment": "The elapsed time that has passed since the last heartbeat"
        },
        "HeartbeatTimeout": {
          "comment": "The maximum amount of time to pass between heartbeat packets being sent"
        },
        "MaxBandwidthHistoryEntries": {
          "comment": "Maximum number of entries allowed for the bandwidth history of a client connection"
        },
        "MaxBandwidthTestBufferSize": {
          "comment": "Maximum size of data that is allowed to be sent for bandwidth testing"
        },
        "MaxBandwidthTestReceiveTime": {
          "comment": "Maximum time allowed to receive the buffer for bandwidth testing"
        },
        "MaxBandwidthTestSendTime": {
          "comment": "Maximum time allowed to send the buffer for bandwidth testing"
        },
        "MeshBeaconPort": {
          "comment": "The port that the mesh beacon will listen on"
        },
        "MinBandwidthTestBufferSize": {
          "comment": "Minimum size of data that is required to be sent for acurate bandwidth testing"
        },
        "Socket": {
          "comment": "The object that is used to send/receive data with the remote host/client"
        },
        "SocketReceiveBufferSize": {
          "comment": "Size of socket recv buffer. Once this is filled then socket blocks on the next recv."
        },
        "SocketSendBufferSize": {
          "comment": "Size of socket send buffer. Once this is filled then socket blocks on the next send."
        }
      },
      "functions": {
        "DestroyBeacon": {
          "comment": "Stops listening for requests/responses and releases any allocated memory"
        }
      },
      "structs": {
        "ConnectionBandwidthStats": {
          "comment": "Bandwidth data for a connection",
          "properties": {
            "DownstreamRate": {
              "comment": "Downstream rate in bytes per second"
            },
            "RoundtripLatency": {
              "comment": "Roundtrip latency in milliseconds"
            },
            "UpstreamRate": {
              "comment": "Upstream rate in bytes per second"
            }
          }
        },
        "PlayerMember": {
          "comment": "Player that is to be a member of a new session",
          "properties": {
            "NetId": {
              "comment": "The unique net id for the player"
            },
            "Skill": {
              "comment": "The skill rating of the player"
            },
            "TeamNum": {
              "comment": "The team the player is on"
            }
          }
        }
      }
    },
    "MeshBeaconClient": {
      "comment": "This class is used to connect to a host mesh beacon in order to \n establish a connected mesh network.",
      "properties": {
        "bUsingRegisteredAddr": {
          "comment": "TRUE if address was registered with the beacon address resolver"
        },
        "ClientBeaconRequestType": {
          "comment": "The pending request to be sent"
        },
        "ClientBeaconState": {
          "comment": "The state of the client beacon as it establishes a connection to the host"
        },
        "ClientPendingRequest": {
          "comment": "Active connection request that is pending for this client"
        },
        "ConnectionRequestElapsedTime": {
          "comment": "Used to track how long we've been waiting for a connection response"
        },
        "ConnectionRequestTimeout": {
          "comment": "Indicates how long the client should wait for a connection response before timing out"
        },
        "CurrentBandwidthTest": {
          "comment": "The upstream test state for the client"
        },
        "HostPendingRequest": {
          "comment": "Holds a reference to the data that is used to reach the potential host \n while a connection is being established for this client"
        },
        "Resolver": {
          "comment": "Platform specific address resolver for this beacon. Instantiated using the ResolverClass type."
        },
        "ResolverClass": {
          "comment": "Class to use for address resolving and registering"
        },
        "ResolverClassName": {
          "comment": "Name of the class to use for address resolving and registering"
        }
      },
      "functions": {
        "BeginBandwidthTest": {
          "comment": "Have this client start a bandwidth test on the connected host by sending a start packet \n and then streaming as many dummy packets as possible before timeout (MaxBandwidthTestSendTime).",
          "params": {
            "TestType": "test to run based on enum of EMeshBeaconBandwidthTestType supported bandwidth test types",
            "TestBufferSize": "size in bytes of total data to be sent for the bandwidth test"
          }
        },
        "DebugRender": {
          "comment": "Render debug info about the client mesh beacon",
          "params": {
            "Canvas": "canvas object to use for rendering debug info"
          }
        },
        "DestroyBeacon": {
          "comment": "Stops listening for requests/responses and releases any allocated memory"
        },
        "DumpInfo": {
          "comment": "Render debug info about the client mesh beacon"
        },
        "RequestConnection": {
          "comment": "Request a connection to be established to the remote host. As part of the \n connection request also send the NAT type and bandwidth history data for the client.\n Note this request is async and the results will be sent via the delegate",
          "params": {
            "DesiredHost": "the server that the connection will be made to",
            "ClientRequest": "the client data that is going to be sendt with the request",
            "bRegisterSecureAddress": "if TRUE then then key exchange is required to connect with the host"
          }
        },
        "SendHostNewGameSessionResponse": {
          "comment": "Notify host of a newly created game session by this client. Host can decide to use/discard the new game session.",
          "params": {
            "bSuccess": "TRUE if the session was created successfully",
            "SessionName": "the name of the session that was created",
            "SearchClass": "the search that should be populated with the session",
            "PlatformSpecificInfo": "the binary data to place in the platform specific areas"
          }
        }
      },
      "structs": {
        "ClientBandwidthTestData": {
          "comment": "Keeps track of all data needed for the current upstream bandwidth test",
          "properties": {
            "CurrentState": {
              "comment": "State of the bandwidth test for the client"
            },
            "ElapsedTestTime": {
              "comment": "Time since test was started"
            },
            "NumBytesSentLast": {
              "comment": "Size of last buffer that was sent for the test"
            },
            "NumBytesSentTotal": {
              "comment": "Tally of bytes that have been sent so far for the test"
            },
            "NumBytesToSendTotal": {
              "comment": "Total bytes expected to be sent in order to complete this test"
            },
            "TestType": {
              "comment": "Type of test current being done"
            }
          }
        },
        "ClientConnectionRequest": {
          "comment": "Used to send the initial client connection request to the host",
          "properties": {
            "BandwidthHistory": {
              "comment": "History of bandwidth results from previous tests. Saved/loaded in the player's profile"
            },
            "bCanHostVs": {
              "comment": "TRUE if the client is able to host a vs match"
            },
            "GoodHostRatio": {
              "comment": "Ratio of successful vs unsuccessful matches hosted by this client in the past"
            },
            "MinutesSinceLastTest": {
              "comment": "Elapsed time in minutes since the last bandwidth test"
            },
            "NatType": {
              "comment": "NAT Type for this client"
            },
            "PlayerNetId": {
              "comment": "Net Id of primary player on this client"
            }
          }
        }
      }
    },
    "MeshBeaconHost": {
      "comment": "This class is used to handle connections from client mesh beacons in order to \n establish a mesh network.",
      "properties": {
        "bAllowBandwidthTesting": {
          "comment": "TRUE if new bandwidth test requests should be handled. Set to false to ignore any pending and new requests."
        },
        "ClientConnections": {
          "comment": "The object that is used to send/receive data with the remote host/client"
        },
        "ConnectionBacklog": {
          "comment": "The number of connections to allow before refusing them"
        },
        "OwningPlayerId": {
          "comment": "Net Id of player that is hosting this beacon"
        },
        "PendingPlayerConnections": {
          "comment": "List of players this beacon is waiting to establish connections to."
        }
      },
      "functions": {
        "AllowBandwidthTesting": {
          "comment": "Enable/disable future bandwidth test requests and current pending tests.",
          "params": {
            "bEnabled": "true to allow bandwidth testing to be processed by the beacon"
          }
        },
        "AllPlayersConnected": {
          "comment": "Determine if the players all have connections on this host beacon",
          "params": {
            "Players": "list of player ids we are searching for"
          }
        },
        "CancelInProgressBandwidthTests": {
          "comment": "Cancel any bandwidth tests that are already in progress."
        },
        "CancelPendingBandwidthTests": {
          "comment": "Cancel any bandwidth tests that are pending."
        },
        "DebugRender": {
          "comment": "Render debug info about the client mesh beacon",
          "params": {
            "Canvas": "canvas object to use for rendering debug info",
            "CurOptimalHostId": "net id of player that should be highlighted as the current optimal host"
          }
        },
        "DestroyBeacon": {
          "comment": "Stops listening for clients and releases any allocated memory"
        },
        "DumpConnections": {
          "comment": "Logs the all the connected clients of this this beacon"
        },
        "GetConnectionIndexForPlayer": {
          "comment": "Determine if the given player has an active connection on this host beacon.",
          "params": {
            "PlayerNetId": "player we are searching for"
          }
        },
        "HasInProgressBandwidthTest": {
          "comment": "Determine if a client is currently running a bandwidth test."
        },
        "HasPendingBandwidthTest": {
          "comment": "Determine if a client is currently waiting/pending for a bandwidth test."
        },
        "InitHostBeacon": {
          "comment": "Creates a listening host mesh beacon to accept new client connections.",
          "params": {
            "InOwningPlayerId": "Net Id of player that is hosting this beacon"
          }
        },
        "RequestClientBandwidthTest": {
          "comment": "Send a request to a client connection to initiate a new bandwidth test.",
          "params": {
            "PlayerNetId": "player with an active connection to receive test request",
            "TestType": "EMeshBeaconBandwidthTestType type of bandwidth test to request",
            "TestBufferSize": "size of buffer in bytes to use for running the test"
          }
        },
        "RequestClientCreateNewSession": {
          "comment": "Sends a request to a specified client to create a new game session.",
          "params": {
            "PlayerNetId": "net id of player for client connection to send request to",
            "SessionName": "the name of the session to create",
            "SearchClass": "the search that should be with corresponding game settings when creating the session",
            "Players": "list of players to register on the newly created session"
          }
        },
        "SetPendingPlayerConnections": {
          "comment": "Set list of pending player ids we are waiting to connect with.\n Once all connections are established then the OnAllPendingPlayersConnected delegate is called.",
          "params": {
            "Players": "list of player ids we are waiting to connect"
          }
        },
        "TellClientsToTravel": {
          "comment": "Tells all of the clients to go to a specific session (contained in platform\n specific info). Used to route all clients to one destination.",
          "params": {
            "SessionName": "the name of the session to register",
            "SearchClass": "the search that should be populated with the session",
            "PlatformSpecificInfo": "the binary data to place in the platform specific areas"
          }
        }
      },
      "structs": {
        "ClientConnectionBandwidthTestData": {
          "comment": "Stats stored for the current bandwidth test on a client connection",
          "properties": {
            "BandwidthStats": {
              "comment": "Resulting stats from the bandwidth test"
            },
            "BytesReceived": {
              "comment": "Total bytes received by the client so far"
            },
            "BytesTotalNeeded": {
              "comment": "Total bytes needed to complete the test"
            },
            "CurrentState": {
              "comment": "Current progress of bandwidth test. Only one client should be MB_BandwidthTestState_InProgress at a time."
            },
            "RequestTestStartTime": {
              "comment": "Time when request was first sent to client to start the test"
            },
            "TestStartTime": {
              "comment": "Time when first response was received from client to being the test"
            },
            "TestType": {
              "comment": "Type of bandwidth test currently running"
            }
          }
        },
        "ClientMeshBeaconConnection": {
          "comment": "Holds the information for a client and whether they've timed out",
          "properties": {
            "BandwidthHistory": {
              "comment": "Previous bandwidth history reported by the client ordered from newest to oldest. \n New bandwidth tests that occur on this host also get added to this history."
            },
            "BandwidthTest": {
              "comment": "Bandwidth test being run for the client"
            },
            "bCanHostVs": {
              "comment": "TRUE if the client is able to host a vs match"
            },
            "bConnectionAccepted": {
              "comment": "True if the client connection has already been accepted for this player"
            },
            "ElapsedHeartbeatTime": {
              "comment": "How long it's been since the last heartbeat"
            },
            "GoodHostRatio": {
              "comment": "Ratio of successful vs unsuccessful matches hosted by this client in the past"
            },
            "MinutesSinceLastTest": {
              "comment": "Elapsed time in minutes since the last bandwidth test"
            },
            "NatType": {
              "comment": "The NAT of the client as reported by the client"
            },
            "PlayerNetId": {
              "comment": "The unique id of the player for this connection"
            },
            "Socket": {
              "comment": "The socket this client is communicating on"
            }
          }
        }
      }
    },
    "OnlineEventsInterfaceMcp": {
      "comment": "Provides an in game gameplay events/stats upload mechanism via the MCP backend",
      "properties": {
        "bBinaryStats": {
          "comment": "if true, the stats data will be sent as a binary blob instead of XML"
        },
        "DisabledUploadTypes": {
          "comment": "A list of upload types that are disabled (don't upload)"
        },
        "EventUploadConfigs": {
          "comment": "This is the array of upload task configurations"
        },
        "HttpPostObjects": {
          "comment": "List of HTTP downloader objects that are POSTing the data"
        }
      },
      "functions": {
        "UpdatePlaylistPopulation": {
          "comment": "Sends the network backend the playlist population for this host",
          "params": {
            "PlaylistId": "the playlist we are updating the population for",
            "NumPlayers": "the number of players on this host in this playlist"
          }
        },
        "UploadGameplayEventsData": {
          "comment": "Sends gameplay event data to MCP",
          "params": {
            "UniqueId": "the player that is sending the stats",
            "Payload": "the stats data to upload"
          }
        },
        "UploadMatchmakingStats": {
          "comment": "Sends matchmaking stats data to MCP",
          "params": {
            "UniqueId": "the unique id for the player",
            "MMStats": "object that contains aggregated matchmaking stats data"
          }
        },
        "UploadPlayerData": {
          "comment": "Sends the profile data to the server for statistics aggregation",
          "params": {
            "UniqueId": "the unique id for the player",
            "PlayerNick": "the player's nick name",
            "ProfileSettings": "the profile object that is being sent",
            "PlayerStorage": "the player storage object that is being sent"
          }
        }
      },
      "structs": {
        "EventUploadConfig": {
          "comment": "Holds the configuration and instance data for event uploading",
          "properties": {
            "bUseCompression": {
              "comment": "Whether to compress the data before sending or not"
            },
            "TimeOut": {
              "comment": "The amount of time to wait before erroring out"
            },
            "UploadType": {
              "comment": "The type of upload this config is for"
            },
            "UploadUrl": {
              "comment": "The URL to send the data to"
            }
          }
        }
      }
    },
    "OnlineGameInterfaceImpl": {
      "comment": "Class that implements a cross platform version of the game interface",
      "properties": {
        "CancelFindOnlineGamesCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game search notification"
        },
        "CreateOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game creation notification"
        },
        "CurrentGameState": {
          "comment": "The current game state as the Live layer understands it"
        },
        "DestroyOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game destruction notification"
        },
        "EndOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game ending notification"
        },
        "FindOnlineGamesCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game search notification"
        },
        "GameSearch": {
          "comment": "The current game search object in use"
        },
        "GameSettings": {
          "comment": "The current game settings object in use"
        },
        "JoinMigratedOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for migrated game join notification"
        },
        "JoinOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game join notification"
        },
        "LanAnnouncePort": {
          "comment": "Port to listen on for LAN queries/responses"
        },
        "LanBeacon": {
          "comment": "LAN announcement socket used to send/receive discovery packets"
        },
        "LanBeaconState": {
          "comment": "The current state the lan beacon is in"
        },
        "LanGameUniqueId": {
          "comment": "Unique id to keep UE3 games from seeing each others' lan packets"
        },
        "LanNonce[8]": {
          "comment": "Used by a client to uniquely identify itself during lan match discovery"
        },
        "LanPacketPlatformMask": {
          "comment": "Mask containing which platforms can cross communicate"
        },
        "LanQueryTimeLeft": {
          "comment": "The amount of time before the lan query is considered done"
        },
        "LanQueryTimeout": {
          "comment": "The amount of time to wait before timing out a lan query request"
        },
        "MigrateOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game migration notification"
        },
        "OwningSubsystem": {
          "comment": "The owning subsystem that this object is providing an implementation for"
        },
        "RecalculateSkillRatingCompleteDelegates": {
          "comment": "Array of delegates to multicast with for skill rating update notification"
        },
        "SessionInfo": {
          "comment": "The session information used to connect to a host"
        },
        "StartOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game starting notification"
        },
        "UpdateOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game update notification"
        }
      },
      "functions": {
        "AcceptGameInvite": {
          "comment": "Tells the online subsystem to accept the game invite that is currently pending",
          "params": {
            "LocalUserNum": "the local user accepting the invite",
            "SessionName": "the name of the session this invite is to be known as"
          }
        },
        "AddArbitrationRegistrationCompleteDelegate": {
          "comment": "Sets the notification callback to use when arbitration registration has completed",
          "params": {
            "ArbitrationRegistrationCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddCancelFindOnlineGamesCompleteDelegate": {
          "comment": "Adds the delegate to the list to notify with",
          "params": {
            "CancelFindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddCreateOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game they\n created has completed the creation process",
          "params": {
            "CreateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddDestroyOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game they\n destroyed has completed the destruction process",
          "params": {
            "DestroyOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddEndOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game has\n transitioned to the ending state.",
          "params": {
            "EndOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFindOnlineGamesCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the search they\n kicked off has completed",
          "params": {
            "FindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddGameInviteAcceptedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code when a game invite has been accepted",
          "params": {
            "LocalUserNum": "the user to request notification for",
            "GameInviteAcceptedDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinMigratedOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the join request for a migrated session they\n kicked off has completed",
          "params": {
            "JoinMigratedOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the join request they\n kicked off has completed",
          "params": {
            "JoinOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddMigrateOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code when the session migration completes",
          "params": {
            "MigrateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddQosStatusChangedDelegate": {
          "comment": "Adds a delegate to the list of objects that want to be notified",
          "params": {
            "QosStatusChangedDelegate": "the delegate to use for notifications"
          }
        },
        "AddRecalculateSkillRatingCompleteDelegate": {
          "comment": "Adds a delegate to the list of objects that want to be notified",
          "params": {
            "RecalculateSkillRatingCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddRegisterPlayerCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the player\n registration request they submitted has completed",
          "params": {
            "RegisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddStartOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game has\n transitioned to the started state.",
          "params": {
            "StartOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddUnregisterPlayerCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the player\n unregistration request they submitted has completed",
          "params": {
            "UnregisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddUpdateOnlineGameCompleteDelegate": {
          "comment": "Adds a delegate to the list of objects that want to be notified",
          "params": {
            "UpdateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "BindPlatformSpecificSessionToSearch": {
          "comment": "Creates a search result out of the platform specific data and adds that to the specified search object",
          "params": {
            "SearchingPlayerNum": "the index of the player searching for a match",
            "SearchSettings": "the desired search to bind the session to",
            "PlatformSpecificInfo": "the platform specific information to convert to a server object"
          }
        },
        "CancelFindOnlineGames": {
          "comment": "Cancels the current search in progress if possible for that search type"
        },
        "ClearArbitrationRegistrationCompleteDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "ArbitrationRegistrationCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearCancelFindOnlineGamesCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "CancelFindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearCreateOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game they\n created has completed the creation process",
          "params": {
            "CreateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearDestroyOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the notification list",
          "params": {
            "DestroyOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearEndOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "EndOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFindOnlineGamesCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "FindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearGameInviteAcceptedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the user to request notification for",
            "GameInviteAcceptedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinMigratedOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "JoinMigratedOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "JoinOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearMigrateOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "MigrateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearQosStatusChangedDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "QosStatusChangedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRecalculateSkillRatingCompleteDelegate": {
          "comment": "Removes a delegate from the list of objects that want to be notified",
          "params": {
            "RecalculateSkillRatingCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRegisterPlayerCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "RegisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearStartOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "StartOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearUnregisterPlayerCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "UnregisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearUpdateOnlineGameCompleteDelegate": {
          "comment": "Removes a delegate from the list of objects that want to be notified",
          "params": {
            "UpdateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "CreateOnlineGame": {
          "comment": "Creates an online game based upon the settings object specified.\n NOTE: online game registration is an async process and does not complete\n until the OnCreateOnlineGameComplete delegate is called.",
          "params": {
            "HostingPlayerNum": "the index of the player hosting the match",
            "SessionName": "the name to use for this session so that multiple sessions can exist at the same time",
            "NewGameSettings": "the settings to use for the new game session"
          }
        },
        "DestroyOnlineGame": {
          "comment": "Destroys the current online game\n NOTE: online game de-registration is an async process and does not complete\n until the OnDestroyOnlineGameComplete delegate is called.",
          "params": {
            "SessionName": "the name of the session to delete"
          }
        },
        "EndOnlineGame": {
          "comment": "Marks an online game as having been ended",
          "params": {
            "SessionName": "the name of the session the to end"
          }
        },
        "FindOnlineGames": {
          "comment": "Searches for games matching the settings specified",
          "params": {
            "SearchingPlayerNum": "the index of the player searching for a match",
            "SearchSettings": "the desired settings that the returned sessions will have"
          }
        },
        "FreeSearchResults": {
          "comment": "Cleans up any platform specific allocated data contained in the search results",
          "params": {
            "Search": "the object to free search results for"
          }
        },
        "GetArbitratedPlayers": {
          "comment": "Returns the list of arbitrated players for the arbitrated session",
          "params": {
            "SessionName": "the name of the session to get the arbitration results for"
          }
        },
        "GetGameSearch": {
          "comment": "Returns the currently set game search object"
        },
        "GetGameSettings": {
          "comment": "Returns the game settings object for the session with a matching name",
          "params": {
            "SessionName": "the name of the session to return"
          }
        },
        "GetResolvedConnectString": {
          "comment": "Returns the platform specific connection information for joining the match.\n Call this function from the delegate of join completion",
          "params": {
            "SessionName": "the name of the session to fetch the connection information for",
            "ConnectInfo": "the out var containing the platform specific connection information"
          }
        },
        "JoinMigratedOnlineGame": {
          "comment": "Joins the migrated game specified",
          "params": {
            "PlayerNum": "the index of the player about to join a match",
            "SessionName": "the name of the migrated session to join",
            "DesiredGame": "the desired migrated game to join"
          }
        },
        "JoinOnlineGame": {
          "comment": "Joins the game specified",
          "params": {
            "PlayerNum": "the index of the player searching for a match",
            "SessionName": "the name of the session to join",
            "DesiredGame": "the desired game to join"
          }
        },
        "MigrateOnlineGame": {
          "comment": "Migrates an existing online game on the host.\n NOTE: online game migration is an async process and does not complete\n until the OnMigrateOnlineGameComplete delegate is called.",
          "params": {
            "HostingPlayerNum": "the index of the player now hosting the match",
            "SessionName": "the name of the existing session to migrate"
          }
        },
        "QueryNonAdvertisedData": {
          "comment": "Fetches the additional data a session exposes outside of the online service.\n NOTE: notifications will come from the OnFindOnlineGamesComplete delegate",
          "params": {
            "StartAt": "the search result index to start gathering the extra information for",
            "NumberToQuery": "the number of additional search results to get the data for"
          }
        },
        "ReadPlatformSpecificSessionInfo": {
          "comment": "Serializes the platform specific data into the provided buffer for the specified search result",
          "params": {
            "DesiredGame": "the game to copy the platform specific data for",
            "PlatformSpecificInfo": "the buffer to fill with the platform specific information"
          }
        },
        "ReadPlatformSpecificSessionInfoBySessionName": {
          "comment": "Serializes the platform specific data into the provided buffer for the specified settings object.\n NOTE: This can only be done for a session that is bound to the online system",
          "params": {
            "GameSettings": "the game to copy the platform specific data for",
            "PlatformSpecificInfo": "the buffer to fill with the platform specific information"
          }
        },
        "RecalculateSkillRating": {
          "comment": "Updates the current session's skill rating using the list of players' skills",
          "params": {
            "SessionName": "the name of the session to update the skill rating for",
            "Players": "the set of players to use in the skill calculation"
          }
        },
        "RegisterForArbitration": {
          "comment": "Tells the game to register with the underlying arbitration server if available",
          "params": {
            "SessionName": "the name of the session to register for arbitration with"
          }
        },
        "RegisterPlayer": {
          "comment": "Registers a player with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "UniquePlayerId": "the player to register with the online service",
            "bWasInvited": "whether the player was invited to the game or searched for it"
          }
        },
        "RegisterPlayers": {
          "comment": "Registers a group of players with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "Players": "the list of players to register with the online service"
          }
        },
        "StartOnlineGame": {
          "comment": "Marks an online game as in progress (as opposed to being in lobby or pending)",
          "params": {
            "SessionName": "the name of the session that is being started"
          }
        },
        "UnregisterPlayer": {
          "comment": "Unregisters a player with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is leaving",
            "PlayerId": "the player to unregister with the online service"
          }
        },
        "UnregisterPlayers": {
          "comment": "Unregisters a group of players with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "Players": "the list of players to unregister with the online service"
          }
        },
        "UpdateOnlineGame": {
          "comment": "Updates the localized settings/properties for the game in question. Updates\n the QoS packet if needed (starting & restarting QoS).",
          "params": {
            "SessionName": "the name of the session to update",
            "UpdatedGameSettings": "the object to update the game settings with",
            "bShouldRefreshOnlineData": "whether to submit the data to the backend or not"
          }
        }
      }
    },
    "OnlineNewsInterfaceMcp": {
      "comment": "Provides an in game news mechanism via the MCP backend",
      "properties": {
        "bNeedsTicking": {
          "comment": "Whether there are outstanding requests that need ticking or not"
        },
        "NewsItems": {
          "comment": "The list of cached news items (ips, results, etc.)"
        },
        "ReadNewsDelegates": {
          "comment": "The list of delegates to notify when the news read is complete"
        }
      },
      "functions": {
        "AddReadNewsCompletedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that news reading has completed",
          "params": {
            "ReadGameNewsDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadNewsCompletedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "ReadGameNewsDelegate": "the delegate to use for notifications"
          }
        },
        "GetNews": {
          "comment": "Returns the game specific news item from the cache",
          "params": {
            "LocalUserNum": "the local user the news is being read for",
            "NewsType": "the type of news to read"
          }
        },
        "ReadNews": {
          "comment": "Reads the game specific news from the online subsystem",
          "params": {
            "LocalUserNum": "the local user the news is being read for",
            "NewsType": "the type of news to read"
          }
        }
      },
      "structs": {
        "NewsCacheEntry": {
          "comment": "Holds the IP, hostname, URL, and news results for a particular news type",
          "properties": {
            "bIsUnicode": {
              "comment": "Whether the news item is in unicode or ansi"
            },
            "HttpDownloader": {
              "comment": "Pointer to the native helper object that performs the download"
            },
            "NewsItem": {
              "comment": "The results of the read"
            },
            "NewsType": {
              "comment": "The type of news that we are reading"
            },
            "NewsUrl": {
              "comment": "The URL to the news page that we're reading"
            },
            "ReadState": {
              "comment": "The current async read state for the operation"
            },
            "TimeOut": {
              "comment": "The amount of time before giving up on the read"
            }
          }
        }
      }
    },
    "OnlinePlaylistManager": {
      "comment": "This class holds the set of playlists that the game exposes, handles\n downloading updates to the playlists via MCP/TitleFiles, and creates the\n game settings objects that make up a playlist",
      "properties": {
        "CurrentPlaylistId": {
          "comment": "The playlist id that is being played"
        },
        "DataCenterFileName": {
          "comment": "The name of the datacenter file to request"
        },
        "DataCenterId": {
          "comment": "The datacenter id to use for this machine"
        },
        "DatastoresToRefresh": {
          "comment": "The set of UIDataStore_GameResource objects to refresh once the download has completed"
        },
        "DownloadCount": {
          "comment": "Used to know when we should finalize the objects"
        },
        "EventsInterfaceName": {
          "comment": "The name of the interface to request as our upload object"
        },
        "MinPlaylistIdToReport": {
          "comment": "The lowest number playlist id to report to the backend. Used to turn off \"not mp\" playlist ids"
        },
        "NextPlaylistPopulationUpdateTime": {
          "comment": "The next time the playlist population data needs to be sent"
        },
        "PlaylistFileNames": {
          "comment": "The file names to request when downloading a playlist from MCP/TMS/etc"
        },
        "PlaylistPopulationUpdateInterval": {
          "comment": "How often (in seconds) we should update the population data"
        },
        "Playlists": {
          "comment": "This is the complete set of playlists available to choose from"
        },
        "PopulationData": {
          "comment": "The list of playlists and the number of players in them"
        },
        "PopulationFileName": {
          "comment": "The name of the population data file to request"
        },
        "RegionTotalPlayers": {
          "comment": "The total number of players across all playlists in the region"
        },
        "SuccessfulCount": {
          "comment": "Incremented when successful to determine whether to update at all"
        },
        "TitleFileInterface": {
          "comment": "Cached object ref that we use for accessing the TitleFileInterface"
        },
        "VersionNumber": {
          "comment": "The version number of the playlist that was downloaded"
        },
        "WorldwideTotalPlayers": {
          "comment": "The total number of players across all playlists worldwide"
        }
      },
      "functions": {
        "DetermineFilesToDownload": {
          "comment": "Uses the current loc setting and game ini name to build the download list"
        },
        "DownloadPlaylist": {
          "comment": "Reads the playlist from either MCP or from some form of title storage"
        },
        "FinalizePlaylistObjects": {
          "comment": "Uses the configuration data to create the requested objects and then applies any\n specific game settings changes to them"
        },
        "GetContentIdsFromPlaylist": {
          "comment": "Finds the specified playlist and return the content ids in the out var",
          "params": {
            "PlaylistId": "the playlist being searched for",
            "ContentIds": "the list to set the content ids in"
          }
        },
        "GetGameSettings": {
          "comment": "Finds the game settings object associated with this playlist and game settings id",
          "params": {
            "PlaylistId": "the playlist we are searching",
            "GameSettingsId": "the game settings id being searched for"
          }
        },
        "GetInventorySwapFromPlaylist": {
          "comment": "Searches for a per playlist inventory swap",
          "params": {
            "PlaylistId": "the playlist we are checking for swaps in",
            "SourceInventory": "the source item we are checking for swapping"
          }
        },
        "GetLoadBalanceIdFromPlaylist": {
          "comment": "Determine the load balance id for the specified playlist and returns it in the out vars.\n The load balance id can be used to change the match mode during a search.",
          "params": {
            "PlaylistId": "the playlist being searched for",
            "LoadBalanceId": "out var getting the id for load balancing"
          }
        },
        "GetMapCycleFromPlaylist": {
          "comment": "Finds the specified playlist and returns the map cycle for it",
          "params": {
            "PlaylistId": "the playlist being searched for",
            "MapCycle": "the out var that gets the map cycle"
          }
        },
        "GetMatchType": {
          "comment": "Determine if the given playlist entry is arbitrated or not",
          "params": {
            "PlaylistId": "the playlist being searched for"
          }
        },
        "GetPopulationInfoFromPlaylist": {
          "comment": "Finds the population information for the specified playlist and returns it in the out vars",
          "params": {
            "PlaylistId": "the playlist being searched for",
            "WorldwideTotal": "out var getting the number of players worldwide",
            "RegionTotal": "out var getting the number of players in this region"
          }
        },
        "GetTeamInfoFromPlaylist": {
          "comment": "Finds the team information for the specified playlist and returns it in the out vars",
          "params": {
            "PlaylistId": "the playlist being searched for",
            "TeamSize": "out var getting the number of players per team",
            "TeamCount": "out var getting the number of teams per match",
            "MaxPartySize": "out var getting the number of players per party"
          }
        },
        "GetUrlFromPlaylist": {
          "comment": "Finds the specified playlist and returns any additional URL options",
          "params": {
            "PlaylistId": "the playlist being searched for"
          }
        },
        "HasAnyGameSettings": {
          "comment": "Determine if any game settings exist for the given playlistid",
          "params": {
            "PlaylistId": "playlist to check for game settings"
          }
        },
        "IsPlaylistArbitrated": {
          "comment": "Determine if the given playlist entry is arbitrated or not",
          "params": {
            "PlaylistId": "the playlist being searched for"
          }
        },
        "OnReadDataCenterIdComplete": {
          "comment": "Notifies us when the download of a file is complete",
          "params": {
            "bWasSuccessful": "true if the download completed ok, false otherwise",
            "FileName": "the file that was downloaded (or failed to)"
          }
        },
        "OnReadPlaylistPopulationComplete": {
          "comment": "Notifies us when the download of a file is complete",
          "params": {
            "bWasSuccessful": "true if the download completed ok, false otherwise",
            "FileName": "the file that was downloaded (or failed to)"
          }
        },
        "OnReadTitleFileComplete": {
          "comment": "Notifies us when the download of the playlist file is complete",
          "params": {
            "bWasSuccessful": "true if the download completed ok, false otherwise",
            "FileName": "the file that was downloaded (or failed to)"
          }
        },
        "ParseDataCenterId": {
          "comment": "Converts the data into the datacenter id",
          "params": {
            "Data": "the data that was downloaded"
          }
        },
        "ParsePlaylistPopulationData": {
          "comment": "Converts the data into the structure used by the playlist manager",
          "params": {
            "Data": "the data that was downloaded"
          }
        },
        "ReadDataCenterId": {
          "comment": "Asks the network backend which datacenter this machine is to use"
        },
        "ReadPlaylistPopulation": {
          "comment": "Reads the player population data for playlists by region"
        },
        "Reset": {
          "comment": "Allows the playlists to be re-requested from the server"
        },
        "SendPlaylistPopulationUpdate": {
          "comment": "Called once enough time has elapsed that a playlist update is required",
          "params": {
            "NumPlayers": "the numbers of players to report (easier to get at in native)"
          }
        }
      },
      "structs": {
        "ConfiguredGameSetting": {
          "comment": "Contains a game settings class name to load and instance using the specified URL to override defaults",
          "properties": {
            "GameSettingId": {
              "comment": "The unique (within the playlist) id for this game setting"
            },
            "GameSettings": {
              "comment": "Holds the object that was created for this entry in a playlist"
            },
            "GameSettingsClassName": {
              "comment": "The name of the class to load and instance"
            },
            "Url": {
              "comment": "The URL to use to replace settings with (see UpdateFromURL())"
            }
          }
        },
        "InventorySwap": {
          "comment": "Allows for per playlist inventory swapping",
          "properties": {
            "Original": {
              "comment": "The inventory to replace"
            },
            "SwapTo": {
              "comment": "The inventory to replace it with"
            }
          }
        },
        "Playlist": {
          "comment": "A playlist contains 1 or more game configurations that players can choose between",
          "properties": {
            "bDisableDedicatedServerSearches": {
              "comment": "Whether dedicated server searches are supported with this playlist"
            },
            "ConfiguredGames": {
              "comment": "Holds the list of game configurations that are part of this playlist"
            },
            "ContentIds": {
              "comment": "The set of content/maps (or DLC bundles) that must be present in order to play on this playlist"
            },
            "InventorySwaps": {
              "comment": "The list of inventory swaps for the playlist"
            },
            "LoadBalanceId": {
              "comment": "The load balance id for this playlist"
            },
            "LocalizationString": {
              "comment": "The string to use to lookup the display name for this playlist"
            },
            "MapCycle": {
              "comment": "The custom map cycle for this playlist"
            },
            "MatchType": {
              "comment": "The type of match this is (ranked, player, recreational, whatever you want)"
            },
            "MaxPartySize": {
              "comment": "The max party size for this playlist if different from the team size"
            },
            "Name": {
              "comment": "The string to use in the UI for this playlist"
            },
            "PlaylistId": {
              "comment": "The unique id for this playlist"
            },
            "TeamCount": {
              "comment": "The number of teams per match if different from the defaults"
            },
            "TeamSize": {
              "comment": "The number of players per team if different from the defaults"
            },
            "Url": {
              "comment": "URL to append to the MP options in GameInfo.InitGame()"
            }
          }
        },
        "PlaylistPopulation": {
          "comment": "Holds the overall and per region playlist population numbers",
          "properties": {
            "PlaylistId": {
              "comment": "The unique id for this playlist"
            },
            "RegionTotal": {
              "comment": "The total for the player's region"
            },
            "WorldwideTotal": {
              "comment": "The total across all regions"
            }
          }
        }
      }
    },
    "OnlinePlaylistProvider": {
      "comment": "Per object config provider that exposes dynamic playlists to the UI system",
      "properties": {
        "DisplayName": {
          "comment": "Localized display name for the playlist"
        },
        "PlaylistGameTypeNames": {
          "comment": "List of the names of the OnlinePlaylistGameTypeProvider for the game modes supported by this playlist"
        },
        "PlaylistId": {
          "comment": "Unique identifier for this Playlist"
        },
        "Priority": {
          "comment": "Value to determine sorting priority (highest is first in the list)"
        }
      }
    },
    "OnlineSubsystemCommonImpl": {
      "comment": "Class that implements commonly needed members/features across all platforms",
      "properties": {
        "bIsUsingSpeechRecognition": {
          "comment": "Whether speech recognition is enabled"
        },
        "GameInterfaceImpl": {
          "comment": "The object that handles the game interface implementation across platforms"
        },
        "MaxLocalTalkers": {
          "comment": "Holds the maximum number of local talkers allowed"
        },
        "MaxRemoteTalkers": {
          "comment": "Holds the maximum number of remote talkers allowed (clamped to 30 which is XHV max)"
        },
        "VoiceEngine": {
          "comment": "Holds the pointer to the platform specific FVoiceInterface implementation\n used for voice communication"
        }
      },
      "functions": {
        "GetPlayerNicknameFromIndex": {
          "comment": "Returns the name of the player for the specified index",
          "params": {
            "UserIndex": "the user to return the name of"
          }
        },
        "GetPlayerUniqueNetIdFromIndex": {
          "comment": "Returns the unique id of the player for the specified index",
          "params": {
            "UserIndex": "the user to return the id of"
          }
        },
        "GetRegisteredPlayers": {
          "comment": "Get a list of the net ids for the players currently registered on the session",
          "params": {
            "SessionName": "name of the session to find",
            "OutRegisteredPlayers": "[out] list of player net ids in the session (empty if not found)"
          }
        },
        "IsPlayerInSession": {
          "comment": "Determine if the player is registered in the specified session",
          "params": {
            "PlayerId": "the player to check if in session or not"
          }
        }
      }
    },
    "OnlineTitleFileDownloadMcp": {
      "comment": "Provides a mechanism for downloading arbitrary files from the MCP server",
      "properties": {
        "BaseUrl": {
          "comment": "The base URL to use when downloading files, such that BaseUrl?TitleID=1234&FileName=MyFile.ini is the complete URL"
        },
        "DownloadCount": {
          "comment": "The number of files in the array being processed"
        },
        "FilesToUrls": {
          "comment": "The routing table to look in when trying to find special URL handlers"
        },
        "ReadTitleFileCompleteDelegates": {
          "comment": "The list of delegates to notify when a file is read"
        },
        "TimeOut": {
          "comment": "The amount of time to allow for downloading of the file"
        },
        "TitleFiles": {
          "comment": "The list of title files that have been read or are being read"
        }
      },
      "functions": {
        "AddReadTitleFileCompleteDelegate": {
          "comment": "Adds the delegate to the list to be notified when a requested file has been read",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to add"
          }
        },
        "ClearDownloadedFile": {
          "comment": "Empties the cached data for this file if it is not being downloaded currently",
          "params": {
            "FileName": "the name of the file to remove from the cache"
          }
        },
        "ClearDownloadedFiles": {
          "comment": "Empties the set of downloaded files if possible (no async tasks outstanding)"
        },
        "ClearReadTitleFileCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to remove"
          }
        },
        "GetTitleFileContents": {
          "comment": "Copies the file data into the specified buffer for the specified file",
          "params": {
            "FileName": "the name of the file to read",
            "FileContents": "the out buffer to copy the data into"
          }
        },
        "GetTitleFileState": {
          "comment": "Determines the async state of the tile file read operation",
          "params": {
            "FileName": "the name of the file to check on"
          }
        },
        "ReadTitleFile": {
          "comment": "Starts an asynchronous read of the specified file from the network platform's\n title specific file store",
          "params": {
            "FileToRead": "the name of the file to read"
          }
        }
      },
      "structs": {
        "FileNameToURLMapping": {
          "comment": "Allows the game to route a specific file or sets of files to a specific URL. If there is no special mapping for a file, then the base URL is used",
          "properties": {
            "FileName": {
              "comment": "The name of the file to route to a specific URL"
            },
            "UrlMapping": {
              "comment": "The URL to route the request to"
            }
          }
        },
        "TitleFileMcp": {
          "comment": "Struct that matches one download object per file for parallel downloading",
          "properties": {
            "HttpDownloader": {
              "comment": "The class that will communicate with backend to download the file"
            }
          }
        }
      }
    },
    "PartyBeacon": {
      "comment": "This class is the base class for the client/host beacon classes.",
      "properties": {
        "BeaconName": {
          "comment": "The name to use when logging (helps debugging)"
        },
        "bIsInTick": {
          "comment": "Used to determine whether to use deferred destruction or not"
        },
        "bShouldTick": {
          "comment": "Whether to the socket(s) or not (not during travel)"
        },
        "bWantsDeferredDestroy": {
          "comment": "True if the beacon should be destroyed at the end of the tick"
        },
        "ElapsedHeartbeatTime": {
          "comment": "The elapsed time that has passed since the last heartbeat"
        },
        "HeartbeatTimeout": {
          "comment": "The maximum amount of time to pass between heartbeat packets being sent"
        },
        "PartyBeaconPort": {
          "comment": "The port that the party beacon will listen on"
        },
        "Socket": {
          "comment": "The object that is used to send/receive data with the remote host/client"
        }
      },
      "functions": {
        "DestroyBeacon": {
          "comment": "Stops listening for requests/responses and releases any allocated memory"
        }
      },
      "structs": {
        "PartyReservation": {
          "comment": "Holds information about a party that has reserved space in the session",
          "properties": {
            "PartyLeader": {
              "comment": "The party leader that has requested a reservation"
            },
            "PartyMembers": {
              "comment": "The list of members of the party (includes the party leader)"
            },
            "TeamNum": {
              "comment": "The team this party was assigned to"
            }
          }
        },
        "PlayerReservation": {
          "comment": "A player that has/is requesting a reservation",
          "properties": {
            "ElapsedSessionTime": {
              "comment": "Seconds since we checked to see if the player reservation exists in the session"
            },
            "Mu": {
              "comment": "The raw skill value"
            },
            "NetId": {
              "comment": "The unique identifier for this player"
            },
            "Sigma": {
              "comment": "The uncertainty of that raw skill value"
            },
            "Skill": {
              "comment": "The skill of the player"
            },
            "XpLevel": {
              "comment": "The player experience level"
            }
          }
        }
      }
    },
    "PartyBeaconClient": {
      "comment": "This class is used to connect to a network beacon in order to request\n a reservation for their party with that host",
      "properties": {
        "ClientBeaconRequestType": {
          "comment": "The pending request to be sent"
        },
        "ClientBeaconState": {
          "comment": "The state of the client beacon"
        },
        "HostPendingRequest": {
          "comment": "Holds a reference to the data that is used to reach the potential host"
        },
        "PendingRequest": {
          "comment": "The request to send once the socket is established"
        },
        "ReservationRequestElapsedTime": {
          "comment": "Used to track how long we've been waiting for a response"
        },
        "ReservationRequestTimeout": {
          "comment": "Indicates how long the client should wait for a response before timing out and trying a new server"
        },
        "Resolver": {
          "comment": "Platform specific address resolver for this beacon. Instantiated using the ResolverClass type."
        },
        "ResolverClass": {
          "comment": "Class to use for address resolving and registering"
        },
        "ResolverClassName": {
          "comment": "Name of the class to use for address resolving and registering"
        }
      },
      "functions": {
        "CancelReservation": {
          "comment": "Sends a cancellation message to the remote host so that it knows there is more\n space available",
          "params": {
            "CancellingPartyLeader": "the leader of this party that wants to cancel"
          }
        },
        "DestroyBeacon": {
          "comment": "Stops listening for requests/responses and releases any allocated memory"
        },
        "RequestReservation": {
          "comment": "Sends a request to the remote host to allow the specified members to reserve space\n in the host's session. Note this request is async and the results will be sent via\n the delegate",
          "params": {
            "DesiredHost": "the server that the connection will be made to",
            "RequestingPartyLeader": "the leader of this party that will be joining",
            "Players": "the list of players that want to reserve space"
          }
        },
        "RequestReservationUpdate": {
          "comment": "Sends a request to the remote host to update an existing reservation for the\n specified party leader. Any new players not already in the party leader's reservation\n will be added to that reservation on the host. Host sends a EPartyReservationResult back.",
          "params": {
            "DesiredHost": "the server that the connection will be made to",
            "RequestingPartyLeader": "party leader that will be updating his existing reservation",
            "PlayersToAdd": "the list of players that want to reserve space in an existing reservation"
          }
        }
      }
    },
    "PartyBeaconHost": {
      "comment": "This class is used to create a network accessible beacon for responding\n to reservation requests for party matches. It handles all tracking of\n who has reserved space, how much space is available, and how many parties\n can reserve space.",
      "properties": {
        "bBestFitTeamAssignment": {
          "comment": "Force new reservations to teams with the smallest accommodating need size, otherwise team assignment is random"
        },
        "BeaconState": {
          "comment": "Current state of the beacon wrt allowing reservation requests"
        },
        "Clients": {
          "comment": "The object that is used to send/receive data with the remote host/client"
        },
        "ConnectionBacklog": {
          "comment": "The number of connections to allow before refusing them"
        },
        "ForceTeamNum": {
          "comment": "Team to force all reservations to in single team situations"
        },
        "NumConsumedReservations": {
          "comment": "The number of slots that have been consumed by parties in total (saves having to iterate and sum)"
        },
        "NumPlayersPerTeam": {
          "comment": "The number of players required for a full team"
        },
        "NumReservations": {
          "comment": "The number of players that are allowed to reserve space"
        },
        "NumTeams": {
          "comment": "The number of teams that these players will be divided amongst"
        },
        "OnlineSessionName": {
          "comment": "The online session name that players will register with"
        },
        "Reservations": {
          "comment": "The list of accepted reservations"
        },
        "ReservedHostTeamNum": {
          "comment": "The team the host (owner of the beacon) is assigned to when random teams are chosen"
        }
      },
      "functions": {
        "AddPartyReservationEntry": {
          "comment": "Add a new party to the reservation list.\n Avoids adding duplicate entries based on party leader.",
          "params": {
            "PartyLeader": "the party leader that is adding the reservation",
            "PlayerMembers": "players (including party leader) being added to the reservation",
            "TeamNum": "team assignment of the new party",
            "bIsHost": "treat the party as the game host"
          }
        },
        "AppendReservationSkillsToSearch": {
          "comment": "Appends the skills from all reservations to the search object so that they can\n be included in the search information",
          "params": {
            "Search": "the search object to update"
          }
        },
        "AreReservationsFull": {
          "comment": "Determine if the beacon has filled all open reservation slots"
        },
        "DestroyBeacon": {
          "comment": "Stops listening for clients and releases any allocated memory"
        },
        "DumpReservations": {
          "comment": "Logs the reservation information for this beacon"
        },
        "GetExistingReservation": {
          "comment": "Find an existing reservation for the party leader",
          "params": {
            "PartyLeader": "the party leader to find a reservation entry for"
          }
        },
        "GetMaxAvailableTeamSize": {
          "comment": "Determine the maximum team size that can be accommodated based \n on the current reservation slots occupied."
        },
        "GetPartyLeaders": {
          "comment": "Gathers all the unique ids for party leaders that have reservations"
        },
        "GetPlayers": {
          "comment": "Gathers all the unique ids for players that have reservations"
        },
        "HandlePlayerLogout": {
          "comment": "Called when a player logs out of the current game. The player's \n party reservation entry is freed up so that a new reservation request\n can be accepted.",
          "params": {
            "PlayerId": "the net Id of the player that just logged out",
            "bMaintainParty": "if TRUE then preserve party members of a reservation when the party leader logs out"
          }
        },
        "InitHostBeacon": {
          "comment": "Creates a listening host beacon with the specified number of parties, players, and\n the session name that remote parties will be registered under",
          "params": {
            "InNumTeams": "the number of teams that are expected to join",
            "InNumPlayersPerTeam": "the number of players that are allowed to be on each team",
            "InNumReservations": "the total number of players to allow to join (if different than team * players)",
            "InSessionName": "the name of the session to add the players to when a reservation occurs",
            "InForceTeamNum": "the team to force to (only single team situations)"
          }
        },
        "PauseReservationRequests": {
          "comment": "Pauses new reservation request on the beacon",
          "params": {
            "bPause": "if true then new reservation requests are denied"
          }
        },
        "RegisterPartyMembers": {
          "comment": "Registers all of the parties as part of the session that this beacon is associated with"
        },
        "TellClientsHostHasCancelled": {
          "comment": "Tells all of the clients that the host has cancelled the matchmaking beacon and that they\n need to find a different host"
        },
        "TellClientsHostIsReady": {
          "comment": "Tells all of the clients that the host is ready for them to travel to the host connection"
        },
        "TellClientsToTravel": {
          "comment": "Tells all of the clients to go to a specific session (contained in platform\n specific info). Used to route clients that aren't in the same party to one destination.",
          "params": {
            "SessionName": "the name of the session to register",
            "SearchClass": "the search that should be populated with the session",
            "PlatformSpecificInfo": "the binary data to place in the platform specific areas"
          }
        },
        "UnregisterParty": {
          "comment": "Unregisters each of the party members that have the specified party leader",
          "params": {
            "PartyLeader": "the leader to search for in the reservation array"
          }
        },
        "UnregisterPartyMembers": {
          "comment": "Unregisters each of the party members at the specified reservation with the session"
        },
        "UpdatePartyReservationEntry": {
          "comment": "Update a party with an existing reservation\n Avoids adding duplicate entries to the player members of a party.",
          "params": {
            "PartyLeader": "the party leader for which the existing reservation entry is being updated",
            "PlayerMembers": "players (not including party leader) being added to the existing reservation"
          }
        }
      },
      "structs": {
        "ClientBeaconConnection": {
          "comment": "Holds the information for a client and whether they've timed out",
          "properties": {
            "ElapsedHeartbeatTime": {
              "comment": "How long it's been since the last heartbeat"
            },
            "PartyLeader": {
              "comment": "The unique id of the party leader for this connection"
            },
            "Socket": {
              "comment": "The socket this client is communicating on"
            }
          }
        }
      }
    },
    "UIDataStore_OnlinePlaylists": {
      "properties": {
        "PlaylistMan": {
          "comment": "The playlist to query about match details"
        },
        "PrivateDataProviders": {
          "comment": "Cached array of perobjectconfig data providers for playlists determined to be \"private\""
        },
        "ProviderClass": {
          "comment": "Class reference for the above provider class name"
        },
        "ProviderClassName": {
          "comment": "Name of provider class associated with this data store (uses them and all child classes)"
        },
        "RankedDataProviders": {
          "comment": "Cached array of perobjectconfig data providers for playlists determined to be \"ranked\""
        },
        "RecModeDataProviders": {
          "comment": "Cached array of perobjectconfig data providers for playlists determined to be \"recreational mode\""
        },
        "UnrankedDataProviders": {
          "comment": "Cached array of perobjectconfig data providers for playlists determined to be \"unranked\""
        }
      },
      "functions": {
        "FindProviderIndexByFieldValue": {
          "comment": "Searches for resource provider instance that has a field with a value that matches the value specified.",
          "params": {
            "ProviderTag": "the name of the provider type; should match the ProviderTag value of an element in the ElementProviderTypes array.",
            "SearchField": "the name of the field within the provider type to compare the value to; should be one of the elements retrieved from a call\n to GetResourceProviderFields.",
            "ValueToSearchFor": "the field value to search for."
          }
        },
        "GetMatchTypeForPlaylistId": {
          "comment": "Returns the match type for the specified playlist",
          "params": {
            "PlaylistId": "the playlist we are searching for"
          }
        },
        "GetOnlinePlaylistProvider": {
          "comment": "Returns the OnlinePlaylistProvider with the corresponding PlaylistId"
        },
        "GetPlaylistProvider": {
          "comment": "Searches for resource provider instance given its associated provider tag and an index within that subset",
          "params": {
            "ProviderTag": "the name of the provider type; should match the ranked or unranked provider tag",
            "SearchField": "the index of the provider within the provider subset specified by the ProviderTag",
            "out_Provider": "the resource provider instance found"
          }
        },
        "GetProviderCount": {
          "comment": "Get the number of UIResourceDataProvider instances associated with the specified tag.",
          "params": {
            "ProviderTag": "the tag to find instances for; should match the ProviderTag value of an element in the ElementProviderTypes array."
          }
        },
        "GetProviderFieldValue": {
          "comment": "Get the value of a single field in a specific resource provider instance. Example: GetProviderFieldValue('PlaylistsRanked', 'PlaylistId', 2, FieldValue)",
          "params": {
            "ProviderTag": "the name of the provider type; should match the ProviderTag value of an element in the ElementProviderTypes array.",
            "SearchField": "the name of the field within the provider type to get the value for; should be one of the elements retrieved from a call\n to GetResourceProviderFields.",
            "ProviderIndex": "the index [into the array of providers associated with the specified tag] of the instance to get the value from;\n should be one of the elements retrieved by calling GetResourceProviders().",
            "out_FieldValue": "receives the value of the field"
          }
        },
        "GetResourceProviderFields": {
          "comment": "Get the list of fields supported by the provider type specified.",
          "params": {
            "ProviderTag": "the name of the provider type to get fields for; should match the ProviderTag value of an element in the ElementProviderTypes array.\n If the provider type is expanded (bExpandProviders=true), this tag should also contain the array index of the provider instance\n to use for retrieving the fields (this can usually be automated by calling GenerateProviderAccessTag)",
            "ProviderFieldTags": "receives the list of tags supported by the provider specified."
          }
        },
        "GetResourceProviders": {
          "comment": "Get the UIResourceDataProvider instances associated with the tag.",
          "params": {
            "ProviderTag": "the tag to find instances for; should match the ProviderTag value of an element in the ElementProviderTypes array.",
            "out_Providers": "receives the list of provider instances. this array is always emptied first."
          }
        },
        "Init": {
          "comment": "Grabs the playlist manager"
        }
      }
    },
    "WebResponse": {
      "functions": {
        "AddHeader": {
          "comment": "Add/update a header to the headers list. It will be send at the first possible occasion.\n To completely remove a given header simply give it an empty value, \"X-Header:\"\n To add multiple headers with the same name (need for Set-Cookie) you'll need\n to edit the headers array directly."
        },
        "HTTPHeader": {
          "comment": "Will actually send a header. You should not call this method, queue the headers\n through the AddHeader() method."
        },
        "HTTPResponse": {
          "comment": "Send the HTTP response code."
        },
        "SendHeaders": {
          "comment": "Send the stored headers."
        },
        "SendStandardHeaders": {
          "comment": "Send the standard response headers."
        }
      }
    }
  },
  "OnlineSubsystemGameCenter": {
    "OnlineSubsystemGameCenter": {
      "properties": {
        "CachedFriends": {
          "comment": "List of friends retrieved from the server"
        },
        "CachedProfile": {
          "comment": "The cached profile for the player"
        },
        "CreateOnlineGameDelegates": {
          "comment": "List of callbacks for when a game was created (ie afdter Game Center matchmaking, and you are chosen as the server)"
        },
        "CurrentStatsRead": {
          "comment": "The current stats read object"
        },
        "EndOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game ending notification"
        },
        "EpicUniqueAchievementPrefix": {
          "comment": "Like UniqueAchievementPrefix, except used when EPIC_INTERNAL is 1, useful for Epic overriding values (similar to the Epic_ as seen in iphone packager utility"
        },
        "EpicUniqueCategoryPrefix": {
          "comment": "Like UniqueCategoryPrefix, except used when EPIC_INTERNAL is 1, useful for Epic overriding values (similar to the Epic_ as seen in iphone packager utility"
        },
        "FriendsChangeDelegates": {
          "comment": "The array of delegates that notify that the friends list has changed"
        },
        "GameInviteAcceptedDelegates": {
          "comment": "List of callbacks for when a game invitation was accepted"
        },
        "GameSearch": {
          "comment": "Current game search settings and results"
        },
        "GameSettings": {
          "comment": "The current game settings used when matchmaking into server mode"
        },
        "JoinOnlineGameDelegates": {
          "comment": "List of callbacks for when a game was joined"
        },
        "LoggedInPlayerId": {
          "comment": "The unique id of the logged in player"
        },
        "LoggedInPlayerName": {
          "comment": "The name of the player that is logged in"
        },
        "LoginCancelledDelegates": {
          "comment": "This is the list of requested delegates to fire when a login is cancelled"
        },
        "LoginChangeDelegates": {
          "comment": "Holds the list of delegates to fire when any login changes"
        },
        "LoginFailedDelegates": {
          "comment": "This is the list of requested delegates to fire when a login fails to process"
        },
        "MutingChangeDelegates": {
          "comment": "The array of delegates that notify that the mute list has changed"
        },
        "PlayerLoginStatusDelegates": {
          "comment": "Used for per player index notification of login status changes"
        },
        "ProfileDataDirectory": {
          "comment": "The directory profile data should be stored in"
        },
        "ProfileDataExtension": {
          "comment": "The file extension to use when saving profile data"
        },
        "ReadAchievementsCompleteDelegates": {
          "comment": "The array of delegates for notifying when an achievements list read has completed"
        },
        "ReadFriendsDelegates": {
          "comment": "The array of delegates that notify read completion of the friends list data"
        },
        "ReadFriendsStatus": {
          "comment": "Current read state"
        },
        "ReadOnlineStatsCompleteDelegates": {
          "comment": "The array of delegates that notify that the stats read operation has completed"
        },
        "ReadProfileSettingsDelegates": {
          "comment": "The array of delegates that notify read completion of profile data"
        },
        "TalkingDelegates": {
          "comment": "Holds the list of delegates that are interested in receiving talking notifications"
        },
        "UniqueAchievementPrefix": {
          "comment": "The string prepended to the achievement ID to generate a globally unique achievement identifier (like com.epicgames.mygame.achievement_). It needs to match what you put in iTunes Connect"
        },
        "UniqueCategoryPrefix": {
          "comment": "The string prepended to the view ID to generate a globally unique category identifier (like com.epicgames.mygame.category_). It needs to match what you put in iTunes Connect"
        },
        "UnlockAchievementCompleteDelegates": {
          "comment": "List of callbacks for when a game invitation was accepted"
        },
        "WriteProfileSettingsDelegates": {
          "comment": "The array of delegates that notify write completion of profile data"
        }
      },
      "functions": {
        "AcceptFriendInvite": {
          "comment": "Used to accept a friend invite sent to this player",
          "params": {
            "LocalUserNum": "the user the invite is for",
            "RequestingPlayer": "the player the invite is from",
            "true": "if successful, false otherwise"
          }
        },
        "AcceptGameInvite": {
          "comment": "Tells the online subsystem to accept the game invite that is currently pending",
          "params": {
            "LocalUserNum": "the local user accepting the invite",
            "SessionName": "the name of the session this invite is to be known as"
          }
        },
        "AddAddFriendByNameCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "FriendDelegate": "the delegate to use for notifications"
          }
        },
        "AddArbitrationRegistrationCompleteDelegate": {
          "comment": "Sets the notification callback to use when arbitration registration has completed",
          "params": {
            "ArbitrationRegistrationCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddCancelFindOnlineGamesCompleteDelegate": {
          "comment": "Adds the delegate to the list to notify with",
          "params": {
            "CancelFindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddConnectionStatusChangeDelegate": {
          "comment": "Adds the delegate to the list to be notified when the connection status changes",
          "params": {
            "ConnectionStatusDelegate": "the delegate to add"
          }
        },
        "AddControllerChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the controller state changed",
          "params": {
            "ControllerChangeDelegate": "the delegate to use for notifications"
          }
        },
        "AddCreateOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game they\n created has completed the creation process",
          "params": {
            "CreateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddDestroyOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game they\n destroyed has completed the destruction process",
          "params": {
            "DestroyOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddDeviceSelectionDoneDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has completed\n their device selection",
          "params": {
            "DeviceDelegate": "the delegate to use for notifications"
          }
        },
        "AddEndOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game has\n transitioned to the ending state.",
          "params": {
            "EndOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddExternalUIChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that external UI state\n changed (opened/closed)",
          "params": {
            "ExternalUIDelegate": "the delegate to use for notifications"
          }
        },
        "AddFindOnlineGamesCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the search they\n kicked off has completed",
          "params": {
            "FindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFlushOnlineStatsCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the stats flush has completed",
          "params": {
            "FlushOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriend": {
          "comment": "Sends a friend invite to the specified player",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "NewFriend": "the player to send the friend request to",
            "Message": "the message to display to the recipient"
          }
        },
        "AddFriendByName": {
          "comment": "Sends a friend invite to the specified player nick",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "FriendName": "the name of the player to send the invite to",
            "Message": "the message to display to the recipient"
          }
        },
        "AddFriendInviteReceivedDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "InviteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriendMessageReceivedDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "MessageDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriendsChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a friends list changed",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "AddGameInviteAcceptedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code when a game invite has been accepted",
          "params": {
            "LocalUserNum": "the user to request notification for",
            "GameInviteAcceptedDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinFriendGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify when the join friend is complete",
          "params": {
            "JoinFriendGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinMigratedOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the join request for a migrated session they\n kicked off has completed",
          "params": {
            "JoinMigratedOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the join request they\n kicked off has completed",
          "params": {
            "JoinOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddKeyboardInputDoneDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has completed\n their keyboard input",
          "params": {
            "InputDelegate": "the delegate to use for notifications"
          }
        },
        "AddLinkStatusChangeDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that link status changed",
          "params": {
            "LinkStatusDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginCancelledDelegate": {
          "comment": "Adds a delegate to the list of delegates that are fired when a login is cancelled",
          "params": {
            "CancelledDelegate": "the delegate to add to the list"
          }
        },
        "AddLoginChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login changed",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "whether to watch for changes on a specific slot or all slots"
          }
        },
        "AddLoginFailedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login failed",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginStatusChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login status has changed",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "the player to watch login status changes for"
          }
        },
        "AddLogoutCompletedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a logout completed",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LogoutDelegate": "the delegate to use for notifications"
          }
        },
        "AddMigrateOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code when the session migration completes",
          "params": {
            "MigrateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddMutingChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a muting list changed",
          "params": {
            "MutingDelegate": "the delegate to use for notifications"
          }
        },
        "AddPlayerTalkingDelegate": {
          "comment": "Adds a talker delegate to the list of notifications",
          "params": {
            "TalkerDelegate": "the delegate to call when a player is talking"
          }
        },
        "AddProfileDataChangedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that someone has changed their profile data externally",
          "params": {
            "LocalUserNum": "the user the delegate is interested in",
            "ProfileDataChangedDelegate": "the delegate to use for notifications"
          }
        },
        "AddQosStatusChangedDelegate": {
          "comment": "Adds a delegate to the list of objects that want to be notified",
          "params": {
            "QosStatusChangedDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadAchievementsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to read the achievements list for",
            "ReadAchievementsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadFriendsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the friends read request has completed",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "ReadFriendsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadOnlineStatsCompleteDelegate": {
          "comment": "Adds the delegate to a list used to notify the gameplay code that the stats read has completed",
          "params": {
            "ReadOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadPlayerStorageCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadPlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadPlayerStorageForNetIdCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "NetId": "the net id for the user to watch for read complete notifications",
            "ReadPlayerStorageForNetIdCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadProfileSettingsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadTitleFileCompleteDelegate": {
          "comment": "Adds the delegate to the list to be notified when a requested file has been read",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to add"
          }
        },
        "AddRecalculateSkillRatingCompleteDelegate": {
          "comment": "Adds a delegate to the list of objects that want to be notified",
          "params": {
            "RecalculateSkillRatingCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReceivedGameInviteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a game invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "ReceivedGameInviteDelegate": "the delegate to use for notifications"
          }
        },
        "AddRecognitionCompleteDelegate": {
          "comment": "Sets the speech recognition notification callback to use for the specified user",
          "params": {
            "LocalUserNum": "the local user to receive notifications for",
            "RecognitionDelegate": "the delegate to call when recognition is complete"
          }
        },
        "AddRegisterHostStatGuidCompleteDelegate": {
          "comment": "Adds the delegate for notifying when the host guid registration is done",
          "params": {
            "RegisterHostStatGuidCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddRegisterPlayerCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the player\n registration request they submitted has completed",
          "params": {
            "RegisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddStartOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game has\n transitioned to the started state.",
          "params": {
            "StartOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddStorageDeviceChangeDelegate": {
          "comment": "Adds the delegate to the list to be notified when a storage device changes",
          "params": {
            "StorageDeviceChangeDelegate": "the delegate to add"
          }
        },
        "AddUnlockAchievementCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the achievement unlocking has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "UnlockAchievementCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddUnregisterPlayerCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the player\n unregistration request they submitted has completed",
          "params": {
            "UnregisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddUpdateOnlineGameCompleteDelegate": {
          "comment": "Adds a delegate to the list of objects that want to be notified",
          "params": {
            "UpdateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWritePlayerStorageCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WritePlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWriteProfileSettingsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AreAnyFriends": {
          "comment": "Checks that whether a group of player ids are among the specified player's\n friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Query": "an array of players to check for being included on the friends list"
          }
        },
        "BindPlatformSpecificSessionToSearch": {
          "comment": "Creates a search result out of the platform specific data and adds that to the specified search object",
          "params": {
            "SearchingPlayerNum": "the index of the player searching for a match",
            "SearchSettings": "the desired search to bind the session to",
            "PlatformSpecificInfo": "the platform specific information to convert to a server object"
          }
        },
        "CalcAggregateSkill": {
          "comment": "Calculates the aggregate skill from an array of skills.",
          "params": {
            "Mus": "array that holds the mu values",
            "Sigmas": "array that holds the sigma values",
            "OutAggregateMu": "aggregate Mu",
            "OutAggregateSigma": "aggregate Sigma"
          }
        },
        "CancelFindOnlineGames": {
          "comment": "Cancels the current search in progress if possible for that search type"
        },
        "CanCommunicate": {
          "comment": "Determines whether the player is allowed to use voice or text chat online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanDownloadUserContent": {
          "comment": "Determines whether the player is allowed to download user created content",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanPlayOnline": {
          "comment": "Determines whether the player is allowed to play online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanPurchaseContent": {
          "comment": "Determines whether the player is allowed to buy content online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanShowPresenceInformation": {
          "comment": "Determines whether the player is allowed to have their online presence\n information shown to remote clients",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanViewPlayerProfiles": {
          "comment": "Determines whether the player is allowed to view other people's player profile",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ClearAddFriendByNameCompleteDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "FriendDelegate": "the delegate to use for notifications"
          }
        },
        "ClearArbitrationRegistrationCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "ArbitrationRegistrationCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearCancelFindOnlineGamesCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "CancelFindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearConnectionStatusChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ConnectionStatusDelegate": "the delegate to remove"
          }
        },
        "ClearControllerChangeDelegate": {
          "comment": "Removes the delegate used to notify the gameplay code that the controller state changed",
          "params": {
            "ControllerChangeDelegate": "the delegate to remove"
          }
        },
        "ClearCreateOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "CreateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearDestroyOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "DestroyOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearDeviceSelectionDoneDelegate": {
          "comment": "Removes the specified delegate from the list of callbacks",
          "params": {
            "DeviceDelegate": "the delegate to use for notifications"
          }
        },
        "ClearEndOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "EndOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearExternalUIChangeDelegate": {
          "comment": "Removes the delegate from the notification list",
          "params": {
            "ExternalUIDelegate": "the delegate to remove"
          }
        },
        "ClearFindOnlineGamesCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "FindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFlushOnlineStatsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the stats flush has completed",
          "params": {
            "FlushOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendInviteReceivedDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "InviteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendMessageReceivedDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "MessageDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendsChangeDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "ClearGameInviteAcceptedDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "GameInviteAcceptedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinFriendGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "JoinFriendGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinMigratedOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "JoinMigratedOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "JoinOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearKeyboardInputDoneDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the user has completed\n their keyboard input",
          "params": {
            "InputDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLinkStatusChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "LinkStatusDelegate": "the delegate to remove"
          }
        },
        "ClearLoginCancelledDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "CancelledDelegate": "the delegate to remove fromt he list"
          }
        },
        "ClearLoginChangeDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "whether to watch for changes on a specific slot or all slots"
          }
        },
        "ClearLoginFailedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLoginStatusChangeDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "the player to watch login status changes for"
          }
        },
        "ClearLogoutCompletedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LogoutDelegate": "the delegate to use for notifications"
          }
        },
        "ClearMigrateOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "MigrateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearMutingChangeDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "ClearPlayerTalkingDelegate": {
          "comment": "Removes a talker delegate to the list of notifications",
          "params": {
            "TalkerDelegate": "the delegate to remove from the notification list"
          }
        },
        "ClearProfileDataChangedDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that someone has changed their profile data externally",
          "params": {
            "LocalUserNum": "the user the delegate is interested in",
            "ProfileDataChangedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearQosStatusChangedDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "QosStatusChangedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadAchievementsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to read the achievements list for",
            "ReadAchievementsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadFriendsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadFriendsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadOnlineStatsCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ReadOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadPlayerStorageCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadPlayerStorageCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadPlayerStorageForNetIdCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "NetId": "the net id for the user to watch for read complete notifications",
            "ReadPlayerStorageForNetIdCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadProfileSettingsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadTitleFileCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to remove"
          }
        },
        "ClearRecalculateSkillRatingCompleteDelegate": {
          "comment": "Removes a delegate from the list of objects that want to be notified",
          "params": {
            "RecalculateSkillRatingCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReceivedGameInviteDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "ReceivedGameInviteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRecognitionCompleteDelegate": {
          "comment": "Clears the speech recognition notification callback to use for the specified user",
          "params": {
            "LocalUserNum": "the local user to receive notifications for",
            "RecognitionDelegate": "the delegate to call when recognition is complete"
          }
        },
        "ClearRegisterHostStatGuidCompleteDelegateDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code",
          "params": {
            "RegisterHostStatGuidCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRegisterPlayerCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "RegisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearStartOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "StartOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearStorageDeviceChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ConnectionStatusDelegate": "the delegate to remove"
          }
        },
        "ClearUnlockAchievementCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the achievement unlocking has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "UnlockAchievementCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearUnregisterPlayerCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "UnregisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearUpdateOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "UpdateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearWritePlayerStorageCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WritePlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearWriteProfileSettingsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "CreateOnlineGame": {
          "comment": "Creates an online game based upon the settings object specified.\n NOTE: online game registration is an async process and does not complete\n until the OnCreateOnlineGameComplete delegate is called.",
          "params": {
            "HostingPlayerNum": "the index of the player hosting the match",
            "SessionName": "the name to use for this session so that multiple sessions can exist at the same time",
            "NewGameSettings": "the settings to use for the new game session"
          }
        },
        "DeleteMessage": {
          "comment": "Deletes a message from the list of messages",
          "params": {
            "LocalUserNum": "the user that is deleting the message",
            "MessageIndex": "the index of the message to delete"
          }
        },
        "DenyFriendInvite": {
          "comment": "Used to deny a friend request sent to this player",
          "params": {
            "LocalUserNum": "the user the invite is for",
            "RequestingPlayer": "the player the invite is from",
            "true": "if successful, false otherwise"
          }
        },
        "DestroyOnlineGame": {
          "comment": "Destroys the current online game\n NOTE: online game de-registration is an async process and does not complete\n until the OnDestroyOnlineGameComplete delegate is called.",
          "params": {
            "SessionName": "the name of the session to delete"
          }
        },
        "EndOnlineGame": {
          "comment": "Marks an online game as having been ended",
          "params": {
            "SessionName": "the name of the session the to end"
          }
        },
        "FindOnlineGames": {
          "comment": "Searches for games matching the settings specified",
          "params": {
            "SearchingPlayerNum": "the index of the player searching for a match",
            "SearchSettings": "the desired settings that the returned sessions will have"
          }
        },
        "FlushOnlineStats": {
          "comment": "Commits any changes in the online stats cache to the permanent storage",
          "params": {
            "SessionName": "the name of the session having stats flushed"
          }
        },
        "FreeSearchResults": {
          "comment": "Cleans up any platform specific allocated data contained in the search results",
          "params": {
            "Search": "the object to free search results for"
          }
        },
        "FreeStats": {
          "comment": "Cleans up any platform specific allocated data contained in the stats data",
          "params": {
            "StatsRead": "the object to handle per platform clean up on"
          }
        },
        "GetAchievements": {
          "comment": "Copies the list of achievements for the specified player and title id",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Achievements": "the out array that receives the copied data",
            "TitleId": "the title id of the game that these were read for"
          }
        },
        "GetArbitratedPlayers": {
          "comment": "Returns the list of arbitrated players for the arbitrated session",
          "params": {
            "SessionName": "the name of the session to get the arbitration results for"
          }
        },
        "GetClientStatGuid": {
          "comment": "Reads the client's stat guid that was generated by registering the host's guid\n Used for synching up stats. Only valid on the client. Only callable after the\n host registration has completed"
        },
        "GetDeviceSelectionResults": {
          "comment": "Fetches the results of the device selection",
          "params": {
            "LocalUserNum": "the player to check the results for",
            "DeviceName": "out param that gets a copy of the string"
          }
        },
        "GetFriendMessages": {
          "comment": "Returns the list of messages for the specified player",
          "params": {
            "LocalUserNum": "the local player wanting to join",
            "FriendMessages": "the set of messages cached locally for the player"
          }
        },
        "GetFriendsList": {
          "comment": "Copies the list of friends for the player previously retrieved from the online\n service. The list can be retrieved in whole or in part.",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Friends": "the out array that receives the copied data",
            "Count": "the number of friends to read or zero for all",
            "StartingAt": "the index of the friends list to start at (for pulling partial lists)"
          }
        },
        "GetGameSearch": {
          "comment": "Returns the currently set game search object"
        },
        "GetGameSettings": {
          "comment": "Returns the game settings object for the session with a matching name",
          "params": {
            "SessionName": "the name of the session to return"
          }
        },
        "GetHostStatGuid": {
          "comment": "Reads the host's stat guid for synching up stats. Only valid on the host."
        },
        "GetKeyboardInputResults": {
          "comment": "Fetches the results of the input",
          "params": {
            "bWasCancelled": "whether the user canceled the input or not"
          }
        },
        "GetLocale": {
          "comment": "Determine the locale (country code) for the player"
        },
        "GetLoginStatus": {
          "comment": "Fetches the login status for a given player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "GetNATType": {
          "comment": "Determines the NAT type the player is using"
        },
        "GetNetworkNotificationPosition": {
          "comment": "Determines the current notification position setting"
        },
        "GetPlayerNickname": {
          "comment": "Reads the player's nick name from the online service",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "GetPlayerNicknameFromIndex": {
          "comment": "Returns the name of the player for the specified index",
          "params": {
            "UserIndex": "the user to return the name of"
          }
        },
        "GetPlayerStorage": {
          "comment": "Returns the online player storage for a given local user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for"
          }
        },
        "GetPlayerUniqueNetIdFromIndex": {
          "comment": "Returns the unique id of the player for the specified index",
          "params": {
            "UserIndex": "the user to return the id of"
          }
        },
        "GetProfileSettings": {
          "comment": "Returns the online profile settings for a given user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for"
          }
        },
        "GetRecognitionResults": {
          "comment": "Gets the results of the voice recognition",
          "params": {
            "LocalUserNum": "the local user to read the results of",
            "Words": "the set of words that were recognized by the voice analyzer"
          }
        },
        "GetResolvedConnectString": {
          "comment": "Returns the platform specific connection information for joining the match.\n Call this function from the delegate of join completion",
          "params": {
            "SessionName": "the name of the session to fetch the connection information for",
            "ConnectInfo": "the out var containing the platform specific connection information"
          }
        },
        "GetTitleFileContents": {
          "comment": "Copies the file data into the specified buffer for the specified file",
          "params": {
            "FileName": "the name of the file to read",
            "FileContents": "the out buffer to copy the data into"
          }
        },
        "GetTitleFileState": {
          "comment": "Determines the async state of the tile file read operation",
          "params": {
            "FileName": "the name of the file to check on"
          }
        },
        "GetUniquePlayerId": {
          "comment": "Gets the platform specific unique id for the specified player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the byte array that will receive the id"
          }
        },
        "HasLinkConnection": {
          "comment": "Determines if the ethernet link is connected or not"
        },
        "Init": {
          "comment": "Called from engine start up code to allow the subsystem to initialize"
        },
        "IsControllerConnected": {
          "comment": "Determines if the specified controller is connected or not",
          "params": {
            "ControllerId": "the controller to query"
          }
        },
        "IsDeviceValid": {
          "comment": "Checks the device id to determine if it is still valid (could be removed) and/or\n if there is enough space on the specified device",
          "params": {
            "DeviceId": "the device to check",
            "SizeNeeded": "the amount of space requested"
          }
        },
        "IsFriend": {
          "comment": "Checks that a unique player id is part of the specified user's friends list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being checked"
          }
        },
        "IsGuestLogin": {
          "comment": "Determines whether the specified user is a guest login or not",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "IsHeadsetPresent": {
          "comment": "Determines if the specified player has a headset connected",
          "params": {
            "LocalUserNum": "the local player index being queried"
          }
        },
        "IsLocalLogin": {
          "comment": "Determines whether the specified user is a local (non-online) login or not",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "IsLocalPlayerTalking": {
          "comment": "Determines if the specified player is actively talking into the mic",
          "params": {
            "LocalUserNum": "the local player index being queried"
          }
        },
        "IsMuted": {
          "comment": "Checks that a unique player id is on the specified user's mute list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being checked"
          }
        },
        "IsRemotePlayerTalking": {
          "comment": "Determines if the specified remote player is actively talking into the mic\n NOTE: Network latencies will make this not 100% accurate",
          "params": {
            "PlayerId": "the unique id of the remote player being queried"
          }
        },
        "JoinFriendGame": {
          "comment": "Allows the local player to follow a friend into a game",
          "params": {
            "LocalUserNum": "the local player wanting to join",
            "Friend": "the player that is being followed"
          }
        },
        "JoinMigratedOnlineGame": {
          "comment": "Joins the migrated game specified",
          "params": {
            "PlayerNum": "the index of the player about to join a match",
            "SessionName": "the name of the migrated session to join",
            "DesiredGame": "the desired migrated game to join"
          }
        },
        "JoinOnlineGame": {
          "comment": "Joins the game specified",
          "params": {
            "PlayerNum": "the index of the player searching for a match",
            "SessionName": "the name of the session to join",
            "DesiredGame": "the desired game to join"
          }
        },
        "Login": {
          "comment": "Logs the player into the online service. If this fails, it generates a\n OnLoginFailed notification",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginName": "the unique identifier for the player",
            "Password": "the password for this account",
            "bWantsLocalOnly": "whether the player wants to sign in locally only or not"
          }
        },
        "Logout": {
          "comment": "Signs the player out of the online service",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "MigrateOnlineGame": {
          "comment": "Migrates an existing online game on the host.\n NOTE: online game migration is an async process and does not complete\n until the OnMigrateOnlineGameComplete delegate is called.",
          "params": {
            "HostingPlayerNum": "the index of the player now hosting the match",
            "SessionName": "the name of the existing session to migrate"
          }
        },
        "MuteAll": {
          "comment": "Mutes all voice or all but friends",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "bAllowFriends": "whether to mute everyone or allow friends"
          }
        },
        "MuteRemoteTalker": {
          "comment": "Mutes a remote talker for the specified local player. NOTE: This only mutes them in the\n game unless the bIsSystemWide flag is true, which attempts to mute them globally",
          "params": {
            "LocalUserNum": "the user that is muting the remote talker",
            "PlayerId": "the remote talker that is being muted",
            "bIsSystemWide": "whether to try to mute them globally or not"
          }
        },
        "QueryNonAdvertisedData": {
          "comment": "Fetches the additional data a session exposes outside of the online service.\n NOTE: notifications will come from the OnFindOnlineGamesComplete delegate",
          "params": {
            "StartAt": "the search result index to start gathering the extra information for",
            "NumberToQuery": "the number of additional search results to get the data for"
          }
        },
        "ReadAchievements": {
          "comment": "Starts an async read for the achievement list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "TitleId": "the title id of the game the achievements are to be read for",
            "bShouldReadText": "whether to fetch the text strings or not",
            "bShouldReadImages": "whether to fetch the image data or not"
          }
        },
        "ReadFriendsList": {
          "comment": "Starts an async task that retrieves the list of friends for the player from the\n online service. The list can be retrieved in whole or in part.",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Count": "the number of friends to read or zero for all",
            "StartingAt": "the index of the friends list to start at (for pulling partial lists)"
          }
        },
        "ReadOnlineStats": {
          "comment": "Reads a set of stats for the specified list of players",
          "params": {
            "Players": "the array of unique ids to read stats for",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object"
          }
        },
        "ReadOnlineStatsByRank": {
          "comment": "Reads stats by ranking. This grabs the rows starting at StartIndex through\n NumToRead and places them in the StatsRead object.",
          "params": {
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object",
            "StartIndex": "the starting rank to begin reads at (1 for top)",
            "NumToRead": "the number of rows to read (clamped at 100 underneath)"
          }
        },
        "ReadOnlineStatsByRankAroundPlayer": {
          "comment": "Reads stats by ranking centered around a player. This grabs a set of rows\n above and below the player's current rank",
          "params": {
            "LocalUserNum": "the local player having their stats being centered upon",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object",
            "NumRows": "the number of rows to read above and below the player's rank"
          }
        },
        "ReadOnlineStatsForFriends": {
          "comment": "Reads a player's stats and all of that player's friends stats for the\n specified set of stat views. This allows you to easily compare a player's\n stats to their friends.",
          "params": {
            "LocalUserNum": "the local player having their stats and friend's stats read for",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object"
          }
        },
        "ReadPlatformSpecificSessionInfo": {
          "comment": "Serializes the platform specific data into the provided buffer for the specified search result",
          "params": {
            "DesiredGame": "the game to copy the platform specific data for",
            "PlatformSpecificInfo": "the buffer to fill with the platform specific information"
          }
        },
        "ReadPlatformSpecificSessionInfoBySessionName": {
          "comment": "Serializes the platform specific data into the provided buffer for the specified settings object.\n NOTE: This can only be done for a session that is bound to the online system",
          "params": {
            "GameSettings": "the game to copy the platform specific data for",
            "PlatformSpecificInfo": "the buffer to fill with the platform specific information"
          }
        },
        "ReadPlayerStorage": {
          "comment": "Reads the online player storage data for a given local user\n If a valid storage device ID is specified then data is also read from that device and the newer version is kept.",
          "params": {
            "LocalUserNum": "the user that we are reading the data for",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read",
            "DeviceId": "optional ID for connected device to read from. -1 for no device"
          }
        },
        "ReadPlayerStorageForNetId": {
          "comment": "Reads the online player storage data for a given net user",
          "params": {
            "LocalUserNum": "the local user that is initiating the read",
            "NetId": "the net user that we are reading the data for",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read"
          }
        },
        "ReadProfileSettings": {
          "comment": "Reads the online profile settings for a given user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for",
            "ProfileSettings": "the object to copy the results to and contains the list of items to read"
          }
        },
        "ReadTitleFile": {
          "comment": "Starts an asynchronous read of the specified file from the network platform's\n title specific file store",
          "params": {
            "FileToRead": "the name of the file to read"
          }
        },
        "RecalculateSkillRating": {
          "comment": "Updates the current session's skill rating using the list of players' skills",
          "params": {
            "SessionName": "the name of the session to update the skill rating for",
            "Players": "the set of players to use in the skill calculation"
          }
        },
        "RegisterForArbitration": {
          "comment": "Tells the game to register with the underlying arbitration server if available",
          "params": {
            "SessionName": "the name of the session to register for arbitration with"
          }
        },
        "RegisterHostStatGuid": {
          "comment": "Registers the host's stat guid with the client for verification they are part of\n the stat. Note this is an async task for any backend communication that needs to\n happen before the registration is deemed complete",
          "params": {
            "HostStatGuid": "the host's stat guid"
          }
        },
        "RegisterLocalTalker": {
          "comment": "Registers the user as a talker",
          "params": {
            "LocalUserNum": "the local player index that is a talker"
          }
        },
        "RegisterPlayer": {
          "comment": "Registers a player with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "UniquePlayerId": "the player to register with the online service",
            "bWasInvited": "whether the player was invited to the game or searched for it"
          }
        },
        "RegisterPlayers": {
          "comment": "Registers a group of players with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "Players": "the list of players to register with the online service"
          }
        },
        "RegisterRemoteTalker": {
          "comment": "Registers a remote player as a talker",
          "params": {
            "PlayerId": "the unique id of the remote player that is a talker"
          }
        },
        "RegisterStatGuid": {
          "comment": "Registers the client's stat guid on the host to validate that the client was in the stat.\n Used for synching up stats. Only valid on the host.",
          "params": {
            "PlayerId": "the client's unique net id",
            "ClientStatGuid": "the client's stat guid"
          }
        },
        "RemoveFriend": {
          "comment": "Removes a friend from the player's friend list",
          "params": {
            "LocalUserNum": "the user that is removing the friend",
            "FormerFriend": "the player to remove from the friend list"
          }
        },
        "SelectVocabulary": {
          "comment": "Changes the vocabulary id that is currently being used",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "VocabularyId": "the new id to use"
          }
        },
        "SendGameInviteToFriend": {
          "comment": "Sends an invitation to play in the player's current session",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "Friend": "the player to send the invite to",
            "Text": "the text of the message for the invite"
          }
        },
        "SendGameInviteToFriends": {
          "comment": "Sends invitations to play in the player's current session",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "Friends": "the player to send the invite to",
            "Text": "the text of the message for the invite"
          }
        },
        "SendMessageToFriend": {
          "comment": "Sends a message to a friend",
          "params": {
            "LocalUserNum": "the user that is sending the message",
            "Friend": "the player to send the message to",
            "Message": "the message to display to the recipient"
          }
        },
        "SetNetworkNotificationPosition": {
          "comment": "Sets a new position for the network notification icons/images",
          "params": {
            "NewPos": "the new location to use"
          }
        },
        "SetOnlineStatus": {
          "comment": "Sets the online status information to use for the specified player. Used to\n tell other players what the player is doing (playing, menus, away, etc.)",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "StatusId": "the status id to use (maps to strings where possible)",
            "LocalizedStringSettings": "the list of localized string settings to set",
            "Properties": "the list of properties to set"
          }
        },
        "SetRemoteTalkerPriority": {
          "comment": "Sets the relative priority for a remote talker. 0 is highest",
          "params": {
            "LocalUserNum": "the user that controls the relative priority",
            "PlayerId": "the remote talker that is having their priority changed for",
            "Priority": "the relative priority to use (0 highest, < 0 is muted)"
          }
        },
        "SetSpeechRecognitionObject": {
          "comment": "Changes the object that is in use to the one specified",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "SpeechRecogObj": "the new object use",
            "true": "if successful, false otherwise"
          }
        },
        "ShowAchievementsUI": {
          "comment": "Displays the achievements UI for a player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowContentMarketplaceUI": {
          "comment": "Displays the marketplace UI for content",
          "params": {
            "LocalUserNum": "the local user viewing available content",
            "CategoryMask": "the bitmask to use to filter content by type",
            "OfferId": "a specific offer that you want shown"
          }
        },
        "ShowCustomPlayersUI": {
          "comment": "Shows a custom players UI for the specified list of players",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Players": "the list of players to show in the custom UI",
            "Title": "the title to use for the UI",
            "Description": "the text to show at the top of the UI"
          }
        },
        "ShowDeviceSelectionUI": {
          "comment": "Displays the UI that allows the user to choose which device to save content to",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "SizeNeeded": "the size of the data to be saved in bytes",
            "bManageStorage": "whether to allow the user to manage their storage or not"
          }
        },
        "ShowFeedbackUI": {
          "comment": "Displays the UI that allows a player to give feedback on another player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player having feedback given for"
          }
        },
        "ShowFriendsInviteUI": {
          "comment": "Displays the UI that shows a user's list of friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being invited"
          }
        },
        "ShowFriendsUI": {
          "comment": "Displays the UI that shows a user's list of friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowGamerCardUI": {
          "comment": "Displays the gamer card UI for the specified player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player to show the gamer card of"
          }
        },
        "ShowInviteUI": {
          "comment": "Displays the invite ui",
          "params": {
            "LocalUserNum": "the local user sending the invite",
            "InviteText": "the string to prefill the UI with"
          }
        },
        "ShowKeyboardUI": {
          "comment": "Displays the UI that shows the keyboard for inputing text",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "TitleText": "the title to display to the user",
            "DescriptionText": "the text telling the user what to input",
            "bIsPassword": "whether the item being entered is a password or not",
            "bShouldValidate": "whether to apply the string validation API after input or not",
            "DefaultText": "the default string to display",
            "MaxResultLength": "the maximum length string expected to be filled in"
          }
        },
        "ShowLoginUI": {
          "comment": "Displays the UI that prompts the user for their login credentials. Each\n platform handles the authentication of the user's data.",
          "params": {
            "bShowOnlineOnly": "whether to only display online enabled profiles or not"
          }
        },
        "ShowMembershipMarketplaceUI": {
          "comment": "Displays the marketplace UI for memberships",
          "params": {
            "LocalUserNum": "the local user viewing available memberships"
          }
        },
        "ShowMessagesUI": {
          "comment": "Displays the messages UI for a player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowPlayersUI": {
          "comment": "Displays the UI that shows the player list",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "StartNetworkedVoice": {
          "comment": "Tells the voice layer that networked processing of the voice data is allowed\n for the specified player. This allows for push-to-talk style voice communication",
          "params": {
            "LocalUserNum": "the local user to allow network transimission for"
          }
        },
        "StartOnlineGame": {
          "comment": "Marks an online game as in progress (as opposed to being in lobby or pending)",
          "params": {
            "SessionName": "the name of the session that is being started"
          }
        },
        "StartSpeechRecognition": {
          "comment": "Tells the voice system to start tracking voice data for speech recognition",
          "params": {
            "LocalUserNum": "the local user to recognize voice data for"
          }
        },
        "StopNetworkedVoice": {
          "comment": "Tells the voice layer to stop processing networked voice support for the\n specified player. This allows for push-to-talk style voice communication",
          "params": {
            "LocalUserNum": "the local user to disallow network transimission for"
          }
        },
        "StopSpeechRecognition": {
          "comment": "Tells the voice system to stop tracking voice data for speech recognition",
          "params": {
            "LocalUserNum": "the local user to recognize voice data for"
          }
        },
        "UnlockAchievement": {
          "comment": "Unlocks the specified achievement for the specified user",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "AchievementId": "the id of the achievement to unlock"
          }
        },
        "UnlockAvatarAward": {
          "comment": "Unlocks an avatar award for the local user",
          "params": {
            "LocalUserNum": "the user to unlock the avatar item for",
            "AvatarItemId": "the id of the avatar item to unlock"
          }
        },
        "UnlockGamerPicture": {
          "comment": "Unlocks a gamer picture for the local user",
          "params": {
            "LocalUserNum": "the user to unlock the picture for",
            "PictureId": "the id of the picture to unlock"
          }
        },
        "UnmuteAll": {
          "comment": "Allows all speakers to send voice",
          "params": {
            "LocalUserNum": "the local user that is making the change"
          }
        },
        "UnmuteRemoteTalker": {
          "comment": "Allows a remote talker to talk to the specified local player. NOTE: This only unmutes them in the\n game unless the bIsSystemWide flag is true, which attempts to unmute them globally",
          "params": {
            "LocalUserNum": "the user that is allowing the remote talker to talk",
            "PlayerId": "the remote talker that is being restored to talking",
            "bIsSystemWide": "whether to try to unmute them globally or not"
          }
        },
        "UnregisterLocalTalker": {
          "comment": "Unregisters the user as a talker",
          "params": {
            "LocalUserNum": "the local player index to be removed"
          }
        },
        "UnregisterPlayer": {
          "comment": "Unregisters a player with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is leaving",
            "PlayerId": "the player to unregister with the online service"
          }
        },
        "UnregisterPlayers": {
          "comment": "Unregisters a group of players with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "Players": "the list of players to unregister with the online service"
          }
        },
        "UnregisterRemoteTalker": {
          "comment": "Unregisters a remote player as a talker",
          "params": {
            "PlayerId": "the unique id of the remote player to be removed"
          }
        },
        "UpdateOnlineGame": {
          "comment": "Updates the localized settings/properties for the game in question",
          "params": {
            "SessionName": "the name of the session to update",
            "UpdatedGameSettings": "the object to update the game settings with",
            "bShouldRefreshOnlineData": "whether to submit the data to the backend or not"
          }
        },
        "WriteOnlinePlayerScores": {
          "comment": "Writes the score data for the match",
          "params": {
            "SessionName": "the name of the session to write scores for",
            "LeaderboardId": "the leaderboard to write the score information to",
            "PlayerScores": "the list of players, teams, and scores they earned"
          }
        },
        "WriteOnlineStats": {
          "comment": "Writes out the stats contained within the stats write object to the online\n subsystem's cache of stats data. Note the new data replaces the old. It does\n not write the data to the permanent storage until a FlushOnlineStats() call\n or a session ends. Stats cannot be written without a session or the write\n request is ignored. No more than 5 stats views can be written to at a time\n or the write request is ignored.",
          "params": {
            "SessionName": "the name of the session to write stats for",
            "Player": "the player to write stats for",
            "StatsWrite": "the object containing the information to write"
          }
        },
        "WritePlayerStorage": {
          "comment": "Writes the online player storage data for a given local user to the online data store\n If a valid storage device ID is specified then data is also written to that device.",
          "params": {
            "LocalUserNum": "the user that we are writing the data for",
            "PlayerStorage": "the object that contains the list of items to write",
            "DeviceId": "optional ID for connected device to write to. -1 for no device"
          }
        },
        "WriteProfileSettings": {
          "comment": "Writes the online profile settings for a given user to the online data store",
          "params": {
            "LocalUserNum": "the user that we are writing the data for",
            "ProfileSettings": "the list of settings to write out"
          }
        }
      }
    },
    "OnlineSuppliedUIGameCenter": {
      "comment": "Provides an GameCenter supplied UI functionality",
      "properties": {
        "ShowOnlineStatsUIDelegates": {
          "comment": "The array of delegates that notify leaderboard UI closed"
        }
      },
      "functions": {
        "AddShowOnlineStatsUICompleteDelegate": {
          "comment": "Adds the delegate to the list to be notified when stats UI is closed",
          "params": {
            "ShowOnlineStatsUICompleteDelegate": "the delegate to add"
          }
        },
        "ClearShowOnlineStatsUICompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ShowOnlineStatsUICompleteDelegate": "the delegate to remove"
          }
        },
        "ShowMatchmakingUI": {
          "comment": "Shows the platform supplied matchmaking UI. This will eventually either the JoinOnlineGameComplete \n or CreateOnlineGameComplete delegates, depending on if it's server or client",
          "params": {
            "SearchingPlayerNum": "the index of the player searching for a match",
            "SearchSettings": "settings used to search for",
            "GameSettings": "the game settings to use if this player becomes the server"
          }
        },
        "ShowOnlineStatsUI": {
          "comment": "Shows the platform supplid leaderboard UI",
          "params": {
            "Players": "the array of unique ids to show stats for",
            "StatsRead": "holds the definitions of the tables to show the data for\n (note that no results will be filled out)"
          }
        }
      }
    }
  },
  "OnlineSubsystemGameSpy": {
    "OnlineGameInterfaceGameSpy": {
      "comment": "Class that implements the GameSpy specific functionality",
      "properties": {
        "GameInviteAcceptedDelegates": {
          "comment": "The list of delegates to notify when a game invite is accepted"
        },
        "InviteGameSearch": {
          "comment": "Game game settings associated with this invite"
        },
        "InviteLocationUrl": {
          "comment": "The last invite's URL information"
        },
        "QR2DataBindableKeyNames": {
          "comment": "The list of databindable properties that are registered as keys"
        },
        "QR2FirstDataBindableKeyId": {
          "comment": "The first databinding property key id in the list"
        },
        "QR2FirstPropertyKeyId": {
          "comment": "The first property key id in the list"
        },
        "QR2FirstSettingKeyId": {
          "comment": "The first localized setting key id in the list"
        },
        "QR2Handle": {
          "comment": "stores a handle to the QR2 instance"
        },
        "QR2NpIdKeyId": {
          "comment": "The QR2 key id for the np id"
        },
        "QR2NpIdString": {
          "comment": "The string form of the np id"
        },
        "QR2NumDataBindableKeys": {
          "comment": "The number of databinding property keys"
        },
        "QR2NumPropertyKeys": {
          "comment": "The number of registered property keys"
        },
        "QR2NumSettingKeys": {
          "comment": "The number of localized settings keys"
        },
        "QR2OwningPlayerIdKeyId": {
          "comment": "The QR2 key id for the player id"
        },
        "RegisterPlayerCompleteDelegates": {
          "comment": "This is the list of requested delegates to fire when complete"
        },
        "SBHandle": {
          "comment": "stores a handle to the ServerBrowsing instance"
        },
        "ServersPendingInfo": {
          "comment": "Holds a set of servers that are pending info requests"
        },
        "UnregisterPlayerCompleteDelegates": {
          "comment": "This is the list of requested delegates to fire when complete"
        }
      },
      "functions": {
        "AcceptGameInvite": {
          "comment": "Tells the online subsystem to accept the game invite that is currently pending",
          "params": {
            "LocalUserNum": "the local user accepting the invite",
            "SessionName": "the name of the session this invite is to be known as"
          }
        },
        "AddGameInviteAcceptedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code when a game invite has been accepted",
          "params": {
            "LocalUserNum": "the user to request notification for",
            "GameInviteAcceptedDelegate": "the delegate to use for notifications"
          }
        },
        "AddRegisterPlayerCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the player\n registration request they submitted has completed",
          "params": {
            "RegisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddUnregisterPlayerCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the player\n Unregistration request they submitted has completed",
          "params": {
            "UnregisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearGameInviteAcceptedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the user to request notification for",
            "GameInviteAcceptedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRegisterPlayerCompleteDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "RegisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearUnregisterPlayerCompleteDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "UnregisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "QueryNonAdvertisedData": {
          "comment": "Fetches the additional data a session exposes outside of the online service.\n NOTE: notifications will come from the OnFindOnlineGamesComplete delegate",
          "params": {
            "StartAt": "the search result index to start gathering the extra information for",
            "NumberToQuery": "the number of additional search results to get the data for"
          }
        },
        "RegisterPlayer": {
          "comment": "Registers a player with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "UniquePlayerId": "the player to register with the online service",
            "bWasInvited": "whether the player was invited to the game or searched for it"
          }
        },
        "UnregisterPlayer": {
          "comment": "Unregisters a player with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is leaving",
            "PlayerId": "the player to unregister with the online service"
          }
        },
        "UpdateOnlineGame": {
          "comment": "Updates the localized settings/properties for the game in question",
          "params": {
            "SessionName": "the name of the session to update",
            "UpdatedGameSettings": "the object to update the game settings with",
            "bShouldRefreshOnlineData": "whether to submit the data to the backend or not"
          }
        }
      }
    },
    "OnlineSubsystemGameSpy": {
      "properties": {
        "AccountCreateDelegates": {
          "comment": "This is the list of requested delegates to fire when an account create completes"
        },
        "AddFriendByNameCompleteDelegates": {
          "comment": "This is the list of requested delegates to fire when a friend by name invite has completed"
        },
        "AsyncTasks": {
          "comment": "This is the array of pending async tasks. Each tick these tasks are checked\n for completion. If complete, the delegate associated with them is called"
        },
        "bHasGameSpyAccount": {
          "comment": "Whether the user has created a GameSpy account or not"
        },
        "bIsLoginInProcess": {
          "comment": "Whether a login is in progress or not"
        },
        "bIsStatsSessionOk": {
          "comment": "Whether the stats session is ok to add stats to etc"
        },
        "bLastHasConnection": {
          "comment": "Whether the last frame has connection status or not"
        },
        "bNeedsKeyboardTicking": {
          "comment": "Whether the keyboard needs to be ticked"
        },
        "bShouldUseMcp": {
          "comment": "Whether to use MCP for news or not"
        },
        "bWasKeyboardInputCanceled": {
          "comment": "Whether the user canceled keyboard input or not"
        },
        "CachedFriendMessage": {
          "comment": "Used by the async add friend by name function"
        },
        "CachedFriendMessages": {
          "comment": "The list of friend messages received while the game was running"
        },
        "CachedGameInt": {
          "comment": "Pointer to the object that handles the game interface"
        },
        "CachedProfile": {
          "comment": "The cached profile for the player"
        },
        "ConnectionPresenceElapsedTime": {
          "comment": "Used to check when to verify connection status"
        },
        "ConnectionPresenceTimeInterval": {
          "comment": "The amount of time to elapse before checking for connection status change"
        },
        "ConnectionStatusChangeDelegates": {
          "comment": "This is the list of delegates requesting notification GameSpy's connection state changes"
        },
        "ControllerChangeDelegates": {
          "comment": "This is the list of delegates requesting notification of controller status changes"
        },
        "ControllerStates[4]": {
          "comment": "Upto 4 player split screen support"
        },
        "CurrentLocalTalker": {
          "comment": "Holds the local talker information for the single signed in player"
        },
        "CurrentStatsRead": {
          "comment": "The currently outstanding stats read request"
        },
        "DefaultStatus": {
          "comment": "This is the default online status to use in status updates"
        },
        "EncryptedProductKey": {
          "comment": "Holds the product key in its encrypted form"
        },
        "FlushOnlineStatsDelegates": {
          "comment": "The list of delegates to notify when the stats flush is complete"
        },
        "FriendInviteReceivedDelegates": {
          "comment": "This is the list of requested delegates to fire when a friend invite is received"
        },
        "FriendMessageReceivedDelegates": {
          "comment": "This is the list of requested delegates to fire when a friend message is received"
        },
        "FriendsChangeDelegates": {
          "comment": "The array of delegates that notify that the friends list has changed"
        },
        "GameID": {
          "comment": "Identifies the GameSpy game"
        },
        "GameInviteMessage": {
          "comment": "The message to use for game invites"
        },
        "GPHandle": {
          "comment": "Stores a handle to the GP instance"
        },
        "JoinFriendGameCompleteDelegates": {
          "comment": "Holds the list of delegates that are interested in receiving join friend completions"
        },
        "KeyboardInputDelegates": {
          "comment": "This is the list of requested delegates to fire when keyboard UI has completed"
        },
        "KeyboardResultsString": {
          "comment": "Holds the results of async keyboard input"
        },
        "LinkStatusDelegates": {
          "comment": "This is the list of delegates requesting notification of network link status changes"
        },
        "LocalPlayerStorageReadDelegates": {
          "comment": "Used for notification of player storage reads completing for local players"
        },
        "LocalPlayerStorageWriteDelegates": {
          "comment": "Used for notification of player storage writes completing for local players"
        },
        "LocalProfileName": {
          "comment": "The name to use for local profiles"
        },
        "LocationUrl": {
          "comment": "The URL to send as the location string"
        },
        "LocationUrlsForInvites": {
          "comment": "The list of location strings that are ok to accept invites for. Used mostly\n the different platform skus use different location strings."
        },
        "LoggedInPlayerId": {
          "comment": "The unique id of the logged in player"
        },
        "LoggedInPlayerName": {
          "comment": "The name of the player that is logged in"
        },
        "LoggedInPlayerNum": {
          "comment": "The number of the player that called the login function"
        },
        "LoggedInPlayerPassword": {
          "comment": "Store the password temporarily during the login attempt for the login certificate request\n Clear it as soon as it is used"
        },
        "LoggedInStatus": {
          "comment": "The current login status for the player"
        },
        "LoginCertificate": {
          "comment": "Stores a login certificate"
        },
        "LoginChangeDelegates": {
          "comment": "This is the list of requested delegates to fire when a login fails to process"
        },
        "LoginFailedDelegates": {
          "comment": "This is the list of requested delegates to fire when a login fails to process"
        },
        "LoginPrivateData": {
          "comment": "Stores the login private data"
        },
        "LogoutCompletedDelegates": {
          "comment": "This is the list of requested delegates to fire when a logout completes"
        },
        "MuteList": {
          "comment": "Holds the set of people that are muted by the currently logged in player"
        },
        "MutingChangeDelegates": {
          "comment": "The array of delegates that notify that the mute list has changed"
        },
        "NamespaceID": {
          "comment": "Identifies the login namespace"
        },
        "NextAuthId": {
          "comment": "An ever incrementing number assigned to auth requests"
        },
        "NickStatsKeyId": {
          "comment": "The stats key id for the nickname"
        },
        "NpData": {
          "comment": "Pointer to the PS3 specific data needed by GameSpy for single sign on"
        },
        "PartnerID": {
          "comment": "Identifies the login partner"
        },
        "PendingStats": {
          "comment": "Stats are stored in this array while waiting for FlushOnlineStats()"
        },
        "PerUserReadProfileSettings[4]": {
          "comment": "Holds callbacks for upto 4 splitscreen players"
        },
        "PlaceStatsKeyId": {
          "comment": "The stats key id for the player's place in the match"
        },
        "PlayerStorageCache[4]": {
          "comment": "Holds the per player online storage data (only for local players)"
        },
        "PlayerTalkingDelegates": {
          "comment": "This list is used to notify the game when a player is talking"
        },
        "ProductID": {
          "comment": "Identifies the GameSpy product"
        },
        "ProfileDataDirectory": {
          "comment": "The directory profile data should be stored in"
        },
        "ProfileDataExtension": {
          "comment": "The file extension to use when saving profile data"
        },
        "ReadAchievementsCompleteDelegates": {
          "comment": "The list of delegate to notify when the achievements have been read"
        },
        "ReadFriendsDelegates": {
          "comment": "The array of delegates that notify read completion of the friends list data"
        },
        "ReadOnlineStatsCompleteDelegates": {
          "comment": "This is the list of delegates requesting notification when a stats read finishes"
        },
        "ReadTitleFileCompleteDelegates": {
          "comment": "The list of delegates to notify when a network platform file is read"
        },
        "ReceivedGameInviteDelegates": {
          "comment": "The list of subscribers for game invite events"
        },
        "RegisterHostStatGuidCompleteDelegates": {
          "comment": "This is the list of requested delegates to fire when a host registration is complete"
        },
        "RemoteAuthPartnerChallenge": {
          "comment": "The partner challenge (when doing remote auth)"
        },
        "RemoteAuthToken": {
          "comment": "The auth token (when doing remote auth)"
        },
        "RemotePlayerStorageReadDelegates": {
          "comment": "Used for notification of player storage reads completing for remote players"
        },
        "RemoteTalkers": {
          "comment": "This is the list of remote talkers"
        },
        "SakeHandle": {
          "comment": "Stores a handle to the Sake instance"
        },
        "SakeProfileRecordID": {
          "comment": "Stores the Sake recordid associated with the player's profile"
        },
        "SCHandle": {
          "comment": "Stores a handle to the SC (stats & competition) SDK"
        },
        "ServerChallenge": {
          "comment": "Holds the server auth challenge"
        },
        "ServerLocalId": {
          "comment": "Holds the server auth local id"
        },
        "ServerResponse": {
          "comment": "Holds the server auth response"
        },
        "SpeechRecognitionCompleteDelegates": {
          "comment": "List of callbacks to notify when speech recognition is complete"
        },
        "StatsKeyMappings": {
          "comment": "Mappings of views and properties to gamespy stats keys"
        },
        "StatsVersion": {
          "comment": "This should match the version configured through the GameSpy stats admin site"
        },
        "StatusMappings": {
          "comment": "Holds the set of status strings for the specified game"
        },
        "UnlockAchievementCompleteDelegates": {
          "comment": "The list of delegate to notify when an achievement has been unlocked"
        },
        "WriteProfileSettingsDelegates": {
          "comment": "The array of delegates that notify write completion of profile data"
        }
      },
      "functions": {
        "AcceptFriendInvite": {
          "comment": "Used to accept a friend invite sent to this player",
          "params": {
            "LocalUserNum": "the user the invite is for",
            "RequestingPlayer": "the player the invite is from",
            "true": "if successful, false otherwise"
          }
        },
        "AddAddFriendByNameCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "FriendDelegate": "the delegate to use for notifications"
          }
        },
        "AddConnectionStatusChangeDelegate": {
          "comment": "Adds the delegate to the list to be notified when the connection status changes",
          "params": {
            "ConnectionStatusDelegate": "the delegate to add"
          }
        },
        "AddControllerChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the controller state changed",
          "params": {
            "ControllerChangeDelegate": "the delegate to use for notifications"
          }
        },
        "AddCreateOnlineAccountCompletedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that account creation completed",
          "params": {
            "AccountCreateDelegate": "the delegate to use for notifications"
          }
        },
        "AddExternalUIChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that external UI state\n changed (opened/closed)",
          "params": {
            "ExternalUIDelegate": "the delegate to use for notifications"
          }
        },
        "AddFlushOnlineStatsCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the stats flush has completed",
          "params": {
            "FlushOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriend": {
          "comment": "Sends a friend invite to the specified player",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "NewFriend": "the player to send the friend request to",
            "Message": "the message to display to the recipient"
          }
        },
        "AddFriendByName": {
          "comment": "Sends a friend invite to the specified player nick",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "FriendName": "the name of the player to send the invite to",
            "Message": "the message to display to the recipient"
          }
        },
        "AddFriendInviteReceivedDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "InviteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriendMessageReceivedDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "MessageDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriendsChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a friends list changed",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinFriendGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify when the join friend is complete",
          "params": {
            "JoinFriendGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddKeyboardInputDoneDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has completed\n their keyboard input",
          "params": {
            "InputDelegate": "the delegate to use for notifications"
          }
        },
        "AddLinkStatusChangeDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that link status changed",
          "params": {
            "LinkStatusDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginCancelledDelegate": {
          "comment": "Adds a delegate to the list of delegates that are fired when a login is cancelled",
          "params": {
            "CancelledDelegate": "the delegate to add to the list"
          }
        },
        "AddLoginChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login changed",
          "params": {
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginFailedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login failed",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginStatusChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login status has changed",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "the player to watch login status changes for"
          }
        },
        "AddLogoutCompletedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a logout completed",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LogoutDelegate": "the delegate to use for notifications"
          }
        },
        "AddMutingChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a muting list changed",
          "params": {
            "MutingDelegate": "the delegate to use for notifications"
          }
        },
        "AddPlayerTalkingDelegate": {
          "comment": "Adds a talker delegate to the list of notifications",
          "params": {
            "TalkerDelegate": "the delegate to call when a player is talking"
          }
        },
        "AddReadAchievementsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to read the achievements list for",
            "ReadAchievementsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadFriendsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the friends read request has completed",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "ReadFriendsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadOnlineStatsCompleteDelegate": {
          "comment": "Adds the delegate to a list used to notify the gameplay code that the stats read has completed",
          "params": {
            "ReadOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadPlayerStorageCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadPlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadPlayerStorageForNetIdCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "NetId": "the net id for the user to watch for read complete notifications",
            "ReadPlayerStorageForNetIdCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadProfileSettingsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadTitleFileCompleteDelegate": {
          "comment": "Adds the delegate to the list to be notified when a requested file has been read",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to add"
          }
        },
        "AddReceivedGameInviteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a game invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "ReceivedGameInviteDelegate": "the delegate to use for notifications"
          }
        },
        "AddRecognitionCompleteDelegate": {
          "comment": "Sets the speech recognition notification callback to use for the specified user",
          "params": {
            "LocalUserNum": "the local user to receive notifications for",
            "RecognitionDelegate": "the delegate to call when recognition is complete"
          }
        },
        "AddRegisterHostStatGuidCompleteDelegate": {
          "comment": "Adds the delegate for notifying when the host guid registration is done",
          "params": {
            "RegisterHostStatGuidCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddStorageDeviceChangeDelegate": {
          "comment": "Adds the delegate to the list to be notified when a storage device changes",
          "params": {
            "StorageDeviceChangeDelegate": "the delegate to add"
          }
        },
        "AddUnlockAchievementCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the achievement unlocking has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "UnlockAchievementCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWritePlayerStorageCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WritePlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWriteProfileSettingsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AreAnyFriends": {
          "comment": "Checks that whether a group of player ids are among the specified player's\n friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Query": "an array of players to check for being included on the friends list"
          }
        },
        "CalcAggregateSkill": {
          "comment": "Calculates the aggregate skill from an array of skills.",
          "params": {
            "Mus": "array that holds the mu values",
            "Sigmas": "array that holds the sigma values",
            "OutAggregateMu": "aggregate Mu",
            "OutAggregateSigma": "aggregate Sigma"
          }
        },
        "CanCommunicate": {
          "comment": "Determines whether the player is allowed to use voice or text chat online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanDownloadUserContent": {
          "comment": "Determines whether the player is allowed to download user created content",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanPlayOnline": {
          "comment": "Determines whether the player is allowed to play online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanPurchaseContent": {
          "comment": "Determines whether the player is allowed to buy content online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanShowPresenceInformation": {
          "comment": "Determines whether the player is allowed to have their online presence\n information shown to remote clients",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanViewPlayerProfiles": {
          "comment": "Determines whether the player is allowed to view other people's player profile",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ClearAddFriendByNameCompleteDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "FriendDelegate": "the delegate to use for notifications"
          }
        },
        "ClearConnectionStatusChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ConnectionStatusDelegate": "the delegate to remove"
          }
        },
        "ClearControllerChangeDelegate": {
          "comment": "Removes the delegate used to notify the gameplay code that the controller state changed",
          "params": {
            "ControllerChangeDelegate": "the delegate to remove"
          }
        },
        "ClearCreateOnlineAccountCompletedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "AccountCreateDelegate": "the delegate to use for notifications"
          }
        },
        "ClearExternalUIChangeDelegate": {
          "comment": "Removes the delegate from the notification list",
          "params": {
            "ExternalUIDelegate": "the delegate to remove"
          }
        },
        "ClearFlushOnlineStatsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the stats flush has completed",
          "params": {
            "FlushOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendInviteReceivedDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "InviteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendMessageReceivedDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "MessageDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendsChangeDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinFriendGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "JoinFriendGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearKeyboardInputDoneDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the user has completed\n their keyboard input",
          "params": {
            "InputDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLinkStatusChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "LinkStatusDelegate": "the delegate to remove"
          }
        },
        "ClearLoginCancelledDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "CancelledDelegate": "the delegate to remove fromt he list"
          }
        },
        "ClearLoginChangeDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLoginFailedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLoginStatusChangeDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "the player to watch login status changes for"
          }
        },
        "ClearLogoutCompletedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LogoutDelegate": "the delegate to use for notifications"
          }
        },
        "ClearMutingChangeDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "ClearPlayerTalkingDelegate": {
          "comment": "Removes a talker delegate to the list of notifications",
          "params": {
            "TalkerDelegate": "the delegate to remove from the notification list"
          }
        },
        "ClearReadAchievementsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to read the achievements list for",
            "ReadAchievementsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadFriendsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadFriendsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadOnlineStatsCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ReadOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadPlayerStorageCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadPlayerStorageCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadPlayerStorageForNetIdCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "NetId": "the net id for the user to watch for read complete notifications",
            "ReadPlayerStorageForNetIdCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadProfileSettingsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadTitleFileCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to remove"
          }
        },
        "ClearReceivedGameInviteDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "ReceivedGameInviteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRecognitionCompleteDelegate": {
          "comment": "Clears the speech recognition notification callback to use for the specified user",
          "params": {
            "LocalUserNum": "the local user to receive notifications for",
            "RecognitionDelegate": "the delegate to call when recognition is complete"
          }
        },
        "ClearRegisterHostStatGuidCompleteDelegateDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code",
          "params": {
            "RegisterHostStatGuidCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearStorageDeviceChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "StorageDeviceChangeDelegate": "the delegate to remove"
          }
        },
        "ClearUnlockAchievementCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the achievement unlocking has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "UnlockAchievementCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearWritePlayerStorageCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WritePlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearWriteProfileSettingsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "CreateLocalAccount": {
          "comment": "Creates a non-networked account on the local system. Password is only used\n when supplied. Otherwise the account is not secured.",
          "params": {
            "UserName": "the unique nickname of the account",
            "Password": "the password securing the account"
          }
        },
        "CreateOnlineAccount": {
          "comment": "Creates a network enabled account on the online service",
          "params": {
            "UserName": "the unique nickname of the account",
            "Password": "the password securing the account",
            "EmailAddress": "the address used to send password hints to"
          }
        },
        "DeleteLocalAccount": {
          "comment": "Deletes a local account if the password matches",
          "params": {
            "UserName": "the unique nickname of the account",
            "Password": "the password securing the account"
          }
        },
        "DeleteMessage": {
          "comment": "Deletes a message from the list of messages",
          "params": {
            "LocalUserNum": "the user that is deleting the message",
            "MessageIndex": "the index of the message to delete"
          }
        },
        "DenyFriendInvite": {
          "comment": "Used to deny a friend request sent to this player",
          "params": {
            "LocalUserNum": "the user the invite is for",
            "RequestingPlayer": "the player the invite is from",
            "true": "if successful, false otherwise"
          }
        },
        "FlushOnlineStats": {
          "comment": "Commits any changes in the online stats cache to the permanent storage",
          "params": {
            "SessionName": "the name of the session having stats flushed"
          }
        },
        "FreeStats": {
          "comment": "Cleans up any platform specific allocated data contained in the stats data",
          "params": {
            "StatsRead": "the object to handle per platform clean up on"
          }
        },
        "GetAchievements": {
          "comment": "Copies the list of achievements for the specified player and title id",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Achievements": "the out array that receives the copied data",
            "TitleId": "the title id of the game that these were read for"
          }
        },
        "GetClientStatGuid": {
          "comment": "Reads the client's stat guid that was generated by registering the host's guid\n Used for synching up stats. Only valid on the client. Only callable after the\n host registration has completed"
        },
        "GetFriendMessages": {
          "comment": "Returns the list of messages for the specified player",
          "params": {
            "LocalUserNum": "the local player wanting to join",
            "FriendMessages": "the set of messages cached locally for the player"
          }
        },
        "GetFriendsList": {
          "comment": "Copies the list of friends for the player previously retrieved from the online\n service. The list can be retrieved in whole or in part.",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Friends": "the out array that receives the copied data",
            "Count": "the number of friends to read or zero for all",
            "StartingAt": "the index of the friends list to start at (for pulling partial lists)"
          }
        },
        "GetHostStatGuid": {
          "comment": "Reads the host's stat guid for synching up stats. Only valid on the host."
        },
        "GetKeyboardInputResults": {
          "comment": "Fetches the results of the input",
          "params": {
            "bWasCanceled": "whether the user cancelled the input or not"
          }
        },
        "GetLocalAccountNames": {
          "comment": "Fetches a list of local accounts",
          "params": {
            "Accounts": "the array that is populated with the accounts"
          }
        },
        "GetLocale": {
          "comment": "Determine the locale (country code) for the player"
        },
        "GetLoginStatus": {
          "comment": "Fetches the login status for a given player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "GetNATType": {
          "comment": "Determines the NAT type the player is using"
        },
        "GetNetworkNotificationPosition": {
          "comment": "Determines the current notification position setting"
        },
        "GetPlayerNickname": {
          "comment": "Reads the player's nick name from the online service",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "GetPlayerNicknameFromIndex": {
          "comment": "Returns the name of the player for the specified index",
          "params": {
            "UserIndex": "the user to return the name of"
          }
        },
        "GetPlayerStorage": {
          "comment": "Returns the online player storage for a given local user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for"
          }
        },
        "GetPlayerUniqueNetIdFromIndex": {
          "comment": "Returns the unique id of the player for the specified index",
          "params": {
            "UserIndex": "the user to return the id of"
          }
        },
        "GetProfileSettings": {
          "comment": "Returns the online profile settings for a given user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for"
          }
        },
        "GetRecognitionResults": {
          "comment": "Gets the results of the voice recognition",
          "params": {
            "LocalUserNum": "the local user to read the results of",
            "Words": "the set of words that were recognized by the voice analyzer"
          }
        },
        "GetTitleFileContents": {
          "comment": "Copies the file data into the specified buffer for the specified file",
          "params": {
            "FileName": "the name of the file to read",
            "FileContents": "the out buffer to copy the data into"
          }
        },
        "GetTitleFileState": {
          "comment": "Determines the async state of the tile file read operation",
          "params": {
            "FileName": "the name of the file to check on"
          }
        },
        "GetUniquePlayerId": {
          "comment": "Gets the platform specific unique id for the specified player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the byte array that will receive the id"
          }
        },
        "HasLinkConnection": {
          "comment": "Determines if the ethernet link is connected or not"
        },
        "Init": {
          "comment": "Called from engine start up code to allow the subsystem to initialize"
        },
        "IsControllerConnected": {
          "comment": "Determines if the specified controller is connected or not",
          "params": {
            "ControllerId": "the controller to query"
          }
        },
        "IsFriend": {
          "comment": "Checks that a unique player id is part of the specified user's friends list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being checked"
          }
        },
        "IsGuestLogin": {
          "comment": "Determines whether the specified user is a guest login or not",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "IsHeadsetPresent": {
          "comment": "Determines if the specified player has a headset connected",
          "params": {
            "LocalUserNum": "the local player index being queried"
          }
        },
        "IsLocalLogin": {
          "comment": "Determines whether the specified user is a local (non-online) login or not",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "IsLocalPlayerTalking": {
          "comment": "Determines if the specified player is actively talking into the mic",
          "params": {
            "LocalUserNum": "the local player index being queried"
          }
        },
        "IsMuted": {
          "comment": "Checks that a unique player id is on the specified user's mute list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being checked"
          }
        },
        "IsRemotePlayerTalking": {
          "comment": "Determines if the specified remote player is actively talking into the mic\n NOTE: Network latencies will make this not 100% accurate",
          "params": {
            "PlayerId": "the unique id of the remote player being queried"
          }
        },
        "JoinFriendGame": {
          "comment": "Allows the local player to follow a friend into a game",
          "params": {
            "LocalUserNum": "the local player wanting to join",
            "Friend": "the player that is being followed"
          }
        },
        "Login": {
          "comment": "Logs the player into the online service. If this fails, it generates a\n OnLoginFailed notification",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginName": "the unique identifier for the player",
            "Password": "the password for this account",
            "bWantsLocalOnly": "whether the player wants to sign in locally only or not"
          }
        },
        "Logout": {
          "comment": "Signs the player out of the online service",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "MuteAll": {
          "comment": "Mutes all voice or all but friends",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "bAllowFriends": "whether to mute everyone or allow friends"
          }
        },
        "MuteRemoteTalker": {
          "comment": "Mutes a remote talker for the specified local player. NOTE: This only mutes them in the\n game unless the bIsSystemWide flag is true, which attempts to mute them globally",
          "params": {
            "LocalUserNum": "the user that is muting the remote talker",
            "PlayerId": "the remote talker that is being muted",
            "bIsSystemWide": "whether to try to mute them globally or not"
          }
        },
        "ReadAchievements": {
          "comment": "Starts an async read for the achievement list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "TitleId": "the title id of the game the achievements are to be read for",
            "bShouldReadText": "whether to fetch the text strings or not",
            "bShouldReadImages": "whether to fetch the image data or not"
          }
        },
        "ReadFriendsList": {
          "comment": "Starts an async task that retrieves the list of friends for the player from the\n online service. The list can be retrieved in whole or in part.",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Count": "the number of friends to read or zero for all",
            "StartingAt": "the index of the friends list to start at (for pulling partial lists)"
          }
        },
        "ReadOnlineStats": {
          "comment": "Reads a set of stats for the specified list of players",
          "params": {
            "Players": "the array of unique ids to read stats for",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object"
          }
        },
        "ReadOnlineStatsByRank": {
          "comment": "Reads stats by ranking. This grabs the rows starting at StartIndex through\n NumToRead and places them in the StatsRead object.",
          "params": {
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object",
            "StartIndex": "the starting rank to begin reads at (1 for top)",
            "NumToRead": "the number of rows to read (clamped at 100 underneath)"
          }
        },
        "ReadOnlineStatsByRankAroundPlayer": {
          "comment": "Reads stats by ranking centered around a player. This grabs a set of rows\n above and below the player's current rank",
          "params": {
            "LocalUserNum": "the local player having their stats being centered upon",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object",
            "NumRows": "the number of rows to read above and below the player's rank"
          }
        },
        "ReadOnlineStatsForFriends": {
          "comment": "Reads a player's stats and all of that player's friends stats for the\n specified set of stat views. This allows you to easily compare a player's\n stats to their friends.",
          "params": {
            "LocalUserNum": "the local player having their stats and friend's stats read for",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object"
          }
        },
        "ReadPlayerStorage": {
          "comment": "Reads the online player storage data for a given local user\n If a valid storage device ID is specified then data is also read from that device and the newer version is kept.",
          "params": {
            "LocalUserNum": "the user that we are reading the data for",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read",
            "DeviceId": "optional ID for connected device to read from. -1 for no device"
          }
        },
        "ReadPlayerStorageForNetId": {
          "comment": "Reads the online player storage data for a given net user",
          "params": {
            "LocalUserNum": "the local user that is initiating the read",
            "NetId": "the net user that we are reading the data for",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read"
          }
        },
        "ReadProfileSettings": {
          "comment": "Reads the online profile settings for a given user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for",
            "ProfileSettings": "the object to copy the results to and contains the list of items to read"
          }
        },
        "ReadTitleFile": {
          "comment": "Starts an asynchronous read of the specified file from the network platform's\n title specific file store",
          "params": {
            "FileToRead": "the name of the file to read"
          }
        },
        "RegisterHostStatGuid": {
          "comment": "Registers the host's stat guid with the client for verification they are part of\n the stat. Note this is an async task for any backend communication that needs to\n happen before the registration is deemed complete",
          "params": {
            "HostStatGuid": "the host's stat guid"
          }
        },
        "RegisterLocalTalker": {
          "comment": "Registers the user as a talker",
          "params": {
            "LocalUserNum": "the local player index that is a talker"
          }
        },
        "RegisterRemoteTalker": {
          "comment": "Registers a remote player as a talker",
          "params": {
            "PlayerId": "the unique id of the remote player that is a talker"
          }
        },
        "RegisterStatGuid": {
          "comment": "Registers the client's stat guid on the host to validate that the client was in the stat.\n Used for synching up stats. Only valid on the host.",
          "params": {
            "PlayerId": "the client's unique net id",
            "ClientStatGuid": "the client's stat guid"
          }
        },
        "RemoveFriend": {
          "comment": "Removes a friend from the player's friend list",
          "params": {
            "LocalUserNum": "the user that is removing the friend",
            "FormerFriend": "the player to remove from the friend list"
          }
        },
        "RenameLocalAccount": {
          "comment": "Changes the name of a local account",
          "params": {
            "UserName": "the unique nickname of the account",
            "Password": "the password securing the account"
          }
        },
        "SelectVocabulary": {
          "comment": "Changes the vocabulary id that is currently being used",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "VocabularyId": "the new id to use"
          }
        },
        "SendGameInviteToFriend": {
          "comment": "Sends an invitation to play in the player's current session",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "Friend": "the player to send the invite to",
            "Text": "the text of the message for the invite"
          }
        },
        "SendGameInviteToFriends": {
          "comment": "Sends invitations to play in the player's current session",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "Friends": "the player to send the invite to",
            "Text": "the text of the message for the invite"
          }
        },
        "SendMessageToFriend": {
          "comment": "Sends a message to a friend",
          "params": {
            "LocalUserNum": "the user that is sending the message",
            "Friend": "the player to send the message to",
            "Message": "the message to display to the recipient"
          }
        },
        "SetNetworkNotificationPosition": {
          "comment": "Sets a new position for the network notification icons/images",
          "params": {
            "NewPos": "the new location to use"
          }
        },
        "SetOnlineStatus": {
          "comment": "Sets the online status information to use for the specified player. Used to\n tell other players what the player is doing (playing, menus, away, etc.)",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "StatusId": "the status id to use (maps to strings where possible)",
            "LocalizedStringSettings": "the list of localized string settings to set",
            "Properties": "the list of properties to set"
          }
        },
        "SetRemoteTalkerPriority": {
          "comment": "Sets the relative priority for a remote talker. 0 is highest",
          "params": {
            "LocalUserNum": "the user that controls the relative priority",
            "PlayerId": "the remote talker that is having their priority changed for",
            "Priority": "the relative priority to use (0 highest, < 0 is muted)"
          }
        },
        "SetSpeechRecognitionObject": {
          "comment": "Changes the object that is in use to the one specified",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "SpeechRecogObj": "the new object use",
            "true": "if successful, false otherwise"
          }
        },
        "ShowFriendsUI": {
          "comment": "Displays the UI that shows a user's list of friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowKeyboardUI": {
          "comment": "Displays the UI that shows the keyboard for inputing text",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "TitleText": "the title to display to the user",
            "DescriptionText": "the text telling the user what to input",
            "bIsPassword": "whether the item being entered is a password or not",
            "bShouldValidate": "whether to apply the string validation API after input or not",
            "DefaultText": "the default string to display",
            "MaxResultLength": "the maximum length string expected to be filled in"
          }
        },
        "ShowLoginUI": {
          "comment": "Displays the UI that prompts the user for their login credentials. Each\n platform handles the authentication of the user's data.",
          "params": {
            "bShowOnlineOnly": "whether to only display online enabled profiles or not"
          }
        },
        "StartNetworkedVoice": {
          "comment": "Tells the voice layer that networked processing of the voice data is allowed\n for the specified player. This allows for push-to-talk style voice communication",
          "params": {
            "LocalUserNum": "the local user to allow network transimission for"
          }
        },
        "StartSpeechRecognition": {
          "comment": "Tells the voice system to start tracking voice data for speech recognition",
          "params": {
            "LocalUserNum": "the local user to recognize voice data for"
          }
        },
        "StopNetworkedVoice": {
          "comment": "Tells the voice layer to stop processing networked voice support for the\n specified player. This allows for push-to-talk style voice communication",
          "params": {
            "LocalUserNum": "the local user to disallow network transimission for"
          }
        },
        "StopSpeechRecognition": {
          "comment": "Tells the voice system to stop tracking voice data for speech recognition",
          "params": {
            "LocalUserNum": "the local user to recognize voice data for"
          }
        },
        "UnlockAchievement": {
          "comment": "Unlocks the specified achievement for the specified user",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "AchievementId": "the id of the achievement to unlock"
          }
        },
        "UnmuteAll": {
          "comment": "Allows all speakers to send voice",
          "params": {
            "LocalUserNum": "the local user that is making the change"
          }
        },
        "UnmuteRemoteTalker": {
          "comment": "Allows a remote talker to talk to the specified local player. NOTE: This only unmutes them in the\n game unless the bIsSystemWide flag is true, which attempts to unmute them globally",
          "params": {
            "LocalUserNum": "the user that is allowing the remote talker to talk",
            "PlayerId": "the remote talker that is being restored to talking",
            "bIsSystemWide": "whether to try to unmute them globally or not"
          }
        },
        "UnregisterLocalTalker": {
          "comment": "Unregisters the user as a talker",
          "params": {
            "LocalUserNum": "the local player index to be removed"
          }
        },
        "UnregisterRemoteTalker": {
          "comment": "Unregisters a remote player as a talker",
          "params": {
            "PlayerId": "the unique id of the remote player to be removed"
          }
        },
        "WriteOnlinePlayerScores": {
          "comment": "Writes the score data for the match",
          "params": {
            "SessionName": "the name of the session to write scores for",
            "LeaderboardId": "the leaderboard to write the score information to",
            "PlayerScores": "the list of players, teams, and scores they earned"
          }
        },
        "WriteOnlineStats": {
          "comment": "Writes out the stats contained within the stats write object to the online\n subsystem's cache of stats data. Note the new data replaces the old. It does\n not write the data to the permanent storage until a FlushOnlineStats() call\n or a session ends. Stats cannot be written without a session or the write\n request is ignored. No more than 5 stats views can be written to at a time\n or the write request is ignored.",
          "params": {
            "SessionName": "the name of the session to write stats for",
            "Player": "the player to write stats for",
            "StatsWrite": "the object containing the information to write"
          }
        },
        "WritePlayerStorage": {
          "comment": "Writes the online player storage data for a given local user to the online data store\n If a valid storage device ID is specified then data is also written to that device.",
          "params": {
            "LocalUserNum": "the user that we are writing the data for",
            "PlayerStorage": "the object that contains the list of items to write",
            "DeviceId": "optional ID for connected device to write to. -1 for no device"
          }
        },
        "WriteProfileSettings": {
          "comment": "Writes the online profile settings for a given user to the online data store",
          "params": {
            "LocalUserNum": "the user that we are writing the data for",
            "ProfileSettings": "the list of settings to write out"
          }
        }
      },
      "structs": {
        "ControllerConnectionState": {
          "comment": "Struct to hold current and previous frame's game state",
          "properties": {
            "bIsControllerConnected": {
              "comment": "Whether the controller is connected or not"
            },
            "bLastIsControllerConnected": {
              "comment": "Last frame's version of the above"
            }
          }
        },
        "LocalTalkerGS": {
          "comment": "Adds to the local talker definition so we can support muting"
        },
        "OnlineStatusMapping": {
          "comment": "Holds the items used to map an online status string to its format string",
          "properties": {
            "StatusId": {
              "comment": "The id of the status string"
            },
            "StatusString": {
              "comment": "The format string to use to apply the passed in properties/strings"
            }
          }
        },
        "PendingPlayerStats": {
          "comment": "This stores the stats for a single player before being written out to the backend",
          "properties": {
            "Place": {
              "comment": "This player's place when sorted against the other players. Calculated at reporting time"
            },
            "Player": {
              "comment": "The player for which stats are being written"
            },
            "PlayerName": {
              "comment": "The name of the player to report with"
            },
            "Score": {
              "comment": "The score for this player"
            },
            "StatGuid": {
              "comment": "This is a per-player guid that needs to be passed to the backend"
            },
            "Stats": {
              "comment": "The stats for this player"
            }
          }
        },
        "PerUserProfileDelegates": {
          "properties": {
            "Delegates": {
              "comment": "The array of delegates that notify read completion of profile data"
            }
          }
        },
        "PlayerStat": {
          "comment": "This holds a single stat waiting to be written out",
          "properties": {
            "Data": {
              "comment": "The stat's value"
            },
            "KeyId": {
              "comment": "The GameSpy key for this stat"
            }
          }
        },
        "ViewPropertyToKeyId": {
          "comment": "Maps a view and property to a gamespy stats key\n If only PropertyId is 0, then this is the KeyId for the View itself",
          "properties": {
            "KeyId": {
              "comment": "The id of the gamespy stats key"
            },
            "PropertyId": {
              "comment": "The id of the property"
            },
            "ViewId": {
              "comment": "The id of the view"
            }
          }
        }
      }
    }
  },
  "OnlineSubsystemLive": {
    "ClientBeaconAddressResolverLive": {
      "comment": "This is the Live specific version of beacon address resolver. It handles registering \n unregistering of secure keys so that communication with a potential host is\n possible"
    },
    "DownloadableContentEnumeratorLive": {
      "comment": "This object is responsible for the enumeration of downloadable content bundles on Xbox Live",
      "properties": {
        "ReadsOutstanding": {
          "comment": "The number of reads that are outstanding"
        }
      },
      "functions": {
        "AppendDLC": {
          "comment": "Appends the specified array to the DLCBundles array",
          "params": {
            "Bundles": "the array to append"
          }
        },
        "DeleteDLC": {
          "comment": "Can't work, so ignore the call",
          "params": {
            "DLCName": "the name of the DLC bundle to delete"
          }
        },
        "FindDLC": {
          "comment": "Uses the OnlineContentInterface to populate the DLC data for all signed in users"
        },
        "OnReadContentComplete": {
          "comment": "Called when an async read of content has completed",
          "params": {
            "bWasSuccessful": "whether the read worked or not"
          }
        }
      }
    },
    "LivePartyChat": {
      "comment": "This class implements the live party chat interface",
      "properties": {
        "AsyncTasks": {
          "comment": "This is the array of pending async tasks. Each tick these tasks are checked\n completion. If complete, the delegate associated with them is called"
        },
        "BandwidthUsed": {
          "comment": "The bandwidth used by party chat over the last second"
        },
        "CachedPartyMembers": {
          "comment": "Used to track changes to the membership list"
        },
        "ElapsedTime": {
          "comment": "The amount of elapsed time since the last time we updated the bandwidth information"
        },
        "NotificationHandle": {
          "comment": "The notification handle to use for polling events"
        },
        "PartyChatDelegates[4]": {
          "comment": "Used for per player index notification of party game invite delegates"
        },
        "TotalBandwidthUsed": {
          "comment": "How much data has been used across all sessions"
        }
      },
      "functions": {
        "AddPartyMemberListChangedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that async task has completed",
          "params": {
            "LocalUserNum": "the user to listening for party chat notifications",
            "PartyMemberListChangedDelegate": "the delegate to use for notifications"
          }
        },
        "AddPartyMembersInfoChangedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that async task has completed",
          "params": {
            "LocalUserNum": "the user to listening for party chat notifications",
            "PartyMembersInfoChangedDelegate": "the delegate to use for notifications"
          }
        },
        "AddSendPartyGameInvitesCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to sending the invites",
            "SendPartyGameInvitesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearPartyMemberListChangedDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that async task has completed",
          "params": {
            "LocalUserNum": "the user to listening for party chat notifications",
            "PartyMemberListChangedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearPartyMembersInfoChangedDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that async task has completed",
          "params": {
            "LocalUserNum": "the user to listening for party chat notifications",
            "PartyMembersInfoChangedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearSendPartyGameInvitesCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to sending the invites",
            "SendPartyGameInvitesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "GetPartyBandwidth": {
          "comment": "Determines the amount of data that has been sent in the last second"
        },
        "GetPartyMemberInformation": {
          "comment": "Gets the individual party member's information from the platform, including the application specific data",
          "params": {
            "MemberId": "the id of the party member to lookup",
            "PartyMember": "out value where the data is copied to"
          }
        },
        "GetPartyMembersInformation": {
          "comment": "Gets the party member information from the platform, including the application specific data",
          "params": {
            "PartyMembers": "the array to be filled out of party member information"
          }
        },
        "IsInPartyChat": {
          "comment": "Checks for the specified player being in a party chat",
          "params": {
            "LocalUserNum": "the user that you are setting the data for"
          }
        },
        "SendPartyGameInvites": {
          "comment": "Sends an invite to everyone in the existing party session",
          "params": {
            "LocalUserNum": "the user to sending the invites"
          }
        },
        "SetPartyMemberCustomData": {
          "comment": "Sets a party member's application specific data",
          "params": {
            "LocalUserNum": "the user that you are setting the data for",
            "Data1": "the first 4 bytes of custom data",
            "Data2": "the second 4 bytes of custom data",
            "Data3": "the third 4 bytes of custom data",
            "Data4": "the fourth 4 bytes of custom data"
          }
        },
        "ShowCommunitySessionsUI": {
          "comment": "Opens the community sessions UI for the user",
          "params": {
            "LocalUserNum": "the user requesting the UI"
          }
        },
        "ShowPartyUI": {
          "comment": "Opens the party UI for the user",
          "params": {
            "LocalUserNum": "the user requesting the UI"
          }
        },
        "ShowVoiceChannelUI": {
          "comment": "Opens the voice channel UI for the user",
          "params": {
            "LocalUserNum": "the user requesting the UI"
          }
        }
      },
      "structs": {
        "PerUserPartyChatDelegates": {
          "comment": "Holds an array of party chat delegates",
          "properties": {
            "GameInviteDelegates": {
              "comment": "This is the list of requested delegates to fire"
            },
            "PartyMemberDelegates": {
              "comment": "This is the list of requested delegates to fire"
            },
            "PartyMemberInfoDelegates": {
              "comment": "This is the list of requested delegates to fire"
            }
          }
        }
      }
    },
    "OnlineEventsInterfaceMcpLive": {
      "comment": "Provides an in game gameplay events/stats upload mechanism via the MCP backend"
    },
    "OnlineSubsystemLive": {
      "properties": {
        "AchievementList": {
          "comment": "Holds the list of achievements that have been read for players"
        },
        "AnyContentChangeDelegates": {
          "comment": "The list of delegates to notify when any content changes"
        },
        "ArbitrationRegistrationCompleteDelegates": {
          "comment": "Array of delegates to multicast with for arbitration registration notification"
        },
        "AsyncTasks": {
          "comment": "This is the array of pending async tasks. Each tick these tasks are checked\n completion. If complete, the delegate associated with them is called"
        },
        "bIsCountingDownSigninNotification": {
          "comment": "Whether the code is ticking the count down timer or not"
        },
        "bIsInSignInUI": {
          "comment": "Used to track when a user cancels a sign-in request so that code waiting for a result can continue"
        },
        "bShouldLogArbitrationData": {
          "comment": "Whether to log arbitration data or not"
        },
        "bShouldLogStatsData": {
          "comment": "Whether to log stats (including true skill) data or not"
        },
        "bShouldUseMcp": {
          "comment": "Whether to use MCP or not"
        },
        "bWasKeyboardInputCanceled": {
          "comment": "Whether the user canceled keyboard input or not"
        },
        "CancelFindOnlineGamesCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game search cancellation notification"
        },
        "ConnectionStatusChangeDelegates": {
          "comment": "This is the list of delegates requesting notification Live's connection state changes"
        },
        "ContentCache[4]": {
          "comment": "Cache of content list per player"
        },
        "ControllerChangeDelegates": {
          "comment": "This is the list of delegates requesting notification when a controller's state changes"
        },
        "CreateOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game creation notification"
        },
        "CurrentNotificationPosition": {
          "comment": "Where Live notifications will be displayed on the screen"
        },
        "CurrentStatsRead": {
          "comment": "The currently outstanding stats read request"
        },
        "DebugLogLevel": {
          "comment": "Sets the debug logging level for getting extra spew from Live"
        },
        "DelayedInviteUserMask": {
          "comment": "A bit mask indicating which players have a pending invite that was delayed at start up"
        },
        "DestroyOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game destruction notification"
        },
        "DeviceCache[4]": {
          "comment": "Holds the last results of device selection"
        },
        "EndOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game ending notification"
        },
        "ExternalUIChangeDelegates": {
          "comment": "This is the list of delegates requesting notification when a Live UI opens/closes"
        },
        "FindOnlineGamesCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game search notification"
        },
        "FlushOnlineStatsDelegates": {
          "comment": "The list of delegates to notify when the stats flush is complete"
        },
        "FriendsCache[4]": {
          "comment": "Cache of friends data per player"
        },
        "GameSearch": {
          "comment": "The current game search object in use"
        },
        "InviteCache[4]": {
          "comment": "The cached data for the players"
        },
        "JoinFriendGameCompleteDelegates": {
          "comment": "Holds the list of delegates that are interested in receiving join friend completions"
        },
        "JoinMigratedOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for migrated game join notification"
        },
        "JoinOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game join notification"
        },
        "KeyboardInputDelegates": {
          "comment": "The list of delegates to notify when the keyboard input is complete"
        },
        "KeyboardInputResults": {
          "comment": "Holds the last keyboard input results"
        },
        "LanAnnouncePort": {
          "comment": "Port to listen on for LAN queries/responses"
        },
        "LanBeacon": {
          "comment": "LAN announcement socket used to send/receive discovery packets"
        },
        "LanBeaconState": {
          "comment": "The current state the lan beacon is in"
        },
        "LanGameUniqueId": {
          "comment": "Unique id to keep UE3 games from seeing each others' lan packets"
        },
        "LanNonce[8]": {
          "comment": "Used by a client to uniquely identify itself during lan match discovery"
        },
        "LanPacketPlatformMask": {
          "comment": "Mask containing which platforms can cross communicate"
        },
        "LanQueryTimeLeft": {
          "comment": "The amount of time before the lan query is considered done"
        },
        "LanQueryTimeout": {
          "comment": "The amount of time to wait before timing out a lan query request"
        },
        "LastInputDeviceConnectedMask": {
          "comment": "Holds a true/false connection state for each of the possible 4 controllers"
        },
        "LastLoginState[4]": {
          "comment": "The set of last known xuids & state for sign in change comparisons"
        },
        "LinkStatusChangeDelegates": {
          "comment": "This is the list of delegates requesting notification of link status changes"
        },
        "LocalTalkers[4]": {
          "comment": "Holds information about each of the local talkers"
        },
        "LoginCancelledDelegates": {
          "comment": "This is the list of requested delegates to fire when a login is cancelled"
        },
        "LoginChangeDelegates": {
          "comment": "Holds the list of delegates to fire when any login changes"
        },
        "LoginFailedDelegates": {
          "comment": "This is the list of requested delegates to fire when a login fails to process"
        },
        "LogoutCompletedDelegates": {
          "comment": "This is the list of requested delegates to fire when a logout completes"
        },
        "LspNames": {
          "comment": "The list of LSPs to cache the DNS information for so that we don't repeatedly enumerate them"
        },
        "MaxElapsedAsyncTaskTime": {
          "comment": "The maximum amount of time to wait for an async task before treating it as having an error"
        },
        "MigrateOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game migration notification"
        },
        "MutingChangeDelegates": {
          "comment": "Holds the list of delegates that are interested in receiving mute change notifications"
        },
        "NotificationHandle": {
          "comment": "The notification handle to use for polling events"
        },
        "NumLogins": {
          "comment": "The number of simultaneous logins allowed (1, 2, or 4)"
        },
        "PerUserDelegates[4]": {
          "comment": "Per user array of array of delegates"
        },
        "PlayerLoginStatusDelegates[4]": {
          "comment": "Used for per player index notification of login status changes"
        },
        "PlayerStorageCacheLocal[4]": {
          "comment": "Holds the per player online storage data (only for local players)"
        },
        "PlayerStorageCacheRemote": {
          "comment": "Map of unique net id to player storage cache entry (only for remote pla`ters)"
        },
        "ProfileCache[4]": {
          "comment": "Holds the per player profile data"
        },
        "QoSPacket[512]": {
          "comment": "QoS packet with extra data to send to client"
        },
        "QosStatusChangedDelegates": {
          "comment": "Array of delegates to multicast with for game search qos changed notifications"
        },
        "ReadOnlineStatsCompleteDelegates": {
          "comment": "This is the list of delegates requesting notification when a stats read finishes"
        },
        "ReadTitleFileCompleteDelegates": {
          "comment": "The list of delegates to notify when a network platform file is read"
        },
        "RecalculateSkillRatingCompleteDelegates": {
          "comment": "Array of delegates to multicast with for skill rating update notification"
        },
        "RegisterPlayerCompleteDelegates": {
          "comment": "Array of delegates to multicast with for player registration notification"
        },
        "RemoteTalkers": {
          "comment": "Array of registered remote talkers"
        },
        "SigninCountDownCounter": {
          "comment": "The current elapsed time while waiting to signal a sign in change"
        },
        "SigninCountDownDelay": {
          "comment": "The value to use as the delay between sign in notification from Live and processing it"
        },
        "StartOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game starting notification"
        },
        "StorageDeviceChangeDelegates": {
          "comment": "This is the list of delegates requesting notification of storage device changes"
        },
        "TalkingDelegates": {
          "comment": "Holds the list of delegates that are interested in receiving talking notifications"
        },
        "TitleManagedFiles": {
          "comment": "The list of title managed storage files that have been read or are being read"
        },
        "UnregisterPlayerCompleteDelegates": {
          "comment": "Array of delegates to multicast with for player unregistration notification"
        },
        "UpdateOnlineGameCompleteDelegates": {
          "comment": "Array of delegates to multicast with for game update notification"
        },
        "VoiceNotificationDelta": {
          "comment": "The amount of time between voice notifications"
        }
      },
      "functions": {
        "AcceptFriendInvite": {
          "comment": "Used to accept a friend invite sent to this player",
          "params": {
            "LocalUserNum": "the user the invite is for",
            "RequestingPlayer": "the player the invite is from",
            "true": "if successful, false otherwise"
          }
        },
        "AcceptGameInvite": {
          "comment": "Tells the online subsystem to accept the game invite that is currently pending",
          "params": {
            "LocalUserNum": "the local user accepting the invite",
            "SessionName": "the name of the session this invite is to be known as"
          }
        },
        "AddAddFriendByNameCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "FriendDelegate": "the delegate to use for notifications"
          }
        },
        "AddArbitrationRegistrationCompleteDelegate": {
          "comment": "Sets the notification callback to use when arbitration registration has completed",
          "params": {
            "ArbitrationRegistrationCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddCancelFindOnlineGamesCompleteDelegate": {
          "comment": "Adds the delegate to the list to notify with",
          "params": {
            "CancelFindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddConnectionStatusChangeDelegate": {
          "comment": "Adds the delegate to the list to be notified when the connection status changes",
          "params": {
            "ConnectionStatusDelegate": "the delegate to add"
          }
        },
        "AddContentChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that (downloaded) content changed",
          "params": {
            "Content": "Delegate the delegate to use for notifications",
            "LocalUserNum": "whether to watch for changes on a specific slot or all slots"
          }
        },
        "AddControllerChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the controller state changed",
          "params": {
            "ControllerChangeDelegate": "the delegate to use for notifications"
          }
        },
        "AddCreateOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game they\n created has completed the creation process",
          "params": {
            "CreateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddDestroyOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game they\n destroyed has completed the destruction process",
          "params": {
            "DestroyOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddDeviceSelectionDoneDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the user has completed\n their device selection",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "DeviceDelegate": "the delegate to use for notifications"
          }
        },
        "AddEndOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game has\n transitioned to the ending state.",
          "params": {
            "EndOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddExternalUIChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that external UI state\n changed (opened/closed)",
          "params": {
            "ExternalUIDelegate": "the delegate to use for notifications"
          }
        },
        "AddFindOnlineGamesCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the search they\n kicked off has completed",
          "params": {
            "FindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFlushOnlineStatsCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the stats flush has completed",
          "params": {
            "FlushOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriend": {
          "comment": "Sends a friend invite to the specified player",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "NewFriend": "the player to send the friend request to",
            "Message": "the message to display to the recipient"
          }
        },
        "AddFriendByName": {
          "comment": "Sends a friend invite to the specified player nick",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "FriendName": "the name of the player to send the invite to",
            "Message": "the message to display to the recipient"
          }
        },
        "AddFriendInviteReceivedDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "InviteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriendMessageReceivedDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "MessageDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriendsChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a friends list changed",
          "params": {
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "AddGameInviteAcceptedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code when a game invite has been accepted",
          "params": {
            "LocalUserNum": "the user to request notification for",
            "GameInviteAcceptedDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinFriendGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify when the join friend is complete",
          "params": {
            "JoinFriendGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinMigratedOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the join request for a migrated session they\n kicked off has completed",
          "params": {
            "JoinMigratedOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the join request they\n kicked off has completed",
          "params": {
            "JoinOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddKeyboardInputDoneDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has completed\n their keyboard input",
          "params": {
            "InputDelegate": "the delegate to use for notifications"
          }
        },
        "AddLinkStatusChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that link status changed",
          "params": {
            "LinkStatusDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginCancelledDelegate": {
          "comment": "Adds a delegate to the list of delegates that are fired when a login is cancelled",
          "params": {
            "CancelledDelegate": "the delegate to add to the list"
          }
        },
        "AddLoginChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login changed",
          "params": {
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginFailedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login failed",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginStatusChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login status has changed",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "the player to watch login status changes for"
          }
        },
        "AddLogoutCompletedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a logout completed",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LogoutDelegate": "the delegate to use for notifications"
          }
        },
        "AddMigrateOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code when the session migration completes",
          "params": {
            "MigrateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddMutingChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a muting list changed",
          "params": {
            "MutingDelegate": "the delegate to use for notifications"
          }
        },
        "AddPlayerTalkingDelegate": {
          "comment": "Adds a talker delegate to the list of notifications",
          "params": {
            "TalkerDelegate": "the delegate to call when a player is talking"
          }
        },
        "AddProfileDataChangedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that someone has changed their profile data externally",
          "params": {
            "LocalUserNum": "the user the delegate is interested in",
            "ProfileDataChangedDelegate": "the delegate to use for notifications"
          }
        },
        "AddQosStatusChangedDelegate": {
          "comment": "Adds a delegate to the list of objects that want to be notified",
          "params": {
            "QosStatusChangedDelegate": "the delegate to use for notifications"
          }
        },
        "AddQueryAvailableDownloadsComplete": {
          "comment": "Sets the delegate used to notify the gameplay code that the content download query has completed",
          "params": {
            "LocalUserNum": "the user to check the content download availability for",
            "ReadContentCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadAchievementsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to read the achievements list for",
            "ReadAchievementsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadContentComplete": {
          "comment": "Sets the delegate used to notify the gameplay code that the content read request has completed",
          "params": {
            "LocalUserNum": "the user to read the content list of",
            "ContentType": "the type of content being read",
            "ReadContentCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadFriendsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the friends read request has completed",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "ReadFriendsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadOnlineStatsCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the stats read has completed",
          "params": {
            "ReadOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadPlayerStorageCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadPlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadPlayerStorageForNetIdCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "NetId": "the net id for the user to watch for read complete notifications",
            "ReadPlayerStorageForNetIdCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadProfileSettingsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadSaveGameDataComplete": {
          "comment": "Adds the delegate used to notify the gameplay code that a save game read request has completed",
          "params": {
            "LocalUserNum": "The user that was reading a save game",
            "ReadSaveGameDataCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadTitleFileCompleteDelegate": {
          "comment": "Adds the delegate to the list to be notified when a requested file has been read",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to add"
          }
        },
        "AddRecalculateSkillRatingCompleteDelegate": {
          "comment": "Adds a delegate to the list of objects that want to be notified",
          "params": {
            "RecalculateSkillRatingCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReceivedGameInviteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a game invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "ReceivedGameInviteDelegate": "the delegate to use for notifications"
          }
        },
        "AddRecognitionCompleteDelegate": {
          "comment": "Sets the speech recognition notification callback to use for the specified user",
          "params": {
            "LocalUserNum": "the local user to receive notifications for",
            "RecognitionDelegate": "the delegate to call when recognition is complete"
          }
        },
        "AddRegisterHostStatGuidCompleteDelegate": {
          "comment": "Adds the delegate for notifying when the host guid registration is done",
          "params": {
            "RegisterHostStatGuidCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddRegisterPlayerCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the player\n registration request they submitted has completed",
          "params": {
            "RegisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddStartOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game has\n transitioned to the started state.",
          "params": {
            "StartOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddStorageDeviceChangeDelegate": {
          "comment": "Adds the delegate to the list to be notified when a storage device changes",
          "params": {
            "StorageDeviceChangeDelegate": "the delegate to add"
          }
        },
        "AddUnlockAchievementCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the achievement unlocking has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "UnlockAchievementCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddUnregisterPlayerCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the player\n Unregistration request they submitted has completed",
          "params": {
            "UnregisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddUpdateOnlineGameCompleteDelegate": {
          "comment": "Adds a delegate to the list of objects that want to be notified",
          "params": {
            "UpdateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWritePlayerStorageCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WritePlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWriteProfileSettingsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWriteSaveGameDataComplete": {
          "comment": "Adds the delegate used to notify the gameplay code that a save game write request has completed",
          "params": {
            "LocalUserNum": "The user that was writing a save game",
            "WriteSaveGameDataCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AreAnyFriends": {
          "comment": "Checks that whether a group of player ids are among the specified player's\n friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Query": "an array of players to check for being included on the friends list"
          }
        },
        "BindPlatformSpecificSessionToSearch": {
          "comment": "Creates a search result out of the platform specific data and adds that to the specified search object",
          "params": {
            "SearchingPlayerNum": "the index of the player searching for a match",
            "SearchSettings": "the desired search to bind the session to",
            "PlatformSpecificInfo": "the platform specific information to convert to a server object"
          }
        },
        "CalcAggregateSkill": {
          "comment": "Calculates the aggregate skill from an array of skills.",
          "params": {
            "Mus": "array that holds the mu values",
            "Sigmas": "array that holds the sigma values",
            "OutAggregateMu": "aggregate Mu",
            "OutAggregateSigma": "aggregate Sigma"
          }
        },
        "CancelFindOnlineGames": {
          "comment": "Cancels the current search in progress if possible for that search type"
        },
        "CanCommunicate": {
          "comment": "Determines whether the player is allowed to use voice or text chat online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanDownloadUserContent": {
          "comment": "Determines whether the player is allowed to download user created content",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanPlayOnline": {
          "comment": "Determines whether the player is allowed to play online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanPurchaseContent": {
          "comment": "Determines whether the player is allowed to buy content online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanShowPresenceInformation": {
          "comment": "Determines whether the player is allowed to have their online presence\n information shown to remote clients",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanViewPlayerProfiles": {
          "comment": "Determines whether the player is allowed to view other people's player profile",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ClearAddFriendByNameCompleteDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "FriendDelegate": "the delegate to use for notifications"
          }
        },
        "ClearArbitrationRegistrationCompleteDelegate": {
          "comment": "Removes the notification callback to use when arbitration registration has completed",
          "params": {
            "ArbitrationRegistrationCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearCancelFindOnlineGamesCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "CancelFindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearConnectionStatusChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ConnectionStatusDelegate": "the delegate to remove"
          }
        },
        "ClearContentChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that (downloaded) content changed",
          "params": {
            "Content": "Delegate the delegate to use for notifications",
            "LocalUserNum": "whether to watch for changes on a specific slot or all slots"
          }
        },
        "ClearContentList": {
          "comment": "Starts an async task that frees any downloaded content resources for that player",
          "params": {
            "LocalUserNum": "The user to clear the content list for",
            "ContentType": "the type of content being read"
          }
        },
        "ClearControllerChangeDelegate": {
          "comment": "Removes the delegate used to notify the gameplay code that the controller state changed",
          "params": {
            "ControllerChangeDelegate": "the delegate to remove"
          }
        },
        "ClearCreateOnlineGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the online game they\n created has completed the creation process",
          "params": {
            "CreateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearDestroyOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the notification list",
          "params": {
            "DestroyOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearDeviceSelectionDoneDelegate": {
          "comment": "Removes the specified delegate from the list of callbacks",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "DeviceDelegate": "the delegate to use for notifications"
          }
        },
        "ClearDownloadedFile": {
          "comment": "Empties the cached data for this file if it is not being downloaded currently",
          "params": {
            "FileName": "the name of the file to remove from the cache"
          }
        },
        "ClearDownloadedFiles": {
          "comment": "Empties the set of downloaded files if possible (no async tasks outstanding)"
        },
        "ClearEndOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "EndOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearExternalUIChangeDelegate": {
          "comment": "Removes the delegate from the notification list",
          "params": {
            "ExternalUIDelegate": "the delegate to remove"
          }
        },
        "ClearFindOnlineGamesCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "FindOnlineGamesCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFlushOnlineStatsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the stats flush has completed",
          "params": {
            "FlushOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendInviteReceivedDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "InviteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendMessageReceivedDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "MessageDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendsChangeDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "ClearGameInviteAcceptedDelegate": {
          "comment": "Removes the delegate used to notify the gameplay code when a game invite has been accepted",
          "params": {
            "LocalUserNum": "the user to request notification for",
            "GameInviteAcceptedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinFriendGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "JoinFriendGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinMigratedOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "JoinMigratedOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "JoinOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearKeyboardInputDoneDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the user has completed\n their keyboard input",
          "params": {
            "InputDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLinkStatusChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "LinkStatusDelegate": "the delegate to remove"
          }
        },
        "ClearLoginCancelledDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "CancelledDelegate": "the delegate to remove fromt he list"
          }
        },
        "ClearLoginChangeDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLoginFailedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLoginStatusChangeDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "the player to watch login status changes for"
          }
        },
        "ClearLogoutCompletedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LogoutDelegate": "the delegate to use for notifications"
          }
        },
        "ClearMigrateOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "MigrateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearMutingChangeDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "MutingDelegate": "the delegate to use for notifications"
          }
        },
        "ClearPlayerTalkingDelegate": {
          "comment": "Removes a talker delegate to the list of notifications",
          "params": {
            "TalkerDelegate": "the delegate to remove from the notification list"
          }
        },
        "ClearProfileDataChangedDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that someone has changed their profile data externally",
          "params": {
            "LocalUserNum": "the user the delegate is interested in",
            "ProfileDataChangedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearQosStatusChangedDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "QosStatusChangedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearQueryAvailableDownloadsComplete": {
          "comment": "Sets the delegate used to notify the gameplay code that the content download query has completed",
          "params": {
            "LocalUserNum": "the user to check the content download availability for",
            "ReadContentCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadAchievementsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to read the achievements list for",
            "ReadAchievementsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadContentComplete": {
          "comment": "Sets the delegate used to notify the gameplay code that the content read request has completed",
          "params": {
            "LocalUserNum": "the user to read the content list of",
            "ContentType": "the type of content being read",
            "ReadContentCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadFriendsCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "ReadFriendsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadOnlineStatsCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ReadOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadPlayerStorageCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadPlayerStorageCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadPlayerStorageForNetIdCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "NetId": "the net id for the user to watch for read complete notifications",
            "ReadPlayerStorageForNetIdCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadProfileSettingsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadSaveGameDataComplete": {
          "comment": "Clears the delegate used to notify the gameplay code that a save game read request has completed",
          "params": {
            "LocalUserNum": "The user that was reading a save game",
            "ReadSaveGameDataCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadTitleFileCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to remove"
          }
        },
        "ClearRecalculateSkillRatingCompleteDelegate": {
          "comment": "Removes a delegate from the list of objects that want to be notified",
          "params": {
            "RecalculateSkillRatingCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReceivedGameInviteDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "ReceivedGameInviteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRecognitionCompleteDelegate": {
          "comment": "Clears the speech recognition notification callback to use for the specified user",
          "params": {
            "LocalUserNum": "the local user to receive notifications for",
            "RecognitionDelegate": "the delegate to call when recognition is complete"
          }
        },
        "ClearRegisterHostStatGuidCompleteDelegateDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code",
          "params": {
            "RegisterHostStatGuidCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRegisterPlayerCompleteDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "RegisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearSaveGames": {
          "comment": "Clears any cached save games",
          "params": {
            "LocalUserNum": "the user that is deleting data"
          }
        },
        "ClearStartOnlineGameCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "StartOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearStorageDeviceChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "StorageDeviceChangeDelegate": "the delegate to remove"
          }
        },
        "ClearUnlockAchievementCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the achievement unlocking has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "UnlockAchievementCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearUnregisterPlayerCompleteDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "UnregisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearUpdateOnlineGameCompleteDelegate": {
          "comment": "Removes a delegate from the list of objects that want to be notified",
          "params": {
            "UpdateOnlineGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearWritePlayerStorageCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WritePlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearWriteProfileSettingsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearWriteSaveGameDataComplete": {
          "comment": "Clears the delegate used to notify the gameplay code that a save game write request has completed",
          "params": {
            "LocalUserNum": "The user that was writing a save game",
            "WriteSaveGameDataCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "CreateOnlineGame": {
          "comment": "Creates an online game based upon the settings object specified.\n NOTE: online game registration is an async process and does not complete\n until the OnCreateOnlineGameComplete delegate is called.",
          "params": {
            "HostingPlayerNum": "the index of the player hosting the match",
            "SessionName": "the name to use for this session so that multiple sessions can exist at the same time",
            "NewGameSettings": "the settings to use for the new game session"
          }
        },
        "DeleteMessage": {
          "comment": "Deletes a message from the list of messages",
          "params": {
            "LocalUserNum": "the user that is deleting the message",
            "MessageIndex": "the index of the message to delete"
          }
        },
        "DeleteSaveGame": {
          "comment": "Deletes a player's save game data",
          "params": {
            "LocalUserNum": "the user that is deleting data",
            "DeviceId": "the device to delete the same game from",
            "FriendlyName": "the friendly name of the save game that was returned by enumeration",
            "FileName": "the file name of the content package to delete"
          }
        },
        "DenyFriendInvite": {
          "comment": "Used to deny a friend request sent to this player",
          "params": {
            "LocalUserNum": "the user the invite is for",
            "RequestingPlayer": "the player the invite is from",
            "true": "if successful, false otherwise"
          }
        },
        "DestroyOnlineGame": {
          "comment": "Destroys the specified online game",
          "params": {
            "SessionName": "the name of the session to delete"
          }
        },
        "DumpLiveSessionState": {
          "comment": "Enumerates the sessions that are set and call XSessionGetDetails() on them to\n log Live's view of the session information"
        },
        "DumpSessionState": {
          "comment": "Calls the base version to log Unreal's state and then calls the code that dumps\n the Live specific view of that state"
        },
        "DumpVoiceRegistration": {
          "comment": "Logs the list of players that are registered for voice"
        },
        "EndOnlineGame": {
          "comment": "Marks an online game as having been ended",
          "params": {
            "SessionName": "the name of the session the to end"
          }
        },
        "Exit": {
          "comment": "Called from the engine shutdown code to allow the Live to cleanup. Also, this\n version blocks until all async tasks are complete before returning."
        },
        "FindOnlineGames": {
          "comment": "Searches for games matching the settings specified",
          "params": {
            "SearchingPlayerNum": "the index of the player searching for a match",
            "SearchSettings": "the desired settings that the returned sessions will have"
          }
        },
        "FlushOnlineStats": {
          "comment": "Commits any changes in the online stats cache to the permanent storage",
          "params": {
            "SessionName": "the name of the session that stats are being flushed for"
          }
        },
        "FreeSearchResults": {
          "comment": "Cleans up any platform specific allocated data contained in the search results",
          "params": {
            "Search": "the object to free search results for"
          }
        },
        "FreeStats": {
          "comment": "Cleans up any platform specific allocated data contained in the stats data",
          "params": {
            "StatsRead": "the object to handle per platform clean up on"
          }
        },
        "GetAchievements": {
          "comment": "Copies the list of achievements for the specified player and title id",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Achievements": "the out array that receives the copied data",
            "TitleId": "the title id of the game that these were read for"
          }
        },
        "GetArbitratedPlayers": {
          "comment": "Returns the list of arbitrated players for the arbitrated session",
          "params": {
            "SessionName": "the name of the session to get the arbitration results for"
          }
        },
        "GetAvailableDownloadCounts": {
          "comment": "Returns the number of new and total downloads available for the user",
          "params": {
            "LocalUserNum": "the user to check the content download availability for",
            "NewDownloads": "out value of the number of new downloads available",
            "TotalDownloads": "out value of the number of total downloads available"
          }
        },
        "GetBuildUniqueId": {
          "comment": "Generates a unique number based off of the current script compilation"
        },
        "GetClientStatGuid": {
          "comment": "Reads the client's stat guid that was generated by registering the host's guid\n Used for synching up stats. Only valid on the client. Only callable after the\n host registration has completed"
        },
        "GetContentList": {
          "comment": "Retrieve the list of content the given user has downloaded or otherwise retrieved\n to the local console.",
          "params": {
            "LocalUserNum": "The user to read the content list of",
            "ContentType": "the type of content being read",
            "ContentList": "The out array that receives the list of all content"
          }
        },
        "GetDeviceSelectionResults": {
          "comment": "Fetches the results of the device selection",
          "params": {
            "LocalPlayerNum": "the player to check the results for",
            "DeviceName": "out param that gets a copy of the string"
          }
        },
        "GetFriendMessages": {
          "comment": "Returns the list of messages for the specified player",
          "params": {
            "LocalUserNum": "the local player wanting to join",
            "FriendMessages": "the set of messages cached locally for the player"
          }
        },
        "GetFriendsList": {
          "comment": "Copies the list of friends for the player previously retrieved from the online\n service. The list can be retrieved in whole or in part.",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Friends": "the out array that receives the copied data",
            "Count": "the number of friends to read or zero for all",
            "StartingAt": "the index of the friends list to start at (for pulling partial lists)"
          }
        },
        "GetGameSearch": {
          "comment": "Returns the currently set game search object"
        },
        "GetGameSettings": {
          "comment": "Returns the game settings object for the session with a matching name",
          "params": {
            "SessionName": "the name of the session to return"
          }
        },
        "GetHostStatGuid": {
          "comment": "Reads the host's stat guid for synching up stats. Only valid on the host."
        },
        "GetKeyboardInputResults": {
          "comment": "Fetches the results of the input",
          "params": {
            "bWasCanceled": "whether the user cancelled the input or not"
          }
        },
        "GetLocale": {
          "comment": "Determine the locale (country code) for the player"
        },
        "GetLoginStatus": {
          "comment": "Fetches the login status for a given player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "GetNATType": {
          "comment": "Determines the NAT type the player is using"
        },
        "GetNetworkNotificationPosition": {
          "comment": "Determines the current notification position setting"
        },
        "GetPlayerNickname": {
          "comment": "Reads the player's nick name from the online service",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "GetPlayerStorage": {
          "comment": "Returns the online player storage for a given local user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for"
          }
        },
        "GetProfileSettings": {
          "comment": "Returns the online profile settings for a given user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for"
          }
        },
        "GetRecognitionResults": {
          "comment": "Gets the results of the voice recognition",
          "params": {
            "LocalUserNum": "the local user to read the results of",
            "Words": "the set of words that were recognized by the voice analyzer"
          }
        },
        "GetResolvedConnectString": {
          "comment": "Returns the platform specific connection information for joining the match.\n Call this function from the delegate of join completion",
          "params": {
            "SessionName": "the name of the session to fetch the connection information for",
            "ConnectInfo": "the out var containing the platform specific connection information"
          }
        },
        "GetSaveGameData": {
          "comment": "Copies a player's save game data from the cached async read data",
          "params": {
            "LocalUserNum": "the user that is initiating the data read (also used in validating ownership of the data)",
            "DeviceId": "the device to read the same game from",
            "FriendlyName": "the friendly name of the save game that was returned by enumeration",
            "FileName": "the file to read from inside of the content package",
            "SaveFileName": "the file name of the save game inside the content package",
            "bIsValid": "out value indicating whether the save is corrupt or not",
            "SaveGameData": "the array that is filled with the save game data"
          }
        },
        "GetTitleFileContents": {
          "comment": "Copies the file data into the specified buffer for the specified file",
          "params": {
            "FileName": "the name of the file to read",
            "FileContents": "the out buffer to copy the data into"
          }
        },
        "GetTitleFileState": {
          "comment": "Determines the async state of the tile file read operation",
          "params": {
            "FileName": "the name of the file to check on"
          }
        },
        "GetUniquePlayerId": {
          "comment": "Gets the platform specific unique id for the specified player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the byte array that will receive the id"
          }
        },
        "HasLinkConnection": {
          "comment": "Determines if the ethernet link is connected or not"
        },
        "Init": {
          "comment": "Called from engine start up code to allow the subsystem to initialize"
        },
        "IsControllerConnected": {
          "comment": "Determines if the specified controller is connected or not",
          "params": {
            "ControllerId": "the controller to query"
          }
        },
        "IsDeviceValid": {
          "comment": "Checks the device id to determine if it is still valid (could be removed) and/or\n if there is enough space on the specified device",
          "params": {
            "DeviceId": "the device to check",
            "SizeNeeded": "the amount of space requested"
          }
        },
        "IsFriend": {
          "comment": "Checks that a unique player id is part of the specified user's friends list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being checked"
          }
        },
        "IsGuestLogin": {
          "comment": "Determines whether the specified user is a guest login or not",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "IsHeadsetPresent": {
          "comment": "Determines if the specified player has a headset connected",
          "params": {
            "LocalUserNum": "the local player index being queried"
          }
        },
        "IsLocalLogin": {
          "comment": "Determines whether the specified user is a local (non-online) login or not",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "IsLocalPlayerTalking": {
          "comment": "Determines if the specified player is actively talking into the mic",
          "params": {
            "LocalUserNum": "the local player index being queried"
          }
        },
        "IsMuted": {
          "comment": "Checks that a unique player id is on the specified user's mute list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being checked"
          }
        },
        "IsRemotePlayerTalking": {
          "comment": "Determines if the specified remote player is actively talking into the mic\n NOTE: Network latencies will make this not 100% accurate",
          "params": {
            "PlayerId": "the unique id of the remote player being queried"
          }
        },
        "JoinFriendGame": {
          "comment": "Allows the local player to follow a friend into a game",
          "params": {
            "LocalUserNum": "the local player wanting to join",
            "Friend": "the player that is being followed"
          }
        },
        "JoinMigratedOnlineGame": {
          "comment": "Joins the migrated game specified",
          "params": {
            "PlayerNum": "the index of the player about to join a match",
            "SessionName": "the name of the migrated session to join",
            "DesiredGame": "the desired migrated game to join"
          }
        },
        "JoinOnlineGame": {
          "comment": "Joins the game specified",
          "params": {
            "PlayerNum": "the index of the player searching for a match",
            "SessionName": "the name of the session to join",
            "DesiredGame": "the desired game to join"
          }
        },
        "Login": {
          "comment": "Logs the player into the online service. If this fails, it generates a\n OnLoginFailed notification",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginName": "the unique identifier for the player",
            "Password": "the password for this account",
            "bWantsLocalOnly": "whether the player wants to sign in locally only or not"
          }
        },
        "Logout": {
          "comment": "Signs the player out of the online service",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "MigrateOnlineGame": {
          "comment": "Migrates an existing online game on the host.\n NOTE: online game migration is an async process and does not complete\n until the OnMigrateOnlineGameComplete delegate is called.",
          "params": {
            "HostingPlayerNum": "the index of the player now hosting the match",
            "SessionName": "the name of the existing session to migrate"
          }
        },
        "MulticastReadOnlineStatsComplete": {
          "comment": "Local version of the delegate that sends to the array of subscribers",
          "params": {
            "bWasSuccessful": "whether the call completed or not"
          }
        },
        "MuteAll": {
          "comment": "Mutes all voice or all but friends",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "bAllowFriends": "whether to mute everyone or allow friends"
          }
        },
        "MuteRemoteTalker": {
          "comment": "Mutes a remote talker for the specified local player. NOTE: This only mutes them in the\n game unless the bIsSystemWide flag is true, which attempts to mute them globally",
          "params": {
            "LocalUserNum": "the user that is muting the remote talker",
            "PlayerId": "the remote talker that is being muted",
            "bIsSystemWide": "whether to try to mute them globally or not"
          }
        },
        "QueryAvailableDownloads": {
          "comment": "Asks the online system for the number of new and total content downloads",
          "params": {
            "LocalUserNum": "the user to check the content download availability for",
            "CategoryMask": "the bitmask to use to filter content by type"
          }
        },
        "QueryNonAdvertisedData": {
          "comment": "Fetches the additional data a session exposes outside of the online service.\n NOTE: notifications will come from the OnFindOnlineGamesComplete delegate",
          "params": {
            "StartAt": "the search result index to start gathering the extra information for",
            "NumberToQuery": "the number of additional search results to get the data for"
          }
        },
        "ReadAchievements": {
          "comment": "Starts an async read for the achievement list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "TitleId": "the title id of the game the achievements are to be read for",
            "bShouldReadText": "whether to fetch the text strings or not",
            "bShouldReadImages": "whether to fetch the image data or not"
          }
        },
        "ReadContentList": {
          "comment": "Starts an async task that retrieves the list of downloaded content for the player.",
          "params": {
            "LocalUserNum": "The user to read the content list of",
            "ContentType": "the type of content being read",
            "DeviceId": "optional value to restrict the enumeration to a particular device"
          }
        },
        "ReadFriendsList": {
          "comment": "Starts an async task that retrieves the list of friends for the player from the\n online service. The list can be retrieved in whole or in part.",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Count": "the number of friends to read or zero for all",
            "StartingAt": "the index of the friends list to start at (for pulling partial lists)"
          }
        },
        "ReadOnlineStats": {
          "comment": "Reads a set of stats for the specified list of players",
          "params": {
            "Players": "the array of unique ids to read stats for",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object"
          }
        },
        "ReadOnlineStatsByRank": {
          "comment": "Reads stats by ranking. This grabs the rows starting at StartIndex through\n NumToRead and places them in the StatsRead object.",
          "params": {
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object",
            "StartIndex": "the starting rank to begin reads at (1 for top)",
            "NumToRead": "the number of rows to read (clamped at 100 underneath)"
          }
        },
        "ReadOnlineStatsByRankAroundPlayer": {
          "comment": "Reads stats by ranking centered around a player. This grabs a set of rows\n above and below the player's current rank",
          "params": {
            "LocalUserNum": "the local player having their stats being centered upon",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object",
            "NumRows": "the number of rows to read above and below the player's rank"
          }
        },
        "ReadOnlineStatsForFriends": {
          "comment": "Reads a player's stats and all of that player's friends stats for the\n specified set of stat views. This allows you to easily compare a player's\n stats to their friends.",
          "params": {
            "LocalUserNum": "the local player having their stats and friend's stats read for",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object"
          }
        },
        "ReadPlatformSpecificSessionInfo": {
          "comment": "Serializes the platform specific data into the provided buffer for the specified search result",
          "params": {
            "DesiredGame": "the game to copy the platform specific data for",
            "PlatformSpecificInfo": "the buffer to fill with the platform specific information"
          }
        },
        "ReadPlatformSpecificSessionInfoBySessionName": {
          "comment": "Serializes the platform specific data into the provided buffer for the specified settings object.\n NOTE: This can only be done for a session that is bound to the online system",
          "params": {
            "GameSettings": "the game to copy the platform specific data for",
            "PlatformSpecificInfo": "the buffer to fill with the platform specific information"
          }
        },
        "ReadPlayerStorage": {
          "comment": "Reads the online player storage data for a given local user\n If a valid storage device ID is specified then data is also read from that device and the newer version is kept.",
          "params": {
            "LocalUserNum": "the user that we are reading the data for",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read",
            "DeviceId": "optional ID for connected device to read from. -1 for no device"
          }
        },
        "ReadPlayerStorageForNetId": {
          "comment": "Reads the online player storage data for a given net user",
          "params": {
            "LocalUserNum": "the local user that is initiating the read",
            "NetId": "the net user that we are reading the data for",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read"
          }
        },
        "ReadProfileSettings": {
          "comment": "Reads the online profile settings for a given user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for",
            "ProfileSettings": "the object to copy the results to and contains the list of items to read"
          }
        },
        "ReadSaveGameData": {
          "comment": "Reads a player's save game data from the specified content bundle",
          "params": {
            "LocalUserNum": "the user that is initiating the data read (also used in validating ownership of the data)",
            "DeviceId": "the device to read the same game from",
            "FriendlyName": "the friendly name of the save game that was returned by enumeration",
            "FileName": "the file to read from inside of the content package",
            "SaveFileName": "the file name of the save game inside the content package"
          }
        },
        "ReadTitleFile": {
          "comment": "Starts an asynchronous read of the specified file from the network platform's\n title specific file store",
          "params": {
            "FileToRead": "the name of the file to read"
          }
        },
        "RecalculateSkillRating": {
          "comment": "Updates the current session's skill rating using the list of players' skills",
          "params": {
            "SessionName": "the name of the session to update the skill rating for",
            "Players": "the set of players to use in the skill calculation"
          }
        },
        "RegisterForArbitration": {
          "comment": "Tells the game to register with the underlying arbitration server if available",
          "params": {
            "SessionName": "the name of the session to register for arbitration with"
          }
        },
        "RegisterHostStatGuid": {
          "comment": "Registers the host's stat guid with the client for verification they are part of\n the stat. Note this is an async task for any backend communication that needs to\n happen before the registration is deemed complete",
          "params": {
            "HostStatGuid": "the host's stat guid"
          }
        },
        "RegisterLocalTalker": {
          "comment": "Registers the user as a talker",
          "params": {
            "LocalUserNum": "the local player index that is a talker"
          }
        },
        "RegisterPlayer": {
          "comment": "Registers a player with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "UniquePlayerId": "the player to register with the online service",
            "bWasInvited": "whether the player was invited to the game or searched for it"
          }
        },
        "RegisterPlayers": {
          "comment": "Registers a group of players with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "Players": "the list of players to register with the online service"
          }
        },
        "RegisterRemoteTalker": {
          "comment": "Registers a remote player as a talker",
          "params": {
            "PlayerId": "the unique id of the remote player that is a talker"
          }
        },
        "RegisterStatGuid": {
          "comment": "Registers the client's stat guid on the host to validate that the client was in the stat.\n Used for synching up stats. Only valid on the host.",
          "params": {
            "PlayerId": "the client's unique net id",
            "ClientStatGuid": "the client's stat guid"
          }
        },
        "RemoveFriend": {
          "comment": "Removes a friend from the player's friend list",
          "params": {
            "LocalUserNum": "the user that is removing the friend",
            "FormerFriend": "the player to remove from the friend list"
          }
        },
        "SelectVocabulary": {
          "comment": "Changes the vocabulary id that is currently being used",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "VocabularyId": "the new id to use"
          }
        },
        "SendGameInviteToFriend": {
          "comment": "Sends an invitation to play in the player's current session",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "Friend": "the player to send the invite to",
            "Text": "the text of the message for the invite"
          }
        },
        "SendGameInviteToFriends": {
          "comment": "Sends invitations to play in the player's current session",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "Friends": "the player to send the invite to",
            "Text": "the text of the message for the invite"
          }
        },
        "SendMessageToFriend": {
          "comment": "Sends a message to a friend",
          "params": {
            "LocalUserNum": "the user that is sending the message",
            "Friend": "the player to send the message to",
            "Message": "the message to display to the recipient"
          }
        },
        "SetDebugSpewLevel": {
          "comment": "Sets the debug output level for the platform specific API (if applicable)",
          "params": {
            "DebugSpewLevel": "the level to set"
          }
        },
        "SetNetworkNotificationPosition": {
          "comment": "Sets a new position for the network notification icons/images",
          "params": {
            "NewPos": "the new location to use"
          }
        },
        "SetOnlineStatus": {
          "comment": "Sets a rich presence information to use for the specified player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PresenceMode": "the rich presence mode to use",
            "LocalizedStringSettings": "the list of localized string settings to set",
            "Properties": "the list of properties to set"
          }
        },
        "SetRemoteTalkerPriority": {
          "comment": "Sets the relative priority for a remote talker. 0 is highest",
          "params": {
            "LocalUserNum": "the user that controls the relative priority",
            "PlayerId": "the remote talker that is having their priority changed for",
            "Priority": "the relative priority to use (0 highest, < 0 is muted)"
          }
        },
        "SetSpeechRecognitionObject": {
          "comment": "Changes the object that is in use to the one specified",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "SpeechRecogObj": "the new object use",
            "true": "if successful, false otherwise"
          }
        },
        "ShowAchievementsUI": {
          "comment": "Displays the achievements UI for a player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowContentMarketplaceUI": {
          "comment": "Displays the marketplace UI for content",
          "params": {
            "LocalUserNum": "the local user viewing available content",
            "CategoryMask": "the bitmask to use to filter content by type",
            "OfferId": "a specific offer that you want shown"
          }
        },
        "ShowCustomPlayersUI": {
          "comment": "Shows a custom players UI for the specified list of players",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Players": "the list of players to show in the custom UI",
            "Title": "the title to use for the UI",
            "Description": "the text to show at the top of the UI"
          }
        },
        "ShowDeviceSelectionUI": {
          "comment": "Displays the UI that allows the user to choose which device to save content to",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "SizeNeeded": "the size of the data to be saved in bytes",
            "bManageStorage": "whether to allow the user to manage their storage or not"
          }
        },
        "ShowFeedbackUI": {
          "comment": "Displays the UI that allows a player to give feedback on another player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player having feedback given for"
          }
        },
        "ShowFriendsInviteUI": {
          "comment": "Displays the UI that shows a user's list of friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being invited"
          }
        },
        "ShowFriendsUI": {
          "comment": "Displays the UI that shows a user's list of friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowGamerCardUI": {
          "comment": "Displays the gamer card UI for the specified player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player to show the gamer card of"
          }
        },
        "ShowGuideUI": {
          "comment": "Displays the Guide UI"
        },
        "ShowInviteUI": {
          "comment": "Displays the invite ui",
          "params": {
            "LocalUserNum": "the local user sending the invite",
            "InviteText": "the string to prefill the UI with"
          }
        },
        "ShowKeyboardUI": {
          "comment": "Displays the UI that shows the keyboard for inputing text",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "TitleText": "the title to display to the user",
            "DescriptionText": "the text telling the user what to input",
            "bIsPassword": "whether the entry is a password or not",
            "bShouldValidate": "whether to apply the string validation API after input or not",
            "DefaultText": "the default string to display",
            "MaxResultLength": "the maximum length string expected to be filled in"
          }
        },
        "ShowLoginUI": {
          "comment": "Displays the UI that prompts the user for their login credentials. Each\n platform handles the authentication of the user's data.",
          "params": {
            "bShowOnlineOnly": "whether to only display online enabled profiles or not"
          }
        },
        "ShowMembershipMarketplaceUI": {
          "comment": "Displays the marketplace UI for memberships",
          "params": {
            "LocalUserNum": "the local user viewing available memberships"
          }
        },
        "ShowMessagesUI": {
          "comment": "Displays the messages UI for a player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowPlayersUI": {
          "comment": "Displays the UI that shows the player list",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "StartNetworkedVoice": {
          "comment": "Tells the voice layer that networked processing of the voice data is allowed\n for the specified player. This allows for push-to-talk style voice communication",
          "params": {
            "LocalUserNum": "the local user to allow network transimission for"
          }
        },
        "StartOnlineGame": {
          "comment": "Marks an online game as in progress (as opposed to being in lobby or pending)",
          "params": {
            "SessionName": "the name of the session that is being started"
          }
        },
        "StartSpeechRecognition": {
          "comment": "Tells the voice system to start tracking voice data for speech recognition",
          "params": {
            "LocalUserNum": "the local user to recognize voice data for"
          }
        },
        "StopNetworkedVoice": {
          "comment": "Tells the voice layer to stop processing networked voice support for the\n specified player. This allows for push-to-talk style voice communication",
          "params": {
            "LocalUserNum": "the local user to disallow network transimission for"
          }
        },
        "StopSpeechRecognition": {
          "comment": "Tells the voice system to stop tracking voice data for speech recognition",
          "params": {
            "LocalUserNum": "the local user to recognize voice data for"
          }
        },
        "UnlockAchievement": {
          "comment": "Unlocks the specified achievement for the specified user",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "AchievementId": "the id of the achievement to unlock"
          }
        },
        "UnlockAvatarAward": {
          "comment": "Unlocks an avatar award for the local user",
          "params": {
            "LocalUserNum": "the user to unlock the avatar item for",
            "AvatarItemId": "the id of the avatar item to unlock"
          }
        },
        "UnlockGamerPicture": {
          "comment": "Unlocks a gamer picture for the local user",
          "params": {
            "LocalUserNum": "the user to unlock the picture for",
            "PictureId": "the id of the picture to unlock"
          }
        },
        "UnmuteAll": {
          "comment": "Allows all speakers to send voice",
          "params": {
            "LocalUserNum": "the local user that is making the change"
          }
        },
        "UnmuteRemoteTalker": {
          "comment": "Allows a remote talker to talk to the specified local player. NOTE: This only unmutes them in the\n game unless the bIsSystemWide flag is true, which attempts to unmute them globally",
          "params": {
            "LocalUserNum": "the user that is allowing the remote talker to talk",
            "PlayerId": "the remote talker that is being restored to talking",
            "bIsSystemWide": "whether to try to unmute them globally or not"
          }
        },
        "UnregisterLocalTalker": {
          "comment": "Unregisters the user as a talker",
          "params": {
            "LocalUserNum": "the local player index to be removed"
          }
        },
        "UnregisterPlayer": {
          "comment": "Unregisters a player with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is leaving",
            "PlayerId": "the player to unregister with the online service"
          }
        },
        "UnregisterPlayers": {
          "comment": "Unregisters a group of players with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "Players": "the list of players to unregister with the online service"
          }
        },
        "UnregisterRemoteTalker": {
          "comment": "Unregisters a remote player as a talker",
          "params": {
            "PlayerId": "the unique id of the remote player to be removed"
          }
        },
        "UpdateOnlineGame": {
          "comment": "Updates the localized settings/properties for the game in question. Updates\n the QoS packet if needed (starting & restarting QoS).",
          "params": {
            "SessionName": "the name of the session to update",
            "UpdatedGameSettings": "the object to update the game settings with",
            "bShouldRefreshOnlineData": "whether to submit the data to the backend or not"
          }
        },
        "WriteOnlinePlayerScores": {
          "comment": "Writes the score data for the match",
          "params": {
            "SessionName": "the name of the session to write scores for",
            "LeaderboardId": "the leaderboard to write the score information to",
            "PlayerScores": "the list of players, teams, and scores they earned"
          }
        },
        "WriteOnlineStats": {
          "comment": "Writes out the stats contained within the stats write object to the online\n subsystem's cache of stats data. Note the new data replaces the old. It does\n not write the data to the permanent storage until a FlushOnlineStats() call\n or a session ends. Stats cannot be written without a session or the write\n request is ignored. No more than 5 stats views can be written to at a time\n or the write request is ignored.",
          "params": {
            "SessionName": "the name of the session to write stats for",
            "Player": "the player to write stats for",
            "StatsWrite": "the object containing the information to write"
          }
        },
        "WritePlayerStorage": {
          "comment": "Writes the online player storage data for a given local user to the online data store\n If a valid storage device ID is specified then data is also written to that device.",
          "params": {
            "LocalUserNum": "the user that we are writing the data for",
            "PlayerStorage": "the object that contains the list of items to write",
            "DeviceId": "optional ID for connected device to write to. -1 for no device"
          }
        },
        "WriteProfileSettings": {
          "comment": "Writes the online profile settings for a given user to the online data store",
          "params": {
            "LocalUserNum": "the user that we are writing the data for",
            "ProfileSettings": "the list of settings to write out"
          }
        },
        "WriteSaveGameData": {
          "comment": "Writes a player's save game data to the specified content bundle and file",
          "params": {
            "LocalUserNum": "the user that is initiating the data write",
            "DeviceId": "the device to write the same game to",
            "FriendlyName": "the friendly name of the save game that was returned by enumeration",
            "FileName": "the file to write to inside of the content package",
            "SaveFileName": "the file name of the save game inside the content package",
            "SaveGameData": "the data to write to the save game file"
          }
        }
      },
      "structs": {
        "CachedAchievements": {
          "comment": "Associates the specific achievements per user and title id",
          "properties": {
            "Achievements": {
              "comment": "The list of achievements for this player and title"
            },
            "PlayerNum": {
              "comment": "The player these are for"
            },
            "ReadState": {
              "comment": "Indicates the state of the async read"
            },
            "TempImage": {
              "comment": "temporary texture used for achievement image data during async read"
            },
            "TitleId": {
              "comment": "The title id that these are for"
            }
          }
        },
        "CachedLoginState": {
          "comment": "Holds the login state, online & offline xuids for a player",
          "properties": {
            "LoginStatus": {
              "comment": "The type of login for this player previously"
            },
            "OfflineXuid": {
              "comment": "The offline xuid for the signed in player"
            },
            "OnlineXuid": {
              "comment": "The online xuid for the signed in player"
            }
          }
        },
        "ContentListCache": {
          "comment": "Holds the cached state of the content list for a single player",
          "properties": {
            "Content": {
              "comment": "The list of returned DLC content"
            },
            "ContentChangeDelegates": {
              "comment": "The delegate to call when the content has changed (user logged in, etc)"
            },
            "NewDownloadCount": {
              "comment": "The number of new downloadable content packages available"
            },
            "QueryDownloadsDelegates": {
              "comment": "The delegate to call when the read is complete"
            },
            "ReadCompleteDelegates": {
              "comment": "The delegate to call when the read is complete"
            },
            "ReadSaveGameDataCompleteDelegates": {
              "comment": "The delegate to call when the savegame data read is complete"
            },
            "ReadState": {
              "comment": "Indicates the state of the async read"
            },
            "SaveGameContent": {
              "comment": "The list of returned savegame content"
            },
            "SaveGameReadCompleteDelegates": {
              "comment": "The delegate to call when the savegame read is complete"
            },
            "SaveGameReadState": {
              "comment": "Indicates the state of the savegame async read"
            },
            "SaveGames": {
              "comment": "Holds the list of savegames that are in progress or cached"
            },
            "TotalDownloadCount": {
              "comment": "The total number of downloadable content packages available"
            },
            "WriteSaveGameDataCompleteDelegates": {
              "comment": "The delegate to call when the savegame data write is complete"
            }
          }
        },
        "DeviceIdCache": {
          "comment": "Per user cache of device id information",
          "properties": {
            "DeviceId": {
              "comment": "The last selected device id for this user"
            },
            "DeviceSelectionDelegates": {
              "comment": "List of subscribers interested in device selection notification"
            },
            "DeviceSelectionMulticast": {
              "comment": "Delegate used to fire the array of events off"
            }
          }
        },
        "FriendsListCache": {
          "comment": "Holds the cached state of the friends list for a single player",
          "properties": {
            "Friends": {
              "comment": "The list of returned friends"
            },
            "FriendsChangeDelegates": {
              "comment": "The array of delegates that notify that the friends list has changed"
            },
            "ReadFriendsDelegates": {
              "comment": "The array of delegates that notify read completion of the friends list data"
            },
            "ReadState": {
              "comment": "Indicates the state of the async read"
            }
          }
        },
        "InviteData": {
          "comment": "Holds the delegate and the last accepted invite for a player",
          "properties": {
            "InviteData": {
              "comment": "Cached invite data for the player"
            },
            "InviteDelegates": {
              "comment": "The per user delegates for game invites"
            },
            "InviteSearch": {
              "comment": "Game search results associated with this invite"
            }
          }
        },
        "LiveRemoteTalker": {
          "comment": "Information about a remote talker",
          "properties": {
            "LocalPriorities[4]": {
              "comment": "Holds the priorities for each of the local players"
            }
          }
        },
        "LoginStatusDelegates": {
          "comment": "Holds an array of login status delegates",
          "properties": {
            "Delegates": {
              "comment": "This is the list of requested delegates to fire"
            }
          }
        },
        "OnlineSaveGame": {
          "comment": "Struct that holds the data for a single savegame",
          "properties": {
            "BindRefCount": {
              "comment": "Number of times this save game has been bound"
            },
            "bIsBound": {
              "comment": "Whether the content is bound or not"
            },
            "bIsValid": {
              "comment": "Whether the content passed the owner test or not"
            },
            "SaveGames": {
              "comment": "The list of the save games in this content package"
            }
          }
        },
        "OnlineSaveGameDataMapping": {
          "comment": "Maps an internal file name to the save game data it contains",
          "properties": {
            "InternalFileName": {
              "comment": "The name of the internal save game file"
            },
            "ReadWriteState": {
              "comment": "Tracks the state of the async task for read/write"
            },
            "SaveGameData": {
              "comment": "The data of the save game"
            }
          }
        },
        "PerUserDelegateLists": {
          "comment": "Since the static array of dynamic array syntax appears to be broken",
          "properties": {
            "AchievementDelegates": {
              "comment": "The array of delegates for notifying when an achievement write has completed"
            },
            "AchievementReadDelegates": {
              "comment": "The array of delegates for notifying when an achievements list read has completed"
            },
            "SpeechRecognitionDelegates": {
              "comment": "The array of delegates for notifying when speech recognition has completed for a player"
            }
          }
        },
        "PlayerStorageSettingsCacheLocal": {
          "comment": "Holds the cached state of the player storage settings for a single player (local players only)",
          "properties": {
            "PlayerStorage": {
              "comment": "Online player storage settings for a player which is cached to prevent GC while reading/writing from Live"
            },
            "ReadDelegates": {
              "comment": "Used for notification of player storage reads completing for local players"
            },
            "WriteDelegates": {
              "comment": "Used for notification of player storage writes completing for local players"
            }
          }
        },
        "PlayerStorageSettingsCacheRemote": {
          "comment": "Holds the cached state of the player storage settings for a single player (remote players only)",
          "properties": {
            "PlayerStorage": {
              "comment": "Online player storage settings for a player which is cached to prevent GC while reading/writing from Live"
            },
            "ReadDelegates": {
              "comment": "Used for notification of player storage reads completing for remote players"
            }
          }
        },
        "ProfileSettingsCache": {
          "comment": "Holds the cached state of the profile for a single player",
          "properties": {
            "Profile": {
              "comment": "The profile for the player"
            },
            "ProfileDataChangedDelegates": {
              "comment": "Used to notify subscribers when the player changes their (non-game) profile"
            },
            "ReadDelegates": {
              "comment": "Used for per player index notification of profile reads completing"
            },
            "WriteDelegates": {
              "comment": "Used for per player index notification of profile writes completing"
            }
          }
        },
        "TalkerPriority": {
          "comment": "Information about a remote talker's priority\n Zero means highest priority, < zero means muted",
          "properties": {
            "CurrentPriority": {
              "comment": "Holds the current priority for this talker"
            },
            "LastPriority": {
              "comment": "Holds the last priority for this talker"
            }
          }
        }
      }
    },
    "OnlineTitleFileDownloadMcpLive": {
      "comment": "Provides a mechanism for downloading arbitrary files from the MCP server"
    }
  },
  "OnlineSubsystemPC": {
    "OnlineSubsystemPC": {
      "properties": {
        "AsyncTasks": {
          "comment": "This is the array of pending async tasks. Each tick these tasks are checked\n for completion. If complete, the delegate associated with them is called"
        },
        "CachedProfile": {
          "comment": "The cached profile for the player"
        },
        "FriendsChangeDelegates": {
          "comment": "The array of delegates that notify that the friends list has changed"
        },
        "LoggedInPlayerId": {
          "comment": "The unique id of the logged in player"
        },
        "LoggedInPlayerName": {
          "comment": "The name of the player that is logged in"
        },
        "MutingChangeDelegates": {
          "comment": "The array of delegates that notify that the mute list has changed"
        },
        "ProfileDataDirectory": {
          "comment": "The directory profile data should be stored in"
        },
        "ProfileDataExtension": {
          "comment": "The file extension to use when saving profile data"
        },
        "ReadFriendsDelegates": {
          "comment": "The array of delegates that notify read completion of the friends list data"
        },
        "ReadProfileSettingsDelegates": {
          "comment": "The array of delegates that notify read completion of profile data"
        },
        "SpeechRecognitionCompleteDelegates": {
          "comment": "List of callbacks to notify when speech recognition is complete"
        },
        "WriteProfileSettingsDelegates": {
          "comment": "The array of delegates that notify write completion of profile data"
        }
      },
      "functions": {
        "AcceptFriendInvite": {
          "comment": "Used to accept a friend invite sent to this player",
          "params": {
            "LocalUserNum": "the user the invite is for",
            "RequestingPlayer": "the player the invite is from",
            "true": "if successful, false otherwise"
          }
        },
        "AddAddFriendByNameCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "FriendDelegate": "the delegate to use for notifications"
          }
        },
        "AddConnectionStatusChangeDelegate": {
          "comment": "Adds the delegate to the list to be notified when the connection status changes",
          "params": {
            "ConnectionStatusDelegate": "the delegate to add"
          }
        },
        "AddControllerChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the controller state changed",
          "params": {
            "ControllerChangeDelegate": "the delegate to use for notifications"
          }
        },
        "AddExternalUIChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that external UI state\n changed (opened/closed)",
          "params": {
            "ExternalUIDelegate": "the delegate to use for notifications"
          }
        },
        "AddFlushOnlineStatsCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the stats flush has completed",
          "params": {
            "FlushOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriend": {
          "comment": "Sends a friend invite to the specified player",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "NewFriend": "the player to send the friend request to",
            "Message": "the message to display to the recipient"
          }
        },
        "AddFriendByName": {
          "comment": "Sends a friend invite to the specified player nick",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "FriendName": "the name of the player to send the invite to",
            "Message": "the message to display to the recipient"
          }
        },
        "AddFriendInviteReceivedDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "InviteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriendMessageReceivedDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "MessageDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriendsChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a friends list changed",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinFriendGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify when the join friend is complete",
          "params": {
            "JoinFriendGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddKeyboardInputDoneDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has completed\n their keyboard input",
          "params": {
            "InputDelegate": "the delegate to use for notifications"
          }
        },
        "AddLinkStatusChangeDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that link status changed",
          "params": {
            "LinkStatusDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginCancelledDelegate": {
          "comment": "Adds a delegate to the list of delegates that are fired when a login is cancelled",
          "params": {
            "CancelledDelegate": "the delegate to add to the list"
          }
        },
        "AddLoginChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login changed",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "whether to watch for changes on a specific slot or all slots"
          }
        },
        "AddLoginFailedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login failed",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginStatusChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login status has changed",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "the player to watch login status changes for"
          }
        },
        "AddLogoutCompletedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a logout completed",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LogoutDelegate": "the delegate to use for notifications"
          }
        },
        "AddMutingChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a muting list changed",
          "params": {
            "MutingDelegate": "the delegate to use for notifications"
          }
        },
        "AddPlayerTalkingDelegate": {
          "comment": "Adds a talker delegate to the list of notifications",
          "params": {
            "TalkerDelegate": "the delegate to call when a player is talking"
          }
        },
        "AddReadAchievementsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to read the achievements list for",
            "ReadAchievementsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadFriendsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the friends read request has completed",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "ReadFriendsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadOnlineStatsCompleteDelegate": {
          "comment": "Adds the delegate to a list used to notify the gameplay code that the stats read has completed",
          "params": {
            "ReadOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadPlayerStorageCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadPlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadPlayerStorageForNetIdCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "NetId": "the net id for the user to watch for read complete notifications",
            "ReadPlayerStorageForNetIdCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadProfileSettingsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadTitleFileCompleteDelegate": {
          "comment": "Adds the delegate to the list to be notified when a requested file has been read",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to add"
          }
        },
        "AddReceivedGameInviteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a game invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "ReceivedGameInviteDelegate": "the delegate to use for notifications"
          }
        },
        "AddRecognitionCompleteDelegate": {
          "comment": "Sets the speech recognition notification callback to use for the specified user",
          "params": {
            "LocalUserNum": "the local user to receive notifications for",
            "RecognitionDelegate": "the delegate to call when recognition is complete"
          }
        },
        "AddRegisterHostStatGuidCompleteDelegate": {
          "comment": "Adds the delegate for notifying when the host guid registration is done",
          "params": {
            "RegisterHostStatGuidCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddStorageDeviceChangeDelegate": {
          "comment": "Adds the delegate to the list to be notified when a storage device changes",
          "params": {
            "StorageDeviceChangeDelegate": "the delegate to add"
          }
        },
        "AddUnlockAchievementCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the achievement unlocking has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "UnlockAchievementCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWritePlayerStorageCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WritePlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWriteProfileSettingsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AreAnyFriends": {
          "comment": "Checks that whether a group of player ids are among the specified player's\n friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Query": "an array of players to check for being included on the friends list"
          }
        },
        "CalcAggregateSkill": {
          "comment": "Calculates the aggregate skill from an array of skills.",
          "params": {
            "Mus": "array that holds the mu values",
            "Sigmas": "array that holds the sigma values",
            "OutAggregateMu": "aggregate Mu",
            "OutAggregateSigma": "aggregate Sigma"
          }
        },
        "CanCommunicate": {
          "comment": "Determines whether the player is allowed to use voice or text chat online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanDownloadUserContent": {
          "comment": "Determines whether the player is allowed to download user created content",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanPlayOnline": {
          "comment": "Determines whether the player is allowed to play online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanPurchaseContent": {
          "comment": "Determines whether the player is allowed to buy content online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanShowPresenceInformation": {
          "comment": "Determines whether the player is allowed to have their online presence\n information shown to remote clients",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanViewPlayerProfiles": {
          "comment": "Determines whether the player is allowed to view other people's player profile",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ClearAddFriendByNameCompleteDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "FriendDelegate": "the delegate to use for notifications"
          }
        },
        "ClearConnectionStatusChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ConnectionStatusDelegate": "the delegate to remove"
          }
        },
        "ClearControllerChangeDelegate": {
          "comment": "Removes the delegate used to notify the gameplay code that the controller state changed",
          "params": {
            "ControllerChangeDelegate": "the delegate to remove"
          }
        },
        "ClearExternalUIChangeDelegate": {
          "comment": "Removes the delegate from the notification list",
          "params": {
            "ExternalUIDelegate": "the delegate to remove"
          }
        },
        "ClearFlushOnlineStatsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the stats flush has completed",
          "params": {
            "FlushOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendInviteReceivedDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "InviteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendMessageReceivedDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "MessageDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendsChangeDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinFriendGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "JoinFriendGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearKeyboardInputDoneDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the user has completed\n their keyboard input",
          "params": {
            "InputDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLinkStatusChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "LinkStatusDelegate": "the delegate to remove"
          }
        },
        "ClearLoginCancelledDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "CancelledDelegate": "the delegate to remove fromt he list"
          }
        },
        "ClearLoginChangeDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "whether to watch for changes on a specific slot or all slots"
          }
        },
        "ClearLoginFailedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLoginStatusChangeDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "the player to watch login status changes for"
          }
        },
        "ClearLogoutCompletedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LogoutDelegate": "the delegate to use for notifications"
          }
        },
        "ClearMutingChangeDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "ClearPlayerTalkingDelegate": {
          "comment": "Removes a talker delegate to the list of notifications",
          "params": {
            "TalkerDelegate": "the delegate to remove from the notification list"
          }
        },
        "ClearReadAchievementsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to read the achievements list for",
            "ReadAchievementsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadFriendsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadFriendsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadOnlineStatsCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ReadOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadPlayerStorageCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadPlayerStorageCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadPlayerStorageForNetIdCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "NetId": "the net id for the user to watch for read complete notifications",
            "ReadPlayerStorageForNetIdCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadProfileSettingsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadTitleFileCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to remove"
          }
        },
        "ClearReceivedGameInviteDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "ReceivedGameInviteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRecognitionCompleteDelegate": {
          "comment": "Clears the speech recognition notification callback to use for the specified user",
          "params": {
            "LocalUserNum": "the local user to receive notifications for",
            "RecognitionDelegate": "the delegate to call when recognition is complete"
          }
        },
        "ClearRegisterHostStatGuidCompleteDelegateDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code",
          "params": {
            "RegisterHostStatGuidCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearStorageDeviceChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ConnectionStatusDelegate": "the delegate to remove"
          }
        },
        "ClearUnlockAchievementCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the achievement unlocking has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "UnlockAchievementCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearWritePlayerStorageCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WritePlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearWriteProfileSettingsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "DeleteMessage": {
          "comment": "Deletes a message from the list of messages",
          "params": {
            "LocalUserNum": "the user that is deleting the message",
            "MessageIndex": "the index of the message to delete"
          }
        },
        "DenyFriendInvite": {
          "comment": "Used to deny a friend request sent to this player",
          "params": {
            "LocalUserNum": "the user the invite is for",
            "RequestingPlayer": "the player the invite is from",
            "true": "if successful, false otherwise"
          }
        },
        "FlushOnlineStats": {
          "comment": "Commits any changes in the online stats cache to the permanent storage",
          "params": {
            "SessionName": "the name of the session having stats flushed"
          }
        },
        "FreeStats": {
          "comment": "Cleans up any platform specific allocated data contained in the stats data",
          "params": {
            "StatsRead": "the object to handle per platform clean up on"
          }
        },
        "GetAchievements": {
          "comment": "Copies the list of achievements for the specified player and title id",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Achievements": "the out array that receives the copied data",
            "TitleId": "the title id of the game that these were read for"
          }
        },
        "GetClientStatGuid": {
          "comment": "Reads the client's stat guid that was generated by registering the host's guid\n Used for synching up stats. Only valid on the client. Only callable after the\n host registration has completed"
        },
        "GetFriendMessages": {
          "comment": "Returns the list of messages for the specified player",
          "params": {
            "LocalUserNum": "the local player wanting to join",
            "FriendMessages": "the set of messages cached locally for the player"
          }
        },
        "GetFriendsList": {
          "comment": "Copies the list of friends for the player previously retrieved from the online\n service. The list can be retrieved in whole or in part.",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Friends": "the out array that receives the copied data",
            "Count": "the number of friends to read or zero for all",
            "StartingAt": "the index of the friends list to start at (for pulling partial lists)"
          }
        },
        "GetHostStatGuid": {
          "comment": "Reads the host's stat guid for synching up stats. Only valid on the host."
        },
        "GetKeyboardInputResults": {
          "comment": "Fetches the results of the input",
          "params": {
            "bWasCancelled": "whether the user canceled the input or not"
          }
        },
        "GetLocale": {
          "comment": "Determine the locale (country code) for the player"
        },
        "GetLoginStatus": {
          "comment": "Fetches the login status for a given player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "GetNATType": {
          "comment": "Determines the NAT type the player is using"
        },
        "GetNetworkNotificationPosition": {
          "comment": "Determines the current notification position setting"
        },
        "GetPlayerNickname": {
          "comment": "Reads the player's nick name from the online service",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "GetPlayerNicknameFromIndex": {
          "comment": "Returns the name of the player for the specified index",
          "params": {
            "UserIndex": "the user to return the name of"
          }
        },
        "GetPlayerStorage": {
          "comment": "Returns the online player storage for a given local user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for"
          }
        },
        "GetPlayerUniqueNetIdFromIndex": {
          "comment": "Returns the unique id of the player for the specified index",
          "params": {
            "UserIndex": "the user to return the id of"
          }
        },
        "GetProfileSettings": {
          "comment": "Returns the online profile settings for a given user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for"
          }
        },
        "GetRecognitionResults": {
          "comment": "Gets the results of the voice recognition",
          "params": {
            "LocalUserNum": "the local user to read the results of",
            "Words": "the set of words that were recognized by the voice analyzer"
          }
        },
        "GetTitleFileContents": {
          "comment": "Copies the file data into the specified buffer for the specified file",
          "params": {
            "FileName": "the name of the file to read",
            "FileContents": "the out buffer to copy the data into"
          }
        },
        "GetTitleFileState": {
          "comment": "Determines the async state of the tile file read operation",
          "params": {
            "FileName": "the name of the file to check on"
          }
        },
        "GetUniquePlayerId": {
          "comment": "Gets the platform specific unique id for the specified player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the byte array that will receive the id"
          }
        },
        "HasLinkConnection": {
          "comment": "Determines if the ethernet link is connected or not"
        },
        "Init": {
          "comment": "Called from engine start up code to allow the subsystem to initialize"
        },
        "IsControllerConnected": {
          "comment": "Determines if the specified controller is connected or not",
          "params": {
            "ControllerId": "the controller to query"
          }
        },
        "IsFriend": {
          "comment": "Checks that a unique player id is part of the specified user's friends list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being checked"
          }
        },
        "IsGuestLogin": {
          "comment": "Determines whether the specified user is a guest login or not",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "IsHeadsetPresent": {
          "comment": "Determines if the specified player has a headset connected",
          "params": {
            "LocalUserNum": "the local player index being queried"
          }
        },
        "IsLocalLogin": {
          "comment": "Determines whether the specified user is a local (non-online) login or not",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "IsLocalPlayerTalking": {
          "comment": "Determines if the specified player is actively talking into the mic",
          "params": {
            "LocalUserNum": "the local player index being queried"
          }
        },
        "IsMuted": {
          "comment": "Checks that a unique player id is on the specified user's mute list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being checked"
          }
        },
        "IsRemotePlayerTalking": {
          "comment": "Determines if the specified remote player is actively talking into the mic\n NOTE: Network latencies will make this not 100% accurate",
          "params": {
            "PlayerId": "the unique id of the remote player being queried"
          }
        },
        "JoinFriendGame": {
          "comment": "Allows the local player to follow a friend into a game",
          "params": {
            "LocalUserNum": "the local player wanting to join",
            "Friend": "the player that is being followed"
          }
        },
        "Login": {
          "comment": "Logs the player into the online service. If this fails, it generates a\n OnLoginFailed notification",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginName": "the unique identifier for the player",
            "Password": "the password for this account",
            "bWantsLocalOnly": "whether the player wants to sign in locally only or not"
          }
        },
        "Logout": {
          "comment": "Signs the player out of the online service",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "MuteAll": {
          "comment": "Mutes all voice or all but friends",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "bAllowFriends": "whether to mute everyone or allow friends"
          }
        },
        "MuteRemoteTalker": {
          "comment": "Mutes a remote talker for the specified local player. NOTE: This only mutes them in the\n game unless the bIsSystemWide flag is true, which attempts to mute them globally",
          "params": {
            "LocalUserNum": "the user that is muting the remote talker",
            "PlayerId": "the remote talker that is being muted",
            "bIsSystemWide": "whether to try to mute them globally or not"
          }
        },
        "ReadAchievements": {
          "comment": "Starts an async read for the achievement list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "TitleId": "the title id of the game the achievements are to be read for",
            "bShouldReadText": "whether to fetch the text strings or not",
            "bShouldReadImages": "whether to fetch the image data or not"
          }
        },
        "ReadFriendsList": {
          "comment": "Starts an async task that retrieves the list of friends for the player from the\n online service. The list can be retrieved in whole or in part.",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Count": "the number of friends to read or zero for all",
            "StartingAt": "the index of the friends list to start at (for pulling partial lists)"
          }
        },
        "ReadOnlineStats": {
          "comment": "Reads a set of stats for the specified list of players",
          "params": {
            "Players": "the array of unique ids to read stats for",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object"
          }
        },
        "ReadOnlineStatsByRank": {
          "comment": "Reads stats by ranking. This grabs the rows starting at StartIndex through\n NumToRead and places them in the StatsRead object.",
          "params": {
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object",
            "StartIndex": "the starting rank to begin reads at (1 for top)",
            "NumToRead": "the number of rows to read (clamped at 100 underneath)"
          }
        },
        "ReadOnlineStatsByRankAroundPlayer": {
          "comment": "Reads stats by ranking centered around a player. This grabs a set of rows\n above and below the player's current rank",
          "params": {
            "LocalUserNum": "the local player having their stats being centered upon",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object",
            "NumRows": "the number of rows to read above and below the player's rank"
          }
        },
        "ReadOnlineStatsForFriends": {
          "comment": "Reads a player's stats and all of that player's friends stats for the\n specified set of stat views. This allows you to easily compare a player's\n stats to their friends.",
          "params": {
            "LocalUserNum": "the local player having their stats and friend's stats read for",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object"
          }
        },
        "ReadPlayerStorage": {
          "comment": "Reads the online player storage data for a given local user\n If a valid storage device ID is specified then data is also read from that device and the newer version is kept.",
          "params": {
            "LocalUserNum": "the user that we are reading the data for",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read",
            "DeviceId": "optional ID for connected device to read from. -1 for no device"
          }
        },
        "ReadPlayerStorageForNetId": {
          "comment": "Reads the online player storage data for a given net user",
          "params": {
            "LocalUserNum": "the local user that is initiating the read",
            "NetId": "the net user that we are reading the data for",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read"
          }
        },
        "ReadProfileSettings": {
          "comment": "Reads the online profile settings for a given user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for",
            "ProfileSettings": "the object to copy the results to and contains the list of items to read"
          }
        },
        "ReadTitleFile": {
          "comment": "Starts an asynchronous read of the specified file from the network platform's\n title specific file store",
          "params": {
            "FileToRead": "the name of the file to read"
          }
        },
        "RegisterHostStatGuid": {
          "comment": "Registers the host's stat guid with the client for verification they are part of\n the stat. Note this is an async task for any backend communication that needs to\n happen before the registration is deemed complete",
          "params": {
            "HostStatGuid": "the host's stat guid"
          }
        },
        "RegisterLocalTalker": {
          "comment": "Registers the user as a talker",
          "params": {
            "LocalUserNum": "the local player index that is a talker"
          }
        },
        "RegisterRemoteTalker": {
          "comment": "Registers a remote player as a talker",
          "params": {
            "PlayerId": "the unique id of the remote player that is a talker"
          }
        },
        "RegisterStatGuid": {
          "comment": "Registers the client's stat guid on the host to validate that the client was in the stat.\n Used for synching up stats. Only valid on the host.",
          "params": {
            "PlayerId": "the client's unique net id",
            "ClientStatGuid": "the client's stat guid"
          }
        },
        "RemoveFriend": {
          "comment": "Removes a friend from the player's friend list",
          "params": {
            "LocalUserNum": "the user that is removing the friend",
            "FormerFriend": "the player to remove from the friend list"
          }
        },
        "SelectVocabulary": {
          "comment": "Changes the vocabulary id that is currently being used",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "VocabularyId": "the new id to use"
          }
        },
        "SendGameInviteToFriend": {
          "comment": "Sends an invitation to play in the player's current session",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "Friend": "the player to send the invite to",
            "Text": "the text of the message for the invite"
          }
        },
        "SendGameInviteToFriends": {
          "comment": "Sends invitations to play in the player's current session",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "Friends": "the player to send the invite to",
            "Text": "the text of the message for the invite"
          }
        },
        "SendMessageToFriend": {
          "comment": "Sends a message to a friend",
          "params": {
            "LocalUserNum": "the user that is sending the message",
            "Friend": "the player to send the message to",
            "Message": "the message to display to the recipient"
          }
        },
        "SetNetworkNotificationPosition": {
          "comment": "Sets a new position for the network notification icons/images",
          "params": {
            "NewPos": "the new location to use"
          }
        },
        "SetOnlineStatus": {
          "comment": "Sets the online status information to use for the specified player. Used to\n tell other players what the player is doing (playing, menus, away, etc.)",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "StatusId": "the status id to use (maps to strings where possible)",
            "LocalizedStringSettings": "the list of localized string settings to set",
            "Properties": "the list of properties to set"
          }
        },
        "SetRemoteTalkerPriority": {
          "comment": "Sets the relative priority for a remote talker. 0 is highest",
          "params": {
            "LocalUserNum": "the user that controls the relative priority",
            "PlayerId": "the remote talker that is having their priority changed for",
            "Priority": "the relative priority to use (0 highest, < 0 is muted)"
          }
        },
        "SetSpeechRecognitionObject": {
          "comment": "Changes the object that is in use to the one specified",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "SpeechRecogObj": "the new object use",
            "true": "if successful, false otherwise"
          }
        },
        "ShowFriendsUI": {
          "comment": "Displays the UI that shows a user's list of friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowKeyboardUI": {
          "comment": "Displays the UI that shows the keyboard for inputing text",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "TitleText": "the title to display to the user",
            "DescriptionText": "the text telling the user what to input",
            "bIsPassword": "whether the item being entered is a password or not",
            "bShouldValidate": "whether to apply the string validation API after input or not",
            "DefaultText": "the default string to display",
            "MaxResultLength": "the maximum length string expected to be filled in"
          }
        },
        "ShowLoginUI": {
          "comment": "Displays the UI that prompts the user for their login credentials. Each\n platform handles the authentication of the user's data.",
          "params": {
            "bShowOnlineOnly": "whether to only display online enabled profiles or not"
          }
        },
        "StartNetworkedVoice": {
          "comment": "Tells the voice layer that networked processing of the voice data is allowed\n for the specified player. This allows for push-to-talk style voice communication",
          "params": {
            "LocalUserNum": "the local user to allow network transimission for"
          }
        },
        "StartSpeechRecognition": {
          "comment": "Tells the voice system to start tracking voice data for speech recognition",
          "params": {
            "LocalUserNum": "the local user to recognize voice data for"
          }
        },
        "StopNetworkedVoice": {
          "comment": "Tells the voice layer to stop processing networked voice support for the\n specified player. This allows for push-to-talk style voice communication",
          "params": {
            "LocalUserNum": "the local user to disallow network transimission for"
          }
        },
        "StopSpeechRecognition": {
          "comment": "Tells the voice system to stop tracking voice data for speech recognition",
          "params": {
            "LocalUserNum": "the local user to recognize voice data for"
          }
        },
        "UnlockAchievement": {
          "comment": "Unlocks the specified achievement for the specified user",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "AchievementId": "the id of the achievement to unlock"
          }
        },
        "UnmuteAll": {
          "comment": "Allows all speakers to send voice",
          "params": {
            "LocalUserNum": "the local user that is making the change"
          }
        },
        "UnmuteRemoteTalker": {
          "comment": "Allows a remote talker to talk to the specified local player. NOTE: This only unmutes them in the\n game unless the bIsSystemWide flag is true, which attempts to unmute them globally",
          "params": {
            "LocalUserNum": "the user that is allowing the remote talker to talk",
            "PlayerId": "the remote talker that is being restored to talking",
            "bIsSystemWide": "whether to try to unmute them globally or not"
          }
        },
        "UnregisterLocalTalker": {
          "comment": "Unregisters the user as a talker",
          "params": {
            "LocalUserNum": "the local player index to be removed"
          }
        },
        "UnregisterRemoteTalker": {
          "comment": "Unregisters a remote player as a talker",
          "params": {
            "PlayerId": "the unique id of the remote player to be removed"
          }
        },
        "WriteOnlinePlayerScores": {
          "comment": "Writes the score data for the match",
          "params": {
            "SessionName": "the name of the session to write scores for",
            "LeaderboardId": "the leaderboard to write the score information to",
            "PlayerScores": "the list of players, teams, and scores they earned"
          }
        },
        "WriteOnlineStats": {
          "comment": "Writes out the stats contained within the stats write object to the online\n subsystem's cache of stats data. Note the new data replaces the old. It does\n not write the data to the permanent storage until a FlushOnlineStats() call\n or a session ends. Stats cannot be written without a session or the write\n request is ignored. No more than 5 stats views can be written to at a time\n or the write request is ignored.",
          "params": {
            "SessionName": "the name of the session to write stats for",
            "Player": "the player to write stats for",
            "StatsWrite": "the object containing the information to write"
          }
        },
        "WritePlayerStorage": {
          "comment": "Writes the online player storage data for a given local user to the online data store\n If a valid storage device ID is specified then data is also written to that device.",
          "params": {
            "LocalUserNum": "the user that we are writing the data for",
            "PlayerStorage": "the object that contains the list of items to write",
            "DeviceId": "optional ID for connected device to write to. -1 for no device"
          }
        },
        "WriteProfileSettings": {
          "comment": "Writes the online profile settings for a given user to the online data store",
          "params": {
            "LocalUserNum": "the user that we are writing the data for",
            "ProfileSettings": "the list of settings to write out"
          }
        }
      }
    }
  },
  "OnlineSubsystemSteamworks": {
    "OnlineGameInterfaceSteamworks": {
      "comment": "Class that implements the Steamworks specific functionality",
      "properties": {
        "CurrentMatchmakingQuery": {
          "comment": "Handle to in-progress Steam server query."
        },
        "CurrentMatchmakingType": {
          "comment": "The kind of server search in progress"
        },
        "GameInviteAcceptedDelegates": {
          "comment": "The list of delegates to notify when a game invite is accepted"
        },
        "InviteGameSearch": {
          "comment": "Game game settings associated with this invite"
        },
        "InviteLocationUrl": {
          "comment": "The last invite's URL information"
        },
        "QueryToPingResponseMap": {
          "comment": "Stores in-progress Steam query handles."
        },
        "QueryToRulesResponseMap": {
          "comment": "Stores in-progress Steam query handles."
        },
        "RegisterPlayerCompleteDelegates": {
          "comment": "This is the list of requested delegates to fire when complete"
        },
        "ServerListResponse": {
          "comment": "Provides callbacks when there are master server results."
        },
        "UnregisterPlayerCompleteDelegates": {
          "comment": "This is the list of requested delegates to fire when complete"
        }
      },
      "functions": {
        "AcceptGameInvite": {
          "comment": "Tells the online subsystem to accept the game invite that is currently pending",
          "params": {
            "LocalUserNum": "the local user accepting the invite",
            "SessionName": "the name of the session this invite is to be known as"
          }
        },
        "AddGameInviteAcceptedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code when a game invite has been accepted",
          "params": {
            "LocalUserNum": "the user to request notification for",
            "GameInviteAcceptedDelegate": "the delegate to use for notifications"
          }
        },
        "AddRegisterPlayerCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the player\n registration request they submitted has completed",
          "params": {
            "RegisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddUnregisterPlayerCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the player\n Unregistration request they submitted has completed",
          "params": {
            "UnregisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearGameInviteAcceptedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the user to request notification for",
            "GameInviteAcceptedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRegisterPlayerCompleteDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "RegisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearUnregisterPlayerCompleteDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "UnregisterPlayerCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "QueryNonAdvertisedData": {
          "comment": "Fetches the additional data a session exposes outside of the online service.\n NOTE: notifications will come from the OnFindOnlineGamesComplete delegate",
          "params": {
            "StartAt": "the search result index to start gathering the extra information for",
            "NumberToQuery": "the number of additional search results to get the data for"
          }
        },
        "RegisterPlayer": {
          "comment": "Registers a player with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is joining",
            "UniquePlayerId": "the player to register with the online service",
            "bWasInvited": "whether the player was invited to the game or searched for it"
          }
        },
        "UnregisterPlayer": {
          "comment": "Unregisters a player with the online service as being part of the online game",
          "params": {
            "SessionName": "the name of the session the player is leaving",
            "PlayerId": "the player to unregister with the online service"
          }
        },
        "UpdateOnlineGame": {
          "comment": "Updates the localized settings/properties for the game in question",
          "params": {
            "SessionName": "the name of the session to update",
            "UpdatedGameSettings": "the object to update the game settings with",
            "bShouldRefreshOnlineData": "whether to submit the data to the backend or not"
          }
        }
      },
      "structs": {
        "ServerQueryToPingResponseMapping": {
          "comment": "Maps a Steam HServerQuery to a Steam server rules callback object.",
          "properties": {
            "Query": {
              "comment": "The Steam query handle"
            },
            "Response": {
              "comment": "The Steam callback object"
            }
          }
        },
        "ServerQueryToRulesResponseMapping": {
          "comment": "Maps a Steam HServerQuery to a Steam server rules callback object.",
          "properties": {
            "Query": {
              "comment": "The Steam query handle"
            },
            "Response": {
              "comment": "The Steam callback object"
            }
          }
        }
      }
    },
    "OnlineSubsystemSteamworks": {
      "properties": {
        "AccountCreateDelegates": {
          "comment": "This is the list of requested delegates to fire when an account create completes"
        },
        "AchievementDelegates": {
          "comment": "The array of delegates for notifying when an achievement write has completed"
        },
        "AchievementMappings": {
          "comment": "Maps achievement names (as set on the Steam backend) to their AchievementId value, as taken by UnlockAchievement, and sets up other\n achievement values\n If not specified, achievements are loaded/unlocked based on the pattern 'Achievement_#', where # is the AchievementId value.\n Achievements will be loaded starting from 0, and will keep on being loaded until there are no more achievements.\n NOTE: Achievements must have a picture associated with them, and there must not be a gap in number between achievement names"
        },
        "AchievementReadDelegates": {
          "comment": "The array of delegates for notifying when an achievements list read has completed"
        },
        "AddFriendByNameCompleteDelegates": {
          "comment": "This is the list of requested delegates to fire when a friend by name invite has completed"
        },
        "bGSStatsStoresSuccess": {
          "comment": "Starts as true, changes to false if pending server-side stats stores fail."
        },
        "bHasSteamworksAccount": {
          "comment": "Whether the user has created a Steamworks account or not"
        },
        "bIncrementStatValues": {
          "comment": "If True, FlushOnlineStats increments stat values on the Steam backend, instead of overwriting them"
        },
        "bIsStatsSessionOk": {
          "comment": "Whether the stats session is ok to add stats to etc"
        },
        "bLastHasConnection": {
          "comment": "Whether the last frame has connection status or not"
        },
        "bListenHostAuthenticated": {
          "comment": "If this is a listen server, this is set to True when the listen host is authenticated with steam\n NOTE: If this listen host is not authenticated (can sometimes happen), stats can not be written for the host"
        },
        "bListenHostPendingAuth": {
          "comment": "Set to True when the listen host is pending authentication with Steam, so authing can be retried upon failure"
        },
        "bNeedsKeyboardTicking": {
          "comment": "Whether the keyboard needs to be ticked"
        },
        "bShouldUseMcp": {
          "comment": "Whether to use MCP for news or not"
        },
        "bStoringAchievement": {
          "comment": "True if we're storing an achievement we unlocked, false if just storing stats."
        },
        "bWasKeyboardInputCanceled": {
          "comment": "Whether the user canceled keyboard input or not"
        },
        "CachedFriendMessage": {
          "comment": "Used by the async add friend by name function"
        },
        "CachedFriendMessages": {
          "comment": "The list of friend messages received while the game was running"
        },
        "CachedGameInt": {
          "comment": "Pointer to the object that handles the game interface"
        },
        "CachedProfile": {
          "comment": "The cached profile for the player"
        },
        "CallbackBridge": {
          "comment": "Pointer to class that catches callbacks from Steam"
        },
        "ConnectionPresenceElapsedTime": {
          "comment": "Used to check when to verify connection status"
        },
        "ConnectionPresenceTimeInterval": {
          "comment": "The amount of time to elapse before checking for connection status change"
        },
        "ConnectionStatusChangeDelegates": {
          "comment": "This is the list of delegates requesting notification Steamworks's connection state changes"
        },
        "ControllerChangeDelegates": {
          "comment": "This is the list of delegates requesting notification of controller status changes"
        },
        "ControllerStates[4]": {
          "comment": "Upto 4 player split screen support"
        },
        "CurrentLocalTalker": {
          "comment": "Holds the local talker information for the single signed in player"
        },
        "CurrentNotificationPosition": {
          "comment": "Where Steamworks notifications will be displayed on the screen"
        },
        "CurrentStatsRead": {
          "comment": "The currently outstanding stats read request"
        },
        "DefaultStatus": {
          "comment": "This is the default online status to use in status updates"
        },
        "DeferredLeaderboardReads": {
          "comment": "If a leaderboard read request needs to first initialize a leaderboard, store the request until initialization completes (internal)"
        },
        "DeferredLeaderboardWrites": {
          "comment": "If a leaderboard write request needs to first initialize a leaderboard, store the request until initialization completes (internal)"
        },
        "DeviceCache": {
          "comment": "Holds the last results of device selection"
        },
        "EncryptedProductKey": {
          "comment": "Holds the product key in its encrypted form"
        },
        "FlushOnlineStatsDelegates": {
          "comment": "The list of delegates to notify when the stats flush is complete"
        },
        "FriendInviteReceivedDelegates": {
          "comment": "This is the list of requested delegates to fire when a friend invite is received"
        },
        "FriendMessageReceivedDelegates": {
          "comment": "This is the list of requested delegates to fire when a friend message is received"
        },
        "FriendsChangeDelegates": {
          "comment": "The array of delegates that notify that the friends list has changed"
        },
        "GameID": {
          "comment": "Identifies the Steamworks game"
        },
        "GameInviteMessage": {
          "comment": "The message to use for game invites"
        },
        "GetNumberOfCurrentPlayersCompleteDelegates": {
          "comment": "Holds the list of delegates that are interested in receiving GetNumberOfCurrentPlayers completions"
        },
        "JoinFriendGameCompleteDelegates": {
          "comment": "Holds the list of delegates that are interested in receiving join friend completions"
        },
        "KeyboardInputDelegates": {
          "comment": "This is the list of requested delegates to fire when keyboard UI has completed"
        },
        "KeyboardResultsString": {
          "comment": "Holds the results of async keyboard input"
        },
        "LeaderboardList": {
          "comment": "List of active leaderboards (internal, but it's safe to add and modify entries to specify UpdateType)\n NOTE: Leaderboards are added as they are used, through ReadOnlineStatsByRank* and WriteOnlineStats;\n leaderboard information is populated by the time ReadOnlineStatsComplete/FlushOnlineStatsComplete returns"
        },
        "LeaderboardNameMappings": {
          "comment": "Mappings of ViewId's to LeaderboardName's; this >must< be setup for leaderboards to work"
        },
        "LinkStatusDelegates": {
          "comment": "This is the list of delegates requesting notification of network link status changes"
        },
        "ListenAuthRetryCount": {
          "comment": "The number of times listen host authentication has been retried"
        },
        "ListenAuthTimestamp": {
          "comment": "For listen host authentication, the most recent time authentication was attempted"
        },
        "LocalPlayerStorageReadDelegates": {
          "comment": "Used for notification of player storage reads completing for local players"
        },
        "LocalPlayerStorageWriteDelegates": {
          "comment": "Used for notification of player storage writes completing for local players"
        },
        "LocalProfileName": {
          "comment": "The name to use for local profiles"
        },
        "LocationUrl": {
          "comment": "The URL to send as the location string"
        },
        "LocationUrlsForInvites": {
          "comment": "The list of location strings that are ok to accept invites for. Used mostly\n the different platform skus use different location strings."
        },
        "LoggedInPlayerId": {
          "comment": "The unique id of the logged in player"
        },
        "LoggedInPlayerName": {
          "comment": "The name of the player that is logged in"
        },
        "LoggedInPlayerNum": {
          "comment": "The number of the player that called the login function"
        },
        "LoggedInStatus": {
          "comment": "The current login status for the player"
        },
        "LoginChangeDelegates": {
          "comment": "This is the list of requested delegates to fire when a login fails to process"
        },
        "LoginFailedDelegates": {
          "comment": "This is the list of requested delegates to fire when a login fails to process"
        },
        "LogoutCompletedDelegates": {
          "comment": "This is the list of requested delegates to fire when a logout completes"
        },
        "MuteList": {
          "comment": "Holds the set of people that are muted by the currently logged in player"
        },
        "MutingChangeDelegates": {
          "comment": "The array of delegates that notify that the mute list has changed"
        },
        "NextAuthId": {
          "comment": "An ever incrementing number assigned to auth requests"
        },
        "PendingAchievementProgress": {
          "comment": "Achievement progress toast updates which are put together in WriteOnlineStats and displayed by FlushOnlineStats (internal)"
        },
        "PendingLeaderboardStats": {
          "comment": "Leaderboard stats updates which are put together in WriteOnlineStats, and written by FlushOnlineStats (internal)"
        },
        "PendingStats": {
          "comment": "Stats are stored in this array while waiting for FlushOnlineStats()"
        },
        "PlayerStorageCache": {
          "comment": "Holds the per player online storage data (only for local players)"
        },
        "ProcessedLeaderboardReads": {
          "comment": "Stores leaderboard data, while the OnlineSubsystem pulls each leaderboard entries stats (accessible during ReadOnlineStatsComplete)\n NOTE: If you want to grab raw-leaderboard data early, you can poll this list each Tick after calling ReadOnlineStats*, and get the data\n early before ReadOnlineStatsComplete is called (ReadOnlineStats first pulls the leaderboard data, and then takes longer to\n grab each individual players stats)"
        },
        "ProfileCache": {
          "comment": "Holds the per player profile data"
        },
        "ProfileDataDirectory": {
          "comment": "The directory profile data should be stored in"
        },
        "ProfileDataExtension": {
          "comment": "The file extension to use when saving profile data"
        },
        "QueuedAvatarRequests": {
          "comment": "Pending avatar lookups."
        },
        "ReadFriendsDelegates": {
          "comment": "The array of delegates that notify read completion of the friends list data"
        },
        "ReadOnlineStatsCompleteDelegates": {
          "comment": "This is the list of delegates requesting notification when a stats read finishes"
        },
        "ReadTitleFileCompleteDelegates": {
          "comment": "The list of delegates to notify when a network platform file is read"
        },
        "ReceivedGameInviteDelegates": {
          "comment": "The list of subscribers for game invite events"
        },
        "RegisterHostStatGuidCompleteDelegates": {
          "comment": "This is the list of requested delegates to fire when a host registration is complete"
        },
        "RemotePlayerStorageReadDelegates": {
          "comment": "Used for notification of player storage reads completing for remote players"
        },
        "RemoteTalkers": {
          "comment": "This is the list of remote talkers"
        },
        "ServerChallenge": {
          "comment": "Holds the server auth challenge"
        },
        "ServerLocalId": {
          "comment": "Holds the server auth local id"
        },
        "ServerResponse": {
          "comment": "Holds the server auth response"
        },
        "SpeechRecognitionCompleteDelegates": {
          "comment": "List of callbacks to notify when speech recognition is complete"
        },
        "StatsReadList": {
          "comment": "@todo: Revert the code once the Steam SDK has been fixed"
        },
        "StatusMappings": {
          "comment": "Holds the set of status strings for the specified game"
        },
        "TalkingDelegates": {
          "comment": "Holds the list of delegates that are interested in receiving talking notifications"
        },
        "TotalGSStatsStoresPending": {
          "comment": "Counts number of outstanding server-side stats stores."
        },
        "UserStatsReceivedState": {
          "comment": "Sets when Steam's UserStatsReceived callback triggers."
        },
        "WriteProfileSettingsDelegates": {
          "comment": "The array of delegates that notify write completion of profile data"
        }
      },
      "functions": {
        "AcceptFriendInvite": {
          "comment": "Used to accept a friend invite sent to this player",
          "params": {
            "LocalUserNum": "the user the invite is for",
            "RequestingPlayer": "the player the invite is from",
            "true": "if successful, false otherwise"
          }
        },
        "AddAddFriendByNameCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "FriendDelegate": "the delegate to use for notifications"
          }
        },
        "AddConnectionStatusChangeDelegate": {
          "comment": "Adds the delegate to the list to be notified when the connection status changes",
          "params": {
            "ConnectionStatusDelegate": "the delegate to add"
          }
        },
        "AddControllerChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the controller state changed",
          "params": {
            "ControllerChangeDelegate": "the delegate to use for notifications"
          }
        },
        "AddCreateOnlineAccountCompletedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that account creation completed",
          "params": {
            "AccountCreateDelegate": "the delegate to use for notifications"
          }
        },
        "AddDeviceSelectionDoneDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the user has completed\n their device selection",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "DeviceDelegate": "the delegate to use for notifications"
          }
        },
        "AddExternalUIChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that external UI state\n changed (opened/closed)",
          "params": {
            "ExternalUIDelegate": "the delegate to use for notifications"
          }
        },
        "AddFlushOnlineStatsCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the stats flush has completed",
          "params": {
            "FlushOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriend": {
          "comment": "Sends a friend invite to the specified player",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "NewFriend": "the player to send the friend request to",
            "Message": "the message to display to the recipient"
          }
        },
        "AddFriendByName": {
          "comment": "Sends a friend invite to the specified player nick",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "FriendName": "the name of the player to send the invite to",
            "Message": "the message to display to the recipient"
          }
        },
        "AddFriendInviteReceivedDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "InviteDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriendMessageReceivedDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a friend invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "MessageDelegate": "the delegate to use for notifications"
          }
        },
        "AddFriendsChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a friends list changed",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "AddGetNumberOfCurrentPlayersCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the player count request has completed",
          "params": {
            "GetNumberOfCurrentPlayersCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddJoinFriendGameCompleteDelegate": {
          "comment": "Sets the delegate used to notify when the join friend is complete",
          "params": {
            "JoinFriendGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddKeyboardInputDoneDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has completed\n their keyboard input",
          "params": {
            "InputDelegate": "the delegate to use for notifications"
          }
        },
        "AddLinkStatusChangeDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that link status changed",
          "params": {
            "LinkStatusDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginCancelledDelegate": {
          "comment": "Adds a delegate to the list of delegates that are fired when a login is cancelled",
          "params": {
            "CancelledDelegate": "the delegate to add to the list"
          }
        },
        "AddLoginChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login changed",
          "params": {
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginFailedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login failed",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "AddLoginStatusChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a login status has changed",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "the player to watch login status changes for"
          }
        },
        "AddLogoutCompletedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a logout completed",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LogoutDelegate": "the delegate to use for notifications"
          }
        },
        "AddMutingChangeDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that a muting list changed",
          "params": {
            "MutingDelegate": "the delegate to use for notifications"
          }
        },
        "AddPlayerTalkingDelegate": {
          "comment": "Adds a talker delegate to the list of notifications",
          "params": {
            "TalkerDelegate": "the delegate to call when a player is talking"
          }
        },
        "AddProfileDataChangedDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that someone has changed their profile data externally",
          "params": {
            "LocalUserNum": "the user the delegate is interested in",
            "ProfileDataChangedDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadAchievementsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to read the achievements list for",
            "ReadAchievementsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadFriendsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the friends read request has completed",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "ReadFriendsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadOnlineStatsCompleteDelegate": {
          "comment": "Adds the delegate to a list used to notify the gameplay code that the stats read has completed",
          "params": {
            "ReadOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadPlayerStorageCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadPlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadPlayerStorageForNetIdCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "NetId": "the net id for the user to watch for read complete notifications",
            "ReadPlayerStorageForNetIdCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadProfileSettingsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddReadTitleFileCompleteDelegate": {
          "comment": "Adds the delegate to the list to be notified when a requested file has been read",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to add"
          }
        },
        "AddReceivedGameInviteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the user has received a game invite",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "ReceivedGameInviteDelegate": "the delegate to use for notifications"
          }
        },
        "AddRecognitionCompleteDelegate": {
          "comment": "Sets the speech recognition notification callback to use for the specified user",
          "params": {
            "LocalUserNum": "the local user to receive notifications for",
            "RecognitionDelegate": "the delegate to call when recognition is complete"
          }
        },
        "AddRegisterHostStatGuidCompleteDelegate": {
          "comment": "Adds the delegate for notifying when the host guid registration is done",
          "params": {
            "RegisterHostStatGuidCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddStorageDeviceChangeDelegate": {
          "comment": "Adds the delegate to the list to be notified when a storage device changes",
          "params": {
            "StorageDeviceChangeDelegate": "the delegate to add"
          }
        },
        "AddUnlockAchievementCompleteDelegate": {
          "comment": "Adds the delegate used to notify the gameplay code that the achievement unlocking has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "UnlockAchievementCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWritePlayerStorageCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WritePlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AddWriteProfileSettingsCompleteDelegate": {
          "comment": "Sets the delegate used to notify the gameplay code that the last read request has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "AreAnyFriends": {
          "comment": "Checks that whether a group of player ids are among the specified player's\n friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Query": "an array of players to check for being included on the friends list"
          }
        },
        "CalcAggregateSkill": {
          "comment": "Calculates the aggregate skill from an array of skills.",
          "params": {
            "Mus": "array that holds the mu values",
            "Sigmas": "array that holds the sigma values",
            "OutAggregateMu": "aggregate Mu",
            "OutAggregateSigma": "aggregate Sigma"
          }
        },
        "CanCommunicate": {
          "comment": "Determines whether the player is allowed to use voice or text chat online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanDownloadUserContent": {
          "comment": "Determines whether the player is allowed to download user created content",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanPlayOnline": {
          "comment": "Determines whether the player is allowed to play online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanPurchaseContent": {
          "comment": "Determines whether the player is allowed to buy content online",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanShowPresenceInformation": {
          "comment": "Determines whether the player is allowed to have their online presence\n information shown to remote clients",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "CanViewPlayerProfiles": {
          "comment": "Determines whether the player is allowed to view other people's player profile",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ClearAddFriendByNameCompleteDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "FriendDelegate": "the delegate to use for notifications"
          }
        },
        "ClearConnectionStatusChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ConnectionStatusDelegate": "the delegate to remove"
          }
        },
        "ClearControllerChangeDelegate": {
          "comment": "Removes the delegate used to notify the gameplay code that the controller state changed",
          "params": {
            "ControllerChangeDelegate": "the delegate to remove"
          }
        },
        "ClearCreateOnlineAccountCompletedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "AccountCreateDelegate": "the delegate to use for notifications"
          }
        },
        "ClearDeviceSelectionDoneDelegate": {
          "comment": "Removes the specified delegate from the list of callbacks",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "DeviceDelegate": "the delegate to use for notifications"
          }
        },
        "ClearExternalUIChangeDelegate": {
          "comment": "Removes the delegate from the notification list",
          "params": {
            "ExternalUIDelegate": "the delegate to remove"
          }
        },
        "ClearFlushOnlineStatsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the stats flush has completed",
          "params": {
            "FlushOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendInviteReceivedDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "InviteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendMessageReceivedDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "MessageDelegate": "the delegate to use for notifications"
          }
        },
        "ClearFriendsChangeDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "ClearGetNumberOfCurrentPlayersCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the player count read request has completed",
          "params": {
            "GetNumberOfCurrentPlayersCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearJoinFriendGameCompleteDelegate": {
          "comment": "Removes the delegate from the list of notifications",
          "params": {
            "JoinFriendGameCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearKeyboardInputDoneDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the user has completed\n their keyboard input",
          "params": {
            "InputDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLinkStatusChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "LinkStatusDelegate": "the delegate to remove"
          }
        },
        "ClearLoginCancelledDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "CancelledDelegate": "the delegate to remove fromt he list"
          }
        },
        "ClearLoginChangeDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLoginFailedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginDelegate": "the delegate to use for notifications"
          }
        },
        "ClearLoginStatusChangeDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LoginDelegate": "the delegate to use for notifications",
            "LocalUserNum": "the player to watch login status changes for"
          }
        },
        "ClearLogoutCompletedDelegate": {
          "comment": "Removes the specified delegate from the notification list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LogoutDelegate": "the delegate to use for notifications"
          }
        },
        "ClearMutingChangeDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "FriendsDelegate": "the delegate to use for notifications"
          }
        },
        "ClearPlayerTalkingDelegate": {
          "comment": "Removes a talker delegate to the list of notifications",
          "params": {
            "TalkerDelegate": "the delegate to remove from the notification list"
          }
        },
        "ClearProfileDataChangedDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that someone has changed their profile data externally",
          "params": {
            "LocalUserNum": "the user the delegate is interested in",
            "ProfileDataChangedDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadAchievementsCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the achievements read request has completed",
          "params": {
            "LocalUserNum": "the user to read the achievements list for",
            "ReadAchievementsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadFriendsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadFriendsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadOnlineStatsCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ReadOnlineStatsCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearReadPlayerStorageCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadPlayerStorageCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadPlayerStorageForNetIdCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "NetId": "the net id for the user to watch for read complete notifications",
            "ReadPlayerStorageForNetIdCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadProfileSettingsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "ClearReadTitleFileCompleteDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "ReadTitleFileCompleteDelegate": "the delegate to remove"
          }
        },
        "ClearReceivedGameInviteDelegate": {
          "comment": "Removes the delegate specified from the list",
          "params": {
            "LocalUserNum": "the user associated with the notification",
            "ReceivedGameInviteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearRecognitionCompleteDelegate": {
          "comment": "Clears the speech recognition notification callback to use for the specified user",
          "params": {
            "LocalUserNum": "the local user to receive notifications for",
            "RecognitionDelegate": "the delegate to call when recognition is complete"
          }
        },
        "ClearRegisterHostStatGuidCompleteDelegateDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code",
          "params": {
            "RegisterHostStatGuidCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearStorageDeviceChangeDelegate": {
          "comment": "Removes the delegate from the notify list",
          "params": {
            "StorageDeviceChangeDelegate": "the delegate to remove"
          }
        },
        "ClearUnlockAchievementCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the achievement unlocking has completed",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "UnlockAchievementCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearWritePlayerStorageCompleteDelegate": {
          "comment": "Clears the delegate used to notify the gameplay code that the last write request has completed",
          "params": {
            "LocalUserNum": "which user to watch for write complete notifications",
            "WritePlayerStorageCompleteDelegate": "the delegate to use for notifications"
          }
        },
        "ClearWriteProfileSettingsCompleteDelegate": {
          "comment": "Searches the existing set of delegates for the one specified and removes it\n from the list",
          "params": {
            "LocalUserNum": "which user to watch for read complete notifications",
            "ReadProfileSettingsCompleteDelegate": "the delegate to find and clear"
          }
        },
        "CreateLeaderboard": {
          "comment": "Creates the specified leaderboard on the Steamworks backend\n NOTE: It's best to use this for game/mod development purposes only, not for release usage",
          "params": {
            "LeaderboardName": "The name to give the leaderboard (NOTE: This will be the human-readable name displayed on the backend and stats page)",
            "SortType": "The sorting to use for the leaderboard",
            "DisplayFormat": "The way to display leaderboard data"
          }
        },
        "CreateLocalAccount": {
          "comment": "Creates a non-networked account on the local system. Password is only used\n when supplied. Otherwise the account is not secured.",
          "params": {
            "UserName": "the unique nickname of the account",
            "Password": "the password securing the account"
          }
        },
        "CreateOnlineAccount": {
          "comment": "Creates a network enabled account on the online service",
          "params": {
            "UserName": "the unique nickname of the account",
            "Password": "the password securing the account",
            "EmailAddress": "the address used to send password hints to"
          }
        },
        "DeleteLocalAccount": {
          "comment": "Deletes a local account if the password matches",
          "params": {
            "UserName": "the unique nickname of the account",
            "Password": "the password securing the account"
          }
        },
        "DeleteMessage": {
          "comment": "Deletes a message from the list of messages",
          "params": {
            "LocalUserNum": "the user that is deleting the message",
            "MessageIndex": "the index of the message to delete"
          }
        },
        "DenyFriendInvite": {
          "comment": "Used to deny a friend request sent to this player",
          "params": {
            "LocalUserNum": "the user the invite is for",
            "RequestingPlayer": "the player the invite is from",
            "true": "if successful, false otherwise"
          }
        },
        "DisplayAchievementProgress": {
          "comment": "Pops up the Steam toast dialog, notifying the player of their progress with an achievement (does not unlock achievements)",
          "params": {
            "AchievementId": "The id of the achievment which will have its progress displayed",
            "ProgressCount": "The number of completed steps for this achievement",
            "MaxProgress": "The total number of required steps for this achievement, before it will be unlocked"
          }
        },
        "FlushOnlineStats": {
          "comment": "Commits any changes in the online stats cache to the permanent storage",
          "params": {
            "SessionName": "the name of the session having stats flushed"
          }
        },
        "FreeStats": {
          "comment": "Cleans up any platform specific allocated data contained in the stats data",
          "params": {
            "StatsRead": "the object to handle per platform clean up on"
          }
        },
        "GetAchievements": {
          "comment": "Copies the list of achievements for the specified player and title id\n NOTE: Achievement pictures are not guaranteed to be set, you will need to repeatedly call this in order to load missing pictures\n Check the 'Images' value for all entries in the returned achievements list, to detect missing images",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Achievements": "the out array that receives the copied data",
            "TitleId": "the title id of the game that these were read for"
          }
        },
        "GetClientStatGuid": {
          "comment": "Reads the client's stat guid that was generated by registering the host's guid\n Used for synching up stats. Only valid on the client. Only callable after the\n host registration has completed"
        },
        "GetDeviceSelectionResults": {
          "comment": "Fetches the results of the device selection",
          "params": {
            "LocalUserNum": "the player to check the results for",
            "DeviceName": "out param that gets a copy of the string"
          }
        },
        "GetFriendMessages": {
          "comment": "Returns the list of messages for the specified player",
          "params": {
            "LocalUserNum": "the local player wanting to join",
            "FriendMessages": "the set of messages cached locally for the player"
          }
        },
        "GetFriendsList": {
          "comment": "Copies the list of friends for the player previously retrieved from the online\n service. The list can be retrieved in whole or in part.",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Friends": "the out array that receives the copied data",
            "Count": "the number of friends to read or zero for all",
            "StartingAt": "the index of the friends list to start at (for pulling partial lists)"
          }
        },
        "GetHostStatGuid": {
          "comment": "Reads the host's stat guid for synching up stats. Only valid on the host."
        },
        "GetKeyboardInputResults": {
          "comment": "Fetches the results of the input",
          "params": {
            "bWasCanceled": "whether the user cancelled the input or not"
          }
        },
        "GetLocalAccountNames": {
          "comment": "Fetches a list of local accounts",
          "params": {
            "Accounts": "the array that is populated with the accounts"
          }
        },
        "GetLocale": {
          "comment": "Determine the locale (country code) for the player"
        },
        "GetLoginStatus": {
          "comment": "Fetches the login status for a given player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "GetNATType": {
          "comment": "Determines the NAT type the player is using"
        },
        "GetNetworkNotificationPosition": {
          "comment": "Determines the current notification position setting"
        },
        "GetNumberOfCurrentPlayers": {
          "comment": "Starts an async query for the total players. This is the amount of players the system thinks is playing right now, globally,\n not just on a specific server."
        },
        "GetPlayerNickname": {
          "comment": "Reads the player's nick name from the online service",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "GetPlayerNicknameFromIndex": {
          "comment": "Returns the name of the player for the specified index",
          "params": {
            "UserIndex": "the user to return the name of"
          }
        },
        "GetPlayerStorage": {
          "comment": "Returns the online player storage for a given local user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for"
          }
        },
        "GetPlayerUniqueNetIdFromIndex": {
          "comment": "Returns the unique id of the player for the specified index",
          "params": {
            "UserIndex": "the user to return the id of"
          }
        },
        "GetProfileSettings": {
          "comment": "Returns the online profile settings for a given user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for"
          }
        },
        "GetRecognitionResults": {
          "comment": "Gets the results of the voice recognition",
          "params": {
            "LocalUserNum": "the local user to read the results of",
            "Words": "the set of words that were recognized by the voice analyzer"
          }
        },
        "GetTitleFileContents": {
          "comment": "Copies the file data into the specified buffer for the specified file",
          "params": {
            "FileName": "the name of the file to read",
            "FileContents": "the out buffer to copy the data into"
          }
        },
        "GetTitleFileState": {
          "comment": "Determines the async state of the tile file read operation",
          "params": {
            "FileName": "the name of the file to check on"
          }
        },
        "GetUniquePlayerId": {
          "comment": "Gets the platform specific unique id for the specified player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the byte array that will receive the id"
          }
        },
        "HasLinkConnection": {
          "comment": "Determines if the ethernet link is connected or not"
        },
        "Init": {
          "comment": "Called from engine start up code to allow the subsystem to initialize"
        },
        "IsControllerConnected": {
          "comment": "Determines if the specified controller is connected or not",
          "params": {
            "ControllerId": "the controller to query"
          }
        },
        "IsDeviceValid": {
          "comment": "Checks the device id to determine if it is still valid (could be removed) and/or\n if there is enough space on the specified device",
          "params": {
            "DeviceId": "the device to check",
            "SizeNeeded": "the amount of space requested"
          }
        },
        "IsFriend": {
          "comment": "Checks that a unique player id is part of the specified user's friends list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being checked"
          }
        },
        "IsGuestLogin": {
          "comment": "Determines whether the specified user is a guest login or not",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "IsHeadsetPresent": {
          "comment": "Determines if the specified player has a headset connected",
          "params": {
            "LocalUserNum": "the local player index being queried"
          }
        },
        "IsLocalLogin": {
          "comment": "Determines whether the specified user is a local (non-online) login or not",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "IsLocalPlayerTalking": {
          "comment": "Determines if the specified player is actively talking into the mic",
          "params": {
            "LocalUserNum": "the local player index being queried"
          }
        },
        "IsMuted": {
          "comment": "Checks that a unique player id is on the specified user's mute list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being checked"
          }
        },
        "IsRemotePlayerTalking": {
          "comment": "Determines if the specified remote player is actively talking into the mic\n NOTE: Network latencies will make this not 100% accurate",
          "params": {
            "PlayerId": "the unique id of the remote player being queried"
          }
        },
        "JoinFriendGame": {
          "comment": "Allows the local player to follow a friend into a game",
          "params": {
            "LocalUserNum": "the local player wanting to join",
            "Friend": "the player that is being followed"
          }
        },
        "Login": {
          "comment": "Logs the player into the online service. If this fails, it generates a\n OnLoginFailed notification",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "LoginName": "the unique identifier for the player",
            "Password": "the password for this account",
            "bWantsLocalOnly": "whether the player wants to sign in locally only or not"
          }
        },
        "Logout": {
          "comment": "Signs the player out of the online service",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "MuteAll": {
          "comment": "Mutes all voice or all but friends",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "bAllowFriends": "whether to mute everyone or allow friends"
          }
        },
        "MuteRemoteTalker": {
          "comment": "Mutes a remote talker for the specified local player. NOTE: This only mutes them in the\n game unless the bIsSystemWide flag is true, which attempts to mute them globally",
          "params": {
            "LocalUserNum": "the user that is muting the remote talker",
            "PlayerId": "the remote talker that is being muted",
            "bIsSystemWide": "whether to try to mute them globally or not"
          }
        },
        "ReadAchievements": {
          "comment": "Starts an async read for the achievement list",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "TitleId": "the title id of the game the achievements are to be read for",
            "bShouldReadText": "whether to fetch the text strings or not",
            "bShouldReadImages": "whether to fetch the image data or not"
          }
        },
        "ReadFriendsList": {
          "comment": "Starts an async task that retrieves the list of friends for the player from the\n online service. The list can be retrieved in whole or in part.",
          "params": {
            "LocalUserNum": "the user to read the friends list of",
            "Count": "the number of friends to read or zero for all",
            "StartingAt": "the index of the friends list to start at (for pulling partial lists)"
          }
        },
        "ReadOnlineAvatar": {
          "comment": "Reads an avatar images for the specified player. Results are delivered via OnReadOnlineAvatarComplete delegates.",
          "params": {
            "PlayerNetId": "the unique id to read avatar for",
            "ReadOnlineAvatarCompleteDelegate": "The delegate to call with results."
          }
        },
        "ReadOnlineStats": {
          "comment": "Reads a set of stats for the specified list of players",
          "params": {
            "Players": "the array of unique ids to read stats for",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object"
          }
        },
        "ReadOnlineStatsByRank": {
          "comment": "Reads stats by ranking. This grabs the rows starting at StartIndex through\n NumToRead and places them in the StatsRead object.",
          "params": {
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object",
            "StartIndex": "the starting rank to begin reads at (1 for top)",
            "NumToRead": "the number of rows to read (clamped at 100 underneath)"
          }
        },
        "ReadOnlineStatsByRankAroundPlayer": {
          "comment": "Reads stats by ranking centered around a player. This grabs a set of rows\n above and below the player's current rank",
          "params": {
            "LocalUserNum": "the local player having their stats being centered upon",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object",
            "NumRows": "the number of rows to read above and below the player's rank"
          }
        },
        "ReadOnlineStatsForFriends": {
          "comment": "Reads a player's stats and all of that player's friends stats for the\n specified set of stat views. This allows you to easily compare a player's\n stats to their friends.",
          "params": {
            "LocalUserNum": "the local player having their stats and friend's stats read for",
            "StatsRead": "holds the definitions of the tables to read the data from and\n results are copied into the specified object"
          }
        },
        "ReadPlayerStorage": {
          "comment": "Reads the online player storage data for a given local user\n If a valid storage device ID is specified then data is also read from that device and the newer version is kept.",
          "params": {
            "LocalUserNum": "the user that we are reading the data for",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read",
            "DeviceId": "optional ID for connected device to read from. -1 for no device"
          }
        },
        "ReadPlayerStorageForNetId": {
          "comment": "Reads the online player storage data for a given net user",
          "params": {
            "LocalUserNum": "the local user that is initiating the read",
            "NetId": "the net user that we are reading the data for",
            "PlayerStorage": "the object to copy the results to and contains the list of items to read"
          }
        },
        "ReadProfileSettings": {
          "comment": "Reads the online profile settings for a given user",
          "params": {
            "LocalUserNum": "the user that we are reading the data for",
            "ProfileSettings": "the object to copy the results to and contains the list of items to read"
          }
        },
        "ReadTitleFile": {
          "comment": "Starts an asynchronous read of the specified file from the network platform's\n title specific file store",
          "params": {
            "FileToRead": "the name of the file to read"
          }
        },
        "RegisterHostStatGuid": {
          "comment": "Registers the host's stat guid with the client for verification they are part of\n the stat. Note this is an async task for any backend communication that needs to\n happen before the registration is deemed complete",
          "params": {
            "HostStatGuid": "the host's stat guid"
          }
        },
        "RegisterLocalTalker": {
          "comment": "Registers the user as a talker",
          "params": {
            "LocalUserNum": "the local player index that is a talker"
          }
        },
        "RegisterRemoteTalker": {
          "comment": "Registers a remote player as a talker",
          "params": {
            "PlayerId": "the unique id of the remote player that is a talker"
          }
        },
        "RegisterStatGuid": {
          "comment": "Registers the client's stat guid on the host to validate that the client was in the stat.\n Used for synching up stats. Only valid on the host.",
          "params": {
            "PlayerId": "the client's unique net id",
            "ClientStatGuid": "the client's stat guid"
          }
        },
        "RemoveFriend": {
          "comment": "Removes a friend from the player's friend list",
          "params": {
            "LocalUserNum": "the user that is removing the friend",
            "FormerFriend": "the player to remove from the friend list"
          }
        },
        "RenameLocalAccount": {
          "comment": "Changes the name of a local account",
          "params": {
            "UserName": "the unique nickname of the account",
            "Password": "the password securing the account"
          }
        },
        "ResetStats": {
          "comment": "Resets the players stats (and achievements, if specified)",
          "params": {
            "bResetAchievements": "If true, also resets player achievements"
          }
        },
        "SelectVocabulary": {
          "comment": "Changes the vocabulary id that is currently being used",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "VocabularyId": "the new id to use"
          }
        },
        "SendGameInviteToFriend": {
          "comment": "Sends an invitation to play in the player's current session",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "Friend": "the player to send the invite to",
            "Text": "the text of the message for the invite"
          }
        },
        "SendGameInviteToFriends": {
          "comment": "Sends invitations to play in the player's current session",
          "params": {
            "LocalUserNum": "the user that is sending the invite",
            "Friends": "the player to send the invite to",
            "Text": "the text of the message for the invite"
          }
        },
        "SendMessageToFriend": {
          "comment": "Sends a message to a friend",
          "params": {
            "LocalUserNum": "the user that is sending the message",
            "Friend": "the player to send the message to",
            "Message": "the message to display to the recipient"
          }
        },
        "SetNetworkNotificationPosition": {
          "comment": "Sets a new position for the network notification icons/images",
          "params": {
            "NewPos": "the new location to use"
          }
        },
        "SetOnlineStatus": {
          "comment": "Sets the online status information to use for the specified player. Used to\n tell other players what the player is doing (playing, menus, away, etc.)",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "StatusId": "the status id to use (maps to strings where possible)",
            "LocalizedStringSettings": "the list of localized string settings to set",
            "Properties": "the list of properties to set"
          }
        },
        "SetRemoteTalkerPriority": {
          "comment": "Sets the relative priority for a remote talker. 0 is highest",
          "params": {
            "LocalUserNum": "the user that controls the relative priority",
            "PlayerId": "the remote talker that is having their priority changed for",
            "Priority": "the relative priority to use (0 highest, < 0 is muted)"
          }
        },
        "SetSpeechRecognitionObject": {
          "comment": "Changes the object that is in use to the one specified",
          "params": {
            "LocalUserNum": "the local user that is making the change",
            "SpeechRecogObj": "the new object use",
            "true": "if successful, false otherwise"
          }
        },
        "ShowAchievementsUI": {
          "comment": "Displays the achievements UI for a player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowContentMarketplaceUI": {
          "comment": "Displays the marketplace UI for content",
          "params": {
            "LocalUserNum": "the local user viewing available content",
            "CategoryMask": "the bitmask to use to filter content by type",
            "OfferId": "a specific offer that you want shown"
          }
        },
        "ShowCustomPlayersUI": {
          "comment": "Shows a custom players UI for the specified list of players",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "Players": "the list of players to show in the custom UI",
            "Title": "the title to use for the UI",
            "Description": "the text to show at the top of the UI"
          }
        },
        "ShowDeviceSelectionUI": {
          "comment": "Displays the UI that allows the user to choose which device to save content to",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "SizeNeeded": "the size of the data to be saved in bytes",
            "bManageStorage": "whether to allow the user to manage their storage or not"
          }
        },
        "ShowFeedbackUI": {
          "comment": "Displays the UI that allows a player to give feedback on another player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player having feedback given for"
          }
        },
        "ShowFriendsInviteUI": {
          "comment": "Displays the UI that shows a user's list of friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player being invited"
          }
        },
        "ShowFriendsUI": {
          "comment": "Displays the UI that shows a user's list of friends",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowGamerCardUI": {
          "comment": "Displays the gamer card UI for the specified player",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "PlayerId": "the id of the player to show the gamer card of"
          }
        },
        "ShowInviteUI": {
          "comment": "Displays the invite ui",
          "params": {
            "LocalUserNum": "the local user sending the invite",
            "InviteText": "the string to prefill the UI with"
          }
        },
        "ShowKeyboardUI": {
          "comment": "Displays the UI that shows the keyboard for inputing text",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "TitleText": "the title to display to the user",
            "DescriptionText": "the text telling the user what to input",
            "bIsPassword": "whether the item being entered is a password or not",
            "bShouldValidate": "whether to apply the string validation API after input or not",
            "DefaultText": "the default string to display",
            "MaxResultLength": "the maximum length string expected to be filled in"
          }
        },
        "ShowLoginUI": {
          "comment": "Displays the UI that prompts the user for their login credentials. Each\n platform handles the authentication of the user's data.",
          "params": {
            "bShowOnlineOnly": "whether to only display online enabled profiles or not"
          }
        },
        "ShowMembershipMarketplaceUI": {
          "comment": "Displays the marketplace UI for memberships",
          "params": {
            "LocalUserNum": "the local user viewing available memberships"
          }
        },
        "ShowMessagesUI": {
          "comment": "Displays the messages UI for a player",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "ShowPlayersUI": {
          "comment": "Displays the UI that shows the player list",
          "params": {
            "LocalUserNum": "the controller number of the associated user"
          }
        },
        "StartNetworkedVoice": {
          "comment": "Tells the voice layer that networked processing of the voice data is allowed\n for the specified player. This allows for push-to-talk style voice communication",
          "params": {
            "LocalUserNum": "the local user to allow network transimission for"
          }
        },
        "StartSpeechRecognition": {
          "comment": "Tells the voice system to start tracking voice data for speech recognition",
          "params": {
            "LocalUserNum": "the local user to recognize voice data for"
          }
        },
        "StopNetworkedVoice": {
          "comment": "Tells the voice layer to stop processing networked voice support for the\n specified player. This allows for push-to-talk style voice communication",
          "params": {
            "LocalUserNum": "the local user to disallow network transimission for"
          }
        },
        "StopSpeechRecognition": {
          "comment": "Tells the voice system to stop tracking voice data for speech recognition",
          "params": {
            "LocalUserNum": "the local user to recognize voice data for"
          }
        },
        "UniqueNetIdToPlayerName": {
          "comment": "Converts the specified UID, into the players Steam Community name",
          "params": {
            "UID": "The players UID\n \n@result The username of the player, as stored on the Steam backend"
          }
        },
        "UnlockAchievement": {
          "comment": "Unlocks the specified achievement for the specified user",
          "params": {
            "LocalUserNum": "the controller number of the associated user",
            "AchievementId": "the id of the achievement to unlock"
          }
        },
        "UnlockAvatarAward": {
          "comment": "Unlocks an avatar award for the local user",
          "params": {
            "LocalUserNum": "the user to unlock the avatar item for",
            "AvatarItemId": "the id of the avatar item to unlock"
          }
        },
        "UnlockGamerPicture": {
          "comment": "Unlocks a gamer picture for the local user",
          "params": {
            "LocalUserNum": "the user to unlock the picture for",
            "PictureId": "the id of the picture to unlock"
          }
        },
        "UnmuteAll": {
          "comment": "Allows all speakers to send voice",
          "params": {
            "LocalUserNum": "the local user that is making the change"
          }
        },
        "UnmuteRemoteTalker": {
          "comment": "Allows a remote talker to talk to the specified local player. NOTE: This only unmutes them in the\n game unless the bIsSystemWide flag is true, which attempts to unmute them globally",
          "params": {
            "LocalUserNum": "the user that is allowing the remote talker to talk",
            "PlayerId": "the remote talker that is being restored to talking",
            "bIsSystemWide": "whether to try to unmute them globally or not"
          }
        },
        "UnregisterLocalTalker": {
          "comment": "Unregisters the user as a talker",
          "params": {
            "LocalUserNum": "the local player index to be removed"
          }
        },
        "UnregisterRemoteTalker": {
          "comment": "Unregisters a remote player as a talker",
          "params": {
            "PlayerId": "the unique id of the remote player to be removed"
          }
        },
        "WriteOnlinePlayerScores": {
          "comment": "Writes the score data for the match",
          "params": {
            "SessionName": "the name of the session to write scores for",
            "LeaderboardId": "the leaderboard to write the score information to",
            "PlayerScores": "the list of players, teams, and scores they earned"
          }
        },
        "WriteOnlineStats": {
          "comment": "Writes out the stats contained within the stats write object to the online\n subsystem's cache of stats data. Note the new data replaces the old. It does\n not write the data to the permanent storage until a FlushOnlineStats() call\n or a session ends. Stats cannot be written without a session or the write\n request is ignored. No more than 5 stats views can be written to at a time\n or the write request is ignored.",
          "params": {
            "SessionName": "the name of the session to write stats for",
            "Player": "the player to write stats for",
            "StatsWrite": "the object containing the information to write"
          }
        },
        "WritePlayerStorage": {
          "comment": "Writes the online player storage data for a given local user to the online data store\n If a valid storage device ID is specified then data is also written to that device.",
          "params": {
            "LocalUserNum": "the user that we are writing the data for",
            "PlayerStorage": "the object that contains the list of items to write",
            "DeviceId": "optional ID for connected device to write to. -1 for no device"
          }
        },
        "WriteProfileSettings": {
          "comment": "Writes the online profile settings for a given user to the online data store",
          "params": {
            "LocalUserNum": "the user that we are writing the data for",
            "ProfileSettings": "the list of settings to write out"
          }
        }
      },
      "structs": {
        "AchievementMappingInfo": {
          "comment": "Maps achievement ids to backend achievement names, stats to achievements, and sets up automatic achievement unlocks/progress-toasts\n NOTE: If ProgressCount or bAutoUnlock are set, both ViewId and MaxProgress must be set for them to work; the achievement will display\n progress/unlock when achievement stats are uploaded through Write/FlushOnlineStats\n (use DisplayAchievementProgress and UnlockAchievement for more fine control of progress-toasts/unlocks)\n NOTE: If you have achievements linked to stats on the backend, and have progress set there, the backend will automatically unlock\n achievements for you. HOWEVER, Steam has a bug which causes this to break for Listen servers; bAutoUnlock always works",
          "properties": {
            "AchievementId": {
              "comment": "The id of the achievement, as used by UnlockAchievement"
            },
            "AchievementName": {
              "comment": "The name of the achievement, as specified on the Steam backend"
            },
            "bAutoUnlock": {
              "comment": "If True, achievements are automatically unlocked when the achievements progress hits/exceeds MaxProgress"
            },
            "MaxProgress": {
              "comment": "Specifies the number of steps required for an unlock"
            },
            "ProgressCount": {
              "comment": "Pops up an achievement toast every time the achievement stats value increases by this amount (0 = disabled)"
            },
            "ViewId": {
              "comment": "If the achievement is linked to a stats entry, this is the ViewId for the stats entry (ColumnId is determined by AchievementId)"
            }
          }
        },
        "AchievementProgressStat": {
          "comment": "Stores an achievement progress update (internal)"
        },
        "ControllerConnectionState": {
          "comment": "Struct to hold current and previous frame's game state",
          "properties": {
            "bIsControllerConnected": {
              "comment": "Whether the controller is connected or not"
            },
            "bLastIsControllerConnected": {
              "comment": "Last frame's version of the above"
            }
          }
        },
        "DeferredLeaderboardRead": {
          "comment": "Stores a deferred leaderboard read request (internal)"
        },
        "DeferredLeaderboardWrite": {
          "comment": "Stores a deferred leaderboard write request (internal)"
        },
        "DeviceIdCache": {
          "comment": "Per user cache of device id information",
          "properties": {
            "DeviceId": {
              "comment": "The last selected device id for this user"
            },
            "DeviceSelectionDelegates": {
              "comment": "List of subscribers interested in device selection notification"
            },
            "DeviceSelectionMulticast": {
              "comment": "Delegate used to fire the array of events off"
            }
          }
        },
        "LeaderboardEntry": {
          "comment": "Struct representing an individual leaderboard entry (internal)",
          "properties": {
            "PlayerUID": {
              "comment": "UID of the player this leaderboard entry represents"
            },
            "Rank": {
              "comment": "Global rank of the player this entry represents"
            },
            "Score": {
              "comment": "Leaderboard score"
            }
          }
        },
        "LeaderboardHandle": {
          "comment": "Internally used dud struct"
        },
        "LeaderboardTemplate": {
          "comment": "Struct describing a leaderboard",
          "properties": {
            "bLeaderboardInitializing": {
              "comment": "Whether or not initialization is in progress for this leaderboard"
            },
            "bLeaderboardInitiated": {
              "comment": "Whether or not the leaderboard reference has been initiated"
            },
            "DisplayFormat": {
              "comment": "How the leaderboard should be formatted on the backend"
            },
            "LeaderboardName": {
              "comment": "The name of the leaderboard on the backend"
            },
            "LeaderboardRef": {
              "comment": "Handle to the Steamworks leaderboard reference"
            },
            "LeaderboardSize": {
              "comment": "The number of entries in the leaderboard (updated after every read/write request for this leaderboard)"
            },
            "SortType": {
              "comment": "The method used to sort the leaderboard, as defined on backend"
            },
            "UpdateType": {
              "comment": "How the leaderboard handles score updates (configurable, affects FlushOnlineStats)"
            }
          }
        },
        "LocalTalkerSteam": {
          "comment": "Adds to the local talker definition so we can support muting"
        },
        "OnlineStatusMapping": {
          "comment": "Holds the items used to map an online status string to its format string",
          "properties": {
            "StatusId": {
              "comment": "The id of the status string"
            },
            "StatusString": {
              "comment": "The format string to use to apply the passed in properties/strings"
            }
          }
        },
        "PendingPlayerStats": {
          "comment": "This stores the stats for a single player before being written out to the backend",
          "properties": {
            "Place": {
              "comment": "This player's place when sorted against the other players. Calculated at reporting time"
            },
            "Player": {
              "comment": "The player for which stats are being written"
            },
            "PlayerName": {
              "comment": "The name of the player to report with"
            },
            "Score": {
              "comment": "The score for this player"
            },
            "StatGuid": {
              "comment": "This is a per-player guid that needs to be passed to the backend"
            },
            "Stats": {
              "comment": "The stats for this player"
            }
          }
        },
        "PlayerStat": {
          "comment": "This holds a single stat waiting to be written out",
          "properties": {
            "ColumnId": {
              "comment": "The column for this stat"
            },
            "Data": {
              "comment": "The stat's value"
            },
            "ViewId": {
              "comment": "The view for this stat"
            }
          }
        },
        "ProfileSettingsCache": {
          "comment": "Holds the cached state of the profile for a single player",
          "properties": {
            "Profile": {
              "comment": "The profile for the player"
            },
            "ProfileDataChangedDelegates": {
              "comment": "Used to notify subscribers when the player changes their (non-game) profile"
            },
            "ReadDelegates": {
              "comment": "Used for per player index notification of profile reads completing"
            },
            "WriteDelegates": {
              "comment": "Used for per player index notification of profile writes completing"
            }
          }
        },
        "QueuedAvatarRequest": {
          "comment": "Struct to hold pending avatar requests",
          "properties": {
            "CheckTime": {
              "comment": "Ticks elasped since request was made"
            },
            "NumberOfAttempts": {
              "comment": "Number of times we've (re)requested this avatar."
            },
            "PlayerNetId": {
              "comment": "Steam ID of player to get avatar for."
            },
            "ReadOnlineAvatarCompleteDelegate": {
              "comment": "delegate to trigger when we have a result."
            }
          }
        },
        "ViewIdToLeaderboardName": {
          "comment": "Maps a ViewId (as used by OnlineStats* classes) to a Steam leaderboard name",
          "properties": {
            "LeaderboardName": {
              "comment": "The leaderboard name"
            },
            "ViewId": {
              "comment": "The id of the view"
            }
          }
        }
      }
    }
  }
}